/*! Fengmap version:2.1.28 build:3251 DEBUG 2018-08-24 12:47:36 */
/**
 *
 * private cloud
 * #20160224, build 1261
 * use threejs r74
 *
 */

var fm = window.fm || {}; //for 3rd library namespace!

var fengmap = {
	VERSION: '2.1.28',
	BUILD: 3251
};

window['fengmap'] = fengmap;
window['fm'] = fm;

//jimguo delete beg
//var performance = performance || {};
//jimguo delete end

fengmap.MapLoading = function() {
};

fengmap.MapLoading.prototype = {
	show:function(container) {
		var info = document.getElementById('fm-mapLoading');
		if(info == null) {
			//仅修改这部分，不能使用console.**
			var info = document.createElement('div');
			//var image = document.createElement('img');
			//image.src = 'data:image/gif;base64,R0lGODlhIAAgALMAAP///7Ozs/v7+9bW1uHh4fLy8rq6uoGBgTQ0NAEBARsbG8TExJeXl/39/VRUVAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFBQAAACwAAAAAIAAgAAAE5xDISSlLrOrNp0pKNRCdFhxVolJLEJQUoSgOpSYT4RowNSsvyW1icA16k8MMMRkCBjskBTFDAZyuAEkqCfxIQ2hgQRFvAQEEIjNxVDW6XNE4YagRjuBCwe60smQUDnd4Rz1ZAQZnFAGDd0hihh12CEE9kjAEVlycXIg7BAsMB6SlnJ87paqbSKiKoqusnbMdmDC2tXQlkUhziYtyWTxIfy6BE8WJt5YEvpJivxNaGmLHT0VnOgGYf0dZXS7APdpB309RnHOG5gDqXGLDaC457D1zZ/V/nmOM82XiHQjYKhKP1oZmADdEAAAh+QQFBQAAACwAAAAAGAAXAAAEchDISasKNeuJFKoHs4mUYlJIkmjIV54Soypsa0wmLSnqoTEtBw52mG0AjhYpBxioEqRNy8V0qFzNw+GGwlJki4lBqx1IBgjMkRIghwjrzcDti2/Gh7D9qN774wQGAYOEfwCChIV/gYmDho+QkZKTR3p7EQAh+QQFBQAAACwBAAAAHQAOAAAEchDISWdANesNHHJZwE2DUSEo5SjKKB2HOKGYFLD1CB/DnEoIlkti2PlyuKGEATMBaAACSyGbEDYD4zN1YIEmh0SCQQgYehNmTNNaKsQJXmBuuEYPi9ECAU/UFnNzeUp9VBQEBoFOLmFxWHNoQw6RWEocEQAh+QQFBQAAACwHAAAAGQARAAAEaRDICdZZNOvNDsvfBhBDdpwZgohBgE3nQaki0AYEjEqOGmqDlkEnAzBUjhrA0CoBYhLVSkm4SaAAWkahCFAWTU0A4RxzFWJnzXFWJJWb9pTihRu5dvghl+/7NQmBggo/fYKHCX8AiAmEEQAh+QQFBQAAACwOAAAAEgAYAAAEZXCwAaq9ODAMDOUAI17McYDhWA3mCYpb1RooXBktmsbt944BU6zCQCBQiwPB4jAihiCK86irTB20qvWp7Xq/FYV4TNWNz4oqWoEIgL0HX/eQSLi69boCikTkE2VVDAp5d1p0CW4RACH5BAUFAAAALA4AAAASAB4AAASAkBgCqr3YBIMXvkEIMsxXhcFFpiZqBaTXisBClibgAnd+ijYGq2I4HAamwXBgNHJ8BEbzgPNNjz7LwpnFDLvgLGJMdnw/5DRCrHaE3xbKm6FQwOt1xDnpwCvcJgcJMgEIeCYOCQlrF4YmBIoJVV2CCXZvCooHbwGRcAiKcmFUJhEAIfkEBQUAAAAsDwABABEAHwAABHsQyAkGoRivELInnOFlBjeM1BCiFBdcbMUtKQdTN0CUJru5NJQrYMh5VIFTTKJcOj2HqJQRhEqvqGuU+uw6AwgEwxkOO55lxIihoDjKY8pBoThPxmpAYi+hKzoeewkTdHkZghMIdCOIhIuHfBMOjxiNLR4KCW1ODAlxSxEAIfkEBQUAAAAsCAAOABgAEgAABGwQyEkrCDgbYvvMoOF5ILaNaIoGKroch9hacD3MFMHUBzMHiBtgwJMBFolDB4GoGGBCACKRcAAUWAmzOWJQExysQsJgWj0KqvKalTiYPhp1LBFTtp10Is6mT5gdVFx1bRN8FTsVCAqDOB9+KhEAIfkEBQUAAAAsAgASAB0ADgAABHgQyEmrBePS4bQdQZBdR5IcHmWEgUFQgWKaKbWwwSIhc4LonsXhBSCsQoOSScGQDJiWwOHQnAxWBIYJNXEoFCiEWDI9jCzESey7GwMM5doEwW4jJoypQQ743u1WcTV0CgFzbhJ5XClfHYd/EwZnHoYVDgiOfHKQNREAIfkEBQUAAAAsAAAPABkAEQAABGeQqUQruDjrW3vaYCZ5X2ie6EkcKaooTAsi7ytnTq046BBsNcTvItz4AotMwKZBIC6H6CVAJaCcT0CUBTgaTg5nTCu9GKiDEMPJg5YBBOpwlnVzLwtqyKnZagZWahoMB2M3GgsHSRsRACH5BAUFAAAALAEACAARABgAAARcMKR0gL34npkUyyCAcAmyhBijkGi2UW02VHFt33iu7yiDIDaD4/erEYGDlu/nuBAOJ9Dvc2EcDgFAYIuaXS3bbOh6MIC5IAP5Eh5fk2exC4tpgwZyiyFgvhEMBBEAIfkEBQUAAAAsAAACAA4AHQAABHMQyAnYoViSlFDGXBJ808Ep5KRwV8qEg+pRCOeoioKMwJK0Ekcu54h9AoghKgXIMZgAApQZcCCu2Ax2O6NUud2pmJcyHA4L0uDM/ljYDCnGfGakJQE5YH0wUBYBAUYfBIFkHwaBgxkDgX5lgXpHAXcpBIsRADs=';
			//var text = document.createElement('label');			
			//info.appendChild(image);
			info.setAttribute('id', 'fm-mapLoading');
			info.style.zIndex = 100;
			info.style.position = 'fixed';
			info.style.top = '50%';
			info.style.left ='50%';
			document.body.appendChild(info);
		}
		
		info.innerHTML = '地图加载中...';
		
		if(container != document.body)
			container.style.display='none';
	},
	
	showLoadError:function(container) {
		var info = document.getElementById('fm-mapLoading');
		if(info == null) {
			//仅修改这部分，不能使用console.**
			var info = document.createElement('div');
			//var image = document.createElement('img');
			//image.src = 'data:image/gif;base64,R0lGODlhIAAgALMAAP///7Ozs/v7+9bW1uHh4fLy8rq6uoGBgTQ0NAEBARsbG8TExJeXl/39/VRUVAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFBQAAACwAAAAAIAAgAAAE5xDISSlLrOrNp0pKNRCdFhxVolJLEJQUoSgOpSYT4RowNSsvyW1icA16k8MMMRkCBjskBTFDAZyuAEkqCfxIQ2hgQRFvAQEEIjNxVDW6XNE4YagRjuBCwe60smQUDnd4Rz1ZAQZnFAGDd0hihh12CEE9kjAEVlycXIg7BAsMB6SlnJ87paqbSKiKoqusnbMdmDC2tXQlkUhziYtyWTxIfy6BE8WJt5YEvpJivxNaGmLHT0VnOgGYf0dZXS7APdpB309RnHOG5gDqXGLDaC457D1zZ/V/nmOM82XiHQjYKhKP1oZmADdEAAAh+QQFBQAAACwAAAAAGAAXAAAEchDISasKNeuJFKoHs4mUYlJIkmjIV54Soypsa0wmLSnqoTEtBw52mG0AjhYpBxioEqRNy8V0qFzNw+GGwlJki4lBqx1IBgjMkRIghwjrzcDti2/Gh7D9qN774wQGAYOEfwCChIV/gYmDho+QkZKTR3p7EQAh+QQFBQAAACwBAAAAHQAOAAAEchDISWdANesNHHJZwE2DUSEo5SjKKB2HOKGYFLD1CB/DnEoIlkti2PlyuKGEATMBaAACSyGbEDYD4zN1YIEmh0SCQQgYehNmTNNaKsQJXmBuuEYPi9ECAU/UFnNzeUp9VBQEBoFOLmFxWHNoQw6RWEocEQAh+QQFBQAAACwHAAAAGQARAAAEaRDICdZZNOvNDsvfBhBDdpwZgohBgE3nQaki0AYEjEqOGmqDlkEnAzBUjhrA0CoBYhLVSkm4SaAAWkahCFAWTU0A4RxzFWJnzXFWJJWb9pTihRu5dvghl+/7NQmBggo/fYKHCX8AiAmEEQAh+QQFBQAAACwOAAAAEgAYAAAEZXCwAaq9ODAMDOUAI17McYDhWA3mCYpb1RooXBktmsbt944BU6zCQCBQiwPB4jAihiCK86irTB20qvWp7Xq/FYV4TNWNz4oqWoEIgL0HX/eQSLi69boCikTkE2VVDAp5d1p0CW4RACH5BAUFAAAALA4AAAASAB4AAASAkBgCqr3YBIMXvkEIMsxXhcFFpiZqBaTXisBClibgAnd+ijYGq2I4HAamwXBgNHJ8BEbzgPNNjz7LwpnFDLvgLGJMdnw/5DRCrHaE3xbKm6FQwOt1xDnpwCvcJgcJMgEIeCYOCQlrF4YmBIoJVV2CCXZvCooHbwGRcAiKcmFUJhEAIfkEBQUAAAAsDwABABEAHwAABHsQyAkGoRivELInnOFlBjeM1BCiFBdcbMUtKQdTN0CUJru5NJQrYMh5VIFTTKJcOj2HqJQRhEqvqGuU+uw6AwgEwxkOO55lxIihoDjKY8pBoThPxmpAYi+hKzoeewkTdHkZghMIdCOIhIuHfBMOjxiNLR4KCW1ODAlxSxEAIfkEBQUAAAAsCAAOABgAEgAABGwQyEkrCDgbYvvMoOF5ILaNaIoGKroch9hacD3MFMHUBzMHiBtgwJMBFolDB4GoGGBCACKRcAAUWAmzOWJQExysQsJgWj0KqvKalTiYPhp1LBFTtp10Is6mT5gdVFx1bRN8FTsVCAqDOB9+KhEAIfkEBQUAAAAsAgASAB0ADgAABHgQyEmrBePS4bQdQZBdR5IcHmWEgUFQgWKaKbWwwSIhc4LonsXhBSCsQoOSScGQDJiWwOHQnAxWBIYJNXEoFCiEWDI9jCzESey7GwMM5doEwW4jJoypQQ743u1WcTV0CgFzbhJ5XClfHYd/EwZnHoYVDgiOfHKQNREAIfkEBQUAAAAsAAAPABkAEQAABGeQqUQruDjrW3vaYCZ5X2ie6EkcKaooTAsi7ytnTq046BBsNcTvItz4AotMwKZBIC6H6CVAJaCcT0CUBTgaTg5nTCu9GKiDEMPJg5YBBOpwlnVzLwtqyKnZagZWahoMB2M3GgsHSRsRACH5BAUFAAAALAEACAARABgAAARcMKR0gL34npkUyyCAcAmyhBijkGi2UW02VHFt33iu7yiDIDaD4/erEYGDlu/nuBAOJ9Dvc2EcDgFAYIuaXS3bbOh6MIC5IAP5Eh5fk2exC4tpgwZyiyFgvhEMBBEAIfkEBQUAAAAsAAACAA4AHQAABHMQyAnYoViSlFDGXBJ808Ep5KRwV8qEg+pRCOeoioKMwJK0Ekcu54h9AoghKgXIMZgAApQZcCCu2Ax2O6NUud2pmJcyHA4L0uDM/ljYDCnGfGakJQE5YH0wUBYBAUYfBIFkHwaBgxkDgX5lgXpHAXcpBIsRADs=';
			//var text = document.createElement('label');
			info.innerHTML = '地图加载出错';
			//info.appendChild(image);
			info.setAttribute('id', 'fm-mapLoading');
			info.style.zIndex = 100;
			info.style.position = 'fixed';
			info.style.top = '50%';
			info.style.left ='50%';
			document.body.appendChild(info);
		} else 
			info.innerHTML = '地图加载出错';
	},
	
	hide:function(container,interval) {
		if(container != document.body)
			container.style.display='block';
		var info = document.getElementById('fm-mapLoading');
		document.body.removeChild(info);
	}
};


/////////////////////////
// fengmap SDK methods //
/////////////////////////

/**
 * 设置sdk key and appName
 * @param {string} key     key
 * @param {string} appName appName
 */
fengmap.setKeyAndAppName = function (key, appName) {
	fengmap.key = key;
	fengmap.appName = appName;
};

fengmap.key     = '';
fengmap.appName = '';

/**
 * get version of fengmap JS SDK
 * @type {string}
 */
fengmap.getVersion = function () {
	return fengmap.VERSION;
}

/**
 * get the build number of fengmap JS SDK
 * @return {int} build number
 */
fengmap.getBuild = function () {
	return fengmap.BUILD;
}







fengmap.MapError = function() {
};

fengmap.MapError.prototype = {
	noWebGL:function(container) {
		
		//仅修改这部分，不能使用console.**		
		var info = document.createElement('div');
		info.innerHTML = '<h5>您的浏览器目前不支持WebGL!<h5><h5>为更好的浏览，建议您下载 &nbsp;谷歌浏览器</h5>';
		info.setAttribute('class', 'noWebGL'); // and make sure myclass has some styles in css
		
		container.appendChild(info);
	}
};

window.onerror = function(msg) {
	// alert('onerror, ' + msg);
	// console.log(msg);

	//overwrite
	fengmap.FMMap = function(opts) {
		var container;
		if (!opts || !opts.container) {
			container = document.body;
		} else {
			container = opts.container;
		}
		
		var error = new fengmap.MapError();
		error.noWebGL(container); //因为别处也使用，所以不要修改这个结构！
		
	};
	
	window.onerror = null;
};

//throw 'Manually trigger error test';

// console.log('build', fengmap.BUILD);
console.log('FengMap Version:', fengmap.VERSION, 'Build:', fengmap.BUILD);

//window.Float32Array = Float32Array || {};//只是为了避免提前js出错，如果没有Float32Array本身浏览器也不能再继续运行了。

/**
 * 得到json中的属性,并设置默认值
 */
function fmg (obj, prop, val) {
	var _res;

	for (var i = 1; i < arguments.length - 1; i++) {
		_res = obj[arguments[i]]
		if ( _res !== undefined) {
			return _res;
		}
	}

	return arguments[arguments.length - 1];
}

/**
 * log and warn
 */
fm.log = console.log;
fm.warn = console.warn;

fm.ss = {
	// key值未配置，请访问蜂鸟云控制台查看应用名称。
	warn_nokey: 'key%E5%80%BC%E6%9C%AA%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%E3%80%82',
	// 应用名称（appname）未配置，请访问蜂鸟云控制台查看应用名称。
	warn_noappname: '%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%EF%BC%88appname%EF%BC%89%E6%9C%AA%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%E3%80%82',
	// 地图ID未配置，请访问蜂鸟云控制台查看地图ID。
	warn_nomapid: '%E5%9C%B0%E5%9B%BEID%E6%9C%AA%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E5%9C%B0%E5%9B%BEID%E3%80%82',
	// 您配置的key值不正确，请访问蜂鸟云控制台检查此应用下的key值。
	warn_keynotright: '%E6%82%A8%E9%85%8D%E7%BD%AE%E7%9A%84key%E5%80%BC%E4%B8%8D%E6%AD%A3%E7%A1%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%A3%80%E6%9F%A5%E6%AD%A4%E5%BA%94%E7%94%A8%E4%B8%8B%E7%9A%84key%E5%80%BC%E3%80%82',
	// 您配置的应用名称（appname）或key值不正确，请访问蜂鸟云控制台检查您的应用。
	warn_offline: '%E6%82%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%EF%BC%88appname%EF%BC%89%E6%88%96key%E5%80%BC%E4%B8%8D%E6%AD%A3%E7%A1%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%A3%80%E6%9F%A5%E6%82%A8%E7%9A%84%E5%BA%94%E7%94%A8%E3%80%82',

	// 文件解析失败
	warn_openerror: '%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E5%A4%B1%E8%B4%A5',
	// 无法连接到蜂鸟云
	warn_connecterror: '%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%9C%82%E9%B8%9F%E4%BA%91',
	// 从蜂鸟云上获得地图数据失败
	warn_downloaderror: '%E4%BB%8E%E8%9C%82%E9%B8%9F%E4%BA%91%E4%B8%8A%E8%8E%B7%E5%BE%97%E5%9C%B0%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%A4%B1%E8%B4%A5'
};

fm.gs = function(string) {
	return decodeURIComponent(string);
};

/////////////////////////////////
// very simple Promise 
/////////////////////////////////
fm.Promise = function () {
	this.callbacks = [];
};

fm.Promise.delay = function (time) {
	var p = new fm.Promise();
	setTimeout(function () {
		p.resolve();
	}, time);
	return p;
};

fm.Promise.prototype = {
	constructor: fm.Promise,
	then: function (cb) {
		this.callbacks.push(cb);
		return this;
	},
	resolve: function(param) {
		var s = this;
		setTimeout(function () {
			for (var i = 0; i < s.callbacks.length; i++) {
				var tmp = s.callbacks[i](param);
				if (tmp instanceof fm.Promise) {
					for (i ++; i < s.callbacks.length; i++) {
						tmp.then(s.callbacks[i]);
					}
				}
			}
		}, 0)
	}
};



/**
 * fengmap JavaScript SDK 提供基本控件。
 * 包括：放大、缩小控件。单层、多层控件。两种楼层切换控件、二三维控件、指南针。
 * @module FMControls
 */

/**
 *   controlOptions 地图控件的配置项
 */
fengmap.controlOptions = function(opt) {
    Object.assign(this, opt);
    this.size = (opt && opt.size ? opt.size : fengmap.controlSize.FMMap_CONTROL_NORMAL);
    this.position = (opt && opt.position ? opt.position : null);
    this.offset = (opt && opt.offset ? opt.offset : new fengmap.controlOffset(0, 0));
    this.imgURL = (opt && opt.imgURL ? opt.imgURL : 'resource/style/wedgets/img/'); //组件内部引用图片地址
}

fengmap["controlSize"] = {
    "FMMap_CONTROL_SMALL": 'small',
    "FMMap_CONTROL_NORMAL": 'normal'
}

/**
 *   controlPositon 控件位置枚举
 *   @class controlPositon
 *   @module FMControls
 *   @namespace fengmap
 */
fengmap["controlPositon"] = {
    /**
     * 左上角,默认距离左边10px,距离上部20px;
     * @property LEFT_TOP
     * @final
     */
    "LEFT_TOP": 1,
    /**
     * 左下角,默认距离左边10px,距离底部水印20px;
     * @property LEFT_BOTTOM
     * @final
     */
    "LEFT_BOTTOM": 2,
    /**
     * 右上角,默认距离右边10px,上部20px;
     * @property RIGHT_TOP
     * @final
     */
    "RIGHT_TOP": 3,
    /**
     * 右下角,默认距离右边10px,距离底部水印20px;
     * @property RIGHT_BOTTOM
     * @final
     */
    "RIGHT_BOTTOM": 4
}

/**
 *   controlOffset 控件位置偏移对象 
 */
fengmap["controlOffset"] = function(x, y) {
    /**
     * 根据当前位置的x方向偏移。如controlPositon为左上角，表示距离左边的x位移；如位置为右下角，则表示距离右边的x偏移。
     * @property x
     * @final
     */
    this.x = x ? x : 0;
    /**
     * 根据当前位置的x方向偏移。如controlPositon为左上角，表示距离左边的x位移；如位置为右下角，则表示距离右边的x偏移。
     * @property y
     * @final
     */
    this.y = y ? y : 0;
}
//图层控制控件1，带滚动
/**
 *   buttonGroupsControl 楼层控制控件,按钮型，初始时候为一个按钮，点击后弹出楼层。一个地图只包含1个楼层控件。
 *   @class buttonGroupsControl
 *   @constructor
 *   @module FMControls
 *   @namespace fengmap
 *   @param {fengmap.FMMap} map 地图控件配置
 *   @param {JSON} ctrlOpts  控件参数配置
 *           @param {boolean} ctrlOpts.allLayer  初始显示多层还是单层，默认值false,单层显示。
 *           @param {number} ctrlOpts.showBtnCount  初始楼层按钮显示个数配置。默认显示5层,其他的隐藏，可滚动查看
 *           @param {fengmap.controlPositon} ctrlOpts.position  控件位置。分为左上、左下、右上、右下。 
 *           @param {JSON} ctrlOpts.offset  控件位置偏移。{x:0,y:0},基于原始位置的x,y方向的偏移。
 *           @param {string} ctrlOpts.imgURL  配置组件引用图片资源的路径地址。默认在页面的'resource/style/wedgets/img/'路径下
 *   @demo controls/楼层切换控件配置1.js
 */
/**
 * 当前楼层的状态,默认是单楼层的。
 * @property allLayer {boolean}
 * @final
 */

/**
 * 是否展开楼层列表，true为展开，false为不展开
 * @property expand {boolean}
 */

/**
 * 能否点击楼层主按钮。false为允许弹出楼层列表。
 * @property enableExpand {boolean}
 */

/**
 * 楼层按钮切换回调
 * @method onChange
 * @param {function} function(groups,allLayer){} 当楼层切换时候回调,返回参数包括groups,allLayer。groups是目标层id数组，如切换到第二层：[2]。allLayer是当前地图处于多层还是单层模式。多层为true，否则为false.
 * @demo controls/切换楼层方法回调.js
 */

/**
 * 切换楼层方法
 * @method changeFocusGroup
 * @param {int} 目标层groupID
 * @param {boolean} 是否多层状态
 */
fengmap.buttonGroupsControl = function(map, ctrlOpts) {

    // 设置默认停靠位置和偏移量
    this.options_ = new fengmap.controlOptions(ctrlOpts);

    if (this.options_.size == 'normal') {
        this.w_ = 42;
        this.h_ = 42;
        this.padding_ = 10;
    } else {
        this.w_ = 32;
        this.h_ = 32;
        this.padding_ = 8;
    }

    this.x_ = this.options_.offset.x;
    this.y_ = this.options_.offset.y;

    this.allLayer = (this.options_.allLayer ? this.options_.allLayer : false); //控制单层显示还是所有模型展示
    this.showBtnCount = (this.options_.showBtnCount ? this.options_.showBtnCount : 5); //默认显示多少按钮

    this.expandLayers_ = (this.options_.expand ? this.options_.expand : false); //是按钮型的时候是否展开楼层
    this.positon_ = (this.options_.position ? this.options_.position : 2); //默认左下角

    this.change_ = null;
    this.inited = false; //是否已经初始化

    //楼层名称颜色
    this.selectedColor = '#1E82FA';
    this.defaultColor = '#666666';

    //是否允许弹出楼层层
    this.enableExpand_ = true;

    //阴影样式
    this.defaultShadow_ = '2px 2px 3px rgba(0,0,0, 0.3)';
    this.defaultRadius_ = '2px';

    //封装querySelecter方法
    this.$ = function(cssname) {
        if (this.map)
            return this.map.mapView.container_.querySelector(cssname);
        else
            return document.querySelector(cssname);
    }

    //记录手机滑动的touchstart位置
    this.touchPointX;
    this.touchPointY;

    //手机滑动和点击结束后的touchend位置
    this.touchEndPointX;
    this.touchEndPointY;

    this.map = map;
    this.left_ = 10; //距离地图左边界的距离
    this.top_ = 20;
    this.right_ = 10;
    this.defaultPadding_ = 10; //工具按钮之间的间距

    this.imgURL_ = this.options_.imgURL; //组件内部引用图片地址

    if (map) {
        this._tryInit(map);
    }
}

fengmap.buttonGroupsControl.prototype = {
    //按钮型的楼层控件初始化
    _tryInit: function(map) {
        var groupDiv = document.createElement("div");
        groupDiv.setAttribute('class', 'fm-control-groups-btn');
        groupDiv.style.width = this.w_ + 'px';
        groupDiv.style.height = this.h_ + 'px';
        groupDiv.style.position = 'absolute';
        //groupDiv.style.left = left + this.x_ + 'px';
        //groupDiv.style.top = top + this.y_ + 'px';
        groupDiv.style.backgroundColor = 'white';
        groupDiv.style.boxShadow = this.defaultShadow_;
        groupDiv.style.borderRadius = this.defaultRadius_;
        groupDiv.style.textAlign = 'center';
        groupDiv.style.cursor = 'pointer';
        groupDiv.style.fontSize = '0.8em';
        groupDiv.style.fontWeight = 'bold';
        groupDiv.style.textTransform = 'uppercase';
        groupDiv.style.lineHeight = this.h_ + 'px';
        groupDiv.style.color = this.selectedColor;
        groupDiv.innerText = 'F1';

        var layerlistDiv = document.createElement("div");
        layerlistDiv.setAttribute('class', 'fm-layer-list');
        layerlistDiv.style.position = 'absolute';
        //layerlistDiv.style.left = left + this.x_ + 'px';
        //layerlistDiv.style.top = top + this.y_ - this.left_ + 'px';
        layerlistDiv.style.backgroundColor = 'white';
        layerlistDiv.style.boxShadow = this.defaultShadow_;
        layerlistDiv.style.borderRadius = this.defaultRadius_;

        layerlistDiv.onmousewheel = this.scroll.bind(this);
        layerlistDiv.addEventListener('MozMousePixelScroll', this.scroll.bind(this), false); //firefox

        //如果是移动端ios andriod添加touch事件,电脑端绑定点击事件
        //ios andriod
        layerlistDiv.addEventListener('touchstart', this.touchstart.bind(this), false);
        layerlistDiv.addEventListener('touchmove', this.touchmove.bind(this), false);
        layerlistDiv.addEventListener('touchend', this.touchend.bind(this), false);

        //avoid select word content
        groupDiv.onselectstart = function() {
            return false;
        }
        groupDiv.style.MozUserSelect = "none";

        layerlistDiv.onselectstart = function() {
            return false;
        }
        layerlistDiv.style.MozUserSelect = "none";

        //add tooldiv to map container
        var mapCanvas = map.mapView.container_.getElementsByTagName("canvas")[0];
        map.mapView.container_.insertBefore(groupDiv, mapCanvas);
        map.mapView.container_.insertBefore(layerlistDiv, mapCanvas);

        this.createLayers(map.listGroups, map.focusGroupID);
        layerlistDiv.style.display = 'none';

        if (this.showBtnCount < map.listGroups.length) {
            var arrowTopDiv = document.createElement("div");
            arrowTopDiv.setAttribute('class', 'fm-control-groups fm-arrow-top');
            arrowTopDiv.style.height = '18px';
            arrowTopDiv.style.display = 'none';
            arrowTopDiv.style.background = 'url(' + this.imgURL_ + 'arrow1.png) no-repeat 50% 50%';
            arrowTopDiv.style.cursor = 'pointer';
            arrowTopDiv.onclick = this.up.bind(this);

            var arrowBottomDiv = document.createElement("div");
            arrowBottomDiv.setAttribute('class', 'fm-control-groups fm-arrow-down');
            arrowBottomDiv.style.height = '18px';
            arrowBottomDiv.style.background = 'url(' + this.imgURL_ + 'arrow1.png) no-repeat 50% 50%';
            arrowBottomDiv.style.cursor = 'pointer';
            arrowBottomDiv.style.display = 'none';
            arrowBottomDiv.onclick = this.down.bind(this);

            layerlistDiv.appendChild(arrowTopDiv, layerlistDiv);
            layerlistDiv.appendChild(arrowBottomDiv);

            //修改楼层列表的高度
            layerlistDiv.style.overflow = 'hidden';
            layerlistDiv.style.height = this.showBtnCount * (this.h_ + 1) + 'px';

            this.changeScrollState(map.listGroups.length - map.focusGroupID);
        } else {
            this.showBtnCount = map.listGroups.length;
            layerlistDiv.style.height = this.showBtnCount * (this.h_ + 1) + 'px';
        }


        //设置控件距离上边界的高度
        //var ltop = top - this.showBtnCount * (this.h_+2) - this.left_;

        this.setPosition_(groupDiv);
        this.setPosition_(layerlistDiv, this.showBtnCount * (this.h_ + 2));
        //layerlistDiv.style.top = ltop + this.y_ + 'px';

        this.controlPositionListener(); //当地图视窗变化时调整小组件的位置
        this.focusGroupListener();

        var this_ = this;
        groupDiv.addEventListener('click', function(event) {
            var visibleTmp = this_.$('.fm-layer-list');
            var expanded = this_.enableExpand;
            if (visibleTmp.style.display == 'none') {
                if (!expanded) return;
                visibleTmp.style.display = 'block';
                this_.changeScrollState(map.listGroups.length - map.focusGroupID); //可见时重新设置滚动位置
                this_.expandLayers_ = true;
            } else {
                visibleTmp.style.display = 'none';
                this_.expandLayers_ = false;
            }
        }, false);
    },

    //当地图视窗变化时调整小组件的位置
    controlPositionListener: function() {
        if (this.map) {
            var this_ = this;
            this.map.on('update', function() {
                var groupDiv = this_.$('.fm-control-groups-btn');
                var layerlistDiv = this_.$('.fm-layer-list');

                this_.setPosition_(groupDiv);
                this_.setPosition_(layerlistDiv, this_.showBtnCount * (this_.h_ + 2));
            });
        }
    },

    //是否允许展开楼层列表
    get enableExpand() {
        return this.enableExpand_;
    },
    set enableExpand(v) {
        if (!v)
            this.$('.fm-layer-list').style.display = 'none';
        this.enableExpand_ = v;
    },

    get expand() {
        return this.expandLayers_;
    },

    set expand(v) {
        if (!v)
            this.$('.fm-layer-list').style.display = 'none';
        else
            this.$('.fm-layer-list').style.display = 'block';
        this.expandLayers_ = v;
    },

    //监听切换按钮状态
    focusGroupListener: function() {
        if (this.map) {
            var this_ = this;
            this.map.on('focusGroupIDChanged', function(gid) {
                var index = this_.map.listGroups.length - gid;
                this_.changeScrollState(index);
            })
        }
    },

    //设置位置
    setPosition_: function(ele, h) {
        if (!ele) return;
        switch (this.positon_) {
            case 1:
                if (h)
                    ele.style.top = this.top_ + this.h_ + this.defaultPadding_ + this.y_ + 'px';
                else
                    ele.style.top = this.top_ + this.y_ + 'px';

                ele.style.left = this.left_ + this.x_ + 'px';
                break;
            case 2:
                if (this.map.mapView.container_.offsetHeight == 0) return;
                var top1 = this.map.mapView.container_.offsetHeight - this.h_ - 60; //减去水印的高度+自身的高度
                if (h) top1 = top1 - h - this.defaultPadding_;
                ele.style.top = top1 - this.y_ + 'px';
                ele.style.left = this.left_ + this.x_ + 'px';
                break;
            case 3:
                if (h)
                    ele.style.top = this.top_ + this.h_ + this.defaultPadding_ + this.y_ + 'px';
                else
                    ele.style.top = this.top_ + this.y_ + 'px';

                ele.style.right = this.right_ + this.x_ + 'px';
                break;
            case 4:
                if (this.map.mapView.container_.offsetHeight == 0) return;
                var top2 = this.map.mapView.container_.offsetHeight - this.h_ - 60;
                if (h) top2 = top2 - h - this.defaultPadding_;
                ele.style.top = top2 - this.y_ + 'px';
                ele.style.right = this.right_ + this.x_ + 'px';
                break;
        }
    },

    createLayers: function(gs, focusGroupId) {
        var this_ = this;
        this.$('.fm-layer-list').innerHTML = '';
        for (i = gs.length - 1; i >= 0; i--) {
            var g = gs[i];

            this.$('.fm-layer-list').appendChild(
                this.createLayerButton_(g.gid, g.gname.toUpperCase(),
                    focusGroupId == g.gid
                ));
            if (i > 0) this.$('.fm-layer-list').appendChild(this.addHr_());
        }

        this.inited = true;
    },

    onChange: function(change) {
        this.change_ = change;
    },

    //上一个的按钮状态
    up: function() {
        var count = document.querySelectorAll(".fm-layer-list > label").length;
        var index = count - parseInt(this.$(".fm-layer-list>label[class*='active']").dataset.gid);
        if (index != 0) {
            var nextIndex = index - 1;
            this.triggerClick(document.querySelectorAll(".fm-layer-list > label")[nextIndex]);
            this.changeScrollState(nextIndex);
        }
    },

    //下一个的按钮状态
    down: function() {
        var count = document.querySelectorAll(".fm-layer-list > label").length;
        var index = count - parseInt(this.$(".fm-layer-list>label[class*='active']").dataset.gid);
        if (index + 1 != count) {
            var nextIndex = index + 1;
            this.triggerClick(document.querySelectorAll(".fm-layer-list > label")[nextIndex]);
            this.changeScrollState(nextIndex);
        }
    },
    touchstart: function(e) {
        e.preventDefault();
        this.touchPointX = e.touches[0].pageX;
        this.touchPointY = e.touches[0].pageY;
        //alert(this.touchPointY);
    },
    touchmove: function(e) {
        e.preventDefault();
        this.touchEndPointX = e.touches[0].pageX;
        this.touchEndPointY = e.touches[0].pageY;
    },
    //添加手机端滚动和点击事件
    touchend: function(e) {
        var e = e || window.event;

        var labelObj = null;
        var scrollTop = this.$(".fm-layer-list").scrollTop;

        if (e.changedTouches.length > 0) {
            this.touchEndPointX = e.changedTouches[0].pageX;
            this.touchEndPointY = e.changedTouches[0].pageY;
        }
        labelObj = e.target;

        var delphaY = this.touchEndPointY - this.touchPointY;

        if (delphaY > 0 && delphaY > this.h_) {
            //alert("向上：" + delphaY);
            scrollTop = scrollTop - delphaY;
        } else if (delphaY < 0 && -delphaY > this.h_) {
            //alert("向下：" + delphaY);
            scrollTop = scrollTop + (-delphaY);
        } else if (((delphaY < this.h_ && delphaY >= 0) || (-delphaY < this.h_ && -delphaY >= 0)) && labelObj) {
            //alert("点击" + delphaY);
            this.triggerClick(labelObj);
        } else {
            //alert("无效" + delphaY);
        }

        this.$(".fm-layer-list").scrollTop = scrollTop;

        this.touchPointX = this.touchEndPointX;
        this.touchPointY = this.touchEndPointY;
    },
    //滚动切换楼层事件
    scroll: function(e) {
        var direct = 0;
        e = e || window.event;
        var scrollTop = this.$(".fm-layer-list").scrollTop;

        if (e.wheelDelta) { //判断浏览器IE，谷歌滑轮事件
            if (e.wheelDelta > 0) { //当滑轮向上滚动时
                scrollTop = scrollTop - e.wheelDelta;
            }
            if (e.wheelDelta < 0) { //当滑轮向下滚动时
                //this.triggerClick(downObj);
                scrollTop = scrollTop + (-e.wheelDelta);
            }
        } else if (e.detail) { //Firefox滑轮事件
            if (e.detail > 0) { //当滑轮向上滚动时
                scrollTop = scrollTop - e.detail;
            }
            if (e.detail < 0) { //当滑轮向下滚动时
                scrollTop = scrollTop + (-e.detail);
            }
        }

        this.$(".fm-layer-list").scrollTop = scrollTop;
    },

    createLayerButton_: function(gid, lbl, selected) {
        var this_ = this;
        var label = document.createElement("label");
        label.setAttribute('class', 'fm-control-groups-layer fm-layer-btn-default');
        label.setAttribute('data-gid', gid);
        label.style.display = 'inline-block';
        label.style.textAlign = 'center';
        label.style.width = this_.w_ + 'px';
        label.style.height = this_.h_ + 'px';
        label.style.lineHeight = this.h_ + 'px';
        label.style.cursor = 'pointer';
        label.style.fontSize = '0.8em';
        label.style.fontWeight = 'bold';
        label.style.margin = 0;
        label.style.color = this_.defaultColor;

        if (selected) {
            this.addClass(label, 'active');
            label.style.color = this_.selectedColor;
            var groupLbl = this_.$(".fm-control-groups-btn");
            groupLbl.innerText = lbl;
        }

        label.onclick = function() {
            var activelbl = this_.$(".fm-layer-list>label[class*='active']");
            if (activelbl.innerText === this.innerText) return;

            this_.triggerChange_(this);
        }

        var span = document.createElement("span");
        span.innerText = lbl;

        label.appendChild(span);

        return label;
    },

    addHr_: function() {
        var hr = document.createElement("hr");
        hr.style.height = '1px';
        hr.style.border = 'none';
        hr.style.borderTop = '1px solid rgba(153, 153, 153, 0.45)';
        hr.style.width = '60%';
        hr.style.margin = '0 20%';
        hr.style.filter = 'alpha(opacity=100, finishopacity=0, style=3)';
        return hr;
    },

    triggerChange_: function(ele) {

        var groups = [];
        //var ele = this.$(".fm-layer-list>label[class*='active']");

        if (ele) {
            groups.push(parseInt(ele.dataset['gid']));
        }
        this.changeMapVisibleGroups_(groups);
        //如果有回调函数回调
        if (this.change_ !== null) {
            this.change_(groups, this.allLayer);
        }
    },

    //切换聚焦层方法
    changeFocusGroup: function(groupId, isAllLayer) {
        if (isAllLayer) this.allLayer = isAllLayer;
        var index = this.map.listGroups.length - groupId;
        this.triggerClick(document.querySelectorAll(".fm-layer-list > label")[index]);
    },

    changeMapVisibleGroups_: function(sg) {
        if (!this.map) return;
        if (this.allLayer) {
            var gs = this.map.listGroups.map(function(obj) {
                return obj.gid;
            })

            this.map.visibleGroupIDs = gs;
        } else {
            this.map.visibleGroupIDs = sg;
        }

        this.map.focusGroupID = sg[0];
    },

    changeActiveStyle_: function(nextIndex) {
        var groupLbl = this.$(".fm-control-groups-btn");

        var labels = document.querySelectorAll(".fm-layer-list > label");
        var activelbl = this.$(".fm-layer-list>label[class*='active']");
        this.removeClass(activelbl, 'active');
        if (activelbl) activelbl.style.color = this.defaultColor;

        for (var i = 0, ilen = labels.length; i < ilen; i++) {
            var label = labels[i];
            if (i == nextIndex) {
                this.addClass(label, 'active');
                label.style.color = this.selectedColor;
                groupLbl.style.color = this.selectedColor;
                groupLbl.innerText = label.innerText;
                break;
            }
        }
    },

    //根据当前选择的按钮位置动态改变scroll的样式
    changeScrollState: function(nextIndex) {
        this.changeActiveStyle_(nextIndex);
        var btnHeight = this.$(".fm-layer-list > label").clientHeight;
        var count = document.querySelectorAll(".fm-layer-list > label").length;
        //向上滚动
        if (count - this.showBtnCount > nextIndex) {
            var top = nextIndex * (btnHeight + 2);
            var scrollTop = this.$(".fm-layer-list").scrollTop;
            if (top < scrollTop) {
                this.$(".fm-layer-list").scrollTop = top;
            }
        }

        //向下滚动
        if (this.showBtnCount <= nextIndex) {
            var top = (nextIndex - this.showBtnCount + 1) * (btnHeight + 2);
            var scrollTop = this.$(".fm-layer-list").scrollTop;
            if (top > scrollTop) {
                this.$(".fm-layer-list").scrollTop = top;
            }
        }

        //this.checkBtn();
    },

    //检测按钮式是否可以使用
    checkBtn: function() {
        var index = this.$(".fm-layer-list>label[class*='active']").dataset.gid - 1;
        var count = document.querySelectorAll(".fm-layer-list > label").length;
        var down = this.$(".fm-control-groups.fm-arrow-down");
        var top = this.$(".fm-control-groups.fm-arrow-top");

        if (index == 0) {
            this.addClass(down, "disabled");
            down.style.backgroundImage = "url(" + this.imgURL_ + "arrow4.png)";
        } else {
            this.removeClass(down, "disabled");
            down.style.backgroundImage = "url(" + this.imgURL_ + "arrow2.png)";
        }

        if (index == count - 1) {
            this.addClass(top, "disabled");
            top.style.backgroundImage = "url(" + this.imgURL_ + "arrow3.png)";
        } else {
            this.removeClass(top, "disabled");
            top.style.backgroundImage = "url(" + this.imgURL_ + "arrow1.png)";
        }
    },

    addClass: function(obj, cls) {
        if (!obj || !obj.className) return;
        var obj_class = obj.className; //获取 class 内容.
        var blank = (obj_class != '') ? ' ' : ''; //判断获取到的 class 是否为空, 如果不为空在前面加个'空格'.
        var added = obj_class + blank + cls; //组合原来的 class 和需要添加的 class.
        obj.className = added; //替换原来的 class.
    },

    removeClass: function(obj, cls) {
        if (!obj || !obj.className) return;
        var obj_class = ' ' + obj.className + ' '; //获取 class 内容, 并在首尾各加一个空格. ex) 'abc        bcd' -> ' abc        bcd '
        obj_class = obj_class.replace(/(\s+)/gi, ' '); //将多余的空字符替换成一个空格. ex) ' abc        bcd ' -> ' abc bcd '
        var removed = obj_class.replace(' ' + cls + ' ', ' '); //在原来的 class 替换掉首尾加了空格的 class. ex) ' abc bcd ' -> 'bcd '
        removed = removed.replace(/(^\s+)|(\s+$)/g, ''); //去掉首尾空格. ex) 'bcd ' -> 'bcd'
        obj.className = removed; //替换原来的 class.
    },

    hasClass: function(obj, cls) {
        if (!obj || !obj.className) return;
        var obj_class = obj.className; //获取 class 内容.
        var obj_class_lst = obj_class.split(/\s+/); //通过split空字符将cls转换成数组.
        var x = 0;
        for (x in obj_class_lst) {
            if (obj_class_lst[x] == cls) { //循环数组, 判断是否包含cls
                return true;
            }
        }
        return false;
    },

    triggerClick: function(obj) {
        if (!obj) return;
        //IE
        if (document.all) {
            obj.click();
        }
        // 其它浏览器
        else {
            var e = document.createEvent("MouseEvents");
            e.initMouseEvent("click", true, true);
            obj.dispatchEvent(e);
        }
    }
}
//楼层控制控件1，带滚动

/**
 *   scrollGroupsControl 楼层控制控件,滚动型，自带单双层切换按钮。一个地图只包含1个楼层控件。
 *   @class scrollGroupsControl
 *   @constructor
 *   @module FMControls
 *   @namespace fengmap
 *   @param {fengmap.FMMap} map 地图控件配置
 *   @param {JSON} ctrlOpts  控件参数配置
 *           @param {boolean} ctrlOpts.allLayer  初始显示多层还是单层，默认值false,单层显示。
 *           @param {number} ctrlOpts.showBtnCount  初始楼层按钮显示个数配置。默认显示5层,其他的隐藏，可滚动查看
 *           @param {boolean} ctrlOpts.needAllLayerBtn  是否显示多层/单层切换按钮。
 *           @param {fengmap.controlPositon} ctrlOpts.position  控件位置。分为左上、左下、右上、右下。 
 *           @param {JSON} ctrlOpts.offset  控件位置偏移。{x:0,y:0},基于原始位置的x,y方向的偏移。
 *           @param {string} ctrlOpts.imgURL  配置组件引用图片资源的路径地址。默认在页面的'resource/style/wedgets/img/'路径下
 *   @demo controls/楼层切换控件配置.js
 */
/**
 * 当前楼层的状态,默认是单楼层的。
 * @property allLayer
 * @final
 */

/**
 * 楼层按钮切换回调
 * @method onChange
 * @param {function} function(groups,allLayer){} 当楼层切换时候回调,返回参数包括groups,allLayer。
 * @demo controls/切换楼层方法回调.js
 */

/**
 * 切换楼层方法
 * @method changeFocusGroup
 * @param {int} 目标层groupID
 */

/**
 * 切换单、多层方法
 * @method changeGroupsSelect
 * @param {boolean} ture表示多层，false表示单层
 */

fengmap.scrollGroupsControl = function(map, ctrlOpts) {

    // 设置默认停靠位置和偏移量
    this.options_ = new fengmap.controlOptions(ctrlOpts);

    if (this.options_.size == 'normal') {
        this.w_ = 42;
        this.h_ = 42;
        this.padding_ = 10;
    } else {
        this.w_ = 32;
        this.h_ = 32;
        this.padding_ = 8;
    }

    this.x_ = this.options_.offset.x;
    this.y_ = this.options_.offset.y;

    //是否需要显示多楼层按钮
    this.needAllLayerBtn = (this.options_.needAllLayerBtn != undefined ? this.options_.needAllLayerBtn : true);

    this.allLayer = (this.options_.allLayer ? this.options_.allLayer : false); //控制单层显示还是所有模型展示
    this.showBtnCount = (this.options_.showBtnCount ? this.options_.showBtnCount : 5); //默认显示多少按钮
    this.positon_ = (this.options_.position ? this.options_.position : 2); //默认左下角
    this.top_ = 20;
    this.left_ = 10;
    this.right_ = 10;

    this.change_ = null;
    this.inited = false; //是否已经初始化

    //楼层名称颜色
    this.selectedColor = '#1E82FA';
    this.defaultColor = '#666666';

    //阴影样式
    this.defaultShadow_ = '2px 2px 3px rgba(0,0,0, 0.3)';
    this.defaultRadius_ = '2px';

    //封装querySelecter方法
    this.$ = function(cssname) {
        if (this.map)
            return this.map.mapView.container_.querySelector(cssname);
        else
            return document.querySelector(cssname);
    }

    //记录手机滑动的touchstart位置
    this.touchPointX;
    this.touchPointY;

    //手机滑动和点击结束后的touchend位置
    this.touchEndPointX;
    this.touchEndPointY;

    this.map = map;
    this.left_ = 10; //距离地图左边界的距离

    this.imgURL_ = this.options_.imgURL; //组件内部引用图片地址

    if (map) {
        this._tryInit(map);
    }
}

fengmap.scrollGroupsControl.prototype = {
    //创建可滚动的楼层部件
    _tryInit: function(map) {
        var groupbtnObj = this.$(".fm-control-groups");
        if (groupbtnObj) map.mapView.container_.removeChild(groupbtnObj);

        var groupDiv = document.createElement("div");
        groupDiv.setAttribute('class', 'fm-control-groups');
        groupDiv.style.width = this.w_ + 'px';
        groupDiv.style.position = 'absolute';
        //groupDiv.style.left = left + this.x_ + 'px';
        groupDiv.style.backgroundColor = 'white';
        groupDiv.style.boxShadow = this.defaultShadow_;
        groupDiv.style.borderRadius = this.defaultRadius_;

        if (this.needAllLayerBtn) {
            var layerCtrlLbl = document.createElement("div");
            layerCtrlLbl.setAttribute('class', 'fm-control-groups-layer fm-btn-layer');
            layerCtrlLbl.style.padding = this.padding_ + 'px';
            layerCtrlLbl.style.cursor = 'pointer';

            var layerCtrlImg = document.createElement("img");
            if (this.allLayer)
                layerCtrlImg.setAttribute('src', this.imgURL_ + 'layers.png');
            else
                layerCtrlImg.setAttribute('src', this.imgURL_ + 'layer.png');

            layerCtrlImg.style.width = this.w_ - this.padding_ * 2 + 'px';
            layerCtrlImg.style.height = this.h_ - this.padding_ * 2 + 'px';
            layerCtrlLbl.appendChild(layerCtrlImg);
            groupDiv.appendChild(layerCtrlLbl);
            var this_ = this;
            layerCtrlLbl.onclick = function(event) {
                this_.changeLayersStatus_(!this_.allLayer); //在改变界面
                this_.triggerChange_(); //先改变visibleGroupIDs
            };
        }

        var layerlistDiv = document.createElement("div");
        layerlistDiv.setAttribute('class', 'fm-layer-list');
        layerlistDiv.onmousewheel = this.scroll.bind(this);
        layerlistDiv.addEventListener('MozMousePixelScroll', this.scroll.bind(this), false); //firefox

        //如果是移动端ios andriod添加touch事件,电脑端绑定点击事件
        //console.log(this.isPC_());
        layerlistDiv.addEventListener('touchstart', this.touchstart.bind(this), false);
        layerlistDiv.addEventListener('touchmove', this.touchmove.bind(this), false);
        layerlistDiv.addEventListener('touchend', this.touchend.bind(this), false);


        groupDiv.appendChild(layerlistDiv);

        //avoid select word content
        groupDiv.onselectstart = function() {
            return false;
        }
        groupDiv.style.MozUserSelect = "none";

        //add tooldiv to map container
        var mapCanvas = map.mapView.container_.getElementsByTagName("canvas")[0];
        map.mapView.container_.insertBefore(groupDiv, mapCanvas);

        var focusID = map.focusGroupID > 0 ? map.focusGroupID : map.options.defaultFocusGroup;
        this.createLayers(map.listGroups, focusID);
        if (this.showBtnCount < map.listGroups.length) {
            var arrowTopDiv = document.createElement("div");
            arrowTopDiv.setAttribute('class', 'fm-control-groups fm-arrow-top');
            arrowTopDiv.style.height = '18px';
            arrowTopDiv.style.background = 'url(' + this.imgURL_ + 'arrow1.png) no-repeat 50% 50%';
            arrowTopDiv.style.cursor = 'pointer';
            arrowTopDiv.onclick = this.up.bind(this);

            var arrowBottomDiv = document.createElement("div");
            arrowBottomDiv.setAttribute('class', 'fm-control-groups fm-arrow-down');
            arrowBottomDiv.style.height = '18px';
            arrowBottomDiv.style.background = 'url(' + this.imgURL_ + 'arrow1.png) no-repeat 50% 50%';
            arrowBottomDiv.style.cursor = 'pointer';
            arrowBottomDiv.onclick = this.down.bind(this);

            groupDiv.insertBefore(arrowTopDiv, layerlistDiv);
            groupDiv.appendChild(arrowBottomDiv);

            //修改楼层列表的高度
            layerlistDiv.style.overflow = 'hidden';
            layerlistDiv.style.height = this.showBtnCount * this.h_ + 'px';

            //改变滚动条位置,使定位到当前聚焦层
            this.changeScrollState(map.listGroups.length - focusID);
            this.checkBtn();
        } else
            this.showBtnCount = map.listGroups.length;

        //设置控件距离上边界的高度
        this.setPosition_(groupDiv);
        //当地图视窗变化时调整小组件的位置
        this.controlPositionListener();
        this.focusGroupListener();
        this.visibleGroupsListener();
    },

    //当地图视窗变化时调整小组件的位置
    controlPositionListener: function() {
        if (this.map) {
            var this_ = this;
            this.map.on('update', function() {
                this_.setPosition_(this_.$('.fm-control-groups'));
            });
        }
    },

    //监听切换按钮状态
    focusGroupListener: function() {
        if (this.map) {
            var this_ = this;
            this.map.on('focusGroupIDChanged', function(gid) {
                var index = this_.map.listGroups.length - gid;
                this_.changeScrollState(index);
            })
        }
    },

    //监听切换显示楼层按钮,当外部调用了visibleGroupIDs的接口，且状态和控件内不一致时改变控件的单多层状态。
    visibleGroupsListener: function() {
        if (this.map) {
            var this_ = this;
            this.map.on('visibleGroupIDsChanged', function(groupIDs) {
                if (groupIDs.length > 1) {
                    this_.changeLayersStatus_(true);
                } else {
                    this_.changeLayersStatus_(false);
                }
            });
        }
    },

    //只改变单层、多层按钮样式
    changeLayersStatus_: function(allLayer) {
        if (allLayer == this.allLayer) return;
        var layerCtrlImg = this.$('.fm-btn-layer img');
        if (!allLayer) {
            layerCtrlImg.setAttribute('src', this.imgURL_ + 'layer.png');
            this.allLayer = false;
        } else {
            layerCtrlImg.setAttribute('src', this.imgURL_ + 'layers.png');
            this.allLayer = true;
        }
    },

    //切换单、多层方法
    changeGroupsSelect: function(allLayer) {
        this.changeLayersStatus_(allLayer); //在改变界面
        this.triggerChange_(); //先改变visibleGroupIDs

        // var layerCtrlImg = this.$('.fm-btn-layer img');
        // if (!allLayer) {
        //     layerCtrlImg.setAttribute('src', this.imgURL_ + 'layer.png');
        //     this.allLayer = false;
        // } else {
        //     layerCtrlImg.setAttribute('src', this.imgURL_ + 'layers.png');
        //     this.allLayer = true;
        // }
    },

    //设置位置
    setPosition_: function(ele, top) {
        if (!ele) return;
        switch (this.positon_) {
            case 1:
                ele.style.top = this.top_ + this.y_ + 'px';
                ele.style.left = this.left_ + this.x_ + 'px';
                break;
            case 2:
                // if (this.map.mapView.container_.offsetHeight == 0) return;
                // var top = this.map.mapView.container_.offsetHeight - ele.clientHeight - 60;
                ele.style.bottom = this.y_ + 'px';
                ele.style.left = this.left_ + this.x_ + 'px';
                break;
            case 3:
                ele.style.top = this.top_ + this.y_ + 'px';
                ele.style.right = this.right_ + this.x_ + 'px';
                break;
            case 4:
                //if (this.map.mapView.container_.offsetHeight == 0) return;
                //var top = this.map.mapView.container_.offsetHeight - ele.clientHeight - 60;
                //ele.style.top = top - this.y_ + 'px';
                ele.style.bottom = this.y_ + 'px';
                ele.style.right = this.right_ + this.x_ + 'px';
                break;
        }
    },

    createLayers: function(gs, focusGroupId) {
        var this_ = this;
        this.$('.fm-layer-list').innerHTML = '';
        for (i = gs.length - 1; i >= 0; i--) {
            var g = gs[i];

            this.$('.fm-layer-list').appendChild(
                this.createLayerButton_(g.gid, g.gname.toUpperCase(),
                    focusGroupId == g.gid
                ));
            if (i > 0) this.$('.fm-layer-list').appendChild(this.addHr_());
        }

        this.inited = true;
    },
    onChange: function(change) {
        this.change_ = change;
    },
    //上一个的按钮状态
    up: function() {
        var count = document.querySelectorAll(".fm-layer-list > label").length;
        var index = count - parseInt(this.$(".fm-layer-list>label[class*='active']").dataset.gid);
        if (index != 0) {
            var nextIndex = index - 1;
            this.triggerClick(document.querySelectorAll(".fm-layer-list > label")[nextIndex]);
            this.changeScrollState(nextIndex);
        }
    },

    //下一个的按钮状态
    down: function() {
        var count = document.querySelectorAll(".fm-layer-list > label").length;
        var index = count - parseInt(this.$(".fm-layer-list>label[class*='active']").dataset.gid);
        if (index + 1 != count) {
            var nextIndex = index + 1;
            this.triggerClick(document.querySelectorAll(".fm-layer-list > label")[nextIndex]);
            this.changeScrollState(nextIndex);
        }
    },
    touchstart: function(e) {
        e.preventDefault();
        this.touchPointX = e.touches[0].pageX;
        this.touchPointY = e.touches[0].pageY;
        //alert(this.touchPointY);
    },
    touchmove: function(e) {
        e.preventDefault();
        this.touchEndPointX = e.touches[0].pageX;
        this.touchEndPointY = e.touches[0].pageY;
    },
    touchend: function(e) {
        var e = e || window.event;

        var labelObj = null;
        var scrollTop = this.$(".fm-layer-list").scrollTop;

        if (e.changedTouches.length > 0) {
            this.touchEndPointX = e.changedTouches[0].pageX;
            this.touchEndPointY = e.changedTouches[0].pageY;
        }
        labelObj = e.target;

        var delphaY = this.touchEndPointY - this.touchPointY;

        if (delphaY > 0 && delphaY > this.h_) {
            scrollTop = scrollTop - delphaY;
        } else if (delphaY < 0 && -delphaY > this.h_)
            scrollTop = scrollTop + (-delphaY);
        else if (((delphaY < this.h_ && delphaY >= 0) || (-delphaY < this.h_ && -delphaY >= 0)) && labelObj) {
            this.triggerClick(labelObj);
        }

        this.$(".fm-layer-list").scrollTop = scrollTop;

        this.touchPointX = this.touchEndPointX;
        this.touchPointY = this.touchEndPointY;
    },

    //滚动切换楼层事件
    scroll: function(e) {
        var direct = 0;
        e = e || window.event;
        var scrollTop = this.$(".fm-layer-list").scrollTop;

        if (e.wheelDelta) { //判断浏览器IE，谷歌滑轮事件
            if (e.wheelDelta > 0) { //当滑轮向上滚动时
                scrollTop = scrollTop - e.wheelDelta;
            }
            if (e.wheelDelta < 0) { //当滑轮向下滚动时
                //this.triggerClick(downObj);
                scrollTop = scrollTop + (-e.wheelDelta);
            }
        } else if (e.detail) { //Firefox滑轮事件
            if (e.detail > 0) { //当滑轮向上滚动时
                scrollTop = scrollTop - e.detail;
            }
            if (e.detail < 0) { //当滑轮向下滚动时
                scrollTop = scrollTop + (-e.detail);
            }
        }

        this.$(".fm-layer-list").scrollTop = scrollTop;
    },
    //创建图层按钮方法
    createLayerButton_: function(gid, lbl, selected) {
        var this_ = this;
        var label = document.createElement("label");
        label.setAttribute('class', 'fm-control-groups-layer fm-layer-btn-default');
        label.setAttribute('data-gid', gid);
        label.style.display = 'inline-block';
        label.style.textAlign = 'center';
        label.style.width = this_.w_ + 'px';
        label.style.height = this_.h_ + 'px';
        label.style.lineHeight = this.h_ + 'px';
        label.style.margin = 0;
        label.style.cursor = 'pointer';
        label.style.fontSize = '0.8em';
        label.style.fontWeight = 'bold';

        if (selected) {
            this.addClass(label, 'active');
            label.style.color = this_.selectedColor;
        } else label.style.color = this_.defaultColor;

        label.onclick = function() {
            var activelbl = this_.$(".fm-layer-list>label[class*='active']");
            if (activelbl.innerText === this.innerText) return;
            this_.removeClass(activelbl, 'active');
            activelbl.style.color = this_.defaultColor;
            this_.addClass(this, 'active');
            this.style.color = this_.selectedColor;
            this_.triggerChange_();

            if (this_.showBtnCount < this_.map.listGroups.length)
                this_.checkBtn();
        }

        var span = document.createElement("span");
        span.innerText = lbl;

        label.appendChild(span);

        return label;
    },

    //添加下划线
    addHr_: function() {
        var hr = document.createElement("hr");
        hr.style.height = '1px';
        hr.style.border = 'none';
        hr.style.borderTop = '1px solid rgba(153, 153, 153, 0.45)';
        hr.style.width = '60%';
        hr.style.margin = '0 20%';
        hr.style.filter = 'alpha(opacity=100, finishopacity=0, style=3)';
        return hr;
    },
    //切换选中某楼层
    changeFocusGroup: function(groupId) {
        var index = this.map.listGroups.length - groupId;
        this.triggerClick(document.querySelectorAll(".fm-layer-list > label")[index]);
        this.changeScrollState(index);
    },
    triggerChange_: function(ele) {
        var groups = [];
        var ele = this.$(".fm-layer-list>label[class*='active']");

        if (ele) {
            groups.push(parseInt(ele.dataset['gid']));
        }
        this.changeMapVisibleGroups_(groups);
        if (this.change_ !== null) {
            this.change_(groups, this.allLayer);
        }

    },
    changeMapVisibleGroups_: function(sg) {
        if (!this.map) return;
        if (this.allLayer) {
            var gs = this.map.listGroups.map(function(obj) {
                return obj.gid;
            })
            // this.map.visibleGroupIDs = this.map.groupIDs;
            // to support separate load mode
            this.map.visibleGroupIDs = gs;
        } else {
            this.map.visibleGroupIDs = sg;
        }
        this.map.focusGroupID = sg[0];
    },
    changeActiveStyle_: function(nextIndex) {
        var labels = document.querySelectorAll(".fm-layer-list > label");
        var activelbl = this.$(".fm-layer-list>label[class*='active']");
        this.removeClass(activelbl, 'active');
        if (activelbl) activelbl.style.color = this.defaultColor;

        for (var i = 0, ilen = labels.length; i < ilen; i++) {
            var label = labels[i];
            if (i == nextIndex) {
                this.addClass(label, 'active');
                label.style.color = this.selectedColor;
                break;
            }
        }
    },
    //根据当前选择的按钮位置动态改变scroll的样式
    changeScrollState: function(nextIndex) {
        this.changeActiveStyle_(nextIndex);
        var btnHeight = this.$(".fm-layer-list > label").clientHeight;
        var count = document.querySelectorAll(".fm-layer-list > label").length;
        //向下滚动
        if (count - this.showBtnCount > nextIndex) {
            var top = nextIndex * (btnHeight + 2); //btnHeight+2包括下划线的高度
            var scrollTop = this.$(".fm-layer-list").scrollTop;
            if (top < scrollTop) {
                this.$(".fm-layer-list").scrollTop = top;
            }
        }

        //向上滚动
        if (this.showBtnCount <= nextIndex) {
            var top = (nextIndex - this.showBtnCount + 1) * (btnHeight + 2); //btnHeight+2包括下划线的高度
            var scrollTop = this.$(".fm-layer-list").scrollTop;
            if (top > scrollTop) {
                this.$(".fm-layer-list").scrollTop = top;
            }
        }
        //this.checkBtn();
    },
    //检测按钮式是否可以使用
    checkBtn: function() {
        if (!this.$(".fm-layer-list>label[class*='active']")) return;
        var index = this.$(".fm-layer-list>label[class*='active']").dataset.gid - 1;
        var count = document.querySelectorAll(".fm-layer-list > label").length;
        var down = this.$(".fm-control-groups.fm-arrow-down");
        var top = this.$(".fm-control-groups.fm-arrow-top");

        if (index == 0) {
            this.addClass(down, "disabled");
            down.style.backgroundImage = "url(" + this.imgURL_ + "arrow4.png)";
        } else {
            this.removeClass(down, "disabled");
            down.style.backgroundImage = "url(" + this.imgURL_ + "arrow2.png)";
        }

        if (index == count - 1) {
            this.addClass(top, "disabled");
            top.style.backgroundImage = "url(" + this.imgURL_ + "arrow3.png)";
        } else {
            this.removeClass(top, "disabled");
            top.style.backgroundImage = "url(" + this.imgURL_ + "arrow1.png)";
        }
    },

    addClass: function(obj, cls) {
        if (!obj || !obj.className) return;
        var obj_class = obj.className; //获取 class 内容.
        var blank = (obj_class != '') ? ' ' : ''; //判断获取到的 class 是否为空, 如果不为空在前面加个'空格'.
        var added = obj_class + blank + cls; //组合原来的 class 和需要添加的 class.
        obj.className = added; //替换原来的 class.
    },

    removeClass: function(obj, cls) {
        if (!obj || !obj.className) return;
        var obj_class = ' ' + obj.className + ' '; //获取 class 内容, 并在首尾各加一个空格. ex) 'abc        bcd' -> ' abc        bcd '
        obj_class = obj_class.replace(/(\s+)/gi, ' '); //将多余的空字符替换成一个空格. ex) ' abc        bcd ' -> ' abc bcd '
        var removed = obj_class.replace(' ' + cls + ' ', ' '); //在原来的 class 替换掉首尾加了空格的 class. ex) ' abc bcd ' -> 'bcd '
        removed = removed.replace(/(^\s+)|(\s+$)/g, ''); //去掉首尾空格. ex) 'bcd ' -> 'bcd'
        obj.className = removed; //替换原来的 class.
    },

    hasClass: function(obj, cls) {
        if (!obj || !obj.className) return false;
        var obj_class = obj.className; //获取 class 内容.
        var obj_class_lst = obj_class.split(/\s+/); //通过split空字符将cls转换成数组.
        var x = 0;
        for (x in obj_class_lst) {
            if (obj_class_lst[x] == cls) { //循环数组, 判断是否包含cls
                return true;
            }
        }
        return false;
    },

    triggerClick: function(obj) {
        if (!obj) return;
        //IE
        if (document.all) {
            obj.click();
        }
        // 其它浏览器
        else {
            var e = document.createEvent("MouseEvents");
            e.initMouseEvent("click", true, true);
            obj.dispatchEvent(e);
        }
    },

    //判断是否是pc
    // isPC_: function() {
    //     var userAgentInfo = navigator.userAgent;
    //     var Agents = ["Android", "iPhone", "SymbianOS", "Windows Phone", "iPad", "iPod"];
    //     var flag = true;
    //     for (var v = 0; v < Agents.length; v++) {
    //         if (userAgentInfo.indexOf(Agents[v]) > 0) {
    //             flag = false;
    //             break;
    //         }
    //     }
    //     return flag;
    // }
}
/**
 *   FMPopInfoWindow pop信息框控件。
 *   @class FMPopInfoWindow
 *   @constructor
 *   @module FMControls
 *   @namespace fengmap
 *   @param {fengmap.FMMap} map 地图控件配置
 *   @param {JSON} ctrlOpts  控件参数配置
 *   @param {boolean} ctrlOpts.IsScreenCoord  控件参数配置,默认false，false时参数mapCoord地图坐标生效，true时screenCoord屏幕坐标生效
 *   @param {JSON} ctrlOpts.mapCoord  添加信息框的地图位置坐标，可在此对象中添加height属性，控制信息框距离地图的高度。 如：{x:1000,y:1000,groupID:1,height:1}
 *   @param {JSON} ctrlOpts.screenCoord  添加信息框的屏幕位置坐标，可在此对象中添加height属性，控制信息框距离地图的高度。如：{x:1000,y:1000,height:1}
 *   @param {number} ctrlOpts.width  信息框宽度
 *   @param {number} ctrlOpts.height  控件参数配置
 *   @param {string} ctrlOpts.content  可为文本或html页面元素，如：'<a target="_bank" href="http://www.fengmap.com">这是一个信息框</a>'
 *   @param {number} ctrlOpts.marginTop  信息框距离地图的高度
 *   @param {function} ctrlOpts.closeCallBack  信息框关闭时的回调
 *   @demo controls/pop信息控件配置.js
 */

/**
 * 当前楼层的状态,默认是单楼层的。
 * @property allLayer
 * @final
 */

/**
 * 关闭当前的popInfoWindow
 * @method close
 */

fengmap.FMPopInfoWindow = function(map, ctrlOpts) {

    // 设置默认停靠位置和偏移量
    this.options_ = new fengmap.controlOptions(ctrlOpts);

    if (this.options_.size == 'normal') {
        this.w_ = !this.options_.width ? 300 : this.options_.width;
        this.h_ = !this.options_.height ? 150 : this.options_.height;
        this.padding_ = 10;
    } else {
        this.w_ = 32;
        this.h_ = 32;
        this.padding_ = 8;
    }

    //距离地图的高度，默认为0
    this.marginTop_ = !this.options_.marginTop ? 0 : this.options_.marginTop;

    //阴影样式
    this.defaultShadow_ = '2px 2px 3px rgba(0,0,0, 0.3)';
    this.defaultRadius_ = !this.options_.borderRadius ? '6px' : this.options_.borderRadius;

    //地图坐标
    this.screenCoord_ = !this.options_.screenCoord ? null : this.options_.screenCoord;
    this.mapCoord_ = !this.options_.mapCoord ? null : this.options_.mapCoord;
    //不管是屏幕坐标还是地图坐标都可以传入高度来改变地图坐标z值
    if (this.mapCoord_ && this.mapCoord_.height)
        this.mapCoord_.z = this.mapCoord_.height;
    if (this.screenCoord_ && this.screenCoord_.height)
        this.screenCoord_.z = this.screenCoord_.height;

    if (!this.screenCoord_ && !this.mapCoord_) return; //如果未传入任何坐标,则不添加气泡.

    //当前传的是地图坐标还是屏幕坐标
    this.IsScreenCoord = !this.screenCoord_ ? false : true;

    //封装querySelecter方法
    this.$ = function(cssname) {
        return document.querySelector(cssname);
    }

    this.defaultPadding_ = !this.options_.padding ? 20 : this.options_.padding;
    this.contentHeight_ = this.h_ - this.defaultPadding_ * 2;
    this.content_ = !this.options_.content ? "<span>我是气泡</span>" : this.options_.content;
    this.content_ = "<div style='overflow:auto;height:" + this.contentHeight_ + "px;'>" + this.content_ + "</div>";
    //borderstyle
    this.borderStyle_ = !this.options_.borderStyle ? "1px solid rgba(0,0,0,.2)" : this.options_.borderStyle;
    this.borderColor = !this.options_.borderColor ? 'rgba(0,0,0,.2)' : this.options_.borderColor;
    this.backgroundColor = !this.options_.backgroundColor ? '255,255,255' : this.options_.backgroundColor;
    this.opacity = 1;

    this.map_ = map;

    this.popDiv_ = null; //记录当前弹出框dom

    if (map) {
        this._tryInit(map);
    }
}

fengmap.FMPopInfoWindow.prototype = {
    _tryInit: function(map) {
        var markerDivObj = document.createElement("div");
        markerDivObj.setAttribute('class', 'fm-control-popmarker');
        markerDivObj.style.width = this.w_ + 'px';
        markerDivObj.style.height = this.h_ + 'px';

        markerDivObj.style.padding = this.defaultPadding_ + 'px';
        markerDivObj.style.backgroundColor = 'rgba(' + this.backgroundColor + ',' + this.opacity + ')';
        markerDivObj.style.border = this.borderStyle_;
        //markerDivObj.style.boxShadow = this.defaultShadow_;
        markerDivObj.style.borderRadius = this.defaultRadius_;
        markerDivObj.style.position = 'absolute';

        var popBotDiv = document.createElement("span");
        popBotDiv.setAttribute('class', 'fm-control-popmarker-bot');
        popBotDiv.style.width = 0;
        popBotDiv.style.height = 0;
        popBotDiv.style.fontSize = 0;
        popBotDiv.style.overflow = 'hidden';
        popBotDiv.style.position = 'absolute';
        popBotDiv.style.borderWidth = '20px';
        popBotDiv.style.borderStyle = 'solid dashed dashed';
        popBotDiv.style.borderColor = this.borderColor + ' transparent transparent';

        //popBotDiv.style.boxShadow = this.defaultShadow_;
        //popBotDiv.style.borderRadius = this.defaultRadius_;

        popBotDiv.style.left = this.w_ / 2 - 25 + 'px';
        popBotDiv.style.bottom = '-40px';

        var popTopDiv = document.createElement("span");
        popTopDiv.setAttribute('class', 'fm-control-popmarker-top');
        popTopDiv.style.width = 0;
        popTopDiv.style.height = 0;
        popTopDiv.style.fontSize = 0;
        popTopDiv.style.overflow = 'auto';
        popTopDiv.style.position = 'absolute';
        popTopDiv.style.borderStyle = 'solid dashed dashed';
        popTopDiv.style.borderWidth = '20px';
        popTopDiv.style.borderColor = 'rgba(' + this.backgroundColor + ',' + this.opacity + ') transparent transparent';
        popTopDiv.style.left = this.w_ / 2 - 25 + 'px';
        popTopDiv.style.bottom = '-39px';

        //popTopDiv.style.boxShadow = this.defaultShadow_;
        //popTopDiv.style.borderRadius = this.defaultRadius_;

        var closebutton = document.createElement("input");
        closebutton.type = 'button';
        closebutton.value = '✖';
        closebutton.style.borderRadius = '50%';
        closebutton.style.position = 'absolute';
        closebutton.style.right = '10px';
        closebutton.style.top = '8px';
        closebutton.style.background = '0 0 #eee';
        closebutton.style.width = '24px';
        closebutton.style.height = '24px';
        closebutton.style.border = 0;
        closebutton.style.webkitAppearance = 'none';

        closebutton.onclick = this.bindCloseClick_.bind(this);

        //add tooldiv to map container
        var mapCanvas = map.mapView.container_.getElementsByTagName("canvas")[0];
        map.mapView.container_.insertBefore(markerDivObj, mapCanvas);

        markerDivObj.appendChild(closebutton);
        markerDivObj.appendChild(popBotDiv);
        markerDivObj.appendChild(popTopDiv);
        markerDivObj.insertAdjacentHTML('beforeend', this.content_); //按照html样式添加到气泡框内

        if (this.IsScreenCoord) {
            var box = this.map_.mapView.container_.getBoundingClientRect();
            this.screenCoord_.x -= box.left;
            this.screenCoord_.y -= box.top;

            this.mapCoord_ = this.getMapCoord_(this.screenCoord_);
            this.setPosition_(markerDivObj, this.screenCoord_);
        } else {
            //如果配置了z属性，则使用z属性
            this.mapCoord_.z = this.getMapCoord_Z(this.mapCoord_.groupID, this.mapCoord_.z);
            this.setPosition_(markerDivObj, this.getScreenCoord_(this.mapCoord_));
        }

        this.popDiv_ = markerDivObj;

        this.controlPositionListener(); //当地图视窗变化时调整小组件的位置
    },

    //获取正确的转换高度的z值
    getMapCoord_Z: function(groupID, mapCoord_z) {
        //如果配置了z属性，则使用z属性
        if (!mapCoord_z)
            mapCoord_z = this.map_.getGroupHeight(groupID) + this.map_.layerLocalHeight;
        else
            mapCoord_z = this.map_.getGroupHeight(groupID) + mapCoord_z; //当前楼层高度 + 图层相对高度(固定值)
        return mapCoord_z;
    },

    //从屏幕坐标获取地图坐标.
    getMapCoord_: function(screencoord) {
        if (typeof(screencoord) != 'object' || !screencoord.x || !screencoord.y || !screencoord.groupID) return null;

        var pt1 = {
            x: screencoord.x, //把当前的clientX减去当前容器相对左边的距离得到实际的x坐标
            y: screencoord.y, //把当前的clientY减去当前容器相对顶边的距离得到实际的x坐标
            z: this.getMapCoord_Z(screencoord.groupID, screencoord.z) //当前楼层高度 + 图层相对高度(固定值)
        };

        return map.coordScreenToMap(pt1.x, pt1.y, pt1.z);
    },

    //从地图坐标获取屏幕坐标
    getScreenCoord_: function(mapcoord) {
        if (typeof(mapcoord) != 'object' || !mapcoord.x || !mapcoord.y || !mapcoord.z) return null;

        var pnt = this.map_.coordMapToScreen(mapcoord.x, mapcoord.y, mapcoord.z);

        var screenCoord = pnt;

        return screenCoord;
    },

    //关闭按钮
    bindCloseClick_: function() {
        this.close();
    },

    close: function() {
        if (!this.popDiv_) return;
        var container = this.map_.mapView.container_;

        container.removeChild(this.popDiv_);
        this.popDiv_ = null;

        //添加popInfoWindow的关闭回调函数
        if (this.options_.closeCallBack && typeof this.options_.closeCallBack == 'function') {
            this.options_.closeCallBack(true);
        }
    },

    //设置位置
    //弹出框上移,左移,使弹出框下面小三角对准屏幕坐标位置
    //坐标转换时地图视窗左上角转换出来为{0,0},需根据当前地图视窗所在页面中的实际位置计算.
    setPosition_: function(ele, screencoord) {
        if (!ele || !screencoord || typeof(screencoord) != 'object' || !screencoord.x || !screencoord.y) return;

        ele.style.top = screencoord.y - this.h_ - 35 - (this.marginTop_) + 'px'; //弹出框上移整个弹出框高度+三角高度 + 用户自定义的距离地图的高度
        ele.style.left = screencoord.x - this.w_ / 2 + 2 + 'px'; //弹出框左移半个弹出框宽度
    },

    //当地图视窗变化时调整小组件的位置
    controlPositionListener: function() {
        if (this.map_) {
            var this_ = this;
            this.map_.on('update', function() {
                if (!this_.popDiv_) return;
                this_.setPosition_(this_.popDiv_, this_.getScreenCoord_(this_.mapCoord_));
            });
        }
    }
}
//工具条控件 包括2D，3D切换，多层，单层切换

/**
 *   toolControl 图层控制控件,滚动型，自带单双层切换按钮。一个地图只包含1个工具控件。
 *   @class toolControl
 *   @constructor
 *   @module FMControls
 *   @namespace fengmap
 *   @param {fengmap.FMMap} map 地图控件配置
 *   @param {JSON} ctrlOpts  控件参数配置
 *          @param {bool} ctrlOpts.viewModeButtonNeeded  设置为false表示不显示,即只显示2D,3D切换按钮
 *          @param {bool} ctrlOpts.groupsButtonNeeded  设置为false表示不显示,即只显示楼层切换按钮.若viewModeButtonNeeded和groupsButtonNeeded都为false则不显示该工具控件.
 *          @param {bool} ctrlOpts.init2D  当二三维按钮存在时,设置初始默认显示模式.true表示显示2D模式,false表示显示3D模式.
 *          @param {bool} ctrlOpts.initGroups  当楼层切换按钮存在时,设置初始默认显示状态.true表示显示多层状态,false表示显示单层状态.
 *          @param {bool} ctrlOpts.clickCallBack  点击按钮事件回调方法,返回参数button,value.
 *              如点击二三维切换控件返回"btn-2D/3D",value为当前是二维还是三维的value值,即fengmap.FMViewMode.2D/fengmap.FMViewMode.3D.
 *              点击楼层切换控件时,返回"btn-groups",value为当前是多层还是单层,true表示多层,false表示单层.
 *           @param {fengmap.controlPositon} ctrlOpts.position  控件位置。分为左上、左下、右上、右下。 
 *           @param {JSON} ctrlOpts.offset  控件位置偏移。{x:0,y:0},基于原始位置的x,y方向的偏移。
 *           @param {string} ctrlOpts.imgURL  配置组件引用图片资源的路径地址。默认在页面的'resource/style/wedgets/img/'路径下
 *   @demo controls/工具组控件配置.js
 */

fengmap.toolControl = function(map, ctrlOpts) {

    // 设置默认停靠位置和偏移量
    this.options_ = new fengmap.controlOptions(ctrlOpts);
    //console.log(this.options_);
    if (this.options_.size == 'normal') {
        this.w_ = 42;
        this.h_ = 42;
        this.margin_ = 0;
    } else {
        this.w_ = 42;
        this.h_ = 42;
        this.margin_ = 0;
    }

    this.viewModeButtonNeeded = (this.options_.viewModeButtonNeeded != undefined ? this.options_.viewModeButtonNeeded : true); //是否需要2,3D切换按钮
    this.groupsButtonNeeded = (this.options_.groupsButtonNeeded != undefined ? this.options_.groupsButtonNeeded : true); //是否需要楼层切换按钮
    //console.log(this.options_.groupsButtonNeeded,this.groupsButtonNeeded);

    if (!this.viewModeButtonNeeded && !this.groupsButtonNeeded) return null;

    this.x_ = this.options_.offset.x;
    this.y_ = this.options_.offset.y;

    //点击事件回调函数
    this.clickCallBack = (typeof this.options_.clickCallBack == 'function' ? this.options_.clickCallBack : function(btntype, resp) {});

    this.init2D_ = this.options_.init2D;
    if (!this.init2D_) {
        this.viewMode_ = '3d';
    } else
        this.viewMode_ = 'top';

    this.buttonNum = 2;
    if (!this.groupsButtonNeeded) this.buttonNum -= 1;
    if (!this.viewModeButtonNeeded) this.buttonNum -= 1;

    this.initGroups_ = (this.options_.initGroups ? this.options_.initGroups : false);
    this.groups_ = this.initGroups_;
    //console.log("groups",this.groups_)
    this.defaultPadding_ = 10; //工具按钮之间的间距
    this.visible_ = true;

    this.positon_ = (this.options_.position ? this.options_.position : 3); //默认右上角
    this.top_ = 20;
    this.left_ = 10;
    this.right_ = 10;

    //初始状态是否展开工具栏
    this.expand_ = (this.options_.expanded ? this.options_.expanded : false);

    if (this.buttonNum >= 2) {
        this.expand_ = this.expand_;
    } else this.expand_ = true;

    //阴影+半径效果设置
    this.defaultShadow_ = '2px 2px 3px rgba(0,0,0, 0.3)';
    this.defaultRadius_ = '2px';

    this.imgURL_ = this.options_.imgURL; //组件内部引用图片地址

    if (map) {
        this.map = map;
        this._tryInit(map);
    }
};

fengmap.toolControl.prototype = {
    //private
    _tryInit: function(map) {
        //var top = this.top_;
        //保证当前只有1个工具类控件。
        var toolObj = map.mapView.container_.querySelector(".fm-control-tool");
        if (toolObj) map.mapView.container_.removeChild(toolObj);
        var toolsObj = map.mapView.container_.querySelector(".fm-control-tools");
        if (toolsObj) map.mapView.container_.removeChild(toolsObj);

        var toolDiv = document.createElement("div");
        toolDiv.setAttribute('class', 'fm-control-tool');
        toolDiv.style.zIndex = 10;
        toolDiv.style.position = 'absolute';
        //toolDiv.style.top = top + this.y_ + 'px';
        //toolDiv.style.right = this.x_ + 10 + 'px';
        toolDiv.style.height = this.h_ + 'px';
        toolDiv.style.width = this.w_ + 'px';
        toolDiv.style.cursor = 'pointer';
        toolDiv.style.backgroundColor = 'white';
        toolDiv.style.boxShadow = this.defaultShadow_;
        toolDiv.style.borderRadius = this.defaultRadius_;
        if (!this.expand_)
            toolDiv.style.background = 'white url(' + this.imgURL_ + 'more.png) no-repeat 50% 50%';
        else
            toolDiv.style.background = 'white url(' + this.imgURL_ + 'less.png) no-repeat 50% 50%';
        toolDiv.onclick = this.createTool_.bind(this);

        //avoid select word content
        toolDiv.onselectstart = function() {
            return false;
        }
        toolDiv.style.MozUserSelect = "none";


        //var top1 = top + this.h_ + this.defaultPadding_;

        var tools = document.createElement("div");
        tools.setAttribute('class', 'fm-control-tools');
        tools.style.position = 'absolute';

        tools.style.display = (this.expand_ == true ? 'block' : 'none');
        //console.log(this.expand_,tools.style.display);

        var tools1 = document.createElement("div");
        tools1.setAttribute('class', 'fm-control-tool-3d');
        tools1.style.height = this.h_ + 'px';
        tools1.style.width = this.w_ + 'px';
        tools1.style.padding = this.margin_ + 'px';
        //tools1.style.marginTop = this.defaultPadding_ + 'px';
        tools1.style.cursor = 'pointer';
        tools1.style.boxShadow = this.defaultShadow_;
        tools1.style.borderRadius = this.defaultRadius_;
        if (!this.init2D_)
            tools1.style.background = 'white url(' + this.imgURL_ + '3D.png) no-repeat 50% 50%';
        else
            tools1.style.background = 'white url(' + this.imgURL_ + '2D.png) no-repeat 50% 50%';
        tools1.style.backgroundColor = 'white';

        tools1.onclick = this.controlViewMode.bind(this);

        var tools2 = document.createElement("div");
        tools2.setAttribute('class', 'fm-control-tool-group');
        tools2.style.height = this.h_ + 'px';
        tools2.style.width = this.w_ + 'px';
        tools2.style.padding = this.margin_ + 'px';
        //tools2.style.marginBottom = this.margin_ + 'px';
        tools2.style.marginTop = this.defaultPadding_ + 'px';
        tools2.style.cursor = 'pointer';
        tools2.style.boxShadow = this.defaultShadow_;
        tools2.style.borderRadius = this.defaultRadius_;
        if (!this.initGroups_)
            tools2.style.background = 'white url(' + this.imgURL_ + 'group.png) no-repeat 50% 50%';
        else
            tools2.style.background = 'white url(' + this.imgURL_ + 'groups.png) no-repeat 50% 50%';

        tools2.onclick = this.controlGroup.bind(this);

        if (this.viewModeButtonNeeded)
            tools.appendChild(tools1);
        if (this.groupsButtonNeeded)
            tools.appendChild(tools2);

        //avoid select word content
        tools.onselectstart = function() {
            return false;
        }
        tools.style.MozUserSelect = "none";

        //add tooldiv to map container
        var mapCanvas = map.mapView.container_.getElementsByTagName("canvas")[0];
        if (this.buttonNum >= 2) {
            map.mapView.container_.insertBefore(toolDiv, mapCanvas);
            //设置控件位置
            this.setPosition_(toolDiv);
        }
        map.mapView.container_.insertBefore(tools, mapCanvas);
        if (this.buttonNum >= 2) {
            this.setPosition_(tools, this.h_);
        } else
            this.setPosition_(tools);


        //当地图视窗变化时调整小组件的位置
        this.controlPositionListener();
    },

    //当地图视窗变化时调整小组件的位置
    controlPositionListener: function() {
        if (this.map) {
            var this_ = this;
            this.map.on('update', function() {
                if (this_.buttonNum >= 2) {
                    var toolDiv = document.querySelector('.fm-control-tool');
                    this_.setPosition_(toolDiv);
                }
                var tools = document.querySelector('.fm-control-tools');
                if (this_.buttonNum >= 2) {
                    this_.setPosition_(tools, this_.h_);
                } else
                    this_.setPosition_(tools);
            });
        }
    },

    //设置位置
    setPosition_: function(ele, h) {
        if (!ele) return;
        switch (this.positon_) {
            case 1:
                if (h)
                    ele.style.top = this.top_ + h + this.defaultPadding_ + this.y_ + 'px';
                else
                    ele.style.top = this.top_ + this.y_ + 'px';

                ele.style.left = this.left_ + this.x_ + 'px';
                break;
            case 2:
                if (this.map.mapView.container_.offsetHeight == 0) return;
                var top1 = this.map.mapView.container_.offsetHeight - ele.clientHeight - 60;
                if (h) top1 = top1 - h - this.defaultPadding_;
                ele.style.top = top1 - this.y_ + 'px';
                ele.style.left = this.left_ + this.x_ + 'px';
                break;
            case 3:
                if (h)
                    ele.style.top = this.top_ + h + this.defaultPadding_ + this.y_ + 'px';
                else
                    ele.style.top = this.top_ + this.y_ + 'px';

                ele.style.right = this.right_ + this.x_ + 'px';
                break;
            case 4:
                if (this.map.mapView.container_.offsetHeight == 0) return;
                var top2 = this.map.mapView.container_.offsetHeight - ele.clientHeight - 60;
                if (h) top2 = top2 - h - this.defaultPadding_;
                ele.style.top = top2 - this.y_ + 'px';
                ele.style.right = this.right_ + this.x_ + 'px';
                break;
        }
    },

    createTool_: function() {
        var toolDiv = document.getElementsByClassName("fm-control-tool")[0];
        var toolsDiv = document.getElementsByClassName('fm-control-tools')[0];

        if (toolsDiv.style.display == 'none') {
            toolDiv.style.background = 'white url(' + this.imgURL_ + 'less.png) no-repeat 50% 50%';
            toolsDiv.style.display = 'block';
        } else {
            toolDiv.style.background = 'white url(' + this.imgURL_ + 'more.png) no-repeat 50% 50%';
            toolsDiv.style.display = 'none';
        }
    },

    controlViewMode: function(obj) {
        if (!this.map) return;
        //console.log('viewmode',this.viewMode_);
        var toolDiv = document.getElementsByClassName("fm-control-tool-3d")[0];
        if (!this.viewMode_ || (this.viewMode_ == '3d')) {
            //先切换到单层状态            
            if (this.groups_ && this.groupsButtonNeeded) {
                var groupTool = document.getElementsByClassName("fm-control-tool-group")[0];
                //IE
                if (document.all) {
                    groupTool.click();
                }
                // 其它浏览器
                else {
                    var e = document.createEvent("MouseEvents");
                    e.initEvent("click", true, true);
                    groupTool.dispatchEvent(e);
                }
            }

            toolDiv.style.background = 'white url(' + this.imgURL_ + '2D.png) no-repeat 50% 50%';
            this.map.viewMode = fengmap.FMViewMode.MODE_2D; //2维模式
            this.viewMode_ = 'top';
        } else {
            toolDiv.style.background = 'white url(' + this.imgURL_ + '3D.png) no-repeat 50% 50%';
            this.map.viewMode = fengmap.FMViewMode.MODE_3D; //3维模式
            this.viewMode_ = '3d';
        }

        this.clickCallBack('btn-2D/3D', this.viewMode_);
    },

    controlGroup: function(obj) {
        if (!this.map) return;
        //console.log(this.groups_);
        var toolDiv = document.getElementsByClassName("fm-control-tool-group")[0];
        if (this.groups_) {
            toolDiv.style.background = 'white url(' + this.imgURL_ + 'group.png) no-repeat 50% 50%';
            this.map.visibleGroupIDs = [map.focusGroupID];
        } else {
            //先切换到3D模式
            if (this.viewMode_ == 'top' && this.viewModeButtonNeeded) {
                var viewTool = document.getElementsByClassName("fm-control-tool-3d")[0];
                //IE
                if (document.all) {
                    viewTool.click();
                }
                // 其它浏览器
                else {
                    var e = document.createEvent("MouseEvents");
                    e.initEvent("click", true, true);
                    viewTool.dispatchEvent(e);
                }
            }

            toolDiv.style.background = "white url(" + this.imgURL_ + "groups.png) no-repeat 50% 50%";
            this.map.visibleGroupIDs = map.groupIDs;
        }
        this.map.focusGroupID = {
            gid: map.focusGroupID,
            time: 0
        };
        this.groups_ = !this.groups_;

        this.clickCallBack('btn-groups', this.groups_);
    },

    /**
     * 获取当前是否为多层模式
     * @method IsAllGroups   
     * @return  {boolean} true为多层，false为单层
     */
    IsAllGroups: function() {
        return this.groups_;
    }
};
///定义缩放控件类
/**
 *   zoomControl 定义缩放控件类。一个地图只包含1个缩放控件。
 *   @class zoomControl
 *   @constructor
 *   @module FMControls
 *   @namespace fengmap
 *   @param {fengmap.FMMap} map 地图控件配置
 *   @param {JSON} ctrlOpts  控件参数配置
 *           @param {fengmap.controlPositon} ctrlOpts.position  控件位置。分为左上、左下、右上、右下。 
 *           @param {JSON} ctrlOpts.offset  控件位置偏移。{x:0,y:0},基于原始位置的x,y方向的偏移。
 *           @param {string} ctrlOpts.imgURL  配置组件引用图片资源的路径地址。默认在页面的'resource/style/wedgets/img/'路径下
 *   @demo controls/放大缩小控件配置.js
 */

fengmap.zoomControl = function(map, ctrlOpts) {

    // 设置默认停靠位置和偏移量
    this.options_ = new fengmap.controlOptions(ctrlOpts);
    if (this.options_.size == 'normal') {
        this.w_ = 42;
        this.h_ = 42;
        this.padding_ = 14;
    } else {
        this.w_ = 42;
        this.h_ = 42;
        this.padding_ = 14;
    }

    this.x_ = this.options_.offset.x; //偏移位置
    this.y_ = this.options_.offset.y; //偏移位置

    this.positon_ = (this.options_.position ? this.options_.position : 4); //默认右下角
    this.top_ = 20;
    this.left_ = 10;
    this.right_ = 10;

    this.defaultShadow_ = '2px 2px 3px rgba(0,0,0, 0.3)';
    this.defaultRadius_ = '2px';

    //放大和缩小的回调返回当前级别
    this.scaleLevelcallback = (typeof this.options_.scaleLevelcallback == 'function' ? this.options_.scaleLevelcallback : null);

    this.imgURL_ = this.options_.imgURL; //组件内部引用图片地址
    if (map) {
        this.map = map;
        this._tryInit(map);
    }
};

fengmap.zoomControl.prototype = {

    //private
    _tryInit: function(map) {
        var zoomObj = map.mapView.container_.querySelector(".fm-control-zoom");
        if (zoomObj) map.mapView.container_.removeChild(zoomObj);

        var zoomDiv = document.createElement("div");
        zoomDiv.setAttribute('class', 'fm-control-zoom');
        zoomDiv.style.zIndex = 10;
        zoomDiv.style.position = 'absolute';
        zoomDiv.style.backgroundColor = 'white';
        zoomDiv.style.boxShadow = this.defaultShadow_;
        zoomDiv.style.borderRadius = this.defaultRadius_;

        var zoomInDiv = document.createElement("div");
        zoomInDiv.setAttribute('class', 'fm-control-zoom-in');
        zoomInDiv.onclick = this.scaleLevelIn.bind(this);
        zoomInDiv.style.padding = this.padding_ + 'px';
        zoomInDiv.style.cursor = 'pointer';
        zoomInDiv.style.height = this.h_;

        var zoomInImg = document.createElement("img");
        zoomInImg.setAttribute('src', this.imgURL_ + 'zoomin.png');
        zoomInImg.style.width = this.w_ - this.padding_ * 2 + 'px';
        zoomInImg.style.height = this.h_ - this.padding_ * 2 + 'px';

        zoomInDiv.appendChild(zoomInImg);

        zoomInImg.onmouseover = this.changeZoomInImgActive.bind(this);
        zoomInImg.onmouseout = this.changeZoomInImgUnActive.bind(this);

        zoomInDiv.onmousedown = this.changeZoomInImgUnActive.bind(this);
        zoomInDiv.onmouseup = this.changeZoomInImgActive.bind(this);

        //avoid select word content
        zoomInDiv.onselectstart = function() {
            return false;
        }
        zoomInDiv.style.MozUserSelect = "none";
        //zoomInImg.onselectstart=function(){return false;}

        var zoomOutDiv = document.createElement("div");
        zoomOutDiv.setAttribute('class', 'fm-control-zoom-out');
        zoomOutDiv.onclick = this.scaleLevelOut.bind(this);
        zoomOutDiv.style.padding = this.padding_ + 'px';
        zoomOutDiv.style.cursor = 'pointer';
        zoomOutDiv.style.height = this.h_;

        var zoomOutImg = document.createElement("img");
        zoomOutImg.setAttribute('src', this.imgURL_ + 'zoomout.png');
        zoomOutImg.style.width = this.w_ - this.padding_ * 2 + 'px';
        zoomOutImg.style.height = this.h_ - this.padding_ * 2 + 'px';

        zoomOutDiv.appendChild(zoomOutImg);

        zoomOutImg.onmouseover = this.changeZoomOutImgActive.bind(this);
        zoomOutImg.onmouseout = this.changeZoomOutImgUnActive.bind(this);

        zoomOutDiv.onmousedown = this.changeZoomOutImgActive.bind(this);
        zoomOutDiv.onmouseup = this.changeZoomOutImgUnActive.bind(this);

        //avoid select word content
        zoomOutDiv.onselectstart = function() {
            return false;
        }
        zoomOutDiv.style.MozUserSelect = "none";

        zoomDiv.appendChild(zoomInDiv);
        zoomDiv.appendChild(this.addHr_());
        zoomDiv.appendChild(zoomOutDiv);

        var mapCanvas = map.mapView.container_.getElementsByTagName("canvas")[0];
        map.mapView.container_.insertBefore(zoomDiv, mapCanvas);

        //设置控件位置
        this.setPosition_(zoomDiv);
        //当地图视窗变化时调整小组件的位置
        this.controlPositionListener();
    },

    //放大的mouseover效果
    changeZoomInImgActive: function(event) {
        var zoomIn = document.querySelector('.fm-control-zoom-in img');
        zoomIn.setAttribute('src', this.imgURL_ + 'zoomin_on.png');
    },

    changeZoomInImgUnActive: function() {
        var zoomIn = document.querySelector('.fm-control-zoom-in img');
        zoomIn.setAttribute('src', this.imgURL_ + 'zoomin.png');
    },

    //缩小的mouseover效果
    changeZoomOutImgActive: function(event) {
        var zoomOut = document.querySelector('.fm-control-zoom-out img');
        zoomOut.setAttribute('src', this.imgURL_ + 'zoomout_on.png');
    },

    changeZoomOutImgUnActive: function() {
        var zoomOut = document.querySelector('.fm-control-zoom-out img');
        zoomOut.setAttribute('src', this.imgURL_ + 'zoomout.png');
    },

    //当地图视窗变化时调整小组件的位置
    controlPositionListener: function() {
        if (this.map) {
            var this_ = this;
            this.map.on('update', function() {
                var zoomDiv = document.querySelector('.fm-control-zoom');

                this_.setPosition_(zoomDiv);
            });
        }
    },

    //设置位置
    setPosition_: function(ele, top) {
        if (!ele) return;
        switch (this.positon_) {
            case 1:
                ele.style.top = this.top_ + this.y_ + 'px';
                ele.style.left = this.left_ + this.x_ + 'px';
                break;
            case 2:
                // if (this.map.mapView.container_.offsetHeight == 0) return;
                // var top = this.map.mapView.container_.offsetHeight - ele.clientHeight - 60;
                //ele.style.top = top - this.y_ + 'px';
                ele.style.bottom = this.top_ + this.y_ + 'px';
                ele.style.left = this.left_ + this.x_ + 'px';
                break;
            case 3:
                ele.style.top = this.top_ + this.y_ + 'px';
                ele.style.right = this.right_ + this.x_ + 'px';
                break;
            case 4:
                // if (this.map.mapView.container_.offsetHeight == 0) return;
                // var top = this.map.mapView.container_.offsetHeight - ele.clientHeight - 60;
                // ele.style.top = top - this.y_ + 'px';
                ele.style.bottom = this.top_ + this.y_ + 'px';
                ele.style.right = this.right_ + this.x_ + 'px';
                break;
        }
    },

    addHr_: function() {
        var hr = document.createElement("hr");
        hr.style.height = '1px';
        hr.style.border = 'none';
        hr.style.borderTop = '1px solid rgba(153, 153, 153, 0.45)';
        hr.style.width = '60%';
        hr.style.margin = '0 20%';
        hr.style.filter = 'alpha(opacity=100, finishopacity=0, style=3)';
        return hr;
    },

    //模型缩小
    scaleLevelOut: function(ps) {
        /*if (!this.map) return;
        if (this.map) {
            var mapscale = this.map.mapScale;
            this.map.mapScale = mapscale * 1.5;
        }
        if (typeof(this.scaleLevelcallback) == 'function') this.scaleLevelcallback(this.map.mapScale);*/
        return this._zoom(false, ps);
    },

    //模型放大
    scaleLevelIn: function(ps) {
        /*if (this.map) {
            var mapscale = this.map.mapScale;
            this.map.mapScale = mapscale / 1.5;

            if (typeof(this.scaleLevelcallback) == 'function') this.scaleLevelcallback(mapscale / 1.5);
        }*/
        return this._zoom(true, ps);
    },

    /**
     * ztc add (20161117)
     * @param  {bool} boo true: 放大, false: 缩小
     * @param  {JSON} ps  {duration: , callback:}
     * @return {null}     null
     */
    _zoom: function(boo, ps) {
        var s = this;
        if (s.map) {
            var mapscale = boo ? s.map.mapScale / 1.5 : s.map.mapScale * 1.5;

            // 0: 在正常限制范围, 1: 大于最大比例尺值, -1: 小于最小比例尺值
            var tip = 0;

            if (mapscale < s.map.minMapScale) {
                mapscale = s.map.minMapScale;
                tip = -1;
            } else if (mapscale > s.map.maxMapScale) {
                mapscale = s.map.maxMapScale
                tip = 1;
            }

            ps = ps || {};

            s.map.mapScale = {
                scale: mapscale,
                duration: fmg(ps, 'time', 'duration', .3),
                callback: function() {
                    if (typeof(s.scaleLevelcallback) == 'function') s.scaleLevelcallback(s.map.mapScale, tip);
                    if (ps.callback) {
                        ps.callback();
                    }
                }
            }

            return tip;
        }
    }
}
/**
 * 
 */

fm.requestPool = [];

fm.stopAllRequest = function() {
    fm.requestPool.forEach(function(req) {
        req.abort();
    })
}

fm.Ajax = function(url, callbackFunction, useArrayBuffer, failFunction, timeout) {
    var scope = this;

    this.bindFunction = function(caller, object) {
        return function() {
            return caller.apply(object, [object]);
        };
    };

    this.getRequest = function() {
        if (window.ActiveXObject)
            return new ActiveXObject('Microsoft.XMLHTTP');
        else if (window.XMLHttpRequest)
            return new XMLHttpRequest();
        return false;
    };

    this.postBody = '';

    var _pb = arguments[arguments.length - 1];

    if (typeof _pb === 'string') {
        this.postBody = _pb;
    }

    this.callbackFunction = callbackFunction;
    this.failFunction = (typeof failFunction === 'function' ? failFunction : null);
    this.url = url;
    this.request = this.getRequest();

    // this.request.withCredentials = true;

    // add to pool
    fm.requestPool.push(this.request);

    this.stateChange = function(object) {
        if (this.request.readyState == 4) {

            // clear time out
            clearTimeout(this._timeoutID);

            if (this.isTimeout) {
                console.log('ajax timeout');
                if (this.failFunction) {
                    this.failFunction();
                }
                return;
            }

            //local file ,success status = 0
            if ((window.location.protocol == 'file:' && this.request.status == 0) || (this.request.status >= 200 && this.request.status < 300)) {

                console.log('success::: this.request.status', this.request.status);

                if (useArrayBuffer == true) {
                    this.callbackFunction(this.request.response);
                } else {
                    this.callbackFunction(this.request.responseText);
                }
            } else {
                if (typeof scope.failFunction === 'function') {
                    var boo = true;
                    if (useArrayBuffer === true) {
                        var str = null;

                        if (scope.request.response) {
                            if (window.TextDecoder) {
                                var dec = new window.TextDecoder('utf-8');
                                str = dec.decode(scope.request.response);
                            } else {
                                str = String.fromCharCode.apply(null, new Uint8Array(scope.request.response));
                            }
                        }

                        // arrayBuffer to string
                        if (str) {
                            try {
                                boo = false;
                                var json = JSON.parse(str);
                                scope.failFunction(json);
                            } catch (e) {
                                boo = true;
                            }
                        }
                    }

                    if (boo) {
                        scope.failFunction(scope.request.response);
                    }
                }

                console.log('Ajax:', scope.request.status, scope.request.response);
            }
        }
    };

    //	this.postBody = (arguments[2] || "");

    if (this.request) {
        var req = this.request;
        req.onreadystatechange = this.bindFunction(this.stateChange, this);

        this.isTimeout = false;

        /////////////////////////////////
        // timeout 
        /////////////////////////////////
        if (typeof timeout === 'number') {
            this._timeoutID = setTimeout(function() {
                clearTimeout(scope._timeoutID);
                scope.isTimeout = true;
                scope.request.abort();
            }, (timeout || 30000));
        }

        if (this.postBody !== "") {
            req.open("POST", url, true);
            // req.setRequestHeader('Access-Control-Allow-Headers', '*');
            //req.setRequestHeader("Access-Control-Allow-Origin", '*');
            req.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
            // req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
            req.setRequestHeader('Content-type', 'application/json;charset=utf-8');
            // req.setRequestHeader('Connection', 'close');
        } else {
            req.open("GET", url, true);
            // req.setRequestHeader('Access-Control-Allow-Headers', '*');
            //req.setRequestHeader("Access-Control-Allow-Origin", '*');
        }

        if (useArrayBuffer === true) {
            req.responseType = 'arraybuffer';
        }

        try {
            req.send(this.postBody);
        } catch (e) {
            if (this.failFunction) {
                this.failFunction(e);
            }
        }
    }
}
/**
 * smokesignals
 */

fm.Evento = {
    convert: function(obj, handlers) {
        // we store the list of handlers as a local variable inside the scope
        // so that we don't have to add random properties to the object we are
        // converting. (prefixing variables in the object with an underscore or
        // two is an ugly solution)
        //      we declare the variable in the function definition to use two less
        //      characters (as opposed to using 'var ').  I consider this an inelegant
        //      solution since smokesignals.convert.length now returns 2 when it is
        //      really 1, but doing this doesn't otherwise change the functionallity of
        //      this module, so we'll go with it for now
        handlers = handlers || {};

        // add a listener
        obj.on = function(eventName, handler) {
            // either use the existing array or create a new one for this event
            //      this isn't the most efficient way to do this, but is the shorter
            //      than other more efficient ways, so we'll go with it for now.
            (handlers[eventName] = handlers[eventName] || [])
                // add the handler to the array
                .push(handler);

            return obj;
        }

        // get handlers by eventName
        obj.getHandlers = function(eventName) {
            return handlers[eventName];
        };

        // add a listener that will only be called once
        obj.once = function(eventName, handler) {
            // create a wrapper listener, that will remove itself after it is called
            function wrappedHandler() {
                // remove ourself, and then call the real handler with the args
                // passed to this wrapper
                handler.apply(obj.off(eventName, wrappedHandler), arguments);
            }
            // in order to allow that these wrapped handlers can be removed by
            // removing the original function, we save a reference to the original
            // function
            wrappedHandler.h = handler;

            // call the regular add listener function with our new wrapper
            return obj.on(eventName, wrappedHandler);
        }

        // remove a listener
        obj.off = function(eventName, handler) {
            // loop through all handlers for this eventName, assuming a handler
            // was passed in, to see if the handler passed in was any of them so
            // we can remove it
            //      it would be more efficient to stash the length and compare i
            //      to that, but that is longer so we'll go with this.
            for (var list = handlers[eventName], i = 0; handler && list && list[i]; i++) {
                // either this item is the handler passed in, or this item is a
                // wrapper for the handler passed in.  See the 'once' function
                list[i] != handler && list[i].h != handler ||
                    // remove it!
                    list.splice(i--,1);
            }
            // if i is 0 (i.e. falsy), then there are no items in the array for this
            // event name (or the array doesn't exist)
            // if (!i) {
            if (!handler) {
                // remove the array for this eventname (if it doesn't exist then
                // this isn't really hurting anything)
                delete handlers[eventName];
            }
            return obj;
        }

        obj.emit = function(eventName) {
            // loop through all handlers for this event name and call them all
            //      it would be more efficient to stash the length and compare i
            //      to that, but that is longer so we'll go with this.
            for(var list = handlers[eventName], i = 0; list && list[i];) {
                list[i++].apply(obj, list.slice.call(arguments, 1));
            }
            return obj;
        }

        return obj;
    }
};

//for window resize event!
// fm.addEvent = function(object, type, callback) {
//     if (object == null || typeof(object) == 'undefined') return;
//     if (object.addEventListener) {
//         object.addEventListener(type, callback, false);
//     } else if (object.attachEvent) {
//         object.attachEvent("on" + type, callback);
//     } else {
//         object["on"+type] = callback;
//     }
// };
// File:src/fm.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var fm = window.fm || { REVISION: '76' };

//

if ( typeof define === 'function' && define.amd ) {

	define( 'fm', fm );

} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

	module.exports = fm;

}

//

if ( Number.EPSILON === undefined ) {

	Number.EPSILON = Math.pow( 2, - 52 );

}

//

if ( Math.sign === undefined ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

	};

}

if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

	// Missing in IE9-11.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

	Object.defineProperty( Function.prototype, 'name', {

		get: function () {

			return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

		}

	} );

}

if ( Object.assign === undefined ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

	Object.defineProperty( Object, 'assign', {

		writable: true,
		configurable: true,

		value: function ( target ) {

			'use strict';

			if ( target === undefined || target === null ) {

				throw new TypeError( "Cannot convert first argument to object" );

			}

			var to = Object( target );

			for ( var i = 1, n = arguments.length; i !== n; ++ i ) {

				var nextSource = arguments[ i ];

				if ( nextSource === undefined || nextSource === null ) continue;

				nextSource = Object( nextSource );

				var keysArray = Object.keys( nextSource );

				for ( var nextIndex = 0, len = keysArray.length; nextIndex !== len; ++ nextIndex ) {

					var nextKey = keysArray[ nextIndex ];
					var desc = Object.getOwnPropertyDescriptor( nextSource, nextKey );

					if ( desc !== undefined && desc.enumerable ) {

						to[ nextKey ] = nextSource[ nextKey ];

					}

				}

			}

			return to;

		}

	} );

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

fm.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

fm.CullFaceNone = 0;
fm.CullFaceBack = 1;
fm.CullFaceFront = 2;
fm.CullFaceFrontBack = 3;

fm.FrontFaceDirectionCW = 0;
fm.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

fm.BasicShadowMap = 0;
fm.PCFShadowMap = 1;
fm.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

fm.FrontSide = 0;
fm.BackSide = 1;
fm.DoubleSide = 2;

// shading

fm.FlatShading = 1;
fm.SmoothShading = 2;

// colors

fm.NoColors = 0;
fm.FaceColors = 1;
fm.VertexColors = 2;

// blending modes

fm.NoBlending = 0;
fm.NormalBlending = 1;
fm.AdditiveBlending = 2;
fm.SubtractiveBlending = 3;
fm.MultiplyBlending = 4;
fm.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)

fm.AddEquation = 100;
fm.SubtractEquation = 101;
fm.ReverseSubtractEquation = 102;
fm.MinEquation = 103;
fm.MaxEquation = 104;

// custom blending destination factors

fm.ZeroFactor = 200;
fm.OneFactor = 201;
fm.SrcColorFactor = 202;
fm.OneMinusSrcColorFactor = 203;
fm.SrcAlphaFactor = 204;
fm.OneMinusSrcAlphaFactor = 205;
fm.DstAlphaFactor = 206;
fm.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//fm.ZeroFactor = 200;
//fm.OneFactor = 201;
//fm.SrcAlphaFactor = 204;
//fm.OneMinusSrcAlphaFactor = 205;
//fm.DstAlphaFactor = 206;
//fm.OneMinusDstAlphaFactor = 207;
fm.DstColorFactor = 208;
fm.OneMinusDstColorFactor = 209;
fm.SrcAlphaSaturateFactor = 210;

// depth modes

fm.NeverDepth = 0;
fm.AlwaysDepth = 1;
fm.LessDepth = 2;
fm.LessEqualDepth = 3;
fm.EqualDepth = 4;
fm.GreaterEqualDepth = 5;
fm.GreaterDepth = 6;
fm.NotEqualDepth = 7;


// TEXTURE CONSTANTS

fm.MultiplyOperation = 0;
fm.MixOperation = 1;
fm.AddOperation = 2;

// Tone Mapping modes

fm.NoToneMapping = 0; // do not do any tone mapping, not even exposure (required for special purpose passes.)
fm.LinearToneMapping = 1; // only apply exposure.
fm.ReinhardToneMapping = 2;
fm.Uncharted2ToneMapping = 3; // John Hable
fm.CineonToneMapping = 4;  // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson

// Mapping modes

fm.UVMapping = 300;

fm.CubeReflectionMapping = 301;
fm.CubeRefractionMapping = 302;

fm.EquirectangularReflectionMapping = 303;
fm.EquirectangularRefractionMapping = 304;

fm.SphericalReflectionMapping = 305;
fm.CubeUVReflectionMapping = 306;
fm.CubeUVRefractionMapping = 307;

// Wrapping modes

fm.RepeatWrapping = 1000;
fm.ClampToEdgeWrapping = 1001;
fm.MirroredRepeatWrapping = 1002;

// Filters

fm.NearestFilter = 1003;
fm.NearestMipMapNearestFilter = 1004;
fm.NearestMipMapLinearFilter = 1005;
fm.LinearFilter = 1006;
fm.LinearMipMapNearestFilter = 1007;
fm.LinearMipMapLinearFilter = 1008;

// Data types

fm.UnsignedByteType = 1009;
fm.ByteType = 1010;
fm.ShortType = 1011;
fm.UnsignedShortType = 1012;
fm.IntType = 1013;
fm.UnsignedIntType = 1014;
fm.FloatType = 1015;
fm.HalfFloatType = 1025;

// Pixel types

//fm.UnsignedByteType = 1009;
fm.UnsignedShort4444Type = 1016;
fm.UnsignedShort5551Type = 1017;
fm.UnsignedShort565Type = 1018;

// Pixel formats

fm.AlphaFormat = 1019;
fm.RGBFormat = 1020;
fm.RGBAFormat = 1021;
fm.LuminanceFormat = 1022;
fm.LuminanceAlphaFormat = 1023;
// fm.RGBEFormat handled as fm.RGBAFormat in shaders
fm.RGBEFormat = fm.RGBAFormat; //1024;
fm.DepthFormat = 1026;

// DDS / ST3C Compressed texture formats

fm.RGB_S3TC_DXT1_Format = 2001;
fm.RGBA_S3TC_DXT1_Format = 2002;
fm.RGBA_S3TC_DXT3_Format = 2003;
fm.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

fm.RGB_PVRTC_4BPPV1_Format = 2100;
fm.RGB_PVRTC_2BPPV1_Format = 2101;
fm.RGBA_PVRTC_4BPPV1_Format = 2102;
fm.RGBA_PVRTC_2BPPV1_Format = 2103;

// ETC compressed texture formats

fm.RGB_ETC1_Format = 2151;

// Loop styles for AnimationAction

fm.LoopOnce = 2200;
fm.LoopRepeat = 2201;
fm.LoopPingPong = 2202;

// Interpolation

fm.InterpolateDiscrete = 2300;
fm.InterpolateLinear = 2301;
fm.InterpolateSmooth = 2302;

// Interpolant ending modes

fm.ZeroCurvatureEnding = 2400;
fm.ZeroSlopeEnding = 2401;
fm.WrapAroundEnding = 2402;

// Triangle Draw modes

fm.TrianglesDrawMode = 0;
fm.TriangleStripDrawMode = 1;
fm.TriangleFanDrawMode = 2;

// Texture Encodings

fm.LinearEncoding = 3000; // No encoding at all.
fm.sRGBEncoding = 3001;
fm.GammaEncoding = 3007; // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput

// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.
// These encodings should not specified as output encodings except in rare situations.
fm.RGBEEncoding = 3002; // AKA Radiance.
fm.LogLuvEncoding = 3003;
fm.RGBM7Encoding = 3004;
fm.RGBM16Encoding = 3005;
fm.RGBDEncoding = 3006; // MaxRange is 256.

// Depth packing strategies

fm.BasicDepthPacking = 3200;  // for writing to float textures for high precision or for visualizing results in RGB buffers
fm.RGBADepthPacking = 3201; // for packing into RGBA buffers.

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.Color = function ( color ) {

	if ( arguments.length === 3 ) {

		return this.fromArray( arguments );

	}

	return this.set( color );

};

fm.Color.prototype = {

	constructor: fm.Color,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value instanceof fm.Color ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setScalar: function ( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function () {

		function hue2rgb( p, q, t ) {

			if ( t < 0 ) t += 1;
			if ( t > 1 ) t -= 1;
			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
			if ( t < 1 / 2 ) return q;
			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
			return p;

		}

		return function ( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = fm.Math.euclideanModulo( h, 1 );
			s = fm.Math.clamp( s, 0, 1 );
			l = fm.Math.clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		};

	}(),

	setStyle: function ( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'fm.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		var m;

		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			var color;
			var name = m[ 1 ];
			var components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 5 ] );

						return this;

					}

					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 5 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						var h = parseFloat( color[ 1 ] ) / 360;
						var s = parseInt( color[ 2 ], 10 ) / 100;
						var l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 5 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

			// hex color

			var hex = m[ 1 ];
			var size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			// color keywords
			var hex = fm.ColorKeywords[ style ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex );

			} else {

				// unknown color
				console.warn( 'fm.Color: Unknown color ' + style );

			}

		}

		return this;

	},

	clone: function () {

		return new this.constructor( this.r, this.g, this.b );

	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	},

	copyLinearToGamma: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

};

fm.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

fm.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

fm.Quaternion.prototype = {

	constructor: fm.Quaternion,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( euler instanceof fm.Euler === false ) {

			throw new Error( 'fm.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		var order = euler.order;

		if ( order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

		// assumes direction vectors vFrom and vTo are normalized

		var v1, r;

		var EPS = 0.000001;

		return function ( vFrom, vTo ) {

			if ( v1 === undefined ) v1 = new fm.Vector3();

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			this.normalize();

			return this;

		};

	}(),

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'fm.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

Object.assign( fm.Quaternion, {

	slerp: function( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	},

	slerpFlat: function(
			dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		var x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ],

			x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			var s = 1 - t,

				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				var sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			var tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

} );

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

fm.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

fm.Vector2.prototype = {

	constructor: fm.Vector2,

	get width() {

		return this.x;

	},

	set width( value ) {

		this.x = value;

	},

	get height() {

		return this.y;

	},

	set height( value ) {

		this.y = value;

	},

	//

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'fm.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'fm.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {

			this.x *= scalar;
			this.y *= scalar;

		} else {

			this.x = 0;
			this.y = 0;

		}

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new fm.Vector2();
				max = new fm.Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

		return this;

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	lengthManhattan: function() {

		return Math.abs( this.x ) + Math.abs( this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	angle: function () {

		// computes the angle in radians with respect to the positive x-axis

		var angle = Math.atan2( this.y, this.x );

		if ( angle < 0 ) angle += 2 * Math.PI;

		return angle;

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];

		return this;

	},

	rotateAround: function ( center, angle ) {

		var c = Math.cos( angle ), s = Math.sin( angle );

		var x = this.x - center.x;
		var y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

fm.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

fm.Vector3.prototype = {

	constructor: fm.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'fm.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'fm.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'fm.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function applyEuler( euler ) {

			if ( euler instanceof fm.Euler === false ) {

				console.error( 'fm.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			if ( quaternion === undefined ) quaternion = new fm.Quaternion();

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function applyAxisAngle( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new fm.Quaternion();

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: fm.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

		return this;

	},

	applyProjection: function ( m ) {

		// input: fm.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix;

		return function project( camera ) {

			if ( matrix === undefined ) matrix = new fm.Matrix4();

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyProjection( matrix );

		};

	}(),

	unproject: function () {

		var matrix;

		return function unproject( camera ) {

			if ( matrix === undefined ) matrix = new fm.Matrix4();

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyProjection( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: fm.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new fm.Vector3();
				max = new fm.Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

		return this;

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'fm.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function () {

		var v1, dot;

		return function projectOnVector( vector ) {

			if ( v1 === undefined ) v1 = new fm.Vector3();

			v1.copy( vector ).normalize();

			dot = this.dot( v1 );

			return this.copy( v1 ).multiplyScalar( dot );

		};

	}(),

	projectOnPlane: function () {

		var v1;

		return function projectOnPlane( planeNormal ) {

			if ( v1 === undefined ) v1 = new fm.Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		};

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function reflect( normal ) {

			if ( v1 === undefined ) v1 = new fm.Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		};

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

		// clamp, to handle numerical problems

		return Math.acos( fm.Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setFromSpherical: function( s ) {

		var sinPhiRadius = Math.sin( s.phi ) * s.radius;

		this.x = sinPhiRadius * Math.sin( s.theta );
		this.y = Math.cos( s.phi ) * s.radius;
		this.z = sinPhiRadius * Math.cos( s.theta );

		return this;

	},

	setFromMatrixPosition: function ( m ) {

		return this.setFromMatrixColumn( m, 3 );

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( m, index ) {

		if ( typeof m === 'number' ) {

			console.warn( 'fm.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );

			m = arguments[ 1 ];
			index = arguments[ 0 ];

		}

		return this.fromArray( m.elements, index * 4 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];
		this.z = attribute.array[ index + 2 ];

		return this;

	}

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

fm.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

fm.Vector4.prototype = {

	constructor: fm.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z, this.w );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'fm.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'fm.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;

		}

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
		                   ( m13 - m31 ) * ( m13 - m31 ) +
		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new fm.Vector4();
				max = new fm.Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];
		this.z = attribute.array[ index + 2 ];
		this.w = attribute.array[ index + 3 ];

		return this;

	}

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

fm.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || fm.Euler.DefaultOrder;

};

fm.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

fm.Euler.DefaultOrder = 'XYZ';

fm.Euler.prototype = {

	constructor: fm.Euler,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._order );

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = fm.Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'fm.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromQuaternion: function () {

		var matrix;

		return function ( q, order, update ) {

			if ( matrix === undefined ) matrix = new fm.Matrix4();
			matrix.makeRotationFromQuaternion( q );
			this.setFromRotationMatrix( matrix, order, update );

			return this;

		};

	}(),

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new fm.Quaternion();

		return function ( newOrder ) {

			q.setFromEuler( this );
			this.setFromQuaternion( q, newOrder );

		};

	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new fm.Vector3( this._x, this._y, this._z );

		}

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://clara.io
 */

fm.Line3 = function ( start, end ) {

	this.start = ( start !== undefined ) ? start : new fm.Vector3();
	this.end = ( end !== undefined ) ? end : new fm.Vector3();

};

fm.Line3.prototype = {

	constructor: fm.Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new fm.Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new fm.Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new fm.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function () {

		var startP = new fm.Vector3();
		var startEnd = new fm.Vector3();

		return function ( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = fm.Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new fm.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://clara.io
 */

fm.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new fm.Vector2( + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new fm.Vector2( - Infinity, - Infinity );

};

fm.Box2.prototype = {

	constructor: fm.Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new fm.Vector2();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new fm.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new fm.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new fm.Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	intersectsBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new fm.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new fm.Vector2();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

fm.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new fm.Vector3( + Infinity, + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new fm.Vector3( - Infinity, - Infinity, - Infinity );

};

fm.Box3.prototype = {

	constructor: fm.Box3,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromArray: function ( array ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = array.length; i < l; i += 3 ) {

			var x = array[ i ];
			var y = array[ i + 1 ];
			var z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new fm.Vector3();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function () {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		var v1 = new fm.Vector3();

		return function ( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {
                var geometry = node.geometry;
                
                //jimguo add beg
                if(node instanceof fm.LOD){
                    var lvmesh = node.levels[0].object;
                    geometry = lvmesh.geometry;
                }
                //jimguo add end
                
				if ( geometry !== undefined ) {

					if ( geometry instanceof fm.Geometry ) {

						var vertices = geometry.vertices;

						for ( var i = 0, il = vertices.length; i < il; i ++ ) {

							v1.copy( vertices[ i ] );
							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry instanceof fm.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

						var positions = geometry.attributes[ 'position' ].array;

						for ( var i = 0, il = positions.length; i < il; i += 3 ) {

							v1.fromArray( positions, i );
							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					}

				}

			} );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new fm.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new fm.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
				 point.y < this.min.y || point.y > this.max.y ||
				 point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new fm.Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	intersectsBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
				 box.max.y < this.min.y || box.min.y > this.max.y ||
				 box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	intersectsSphere: ( function () {

		var closestPoint;

		return function intersectsSphere( sphere ) {

			if ( closestPoint === undefined ) closestPoint = new fm.Vector3();

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, closestPoint );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		};

	} )(),

	intersectsPlane: function ( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		var min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= plane.constant && max >= plane.constant );

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new fm.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new fm.Vector3();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function () {

		var v1 = new fm.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new fm.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if( this.isEmpty() ) this.makeEmpty();

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function () {

		var points = [
			new fm.Vector3(),
			new fm.Vector3(),
			new fm.Vector3(),
			new fm.Vector3(),
			new fm.Vector3(),
			new fm.Vector3(),
			new fm.Vector3(),
			new fm.Vector3()
		];

		return function ( matrix ) {

			// transform of empty box is an empty box.
			if( this.isEmpty() ) return this;

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

fm.Matrix3 = function () {

	this.elements = new Float32Array( [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'fm.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

};

fm.Matrix3.prototype = {

	constructor: fm.Matrix3,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ],
			me[ 1 ], me[ 4 ], me[ 7 ],
			me[ 2 ], me[ 5 ], me[ 8 ]

		);

		return this;

	},

	setFromMatrix4: function( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[  8 ],
			me[ 1 ], me[ 5 ], me[  9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	},

	applyToVector3Array: function () {

		var v1;

		return function ( array, offset, length ) {

			if ( v1 === undefined ) v1 = new fm.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

				v1.fromArray( array, j );
				v1.applyMatrix3( this );
				v1.toArray( array, j );

			}

			return array;

		};

	}(),

	applyToBuffer: function () {

		var v1;

		return function applyToBuffer( buffer, offset, length ) {

			if ( v1 === undefined ) v1 = new fm.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = buffer.length / buffer.itemSize;

			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

				v1.x = buffer.getX( j );
				v1.y = buffer.getY( j );
				v1.z = buffer.getZ( j );

				v1.applyMatrix3( this );

				buffer.setXYZ( v1.x, v1.y, v1.z );

			}

			return buffer;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnDegenerate ) {

		if ( matrix instanceof fm.Matrix4 ) {

			console.error( "fm.Matrix3.getInverse no longer takes a Matrix4 argument." );

		}

		var me = matrix.elements,
			te = this.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) {

			var msg = "fm.Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnDegenerate || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();
		}

		te[ 0 ] = t11;
		te[ 1 ] = n31 * n23 - n33 * n21;
		te[ 2 ] = n32 * n21 - n31 * n22;

		te[ 3 ] = t12;
		te[ 4 ] = n33 * n11 - n31 * n13;
		te[ 5 ] = n31 * n12 - n32 * n11;

		te[ 6 ] = t13;
		te[ 7 ] = n21 * n13 - n23 * n11;
		te[ 8 ] = n22 * n11 - n21 * n12;

		return this.multiplyScalar( 1 / det );

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "fm.Matrix3: .flattenToArrayOffset is deprecated " +
				"- just use .toArray instead." );

		return this.toArray( array, offset );

	},

	getNormalMatrix: function ( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ]  = te[ 8 ];

		return array;

	}

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

fm.Matrix4 = function () {

	this.elements = new Float32Array( [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'fm.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

};

fm.Matrix4.prototype = {

	constructor: fm.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new fm.Matrix4().fromArray( this.elements );

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0,       0,       0,       1
		);

		return this;

	},

	extractRotation: function () {

		var v1;

		return function ( m ) {

			if ( v1 === undefined ) v1 = new fm.Vector3();

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( euler instanceof fm.Euler === false ) {

			console.error( 'fm.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;

		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;

		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	lookAt: function () {

		var x, y, z;

		return function ( eye, target, up ) {

			if ( x === undefined ) x = new fm.Vector3();
			if ( y === undefined ) y = new fm.Vector3();
			if ( z === undefined ) z = new fm.Vector3();

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.lengthSq() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.lengthSq() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'fm.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	applyToVector3Array: function () {

		var v1;

		return function ( array, offset, length ) {

			if ( v1 === undefined ) v1 = new fm.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

				v1.fromArray( array, j );
				v1.applyMatrix4( this );
				v1.toArray( array, j );

			}

			return array;

		};

	}(),

	applyToBuffer: function () {

		var v1;

		return function applyToBuffer( buffer, offset, length ) {

			if ( v1 === undefined ) v1 = new fm.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = buffer.length / buffer.itemSize;

			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

				v1.x = buffer.getX( j );
				v1.y = buffer.getY( j );
				v1.z = buffer.getZ( j );

				v1.applyMatrix4( this );

				buffer.setXYZ( v1.x, v1.y, v1.z );

			}

			return buffer;

		};

	}(),

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "fm.Matrix3: .flattenToArrayOffset is deprecated " +
				"- just use .toArray instead." );

		return this.toArray( array, offset );

	},

	getPosition: function () {

		var v1;

		return function () {

			if ( v1 === undefined ) v1 = new fm.Vector3();
			console.warn( 'fm.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

			return v1.setFromMatrixColumn( this, 3 );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnDegenerate ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements,
			me = m.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) {

			var msg = "fm.Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnDegenerate || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();

		}

		te[ 0 ] = t11;
		te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
		te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
		te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;

		te[ 4 ] = t12;
		te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
		te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
		te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;

		te[ 8 ] = t13;
		te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
		te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
		te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;

		te[ 12 ] = t14;
		te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
		te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
		te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

		return this.multiplyScalar( 1 / det );

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, - s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector, matrix;

		return function ( position, quaternion, scale ) {

			if ( vector === undefined ) vector = new fm.Vector3();
			if ( matrix === undefined ) matrix = new fm.Matrix4();

			var te = this.elements;

			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) {

				sx = - sx;

			}

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;

			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;

			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( fm.Math.DEG2RAD * fov * 0.5 );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = 1.0 / ( right - left );
		var h = 1.0 / ( top - bottom );
		var p = 1.0 / ( far - near );

		var x = ( right + left ) * w;
		var y = ( top + bottom ) * h;
		var z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ]  = te[ 8 ];
		array[ offset + 9 ]  = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://clara.io
 */

fm.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new fm.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new fm.Vector3();

};

fm.Ray.prototype = {

	constructor: fm.Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new fm.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	lookAt: function ( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

	},

	recast: function () {

		var v1 = new fm.Vector3();

		return function ( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new fm.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function ( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	},

	distanceSqToPoint: function () {

		var v1 = new fm.Vector3();

		return function ( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceToSquared( point );

		};

	}(),

	distanceSqToSegment: function () {

		var segCenter = new fm.Vector3();
		var segDir = new fm.Vector3();
		var diff = new fm.Vector3();

		return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			segDir.copy( v1 ).sub( v0 ).normalize();
			diff.copy( this.origin ).sub( segCenter );

			var segExtent = v0.distanceTo( v1 ) * 0.5;
			var a01 = - this.direction.dot( segDir );
			var b0 = diff.dot( this.direction );
			var b1 = - diff.dot( segDir );
			var c = diff.lengthSq();
			var det = Math.abs( 1 - a01 * a01 );
			var s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

			}

			return sqrDist;

		};

	}(),

	intersectSphere: function () {

		var v1 = new fm.Vector3();

		return function ( sphere, optionalTarget ) {

			v1.subVectors( sphere.center, this.origin );
			var tca = v1.dot( this.direction );
			var d2 = v1.dot( v1 ) - tca * tca;
			var radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			var thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			var t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			var t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, optionalTarget );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, optionalTarget );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, optionalTarget );

	},



	intersectsPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	intersectBox: function ( box, optionalTarget ) {

		var tmin, tmax, tymin, tymax, tzmin, tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectsBox: ( function () {

		var v = new fm.Vector3();

		return function ( box ) {

			return this.intersectBox( box, v ) !== null;

		};

	} )(),

	intersectTriangle: function () {

		// Compute the offset origin, edges, and normal.
		var diff = new fm.Vector3();
		var edge1 = new fm.Vector3();
		var edge2 = new fm.Vector3();
		var normal = new fm.Vector3();

		return function ( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		};

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;

	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

fm.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new fm.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

fm.Sphere.prototype = {

	constructor: fm.Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	},

	setFromPoints: function () {

		var box = new fm.Box3();

		return function ( points, optionalCenter ) {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).center( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	intersectsBox: function ( box ) {

		return box.intersectsSphere( this );

	},

	intersectsPlane: function ( plane ) {

		// We use the following equation to compute the signed distance from
		// the center of the sphere to the plane.
		//
		// distance = q * n - d
		//
		// If this distance is greater than the radius of the sphere,
		// then there is no intersection.

		return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new fm.Vector3();

		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new fm.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

fm.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new fm.Plane(),
		( p1 !== undefined ) ? p1 : new fm.Plane(),
		( p2 !== undefined ) ? p2 : new fm.Plane(),
		( p3 !== undefined ) ? p3 : new fm.Plane(),
		( p4 !== undefined ) ? p4 : new fm.Plane(),
		( p5 !== undefined ) ? p5 : new fm.Plane()

	];

};

fm.Frustum.prototype = {

	constructor: fm.Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new fm.Sphere();

		return function ( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function () {

		var p1 = new fm.Vector3(),
			p2 = new fm.Vector3();

		return function ( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6 ; i ++ ) {

				var plane = planes[ i ];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}

			}

			return true;

		};

	}(),

	intersectsSprite: function () {

		var sphere = new fm.Sphere();

		return function intersectsSprite( sprite ) {

			sphere.center.set( 0, 0, 0 );
			sphere.radius = 0.7071067811865476;
			sphere.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),



	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://clara.io
 */

fm.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new fm.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

fm.Plane.prototype = {

	constructor: fm.Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function () {

		var v1 = new fm.Vector3();
		var v2 = new fm.Vector3();

		return function ( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new fm.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	intersectLine: function () {

		var v1 = new fm.Vector3();

		return function ( line, optionalTarget ) {

			var result = optionalTarget || new fm.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),

	intersectsLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectsBox: function ( box ) {

		return box.intersectsPlane( this );

	},

	intersectsSphere: function ( sphere ) {

		return sphere.intersectsPlane( this );

	},

	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new fm.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function () {

		var v1 = new fm.Vector3();
		var m1 = new fm.Matrix3();

		return function ( matrix, optionalNormalMatrix ) {

			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

			// transform normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			// recalculate constant (like in setFromNormalAndCoplanarPoint)
			this.constant = - referencePoint.dot( normal );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

};

// File:src/math/Spherical.js

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The poles (phi) are at the positive and negative y axis.
 * The equator starts at positive z.
 */

fm.Spherical = function ( radius, phi, theta ) {

	this.radius = ( radius !== undefined ) ? radius : 1.0;
	this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
	this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

	return this;

};

fm.Spherical.prototype = {

	constructor: fm.Spherical,

	set: function ( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( other ) {

		this.radius.copy( other.radius );
		this.phi.copy( other.phi );
		this.theta.copy( other.theta );

		return this;

	},

	// restrict phi to be betwee EPS and PI-EPS
	makeSafe: function() {

		var EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

	},

	setFromVector3: function( vec3 ) {

		this.radius = vec3.length();

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
			this.phi = Math.acos( fm.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

		}

		return this;

	},

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

fm.Math = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var uuid = new Array( 36 );
		var rnd = 0, r;

		return function () {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

					uuid[ i ] = '-';

				} else if ( i === 14 ) {

					uuid[ i ] = '4';

				} else {

					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

				}

			}

			return uuid.join( '' );

		};

	}(),

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	random16: function () {

		console.warn( 'fm.Math.random16() has been deprecated. Use Math.random() instead.' );
		return Math.random();

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function ( degrees ) {

		return degrees * fm.Math.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * fm.Math.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	nearestPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

	},

	nextPowerOfTwo: function ( value ) {

		value --;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		value ++;

		return value;

	}

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

fm.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function ( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i ++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new fm.Vector3(),
			tmpVec = new fm.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( ! nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint !== oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new fm.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i ++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j ++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

fm.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new fm.Vector3();
	this.b = ( b !== undefined ) ? b : new fm.Vector3();
	this.c = ( c !== undefined ) ? c : new fm.Vector3();

};

fm.Triangle.normal = function () {

	var v0 = new fm.Vector3();

	return function ( a, b, c, optionalTarget ) {

		var result = optionalTarget || new fm.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if ( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
fm.Triangle.barycoordFromPoint = function () {

	var v0 = new fm.Vector3();
	var v1 = new fm.Vector3();
	var v2 = new fm.Vector3();

	return function ( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new fm.Vector3();

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( - 2, - 1, - 1 );

		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

fm.Triangle.containsPoint = function () {

	var v1 = new fm.Vector3();

	return function ( point, a, b, c ) {

		var result = fm.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

fm.Triangle.prototype = {

	constructor: fm.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function () {

		var v0 = new fm.Vector3();
		var v1 = new fm.Vector3();

		return function () {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new fm.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return fm.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new fm.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return fm.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return fm.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	closestPointToPoint: function () {

		var plane, edgeList, projectedPoint, closestPoint;

		return function closestPointToPoint( point, optionalTarget ) {

			if ( plane === undefined ) {

				plane = new fm.Plane();
				edgeList = [ new fm.Line3(), new fm.Line3(), new fm.Line3() ];
				projectedPoint = new fm.Vector3();
				closestPoint = new fm.Vector3();

			}

			var result = optionalTarget || new fm.Vector3();
			var minDistance = Infinity;

			// project the point onto the plane of the triangle

			plane.setFromCoplanarPoints( this.a, this.b, this.c );
			plane.projectPoint( point, projectedPoint );

			// check if the projection lies within the triangle

			if( this.containsPoint( projectedPoint ) === true ) {

				// if so, this is the closest point

				result.copy( projectedPoint );

			} else {

				// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

				edgeList[ 0 ].set( this.a, this.b );
				edgeList[ 1 ].set( this.b, this.c );
				edgeList[ 2 ].set( this.c, this.a );

				for( var i = 0; i < edgeList.length; i ++ ) {

					edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

					var distance = projectedPoint.distanceToSquared( closestPoint );

					if( distance < minDistance ) {

						minDistance = distance;

						result.copy( closestPoint );

					}

				}

			}

			return result;

		};

	}(),

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

};

// File:src/math/Interpolant.js

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */

fm.Interpolant = function(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	this.parameterPositions = parameterPositions;
	this._cachedIndex = 0;

	this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
	this.sampleValues = sampleValues;
	this.valueSize = sampleSize;

};

fm.Interpolant.prototype = {

	constructor: fm.Interpolant,

	evaluate: function( t ) {

		var pp = this.parameterPositions,
			i1 = this._cachedIndex,

			t1 = pp[   i1   ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				var right;

				linear_scan: {
//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( var giveUpAt = i1 + 2; ;) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

//- slower code:
//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						var t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( var giveUpAt = i1 - 2; ;) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					var mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[   i1   ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	},

	settings: null, // optional, subclass-specific settings structure
	// Note: The indirection allows central control of many interpolants.

	// --- Protected interface

	DefaultSettings_: {},

	getSettings_: function() {

		return this.settings || this.DefaultSettings_;

	},

	copySampleValue_: function( index ) {

		// copies a sample value to the result buffer

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	},

	// Template methods for derived classes:

	interpolate_: function( i1, t0, t, t1 ) {

		throw new Error( "call to abstract method" );
		// implementations shall return this.resultBuffer

	},

	intervalChanged_: function( i1, t0, t1 ) {

		// empty

	}

};

Object.assign( fm.Interpolant.prototype, {

	beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
		fm.Interpolant.prototype.copySampleValue_,

	afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
		fm.Interpolant.prototype.copySampleValue_

} );

// File:src/math/interpolants/CubicInterpolant.js

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */

fm.CubicInterpolant = function(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	fm.Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	this._weightPrev = -0;
	this._offsetPrev = -0;
	this._weightNext = -0;
	this._offsetNext = -0;

};

fm.CubicInterpolant.prototype =
		Object.assign( Object.create( fm.Interpolant.prototype ), {

	constructor: fm.CubicInterpolant,

	DefaultSettings_: {

		endingStart: 	fm.ZeroCurvatureEnding,
		endingEnd:		fm.ZeroCurvatureEnding

	},

	intervalChanged_: function( i1, t0, t1 ) {

		var pp = this.parameterPositions,
			iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case fm.ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case fm.WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case fm.ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case fm.WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		var halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	},

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
		var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
		var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
		var sN =       wN   * ppp   -           wN      * pp;

		// combine data linearly

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

} );

// File:src/math/interpolants/DiscreteInterpolant.js

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */

fm.DiscreteInterpolant = function(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	fm.Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

};

fm.DiscreteInterpolant.prototype =
		Object.assign( Object.create( fm.Interpolant.prototype ), {

	constructor: fm.DiscreteInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		return this.copySampleValue_( i1 - 1 );

	}

} );

// File:src/math/interpolants/LinearInterpolant.js

/**
 * @author tschw
 */

fm.LinearInterpolant = function(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	fm.Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

};

fm.LinearInterpolant.prototype =
		Object.assign( Object.create( fm.Interpolant.prototype ), {

	constructor: fm.LinearInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

} );

// File:src/math/interpolants/QuaternionLinearInterpolant.js

/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */

fm.QuaternionLinearInterpolant = function(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	fm.Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

};

fm.QuaternionLinearInterpolant.prototype =
		Object.assign( Object.create( fm.Interpolant.prototype ), {

	constructor: fm.QuaternionLinearInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset = i1 * stride,

			alpha = ( t - t0 ) / ( t1 - t0 );

		for ( var end = offset + stride; offset !== end; offset += 4 ) {

			fm.Quaternion.slerpFlat( result, 0,
					values, offset - stride, values, offset, alpha );

		}

		return result;

	}

} );

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

fm.Clock.prototype = {

	constructor: fm.Clock,

	start: function () {

		// this.startTime = ( performance || Date ).now();
		this.startTime = Date.now();

		this.oldTime = this.startTime;
		this.running = true;

	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			// var newTime = ( performance || Date ).now();
			var newTime = Date.now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

fm.EventDispatcher = function () {};

fm.EventDispatcher.prototype = {

	constructor: fm.EventDispatcher,

	apply: function ( object ) {

		object.addEventListener = fm.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = fm.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = fm.EventDispatcher.prototype.removeEventListener;
		object.dispatchEvent = fm.EventDispatcher.prototype.dispatchEvent;

	},

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = [];
			var length = listenerArray.length;

			for ( var i = 0; i < length; i ++ ) {

				array[ i ] = listenerArray[ i ];

			}

			for ( var i = 0; i < length; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

};

// File:src/core/Layers.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.Layers = function () {

	this.mask = 1;

};

fm.Layers.prototype = {

	constructor: fm.Layers,

	set: function ( channel ) {

		this.mask = 1 << channel;

	},

	enable: function ( channel ) {

		this.mask |= 1 << channel;

	},

	toggle: function ( channel ) {

		this.mask ^= 1 << channel;

	},

	disable: function ( channel ) {

		this.mask &= ~ ( 1 << channel );

	},

	test: function ( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( fm ) {

	fm.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new fm.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {
					console.warn( 'fm.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;
				}
			}
		} );

	};

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.visible === false ) return;

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	//

	fm.Raycaster.prototype = {

		constructor: fm.Raycaster,

		linePrecision: 1,

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( camera instanceof fm.PerspectiveCamera ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

			} else if ( camera instanceof fm.OrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

			} else {

				console.error( 'fm.Raycaster: Unsupported camera type.' );

			}

		},

		intersectObject: function ( object, recursive ) {

			var intersects = [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive ) {

			var intersects = [];

			if ( Array.isArray( objects ) === false ) {

				console.warn( 'fm.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	};

}( fm ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

fm.Object3D = function () {

	Object.defineProperty( this, 'id', { value: fm.Object3DIdCount ++ } );

	this.uuid = fm.Math.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = fm.Object3D.DefaultUp.clone();

	var position = new fm.Vector3();
	var rotation = new fm.Euler();
	var quaternion = new fm.Quaternion();
	var scale = new fm.Vector3( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			enumerable: true,
			value: position
		},
		rotation: {
			enumerable: true,
			value: rotation
		},
		quaternion: {
			enumerable: true,
			value: quaternion
		},
		scale: {
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new fm.Matrix4()
		},
		normalMatrix: {
			value: new fm.Matrix3()
		}
	} );

	this.rotationAutoUpdate = true;

	this.matrix = new fm.Matrix4();
	this.matrixWorld = new fm.Matrix4();

	this.matrixAutoUpdate = fm.Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new fm.Layers();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};

};

fm.Object3D.DefaultUp = new fm.Vector3( 0, 1, 0 );
fm.Object3D.DefaultMatrixAutoUpdate = true;

fm.Object3D.prototype = {

	constructor: fm.Object3D,

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function () {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new fm.Quaternion();

		return function ( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		};

	}(),

	rotateX: function () {

		var v1 = new fm.Vector3( 1, 0, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new fm.Vector3( 0, 1, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new fm.Vector3( 0, 0, 1 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new fm.Vector3();

		return function ( axis, distance ) {

			v1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		};

	}(),

	translateX: function () {

		var v1 = new fm.Vector3( 1, 0, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new fm.Vector3( 0, 1, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new fm.Vector3( 0, 0, 1 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new fm.Matrix4();

		return function ( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new fm.Matrix4();

		return function ( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "fm.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( object instanceof fm.Object3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

		} else {

			console.error( "fm.Object3D.add: object not an instance of fm.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

		}

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;

			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

		}

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( optionalTarget ) {

		var result = optionalTarget || new fm.Vector3();

		this.updateMatrixWorld( true );

		return result.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function () {

		var position = new fm.Vector3();
		var scale = new fm.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new fm.Quaternion();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, result, scale );

			return result;

		};

	}(),

	getWorldRotation: function () {

		var quaternion = new fm.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new fm.Euler();

			this.getWorldQuaternion( quaternion );

			return result.setFromQuaternion( quaternion, this.rotation.order, false );

		};

	}(),

	getWorldScale: function () {

		var position = new fm.Vector3();
		var quaternion = new fm.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new fm.Vector3();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, quaternion, result );

			return result;

		};

	}(),

	getWorldDirection: function () {

		var quaternion = new fm.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new fm.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

		};

	}(),

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		var parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	toJSON: function ( meta ) {

		// meta is '' when called from JSON.stringify
		var isRootObject = ( meta === undefined || meta === '' );

		var output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {}
			};

			output.metadata = {
				version: 4.4,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;

		object.matrix = this.matrix.toArray();

		//

		if ( this.geometry !== undefined ) {

			if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

				meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

			}

			object.geometry = this.geometry.uuid;

		}

		if ( this.material !== undefined ) {

			if ( meta.materials[ this.material.uuid ] === undefined ) {

				meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

			}

			object.material = this.material.uuid;

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( var i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		if ( isRootObject ) {

			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache ( cache ) {

			var values = [];
			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}
			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive ) {

		if ( recursive === undefined ) recursive = true;

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.rotationAutoUpdate = source.rotationAutoUpdate;

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < source.children.length; i ++ ) {

				var child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

};

fm.EventDispatcher.prototype.apply( fm.Object3D.prototype );

fm.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

fm.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof fm.Vector3 ? normal : new fm.Vector3();
	this.vertexNormals = Array.isArray( normal ) ? normal : [];

	this.color = color instanceof fm.Color ? color : new fm.Color();
	this.vertexColors = Array.isArray( color ) ? color : [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

fm.Face3.prototype = {

	constructor: fm.Face3,

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.a = source.a;
		this.b = source.b;
		this.c = source.c;

		this.normal.copy( source.normal );
		this.color.copy( source.color );

		this.materialIndex = source.materialIndex;

		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

		}

		return this;

	}

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.BufferAttribute = function ( array, itemSize, normalized ) {

	this.uuid = fm.Math.generateUUID();

	this.array = array;
	this.itemSize = itemSize;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;
	this.normalized = normalized === true;

};

fm.BufferAttribute.prototype = {

	constructor: fm.BufferAttribute,

	get count() {

		return this.array.length / this.itemSize;

	},

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;

		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = colors.length; i < l; i ++ ) {

			var color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'fm.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new fm.Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyIndicesArray: function ( indices ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = indices.length; i < l; i ++ ) {

			var index = indices[ i ];

			array[ offset ++ ] = index.a;
			array[ offset ++ ] = index.b;
			array[ offset ++ ] = index.c;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'fm.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new fm.Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'fm.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new fm.Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'fm.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new fm.Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

//

fm.Int8Attribute = function ( array, itemSize ) {

	return new fm.BufferAttribute( new Int8Array( array ), itemSize );

};

fm.Uint8Attribute = function ( array, itemSize ) {

	return new fm.BufferAttribute( new Uint8Array( array ), itemSize );

};

fm.Uint8ClampedAttribute = function ( array, itemSize ) {

	return new fm.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

fm.Int16Attribute = function ( array, itemSize ) {

	return new fm.BufferAttribute( new Int16Array( array ), itemSize );

};

fm.Uint16Attribute = function ( array, itemSize ) {

	return new fm.BufferAttribute( new Uint16Array( array ), itemSize );

};

fm.Int32Attribute = function ( array, itemSize ) {

	return new fm.BufferAttribute( new Int32Array( array ), itemSize );

};

fm.Uint32Attribute = function ( array, itemSize ) {

	return new fm.BufferAttribute( new Uint32Array( array ), itemSize );

};

fm.Float32Attribute = function ( array, itemSize ) {

	return new fm.BufferAttribute( new Float32Array( array ), itemSize );

};

fm.Float64Attribute = function ( array, itemSize ) {

	return new fm.BufferAttribute( new Float64Array( array ), itemSize );

};


// Deprecated

fm.DynamicBufferAttribute = function ( array, itemSize ) {

	console.warn( 'fm.DynamicBufferAttribute has been removed. Use new fm.BufferAttribute().setDynamic( true ) instead.' );
	return new fm.BufferAttribute( array, itemSize ).setDynamic( true );

};

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

fm.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {

	fm.BufferAttribute.call( this, array, itemSize );

	this.meshPerAttribute = meshPerAttribute || 1;

};

fm.InstancedBufferAttribute.prototype = Object.create( fm.BufferAttribute.prototype );
fm.InstancedBufferAttribute.prototype.constructor = fm.InstancedBufferAttribute;

fm.InstancedBufferAttribute.prototype.copy = function ( source ) {

	fm.BufferAttribute.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

fm.InterleavedBuffer = function ( array, stride ) {

	this.uuid = fm.Math.generateUUID();

	this.array = array;
	this.stride = stride;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

};

fm.InterleavedBuffer.prototype = {

	constructor: fm.InterleavedBuffer,

	get length () {

		return this.array.length;

	},

	get count () {

		return this.array.length / this.stride;

	},

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.stride = source.stride;
		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( var i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

fm.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {

	fm.InterleavedBuffer.call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

};

fm.InstancedInterleavedBuffer.prototype = Object.create( fm.InterleavedBuffer.prototype );
fm.InstancedInterleavedBuffer.prototype.constructor = fm.InstancedInterleavedBuffer;

fm.InstancedInterleavedBuffer.prototype.copy = function ( source ) {

	fm.InterleavedBuffer.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

fm.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

	this.uuid = fm.Math.generateUUID();

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

};


fm.InterleavedBufferAttribute.prototype = {

	constructor: fm.InterleavedBufferAttribute,

	get length() {

		console.warn( 'fm.BufferAttribute: .length has been deprecated. Please use .count.' );
		return this.array.length;

	},

	get count() {

		return this.data.count;

	},

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

fm.Geometry = function () {

	Object.defineProperty( this, 'id', { value: fm.GeometryIdCount ++ } );

	this.uuid = fm.Math.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [ [] ];

	this.morphTargets = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;
	this.groupsNeedUpdate = false;

};

fm.Geometry.prototype = {

	constructor: fm.Geometry,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new fm.Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		this.verticesNeedUpdate = true;
		this.normalsNeedUpdate = true;

		return this;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new fm.Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new fm.Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new fm.Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new fm.Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new fm.Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new fm.Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var indices = geometry.index !== null ? geometry.index.array : undefined;
		var attributes = geometry.attributes;

		var positions = attributes.position.array;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

		var tempNormals = [];
		var tempUVs = [];
		var tempUVs2 = [];

		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

			scope.vertices.push( new fm.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

			if ( normals !== undefined ) {

				tempNormals.push( new fm.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

			}

			if ( colors !== undefined ) {

				scope.colors.push( new fm.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

			}

			if ( uvs !== undefined ) {

				tempUVs.push( new fm.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

			}

			if ( uvs2 !== undefined ) {

				tempUVs2.push( new fm.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

			}

		}

		function addFace( a, b, c, materialIndex ) {

			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

			var face = new fm.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

			scope.faces.push( face );

			if ( uvs !== undefined ) {

				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

			}

			if ( uvs2 !== undefined ) {

				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

			}

		}

		if ( indices !== undefined ) {

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );

					}

				}

			} else {

				for ( var i = 0; i < indices.length; i += 3 ) {

					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

				}

			}

		} else {

			for ( var i = 0; i < positions.length / 3; i += 3 ) {

				addFace( i, i + 1, i + 2 );

			}

		}

		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.center().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	normalize: function () {

		this.computeBoundingSphere();

		var center = this.boundingSphere.center;
		var radius = this.boundingSphere.radius;

		var s = radius === 0 ? 1 : 1.0 / radius;

		var matrix = new fm.Matrix4();
		matrix.set(
			s, 0, 0, - s * center.x,
			0, s, 0, - s * center.y,
			0, 0, s, - s * center.z,
			0, 0, 0, 1
		);

		this.applyMatrix( matrix );

		return this;

	},

	computeFaceNormals: function () {

		var cb = new fm.Vector3(), ab = new fm.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		if ( areaWeighted === undefined ) areaWeighted = true;

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new fm.Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC;
			var cb = new fm.Vector3(), ab = new fm.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( vertices[ face.a ] );
				vertexNormals[ 1 ].copy( vertices[ face.b ] );
				vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else {

				vertexNormals[ 0 ] = vertices[ face.a ].clone();
				vertexNormals[ 1 ] = vertices[ face.b ].clone();
				vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new fm.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new fm.Vector3();
					vertexNormals = { a: new fm.Vector3(), b: new fm.Vector3(), c: new fm.Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		console.warn( 'fm.Geometry: .computeTangents() has been removed.' );

	},

	computeLineDistances: function () {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new fm.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new fm.Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( geometry instanceof fm.Geometry === false ) {

			console.error( 'fm.Geometry.merge(): geometry not an instance of fm.Geometry.', geometry );
			return;

		}

		var normalMatrix,
		vertexOffset = this.vertices.length,
		vertices1 = this.vertices,
		vertices2 = geometry.vertices,
		faces1 = this.faces,
		faces2 = geometry.faces,
		uvs1 = this.faceVertexUvs[ 0 ],
		uvs2 = geometry.faceVertexUvs[ 0 ];

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new fm.Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new fm.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			if ( uv === undefined ) {

				continue;

			}

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( uv[ j ].clone() );

			}

			uvs1.push( uvCopy );

		}

	},

	mergeMesh: function ( mesh ) {

		if ( mesh instanceof fm.Mesh === false ) {

			console.error( 'fm.Geometry.mergeMesh(): mesh not an instance of fm.Mesh.', mesh );
			return;

		}

		mesh.matrixAutoUpdate && mesh.updateMatrix();

		this.merge( mesh.geometry, mesh.matrix );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i, il, face;
		var indices, j, jl;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		}


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = - 1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {

				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}

			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	sortFacesByMaterialIndex: function () {

		var faces = this.faces;
		var length = faces.length;

		// tag faces

		for ( var i = 0; i < length; i ++ ) {

			faces[ i ]._id = i;

		}

		// sort faces

		function materialIndexSort( a, b ) {

			return a.materialIndex - b.materialIndex;

		}

		faces.sort( materialIndexSort );

		// sort uvs

		var uvs1 = this.faceVertexUvs[ 0 ];
		var uvs2 = this.faceVertexUvs[ 1 ];

		var newUvs1, newUvs2;

		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

		for ( var i = 0; i < length; i ++ ) {

			var id = faces[ i ]._id;

			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

		}

		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'Geometry',
				generator: 'Geometry.toJSON'
			}
		};

		// standard Geometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = true;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 ); // isQuad
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );
			faces.push( face.materialIndex );

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		data.data = {};

		data.data.vertices = vertices;
		data.data.normals = normals;
		if ( colors.length > 0 ) data.data.colors = colors;
		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
		data.data.faces = faces;

		return data;

	},

	clone: function () {

		/*
		// Handle primitives

		var parameters = this.parameters;

		if ( parameters !== undefined ) {

			var values = [];

			for ( var key in parameters ) {

				values.push( parameters[ key ] );

			}

			var geometry = Object.create( this.constructor.prototype );
			this.constructor.apply( geometry, values );
			return geometry;

		}

		return new this.constructor().copy( this );
		*/

		return new fm.Geometry().copy( this );

	},

	copy: function ( source ) {

		this.vertices = [];
		this.faces = [];
		this.faceVertexUvs = [ [] ];

		var vertices = source.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			this.vertices.push( vertices[ i ].clone() );

		}

		var faces = source.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			this.faces.push( faces[ i ].clone() );

		}

		for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs = source.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) {

				this.faceVertexUvs[ i ] = [];

			}

			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

				var uvs = faceVertexUvs[ j ], uvsCopy = [];

				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

					var uv = uvs[ k ];

					uvsCopy.push( uv.clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

fm.EventDispatcher.prototype.apply( fm.Geometry.prototype );

fm.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.DirectGeometry = function () {

	Object.defineProperty( this, 'id', { value: fm.GeometryIdCount ++ } );

	this.uuid = fm.Math.generateUUID();

	this.name = '';
	this.type = 'DirectGeometry';

	this.indices = [];
	this.vertices = [];
	this.normals = [];
	this.colors = [];
	this.uvs = [];
	this.uvs2 = [];

	this.groups = [];

	this.morphTargets = {};

	this.skinWeights = [];
	this.skinIndices = [];

	// this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.groupsNeedUpdate = false;

};

fm.DirectGeometry.prototype = {

	constructor: fm.DirectGeometry,

	computeBoundingBox: fm.Geometry.prototype.computeBoundingBox,
	computeBoundingSphere: fm.Geometry.prototype.computeBoundingSphere,

	computeFaceNormals: function () {

		console.warn( 'fm.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

	},

	computeVertexNormals: function () {

		console.warn( 'fm.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

	},

	computeGroups: function ( geometry ) {

		var group;
		var groups = [];
		var materialIndex;

		var faces = geometry.faces;

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			// materials

			if ( face.materialIndex !== materialIndex ) {

				materialIndex = face.materialIndex;

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				group = {
					start: i * 3,
					materialIndex: materialIndex
				};

			}

		}

		if ( group !== undefined ) {

			group.count = ( i * 3 ) - group.start;
			groups.push( group );

		}

		this.groups = groups;

	},

	fromGeometry: function ( geometry ) {

		var faces = geometry.faces;
		var vertices = geometry.vertices;
		var faceVertexUvs = geometry.faceVertexUvs;

		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

		// morphs

		var morphTargets = geometry.morphTargets;
		var morphTargetsLength = morphTargets.length;

		var morphTargetsPosition;

		if ( morphTargetsLength > 0 ) {

			morphTargetsPosition = [];

			for ( var i = 0; i < morphTargetsLength; i ++ ) {

				morphTargetsPosition[ i ] = [];

			}

			this.morphTargets.position = morphTargetsPosition;

		}

		var morphNormals = geometry.morphNormals;
		var morphNormalsLength = morphNormals.length;

		var morphTargetsNormal;

		if ( morphNormalsLength > 0 ) {

			morphTargetsNormal = [];

			for ( var i = 0; i < morphNormalsLength; i ++ ) {

				morphTargetsNormal[ i ] = [];

			}

			this.morphTargets.normal = morphTargetsNormal;

		}

		// skins

		var skinIndices = geometry.skinIndices;
		var skinWeights = geometry.skinWeights;

		var hasSkinIndices = skinIndices.length === vertices.length;
		var hasSkinWeights = skinWeights.length === vertices.length;

		//

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

			} else {

				var normal = face.normal;

				this.normals.push( normal, normal, normal );

			}

			var vertexColors = face.vertexColors;

			if ( vertexColors.length === 3 ) {

				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

			} else {

				var color = face.color;

				this.colors.push( color, color, color );

			}

			if ( hasFaceVertexUv === true ) {

				var vertexUvs = faceVertexUvs[ 0 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'fm.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

					this.uvs.push( new fm.Vector2(), new fm.Vector2(), new fm.Vector2() );

				}

			}

			if ( hasFaceVertexUv2 === true ) {

				var vertexUvs = faceVertexUvs[ 1 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'fm.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

					this.uvs2.push( new fm.Vector2(), new fm.Vector2(), new fm.Vector2() );

				}

			}

			// morphs

			for ( var j = 0; j < morphTargetsLength; j ++ ) {

				var morphTarget = morphTargets[ j ].vertices;

				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

			}

			for ( var j = 0; j < morphNormalsLength; j ++ ) {

				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

			}

			// skins

			if ( hasSkinIndices ) {

				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

			}

			if ( hasSkinWeights ) {

				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

			}

		}

		this.computeGroups( geometry );

		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

fm.EventDispatcher.prototype.apply( fm.DirectGeometry.prototype );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

fm.BufferGeometry = function () {

	Object.defineProperty( this, 'id', { value: fm.GeometryIdCount ++ } );

	this.uuid = fm.Math.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

};

fm.BufferGeometry.prototype = {

	constructor: fm.BufferGeometry,

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		this.index = index;

	},

	addAttribute: function ( name, attribute ) {

		if ( attribute instanceof fm.BufferAttribute === false && attribute instanceof fm.InterleavedBufferAttribute === false ) {

			console.warn( 'fm.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			this.addAttribute( name, new fm.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

			return;

		}

		if ( name === 'index' ) {

			console.warn( 'fm.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return;

		}

		this.attributes[ name ] = attribute;

		return this;

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	removeAttribute: function ( name ) {

		delete this.attributes[ name ];

		return this;

	},

	addGroup: function ( start, count, materialIndex ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex !== undefined ? materialIndex : 0

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.applyToVector3Array( position.array );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new fm.Matrix3().getNormalMatrix( matrix );

			normalMatrix.applyToVector3Array( normal.array );
			normal.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new fm.Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new fm.Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new fm.Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new fm.Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new fm.Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new fm.Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.center().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	setFromObject: function ( object ) {

		// console.log( 'fm.BufferGeometry.setFromObject(). Converting', object, this );

		var geometry = object.geometry;

		if ( object instanceof fm.Points || object instanceof fm.Line ) {

			var positions = new fm.Float32Attribute( geometry.vertices.length * 3, 3 );
			var colors = new fm.Float32Attribute( geometry.colors.length * 3, 3 );

			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

				var lineDistances = new fm.Float32Attribute( geometry.lineDistances.length, 1 );

				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

		} else if ( object instanceof fm.Mesh ) {

			if ( geometry instanceof fm.Geometry ) {

				this.fromGeometry( geometry );

			}

		}

		return this;

	},

	updateFromObject: function ( object ) {

		var geometry = object.geometry;

		if ( object instanceof fm.Mesh ) {

			var direct = geometry.__directGeometry;

			if ( direct === undefined ) {

				return this.fromGeometry( geometry );

			}

			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

			geometry.verticesNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.groupsNeedUpdate = false;

			geometry = direct;

		}

		if ( geometry.verticesNeedUpdate === true ) {

			var attribute = this.attributes.position;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.vertices );
				attribute.needsUpdate = true;

			}

			geometry.verticesNeedUpdate = false;

		}

		if ( geometry.normalsNeedUpdate === true ) {

			var attribute = this.attributes.normal;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.normals );
				attribute.needsUpdate = true;

			}

			geometry.normalsNeedUpdate = false;

		}

		if ( geometry.colorsNeedUpdate === true ) {

			var attribute = this.attributes.color;

			if ( attribute !== undefined ) {

				attribute.copyColorsArray( geometry.colors );
				attribute.needsUpdate = true;

			}

			geometry.colorsNeedUpdate = false;

		}

		if ( geometry.uvsNeedUpdate ) {

			var attribute = this.attributes.uv;

			if ( attribute !== undefined ) {

				attribute.copyVector2sArray( geometry.uvs );
				attribute.needsUpdate = true;

			}

			geometry.uvsNeedUpdate = false;

		}

		if ( geometry.lineDistancesNeedUpdate ) {

			var attribute = this.attributes.lineDistance;

			if ( attribute !== undefined ) {

				attribute.copyArray( geometry.lineDistances );
				attribute.needsUpdate = true;

			}

			geometry.lineDistancesNeedUpdate = false;

		}

		if ( geometry.groupsNeedUpdate ) {

			geometry.computeGroups( object.geometry );
			this.groups = geometry.groups;

			geometry.groupsNeedUpdate = false;

		}

		return this;

	},

	fromGeometry: function ( geometry ) {

		geometry.__directGeometry = new fm.DirectGeometry().fromGeometry( geometry );

		return this.fromDirectGeometry( geometry.__directGeometry );

	},

	fromDirectGeometry: function ( geometry ) {

		var positions = new Float32Array( geometry.vertices.length * 3 );
		this.addAttribute( 'position', new fm.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

		if ( geometry.normals.length > 0 ) {

			var normals = new Float32Array( geometry.normals.length * 3 );
			this.addAttribute( 'normal', new fm.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

		}

		if ( geometry.colors.length > 0 ) {

			var colors = new Float32Array( geometry.colors.length * 3 );
			this.addAttribute( 'color', new fm.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

		}

		if ( geometry.uvs.length > 0 ) {

			var uvs = new Float32Array( geometry.uvs.length * 2 );
			this.addAttribute( 'uv', new fm.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

		}

		if ( geometry.uvs2.length > 0 ) {

			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
			this.addAttribute( 'uv2', new fm.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

		}

		if ( geometry.indices.length > 0 ) {

			var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
			var indices = new TypeArray( geometry.indices.length * 3 );
			this.setIndex( new fm.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

		}

		// groups

		this.groups = geometry.groups;

		// morphs

		for ( var name in geometry.morphTargets ) {

			var array = [];
			var morphTargets = geometry.morphTargets[ name ];

			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

				var morphTarget = morphTargets[ i ];

				var attribute = new fm.Float32Attribute( morphTarget.length * 3, 3 );

				array.push( attribute.copyVector3sArray( morphTarget ) );

			}

			this.morphAttributes[ name ] = array;

		}

		// skinning

		if ( geometry.skinIndices.length > 0 ) {

			var skinIndices = new fm.Float32Attribute( geometry.skinIndices.length * 4, 4 );
			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

		}

		if ( geometry.skinWeights.length > 0 ) {

			var skinWeights = new fm.Float32Attribute( geometry.skinWeights.length * 4, 4 );
			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

		}

		//

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new fm.Box3();

		}

		var positions = this.attributes.position.array;

		if ( positions !== undefined ) {

			this.boundingBox.setFromArray( positions );

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'fm.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	},

	computeBoundingSphere: function () {

		var box = new fm.Box3();
		var vector = new fm.Vector3();

		return function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new fm.Sphere();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				var center = this.boundingSphere.center;

				box.setFromArray( positions );
				box.center( center );

				// hoping to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.fromArray( positions, i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'fm.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		};

	}(),

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var index = this.index;
		var attributes = this.attributes;
		var groups = this.groups;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.addAttribute( 'normal', new fm.BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var array = attributes.normal.array;

				for ( var i = 0, il = array.length; i < il; i ++ ) {

					array[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC,

			pA = new fm.Vector3(),
			pB = new fm.Vector3(),
			pC = new fm.Vector3(),

			cb = new fm.Vector3(),
			ab = new fm.Vector3();

			// indexed elements

			if ( index ) {

				var indices = index.array;

				if ( groups.length === 0 ) {

					this.addGroup( 0, indices.length );

				}

				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

					var group = groups[ j ];

					var start = group.start;
					var count = group.count;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	merge: function ( geometry, offset ) {

		if ( geometry instanceof fm.BufferGeometry === false ) {

			console.error( 'fm.BufferGeometry.merge(): geometry not an instance of fm.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) offset = 0;

		var attributes = this.attributes;

		for ( var key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			var attribute1 = attributes[ key ];
			var attributeArray1 = attribute1.array;

			var attribute2 = geometry.attributes[ key ];
			var attributeArray2 = attribute2.array;

			var attributeSize = attribute2.itemSize;

			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal.array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i ] *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	toNonIndexed: function () {

		if ( this.index === null ) {

			console.warn( 'fm.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
			return this;

		}

		var geometry2 = new fm.BufferGeometry();

		var indices = this.index.array;
		var attributes = this.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];

			var array = attribute.array;
			var itemSize = attribute.itemSize;

			var array2 = new array.constructor( indices.length * itemSize );

			var index = 0, index2 = 0;

			for ( var i = 0, l = indices.length; i < l; i ++ ) {

				index = indices[ i ] * itemSize;

				for ( var j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			geometry2.addAttribute( name, new fm.BufferAttribute( array2, itemSize ) );

		}

		return geometry2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		data.data = { attributes: {} };

		var index = this.index;

		if ( index !== null ) {

			var array = Array.prototype.slice.call( index.array );

			data.data.index = {
				type: index.array.constructor.name,
				array: array
			};

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var array = Array.prototype.slice.call( attribute.array );

			data.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array,
				normalized: attribute.normalized
			};

		}

		var groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		var boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		/*
		// Handle primitives

		var parameters = this.parameters;

		if ( parameters !== undefined ) {

			var values = [];

			for ( var key in parameters ) {

				values.push( parameters[ key ] );

			}

			var geometry = Object.create( this.constructor.prototype );
			this.constructor.apply( geometry, values );
			return geometry;

		}

		return new this.constructor().copy( this );
		*/

		return new fm.BufferGeometry().copy( this );

	},

	copy: function ( source ) {

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		var attributes = source.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );

		}

		var groups = source.groups;

		for ( var i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

fm.EventDispatcher.prototype.apply( fm.BufferGeometry.prototype );

fm.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

fm.InstancedBufferGeometry = function () {

	fm.BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.maxInstancedCount = undefined;

};

fm.InstancedBufferGeometry.prototype = Object.create( fm.BufferGeometry.prototype );
fm.InstancedBufferGeometry.prototype.constructor = fm.InstancedBufferGeometry;

fm.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

	this.groups.push( {

		start: start,
		count: count,
		instances: instances

	} );

};

fm.InstancedBufferGeometry.prototype.copy = function ( source ) {

	var index = source.index;

	if ( index !== null ) {

		this.setIndex( index.clone() );

	}

	var attributes = source.attributes;

	for ( var name in attributes ) {

		var attribute = attributes[ name ];
		this.addAttribute( name, attribute.clone() );

	}

	var groups = source.groups;

	for ( var i = 0, l = groups.length; i < l; i ++ ) {

		var group = groups[ i ];
		this.addGroup( group.start, group.count, group.instances );

	}

	return this;

};

fm.EventDispatcher.prototype.apply( fm.InstancedBufferGeometry.prototype );

// File:src/core/Uniform.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.Uniform = function ( value ) {

	if ( typeof value === 'string' ) {

		console.warn( 'fm.Uniform: Type parameter is no longer needed.' );
		value = arguments[ 1 ];

	}

	this.value = value;

	this.dynamic = false;

};

fm.Uniform.prototype = {

	constructor: fm.Uniform,

	onUpdate: function ( callback ) {

		this.dynamic = true;
		this.onUpdateCallback = callback;

		return this;

	}

};

// File:src/animation/AnimationClip.js

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

fm.AnimationClip = function ( name, duration, tracks ) {

	this.name = name || fm.Math.generateUUID();
	this.tracks = tracks;
	this.duration = ( duration !== undefined ) ? duration : -1;

	// this means it should figure out its duration by scanning the tracks
	if ( this.duration < 0 ) {

		this.resetDuration();

	}

	// maybe only do these on demand, as doing them here could potentially slow down loading
	// but leaving these here during development as this ensures a lot of testing of these functions
	this.trim();
	this.optimize();

};

fm.AnimationClip.prototype = {

	constructor: fm.AnimationClip,

	resetDuration: function() {

		var tracks = this.tracks,
			duration = 0;

		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

			var track = this.tracks[ i ];

			duration = Math.max(
					duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

	},

	trim: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	},

	optimize: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

};

// Static methods:

Object.assign( fm.AnimationClip, {

	parse: function( json ) {

		var tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( fm.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

		}

		return new fm.AnimationClip( json.name, json.duration, tracks );

	},


	toJSON: function( clip ) {

		var tracks = [],
			clipTracks = clip.tracks;

		var json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks

		};

		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( fm.KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	},


	CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {

		var numMorphTargets = morphTargetSequence.length;
		var tracks = [];

		for ( var i = 0; i < numMorphTargets; i ++ ) {

			var times = [];
			var values = [];

			times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			var order = fm.AnimationUtils.getKeyframeOrder( times );
			times = fm.AnimationUtils.sortedArray( times, 1, order );
			values = fm.AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
					new fm.NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );
		}

		return new fm.AnimationClip( name, -1, tracks );

	},

	findByName: function( clipArray, name ) {

		for ( var i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}
		}

		return null;

	},

	CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {

		var animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		var pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = morphTargets[ i ];
			var parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var name = parts[ 1 ];

				var animationMorphTargets = animationToMorphTargets[ name ];
				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		var clips = [];

		for ( var name in animationToMorphTargets ) {

			clips.push( fm.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	},

	// parse the animation.hierarchy format
	parseAnimation: function( animation, bones, nodeName ) {

		if ( ! animation ) {

			console.error( "  no animation in JSONLoader data" );
			return null;

		}

		var addNonemptyTrack = function(
				trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				var times = [];
				var values = [];

				fm.AnimationUtils.flattenJSON(
						animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		var tracks = [];

		var clipName = animation.name || 'default';
		// automatic length determination in AnimationClip.
		var duration = animation.length || -1;
		var fps = animation.fps || 30;

		var hierarchyTracks = animation.hierarchy || [];

		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

			var animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length == 0 ) continue;

			// process morph targets in a way exactly compatible
			// with AnimationHandler.init( animation )
			if ( animationKeys[0].morphTargets ) {

				// figure out all morph targets used in this track
				var morphTargetNames = {};
				for ( var k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[k].morphTargets ) {

						for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( var morphTargetName in morphTargetNames ) {

					var times = [];
					var values = [];

					for ( var m = 0;
							m !== animationKeys[k].morphTargets.length; ++ m ) {

						var animationKey = animationKeys[k];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )

					}

					tracks.push( new fm.NumberKeyframeTrack(
							'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {
				// ...assume skeletal animation

				var boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
						fm.VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

				addNonemptyTrack(
						fm.QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

				addNonemptyTrack(
						fm.VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		var clip = new fm.AnimationClip( clipName, duration, tracks );

		return clip;

	}

} );


// File:src/animation/AnimationMixer.js

/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

fm.AnimationMixer = function( root ) {

	this._root = root;
	this._initMemoryManager();
	this._accuIndex = 0;

	this.time = 0;

	this.timeScale = 1.0;

};

fm.AnimationMixer.prototype = {

	constructor: fm.AnimationMixer,

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction: function( clip, optionalRoot ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,
			clipName = ( typeof clip === 'string' ) ? clip : clip.name,
			clipObject = ( clip !== clipName ) ? clip : null,

			actionsForClip = this._actionsByClip[ clipName ],
			prototypeAction;

		if ( actionsForClip !== undefined ) {

			var existingAction =
					actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			clipObject = prototypeAction._clip;

			if ( clip !== clipName && clip !== clipObject ) {

				throw new Error(
						"Different clips with the same name detected!" );

			}

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		var newAction = new fm.
				AnimationMixer._Action( this, clipObject, optionalRoot );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipName, rootUuid );

		return newAction;

	},

	// get an existing action
	existingAction: function( clip, optionalRoot ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,
			clipName = ( typeof clip === 'string' ) ? clip : clip.name,
			actionsForClip = this._actionsByClip[ clipName ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	},

	// deactivates all previously scheduled actions
	stopAllAction: function() {

		var actions = this._actions,
			nActions = this._nActiveActions,
			bindings = this._bindings,
			nBindings = this._nActiveBindings;

		this._nActiveActions = 0;
		this._nActiveBindings = 0;

		for ( var i = 0; i !== nActions; ++ i ) {

			actions[ i ].reset();

		}

		for ( var i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].useCount = 0;

		}

		return this;

	},

	// advance the time and update apply the animation
	update: function( deltaTime ) {

		deltaTime *= this.timeScale;

		var actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( var i = 0; i !== nActions; ++ i ) {

			var action = actions[ i ];

			if ( action.enabled ) {

				action._update( time, deltaTime, timeDirection, accuIndex );

			}

		}

		// update scene graph

		var bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( var i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	},

	// return this mixer's root target object
	getRoot: function() {

		return this._root;

	},

	// free all resources specific to a particular clip
	uncacheClip: function( clip ) {

		var actions = this._actions,
			clipName = clip.name,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipName ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			var actionsToRemove = actionsForClip.knownActions;

			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				var action = actionsToRemove[ i ];

				this._deactivateAction( action );

				var cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipName ];

		}

	},

	// free all resources specific to a particular root target object
	uncacheRoot: function( root ) {

		var rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( var clipName in actionsByClip ) {

			var actionByRoot = actionsByClip[ clipName ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( var trackName in bindingByName ) {

				var binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	},

	// remove a targeted clip from the cache
	uncacheAction: function( clip, optionalRoot ) {

		var action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

};

fm.EventDispatcher.prototype.apply( fm.AnimationMixer.prototype );

fm.AnimationMixer._Action =
		function( mixer, clip, localRoot ) {

	this._mixer = mixer;
	this._clip = clip;
	this._localRoot = localRoot || null;

	var tracks = clip.tracks,
		nTracks = tracks.length,
		interpolants = new Array( nTracks );

	var interpolantSettings = {
			endingStart: 	fm.ZeroCurvatureEnding,
			endingEnd:		fm.ZeroCurvatureEnding
	};

	for ( var i = 0; i !== nTracks; ++ i ) {

		var interpolant = tracks[ i ].createInterpolant( null );
		interpolants[ i ] = interpolant;
		interpolant.settings = interpolantSettings

	}

	this._interpolantSettings = interpolantSettings;

	this._interpolants = interpolants;	// bound by the mixer

	// inside: PropertyMixer (managed by the mixer)
	this._propertyBindings = new Array( nTracks );

	this._cacheIndex = null;			// for the memory manager
	this._byClipCacheIndex = null;		// for the memory manager

	this._timeScaleInterpolant = null;
	this._weightInterpolant = null;

	this.loop = fm.LoopRepeat;
	this._loopCount = -1;

	// global mixer time when the action is to be started
	// it's set back to 'null' upon start of the action
	this._startTime = null;

	// scaled local time of the action
	// gets clamped or wrapped to 0..clip.duration according to loop
	this.time = 0;

	this.timeScale = 1;
	this._effectiveTimeScale = 1;

	this.weight = 1;
	this._effectiveWeight = 1;

	this.repetitions = Infinity; 		// no. of repetitions when looping

	this.paused = false;				// false -> zero effective time scale
	this.enabled = true;				// true -> zero effective weight

	this.clampWhenFinished 	= false;	// keep feeding the last frame?

	this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
	this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

};

fm.AnimationMixer._Action.prototype = {

	constructor: fm.AnimationMixer._Action,

	// State & Scheduling

	play: function() {

		this._mixer._activateAction( this );

		return this;

	},

	stop: function() {

		this._mixer._deactivateAction( this );

		return this.reset();

	},

	reset: function() {

		this.paused = false;
		this.enabled = true;

		this.time = 0;			// restart clip
		this._loopCount = -1;	// forget previous loops
		this._startTime = null;	// forget scheduling

		return this.stopFading().stopWarping();

	},

	isRunning: function() {

		var start = this._startTime;

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction( this )

	},

	// return true when play has been called
	isScheduled: function() {

		return this._mixer._isActiveAction( this );

	},

	startAt: function( time ) {

		this._startTime = time;

		return this;

	},

	setLoop: function( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	},

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight: function( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	},

	// return the weight considering fading and .enabled
	getEffectiveWeight: function() {

		return this._effectiveWeight;

	},

	fadeIn: function( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	},

	fadeOut: function( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	},

	crossFadeFrom: function( fadeOutAction, duration, warp ) {

		var mixer = this._mixer;

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if( warp ) {

			var fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	},

	crossFadeTo: function( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	},

	stopFading: function() {

		var weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	},

	// Time Scale Control

	// set the weight stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale: function( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 :timeScale;

		return this.stopWarping();

	},

	// return the time scale considering warping and .paused
	getEffectiveTimeScale: function() {

		return this._effectiveTimeScale;

	},

	setDuration: function( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	},

	syncWith: function( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	},

	halt: function( duration ) {

		return this.warp( this._currentTimeScale, 0, duration );

	},

	warp: function( startTimeScale, endTimeScale, duration ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._timeScaleInterpolant,

			timeScale = this.timeScale;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant(),
			this._timeScaleInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	},

	stopWarping: function() {

		var timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	},

	// Object Accessors

	getMixer: function() {

		return this._mixer;

	},

	getClip: function() {

		return this._clip;

	},

	getRoot: function() {

		return this._localRoot || this._mixer._root;

	},

	// Interna

	_update: function( time, deltaTime, timeDirection, accuIndex ) {
		// called by the mixer

		var startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			var timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				return; // yet to come / don't decide when delta = 0

			}

			// start

			this._startTime = null; // unschedule
			deltaTime = timeDirection * timeRunning;

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		var clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		var weight = this._updateWeight( time );

		if ( weight > 0 ) {

			var interpolants = this._interpolants;
			var propertyMixers = this._propertyBindings;

			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

				interpolants[ j ].evaluate( clipTime );
				propertyMixers[ j ].accumulate( accuIndex, weight );

			}

		}

	},

	_updateWeight: function( time ) {

		var weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			var interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	},

	_updateTimeScale: function( time ) {

		var timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			var interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.pause = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	},

	_updateTime: function( deltaTime ) {

		var time = this.time + deltaTime;

		if ( deltaTime === 0 ) return time;

		var duration = this._clip.duration,

			loop = this.loop,
			loopCount = this._loopCount,

			pingPong = false;

		switch ( loop ) {

			case fm.LoopOnce:

				if ( loopCount === -1 ) {

					// just started

					this.loopCount = 0;
					this._setEndings( true, true, false );

				}

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else break;

				// reached the end

				if ( this.clampWhenFinished ) this.pause = true;
				else this.enabled = false;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? -1 : 1
				} );

				break;

			case fm.LoopPingPong:

				pingPong = true;

			case fm.LoopRepeat:

				if ( loopCount === -1 ) {

					// just started

					if ( deltaTime > 0 ) {

						loopCount = 0;

						this._setEndings(
								true, this.repetitions === 0, pingPong );

					} else {

						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1

						this._setEndings(
								this.repetitions === 0, true, pingPong );

					}

				}

				if ( time >= duration || time < 0 ) {

					// wrap around

					var loopDelta = Math.floor( time / duration ); // signed
					time -= duration * loopDelta;

					loopCount += Math.abs( loopDelta );

					var pending = this.repetitions - loopCount;

					if ( pending < 0 ) {

						// stop (switch state, clamp time, fire event)

						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;

						time = deltaTime > 0 ? duration : 0;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : -1
						} );

						break;

					} else if ( pending === 0 ) {

						// transition to last round

						var atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

				if ( loop === fm.LoopPingPong && ( loopCount & 1 ) === 1 ) {

					// invert time for the "pong round"

					this.time = time;

					return duration - time;

				}

				break;

		}

		this.time = time;

		return time;

	},

	_setEndings: function( atStart, atEnd, pingPong ) {

		var settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart 	= fm.ZeroSlopeEnding;
			settings.endingEnd		= fm.ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ?
						fm.ZeroSlopeEnding : fm.ZeroCurvatureEnding;

			} else {

				settings.endingStart = fm.WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ?
						fm.ZeroSlopeEnding : fm.ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = fm.WrapAroundEnding;

			}

		}

	},

	_scheduleFading: function( duration, weightNow, weightThen ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant(),
			this._weightInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now; 				values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

		return this;

	}

};

// Implementation details:

Object.assign( fm.AnimationMixer.prototype, {

	_bindAction: function( action, prototypeAction ) {

		var root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( var i = 0; i !== nTracks; ++ i ) {

			var track = tracks[ i ],
				trackName = track.name,
				binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				var path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

				binding = new fm.PropertyMixer(
						fm.PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	},

	_activateAction: function( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				var rootUuid = ( action._localRoot || this._root ).uuid,
					clipName = action._clip.name,
					actionsForClip = this._actionsByClip[ clipName ];

				this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipName, rootUuid );

			}

			var bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	},

	_deactivateAction: function( action ) {

		if ( this._isActiveAction( action ) ) {

			var bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	},

	// Memory manager

	_initMemoryManager: function() {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 		knownActions: Array< _Action >	- used as prototypes
		// 		actionByRoot: _Action			- lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		var scope = this;

		this.stats = {

			actions: {
				get total() { return scope._actions.length; },
				get inUse() { return scope._nActiveActions; }
			},
			bindings: {
				get total() { return scope._bindings.length; },
				get inUse() { return scope._nActiveBindings; }
			},
			controlInterpolants: {
				get total() { return scope._controlInterpolants.length; },
				get inUse() { return scope._nActiveControlInterpolants; }
			}

		};

	},

	// Memory management for _Action objects

	_isActiveAction: function( action ) {

		var index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	},

	_addInactiveAction: function( action, clipName, rootUuid ) {

		var actions = this._actions,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipName ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipName ] = actionsForClip;

		} else {

			var knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	},

	_removeInactiveAction: function( action ) {

		var actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		var clipName = action._clip.name,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipName ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		var actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( actions._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipName ];

		}

		this._removeInactiveBindingsForAction( action );

	},

	_removeInactiveBindingsForAction: function( action ) {

		var bindings = action._propertyBindings;
		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

			var binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	},

	_lendAction: function( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	},

	_takeBackAction: function( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	},

	// Memory management for PropertyMixer objects

	_addInactiveBinding: function( binding, rootUuid, trackName ) {

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			bindings = this._bindings;

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	},

	_removeInactiveBinding: function( binding ) {

		var bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		remove_empty_map: {

			for ( var _ in bindingByName ) break remove_empty_map;

			delete bindingsByRoot[ rootUuid ];

		}

	},

	_lendBinding: function( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	},

	_takeBackBinding: function( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	},


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant: function() {

		var interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++,
			interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new fm.LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
						1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	},

	_takeBackControlInterpolant: function( interpolant ) {

		var interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	},

	_controlInterpolantsResultBuffer: new Float32Array( 1 )

} );


// File:src/animation/AnimationObjectGroup.js

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 * 	-	Add objects you would otherwise pass as 'root' to the
 * 		constructor or the .clipAction method of AnimationMixer.
 *
 * 	-	Instead pass this object as 'root'.
 *
 * 	-	You can also add and remove objects later when the mixer
 * 		is running.
 *
 * Note:
 *
 *  	Objects of this class appear as one object to the mixer,
 *  	so cache control of the individual objects must be done
 *  	on the group.
 *
 * Limitation:
 *
 * 	- 	The animated properties must be compatible among the
 * 		all objects in the group.
 *
 *  -	A single property can either be controlled through a
 *  	target group or directly, but not both.
 *
 * @author tschw
 */

fm.AnimationObjectGroup = function( var_args ) {

	this.uuid = fm.Math.generateUUID();

	// cached objects followed by the active ones
	this._objects = Array.prototype.slice.call( arguments );

	this.nCachedObjects_ = 0;			// threshold
	// note: read by PropertyBinding.Composite

	var indices = {};
	this._indicesByUUID = indices;		// for bookkeeping

	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

		indices[ arguments[ i ].uuid ] = i;

	}

	this._paths = [];					// inside: string
	this._parsedPaths = [];				// inside: { we don't care, here }
	this._bindings = []; 				// inside: Array< PropertyBinding >
	this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

	var scope = this;

	this.stats = {

		objects: {
			get total() { return scope._objects.length; },
			get inUse() { return this.total - scope.nCachedObjects_;  }
		},

		get bindingsPerObject() { return scope._bindings.length; }

	};

};

fm.AnimationObjectGroup.prototype = {

	constructor: fm.AnimationObjectGroup,

	add: function( var_args ) {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push(
							new fm.PropertyBinding(
								object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				var knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				var firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new fm.PropertyBinding(
								object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject) {

				console.error( "Different objects with the same UUID " +
						"detected. Clean the caches or recreate your " +
						"infrastructure when reloading scenes..." );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	remove: function( var_args ) {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				var lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// remove & forget
	uncache: function( var_args ) {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					var lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					indicesByUUID[ lastObject.uuid ] = index;
					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_: function( path, parsedPath ) {
		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ],
			bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		var paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( var i = nCachedObjects,
				n = objects.length; i !== n; ++ i ) {

			var object = objects[ i ];

			bindingsForPath[ i ] =
					new fm.PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	},

	unsubscribe_: function( path ) {
		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

};


// File:src/animation/AnimationUtils.js

/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

fm.AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function( array, from, to ) {

		if ( fm.AnimationUtils.isTypedArray( array ) ) {

			return new array.constructor( array.subarray( from, to ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
				! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function( object ) {

		return ArrayBuffer.isView( object ) &&
				! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		var n = times.length;
		var result = new Array( n );
		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function( values, stride, order ) {

		var nValues = values.length;
		var result = new values.constructor( nValues );

		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			var srcOffset = order[ i ] * stride;

			for ( var j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {

		var i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		var value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {
			// ...assume fm.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {
			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	}

};

// File:src/animation/KeyframeTrack.js

/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

fm.KeyframeTrack = function ( name, times, values, interpolation ) {

	if( name === undefined ) throw new Error( "track name is undefined" );

	if( times === undefined || times.length === 0 ) {

		throw new Error( "no keyframes in track named " + name );

	}

	this.name = name;

	this.times = fm.AnimationUtils.convertArray( times, this.TimeBufferType );
	this.values = fm.AnimationUtils.convertArray( values, this.ValueBufferType );

	this.setInterpolation( interpolation || this.DefaultInterpolation );

	this.validate();
	this.optimize();

};

fm.KeyframeTrack.prototype = {

	constructor: fm.KeyframeTrack,

	TimeBufferType: Float32Array,
	ValueBufferType: Float32Array,

	DefaultInterpolation: fm.InterpolateLinear,

	InterpolantFactoryMethodDiscrete: function( result ) {

		return new fm.DiscreteInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodLinear: function( result ) {

		return new fm.LinearInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: function( result ) {

		return new fm.CubicInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	setInterpolation: function( interpolation ) {

		var factoryMethod = undefined;

		switch ( interpolation ) {

			case fm.InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case fm.InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case fm.InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( message );
			return;

		}

		this.createInterpolant = factoryMethod;

	},

	getInterpolation: function() {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return fm.InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return fm.InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return fm.InterpolateSmooth;

		}

	},

	getValueSize: function() {

		return this.values.length / this.times.length;

	},

	// move all keyframes either forwards or backwards in time
	shift: function( timeOffset ) {

		if( timeOffset !== 0.0 ) {

			var times = this.times;

			for( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	},

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale: function( timeScale ) {

		if( timeScale !== 1.0 ) {

			var times = this.times;

			for( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	},

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim: function( startTime, endTime ) {

		var times = this.times,
			nKeys = times.length,
			from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) ++ from;
		while ( to !== -1 && times[ to ] > endTime ) -- to;

		++ to; // inclusive -> exclusive bound

		if( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) to = Math.max( to , 1 ), from = to - 1;

			var stride = this.getValueSize();
			this.times = fm.AnimationUtils.arraySlice( times, from, to );
			this.values = fm.AnimationUtils.
					arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	},

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate: function() {

		var valid = true;

		var valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( "invalid value size in track", this );
			valid = false;

		}

		var times = this.times,
			values = this.values,

			nKeys = times.length;

		if( nKeys === 0 ) {

			console.error( "track is empty", this );
			valid = false;

		}

		var prevTime = null;

		for( var i = 0; i !== nKeys; i ++ ) {

			var currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( "time is not a valid number", this, i, currTime );
				valid = false;
				break;

			}

			if( prevTime !== null && prevTime > currTime ) {

				console.error( "out of order keys", this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( fm.AnimationUtils.isTypedArray( values ) ) {

				for ( var i = 0, n = values.length; i !== n; ++ i ) {

					var value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( "value is not a valid number", this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	},

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize: function() {

		var times = this.times,
			values = this.values,
			stride = this.getValueSize(),

			writeIndex = 1;

		for( var i = 1, n = times.length - 1; i <= n; ++ i ) {

			var keep = false;

			var time = times[ i ];
			var timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

				// remove unnecessary keyframes same as their neighbors
				var offset = i * stride,
					offsetP = offset - stride,
					offsetN = offset + stride;

				for ( var j = 0; j !== stride; ++ j ) {

					var value = values[ offset + j ];

					if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

						keep = true;
						break;

					}

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					var readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( var j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}


				}

				++ writeIndex;

			}

		}

		if ( writeIndex !== times.length ) {

			this.times = fm.AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = fm.AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		}

		return this;

	}

};

// Static methods:

Object.assign( fm.KeyframeTrack, {

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	parse: function( json ) {

		if( json.type === undefined ) {

			throw new Error( "track type undefined, can not parse" );

		}

		var trackType = fm.KeyframeTrack._getTrackTypeForValueTypeName( json.type );

		if ( json.times === undefined ) {

			console.warn( "legacy JSON format detected, converting" );

			var times = [], values = [];

			fm.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

			json.times = times;
			json.values = values;

		}

		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {

			return trackType.parse( json );

		} else {

			// by default, we asssume a constructor compatible with the base
			return new trackType(
					json.name, json.times, json.values, json.interpolation );

		}

	},

	toJSON: function( track ) {

		var trackType = track.constructor;

		var json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== undefined ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': fm.AnimationUtils.convertArray( track.times, Array ),
				'values': fm.AnimationUtils.convertArray( track.values, Array )

			};

			var interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	},

	_getTrackTypeForValueTypeName: function( typeName ) {

		switch( typeName.toLowerCase() ) {

			case "scalar":
			case "double":
			case "float":
			case "number":
			case "integer":

				return fm.NumberKeyframeTrack;

			case "vector":
			case "vector2":
			case "vector3":
			case "vector4":

				return fm.VectorKeyframeTrack;

			case "color":

				return fm.ColorKeyframeTrack;

			case "quaternion":

				return fm.QuaternionKeyframeTrack;

			case "bool":
			case "boolean":

				return fm.BooleanKeyframeTrack;

			case "string":

				return fm.StringKeyframeTrack;

		};

		throw new Error( "Unsupported typeName: " + typeName );

	}

} );

// File:src/animation/PropertyBinding.js

/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

fm.PropertyBinding = function ( rootNode, path, parsedPath ) {

	this.path = path;
	this.parsedPath = parsedPath ||
			fm.PropertyBinding.parseTrackName( path );

	this.node = fm.PropertyBinding.findNode(
			rootNode, this.parsedPath.nodeName ) || rootNode;

	this.rootNode = rootNode;

};

fm.PropertyBinding.prototype = {

	constructor: fm.PropertyBinding,

	getValue: function getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

		// Note: This class uses a State pattern on a per-method basis:
		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
		// prototype version of these methods with one that represents
		// the bound state. When the property is not found, the methods
		// become no-ops.

	},

	setValue: function getValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	},

	// create getter / setter pair for a property in the scene graph
	bind: function() {

		var targetObject = this.node,
			parsedPath = this.parsedPath,

			objectName = parsedPath.objectName,
			propertyName = parsedPath.propertyName,
			propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = fm.PropertyBinding.findNode(
					this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

 		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
			return;

		}

		if( objectName ) {

			var objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if( ! targetObject.material ) {

						console.error( '  can not bind to material as node does not have a material', this );
						return;

					}

					if( ! targetObject.material.materials ) {

						console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if( ! targetObject.skeleton ) {

						console.error( '  can not bind to bones as node does not have a skeleton', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( var i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[i].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( '  can not bind to objectName of node, undefined', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if( targetObject[ objectIndex ] === undefined ) {

					console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		var nodeProperty = targetObject[ propertyName ];

		if ( ! nodeProperty ) {

			var nodeName = parsedPath.nodeName;

			console.error( "  trying to update property for track: " + nodeName +
					'.' + propertyName + " but it wasn't found.", targetObject );
			return;

		}

		// determine versioning scheme
		var versioning = this.Versioning.None;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;
			this.targetObject = targetObject;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;
			this.targetObject = targetObject;

		}

		// determine how the property gets bound
		var bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {
			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === "morphTargetInfluences" ) {
				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
					return;

				}

				if ( ! targetObject.geometry.morphTargets ) {

					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
					return;

				}

				for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

					if ( targetObject.geometry.morphTargets[i].name === propertyIndex ) {

						propertyIndex = i;
						break;

					}

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( nodeProperty.length !== undefined ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	},

	unbind: function() {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

};

Object.assign( fm.PropertyBinding.prototype, { // prototype, continued

	// these are used to "bind" a nonexistent property
	_getValue_unavailable: function() {},
	_setValue_unavailable: function() {},

	// initial state of these methods that calls 'bind'
	_getValue_unbound: fm.PropertyBinding.prototype.getValue,
	_setValue_unbound: fm.PropertyBinding.prototype.setValue,

	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},

	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},

	GetterByBindingType: [

		function getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.node[ this.propertyName ];

		},

		function getValue_array( buffer, offset ) {

			var source = this.resolvedProperty;

			for ( var i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		},

		function getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		},

		function getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

	],

	SetterByBindingTypeAndVersioning: [

		[
			// Direct

			function setValue_direct( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];

			},

			function setValue_direct_setNeedsUpdate( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// EntireArray

			function setValue_array( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

			},

			function setValue_array_setNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.needsUpdate = true;

			},

			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// ArrayElement

			function setValue_arrayElement( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

			},

			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// HasToFromArray

			function setValue_fromArray( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

			},

			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.needsUpdate = true;

			},

			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		]

	]

} );

fm.PropertyBinding.Composite =
		function( targetGroup, path, optionalParsedPath ) {

	var parsedPath = optionalParsedPath ||
			fm.PropertyBinding.parseTrackName( path );

	this._targetGroup = targetGroup;
	this._bindings = targetGroup.subscribe_( path, parsedPath );

};

fm.PropertyBinding.Composite.prototype = {

	constructor: fm.PropertyBinding.Composite,

	getValue: function( array, offset ) {

		this.bind(); // bind all binding

		var firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	},

	setValue: function( array, offset ) {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	},

	bind: function() {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	},

	unbind: function() {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

};

fm.PropertyBinding.create = function( root, path, parsedPath ) {

	if ( ! ( root instanceof fm.AnimationObjectGroup ) ) {

		return new fm.PropertyBinding( root, path, parsedPath );

	} else {

		return new fm.PropertyBinding.Composite( root, path, parsedPath );

	}

};

fm.PropertyBinding.parseTrackName = function( trackName ) {

	// matches strings in the form of:
	//    nodeName.property
	//    nodeName.property[accessor]
	//    nodeName.material.property[accessor]
	//    uuid.property[accessor]
	//    uuid.objectName[objectIndex].propertyName[propertyIndex]
	//    parentName/nodeName.property
	//    parentName/parentName/nodeName.property[index]
	//	  .bone[Armature.DEF_cog].position
	// created and tested via https://regex101.com/#javascript

	var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_.:\- ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
	var matches = re.exec(trackName);

	if( ! matches ) {
		throw new Error( "cannot parse trackName at all: " + trackName );
	}

    if (matches.index === re.lastIndex) {
        re.lastIndex++;
    }

	var results = {
		// directoryName: matches[1], // (tschw) currently unused
		nodeName: matches[3], 	// allowed to be null, specified root node.
		objectName: matches[5],
		objectIndex: matches[7],
		propertyName: matches[9],
		propertyIndex: matches[11]	// allowed to be null, specifies that the whole property is set.
	};

	if( results.propertyName === null || results.propertyName.length === 0 ) {
		throw new Error( "can not parse propertyName from trackName: " + trackName );
	}

	return results;

};

fm.PropertyBinding.findNode = function( root, nodeName ) {

	if( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

		return root;

	}

	// search into skeleton bones.
	if( root.skeleton ) {

		var searchSkeleton = function( skeleton ) {

			for( var i = 0; i < skeleton.bones.length; i ++ ) {

				var bone = skeleton.bones[i];

				if( bone.name === nodeName ) {

					return bone;

				}
			}

			return null;

		};

		var bone = searchSkeleton( root.skeleton );

		if( bone ) {

			return bone;

		}
	}

	// search into node subtree.
	if( root.children ) {

		var searchNodeSubtree = function( children ) {

			for( var i = 0; i < children.length; i ++ ) {

				var childNode = children[i];

				if( childNode.name === nodeName || childNode.uuid === nodeName ) {

					return childNode;

				}

				var result = searchNodeSubtree( childNode.children );

				if( result ) return result;

			}

			return null;

		};

		var subTreeNode = searchNodeSubtree( root.children );

		if( subTreeNode ) {

			return subTreeNode;

		}

	}

	return null;

}

// File:src/animation/PropertyMixer.js

/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

fm.PropertyMixer = function ( binding, typeName, valueSize ) {

	this.binding = binding;
	this.valueSize = valueSize;

	var bufferType = Float64Array,
		mixFunction;

	switch ( typeName ) {

		case 'quaternion':			mixFunction = this._slerp;		break;

		case 'string':
		case 'bool':

			bufferType = Array,		mixFunction = this._select;		break;

		default:					mixFunction = this._lerp;

	}

	this.buffer = new bufferType( valueSize * 4 );
	// layout: [ incoming | accu0 | accu1 | orig ]
	//
	// interpolators can use .buffer as their .result
	// the data then goes to 'incoming'
	//
	// 'accu0' and 'accu1' are used frame-interleaved for
	// the cumulative result and are compared to detect
	// changes
	//
	// 'orig' stores the original state of the property

	this._mixBufferRegion = mixFunction;

	this.cumulativeWeight = 0;

	this.useCount = 0;
	this.referenceCount = 0;

};

fm.PropertyMixer.prototype = {

	constructor: fm.PropertyMixer,

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate: function( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		var buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride,

			currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			var mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	},

	// apply the state of 'accu<i>' to the binding when accus differ
	apply: function( accuIndex ) {

		var stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,

			binding = this.binding;

		this.cumulativeWeight = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			var originalValueOffset = stride * 3;

			this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	},

	// remember the state of the bound property and copy it to both accus
	saveOriginalState: function() {

		var binding = this.binding;

		var buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * 3;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		this.cumulativeWeight = 0;

	},

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState: function() {

		var originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	},


	// mix functions

	_select: function( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	},

	_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {

		fm.Quaternion.slerpFlat( buffer, dstOffset,
				buffer, dstOffset, buffer, srcOffset, t );

	},

	_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {

		var s = 1 - t;

		for ( var i = 0; i !== stride; ++ i ) {

			var j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

};

// File:src/animation/tracks/BooleanKeyframeTrack.js

/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

fm.BooleanKeyframeTrack = function ( name, times, values ) {

	fm.KeyframeTrack.call( this, name, times, values );

};

fm.BooleanKeyframeTrack.prototype =
		Object.assign( Object.create( fm.KeyframeTrack.prototype ), {

	constructor: fm.BooleanKeyframeTrack,

	ValueTypeName: 'bool',
	ValueBufferType: Array,

	DefaultInterpolation: fm.InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,
	InterpolantFactoryMethodSmooth: undefined

	// Note: Actually this track could have a optimized / compressed
	// representation of a single value and a custom interpolant that
	// computes "firstValue ^ isOdd( index )".

} );

// File:src/animation/tracks/ColorKeyframeTrack.js

/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

fm.ColorKeyframeTrack = function ( name, times, values, interpolation ) {

	fm.KeyframeTrack.call( this, name, times, values, interpolation );

};

fm.ColorKeyframeTrack.prototype =
		Object.assign( Object.create( fm.KeyframeTrack.prototype ), {

	constructor: fm.ColorKeyframeTrack,

	ValueTypeName: 'color'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited


	// Note: Very basic implementation and nothing special yet.
	// However, this is the place for color space parameterization.

} );

// File:src/animation/tracks/NumberKeyframeTrack.js

/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

fm.NumberKeyframeTrack = function ( name, times, values, interpolation ) {

	fm.KeyframeTrack.call( this, name, times, values, interpolation );

};

fm.NumberKeyframeTrack.prototype =
		Object.assign( Object.create( fm.KeyframeTrack.prototype ), {

	constructor: fm.NumberKeyframeTrack,

	ValueTypeName: 'number',

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

// File:src/animation/tracks/QuaternionKeyframeTrack.js

/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

fm.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {

	fm.KeyframeTrack.call( this, name, times, values, interpolation );

};

fm.QuaternionKeyframeTrack.prototype =
		Object.assign( Object.create( fm.KeyframeTrack.prototype ), {

	constructor: fm.QuaternionKeyframeTrack,

	ValueTypeName: 'quaternion',

	// ValueBufferType is inherited

	DefaultInterpolation: fm.InterpolateLinear,

	InterpolantFactoryMethodLinear: function( result ) {

		return new fm.QuaternionLinearInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: undefined // not yet implemented

} );

// File:src/animation/tracks/StringKeyframeTrack.js

/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

fm.StringKeyframeTrack = function ( name, times, values, interpolation ) {

	fm.KeyframeTrack.call( this, name, times, values, interpolation );

};

fm.StringKeyframeTrack.prototype =
		Object.assign( Object.create( fm.KeyframeTrack.prototype ), {

	constructor: fm.StringKeyframeTrack,

	ValueTypeName: 'string',
	ValueBufferType: Array,

	DefaultInterpolation: fm.InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,

	InterpolantFactoryMethodSmooth: undefined

} );

// File:src/animation/tracks/VectorKeyframeTrack.js

/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

fm.VectorKeyframeTrack = function ( name, times, values, interpolation ) {

	fm.KeyframeTrack.call( this, name, times, values, interpolation );

};

fm.VectorKeyframeTrack.prototype =
		Object.assign( Object.create( fm.KeyframeTrack.prototype ), {

	constructor: fm.VectorKeyframeTrack,

	ValueTypeName: 'vector'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

// File:src/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

fm.Audio = function ( listener ) {

	fm.Object3D.call( this );

	this.type = 'Audio';

	this.context = listener.context;
	this.source = this.context.createBufferSource();
	this.source.onended = this.onEnded.bind( this );

	this.gain = this.context.createGain();
	this.gain.connect( listener.getInput() );

	this.autoplay = false;

	this.startTime = 0;
	this.playbackRate = 1;
	this.isPlaying = false;
	this.hasPlaybackControl = true;
	this.sourceType = 'empty';

	this.filter = null;

};

fm.Audio.prototype = Object.create( fm.Object3D.prototype );
fm.Audio.prototype.constructor = fm.Audio;

fm.Audio.prototype.getOutput = function () {

	return this.gain;

};

fm.Audio.prototype.setNodeSource = function ( audioNode ) {

	this.hasPlaybackControl = false;
	this.sourceType = 'audioNode';
	this.source = audioNode;
	this.connect();

	return this;

};

fm.Audio.prototype.setBuffer = function ( audioBuffer ) {

	var scope = this;

	scope.source.buffer = audioBuffer;
	scope.sourceType = 'buffer';
	if ( scope.autoplay ) scope.play();

	return this;

};

fm.Audio.prototype.play = function () {

	if ( this.isPlaying === true ) {

		console.warn( 'fm.Audio: Audio is already playing.' );
		return;

	}

	if ( this.hasPlaybackControl === false ) {

		console.warn( 'fm.Audio: this Audio has no playback control.' );
		return;

	}

	var source = this.context.createBufferSource();

	source.buffer = this.source.buffer;
	source.loop = this.source.loop;
	source.onended = this.source.onended;
	source.start( 0, this.startTime );
	source.playbackRate.value = this.playbackRate;

	this.isPlaying = true;

	this.source = source;

	this.connect();

};

fm.Audio.prototype.pause = function () {

	if ( this.hasPlaybackControl === false ) {

		console.warn( 'fm.Audio: this Audio has no playback control.' );
		return;

	}

	this.source.stop();
	this.startTime = this.context.currentTime;

};

fm.Audio.prototype.stop = function () {

	if ( this.hasPlaybackControl === false ) {

		console.warn( 'fm.Audio: this Audio has no playback control.' );
		return;

	}

	this.source.stop();
	this.startTime = 0;

};

fm.Audio.prototype.connect = function () {

	if ( this.filter !== null ) {

		this.source.connect( this.filter );
		this.filter.connect( this.getOutput() );

	} else {

		this.source.connect( this.getOutput() );

	}

};

fm.Audio.prototype.disconnect = function () {

	if ( this.filter !== null ) {

		this.source.disconnect( this.filter );
		this.filter.disconnect( this.getOutput() );

	} else {

		this.source.disconnect( this.getOutput() );

	}

};

fm.Audio.prototype.getFilter = function () {

	return this.filter;

};

fm.Audio.prototype.setFilter = function ( value ) {

	if ( value === undefined ) value = null;

	if ( this.isPlaying === true ) {

		this.disconnect();
		this.filter = value;
		this.connect();

	} else {

		this.filter = value;

	}

};

fm.Audio.prototype.setPlaybackRate = function ( value ) {

	if ( this.hasPlaybackControl === false ) {

		console.warn( 'fm.Audio: this Audio has no playback control.' );
		return;

	}

	this.playbackRate = value;

	if ( this.isPlaying === true ) {

		this.source.playbackRate.value = this.playbackRate;

	}

};

fm.Audio.prototype.getPlaybackRate = function () {

	return this.playbackRate;

};

fm.Audio.prototype.onEnded = function () {

	this.isPlaying = false;

};

fm.Audio.prototype.setLoop = function ( value ) {

	if ( this.hasPlaybackControl === false ) {

		console.warn( 'fm.Audio: this Audio has no playback control.' );
		return;

	}

	this.source.loop = value;

};

fm.Audio.prototype.getLoop = function () {

	if ( this.hasPlaybackControl === false ) {

		console.warn( 'fm.Audio: this Audio has no playback control.' );
		return false;

	}

	return this.source.loop;

};


fm.Audio.prototype.setVolume = function ( value ) {

	this.gain.gain.value = value;

};

fm.Audio.prototype.getVolume = function () {

	return this.gain.gain.value;

};

// File:src/audio/AudioAnalyser.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.AudioAnalyser = function ( audio, fftSize ) {

	this.analyser = audio.context.createAnalyser();
	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

	this.data = new Uint8Array( this.analyser.frequencyBinCount );

	audio.getOutput().connect( this.analyser );

};

fm.AudioAnalyser.prototype = {

	constructor: fm.AudioAnalyser,

	getData: function () {

		this.analyser.getByteFrequencyData( this.data );
		return this.data;

	}

};

// File:src/audio/AudioContext.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

Object.defineProperty( fm, 'AudioContext', {

	get: ( function () {

		var context;

		return function () {

			if ( context === undefined ) {

				context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return context;

		};

	} )()

} );

// File:src/audio/PositionalAudio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.PositionalAudio = function ( listener ) {

	fm.Audio.call( this, listener );

	this.panner = this.context.createPanner();
	this.panner.connect( this.gain );

};

fm.PositionalAudio.prototype = Object.create( fm.Audio.prototype );
fm.PositionalAudio.prototype.constructor = fm.PositionalAudio;

fm.PositionalAudio.prototype.getOutput = function () {

	return this.panner;

};

fm.PositionalAudio.prototype.setRefDistance = function ( value ) {

	this.panner.refDistance = value;

};

fm.PositionalAudio.prototype.getRefDistance = function () {

	return this.panner.refDistance;

};

fm.PositionalAudio.prototype.setRolloffFactor = function ( value ) {

	this.panner.rolloffFactor = value;

};

fm.PositionalAudio.prototype.getRolloffFactor = function () {

	return this.panner.rolloffFactor;

};

fm.PositionalAudio.prototype.setDistanceModel = function ( value ) {

	this.panner.distanceModel = value;

};

fm.PositionalAudio.prototype.getDistanceModel = function () {

	return this.panner.distanceModel;

};

fm.PositionalAudio.prototype.setMaxDistance = function ( value ) {

	this.panner.maxDistance = value;

};

fm.PositionalAudio.prototype.getMaxDistance = function () {

	return this.panner.maxDistance;

};

fm.PositionalAudio.prototype.updateMatrixWorld = ( function () {

	var position = new fm.Vector3();

	return function updateMatrixWorld( force ) {

		fm.Object3D.prototype.updateMatrixWorld.call( this, force );

		position.setFromMatrixPosition( this.matrixWorld );

		this.panner.setPosition( position.x, position.y, position.z );

	};

} )();

// File:src/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.AudioListener = function () {

	fm.Object3D.call( this );

	this.type = 'AudioListener';

	this.context = fm.AudioContext;

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.filter = null;

};

fm.AudioListener.prototype = Object.create( fm.Object3D.prototype );
fm.AudioListener.prototype.constructor = fm.AudioListener;

fm.AudioListener.prototype.getInput = function () {

	return this.gain;

};

fm.AudioListener.prototype.removeFilter = function ( ) {

	if ( this.filter !== null ) {

		this.gain.disconnect( this.filter );
		this.filter.disconnect( this.context.destination );
		this.gain.connect( this.context.destination );
		this.filter = null;

	}

};

fm.AudioListener.prototype.setFilter = function ( value ) {

	if ( this.filter !== null ) {

		this.gain.disconnect( this.filter );
		this.filter.disconnect( this.context.destination );

	} else {

		this.gain.disconnect( this.context.destination );

	}

	this.filter = value;
	this.gain.connect( this.filter );
	this.filter.connect( this.context.destination );

};

fm.AudioListener.prototype.getFilter = function () {

	return this.filter;

};

fm.AudioListener.prototype.setMasterVolume = function ( value ) {

	this.gain.gain.value = value;

};

fm.AudioListener.prototype.getMasterVolume = function () {

	return this.gain.gain.value;

};


fm.AudioListener.prototype.updateMatrixWorld = ( function () {

	var position = new fm.Vector3();
	var quaternion = new fm.Quaternion();
	var scale = new fm.Vector3();

	var orientation = new fm.Vector3();

	return function updateMatrixWorld( force ) {

		fm.Object3D.prototype.updateMatrixWorld.call( this, force );

		var listener = this.context.listener;
		var up = this.up;

		this.matrixWorld.decompose( position, quaternion, scale );

		orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

		listener.setPosition( position.x, position.y, position.z );
		listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

	};

} )();

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

fm.Camera = function () {

	fm.Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new fm.Matrix4();
	this.projectionMatrix = new fm.Matrix4();

};

fm.Camera.prototype = Object.create( fm.Object3D.prototype );
fm.Camera.prototype.constructor = fm.Camera;

fm.Camera.prototype.getWorldDirection = function () {

	var quaternion = new fm.Quaternion();

	return function ( optionalTarget ) {

		var result = optionalTarget || new fm.Vector3();

		this.getWorldQuaternion( quaternion );

		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

	};

}();

fm.Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new fm.Matrix4();

	return function ( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

fm.Camera.prototype.clone = function () {

	return new this.constructor().copy( this );

};

fm.Camera.prototype.copy = function ( source ) {

	fm.Object3D.prototype.copy.call( this, source );

	this.matrixWorldInverse.copy( source.matrixWorldInverse );
	this.projectionMatrix.copy( source.projectionMatrix );

	return this;

};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

fm.CubeCamera = function ( near, far, cubeResolution ) {

	fm.Object3D.call( this );

	this.type = 'CubeCamera';

	var fov = 90, aspect = 1;

	var cameraPX = new fm.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new fm.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new fm.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new fm.Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new fm.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new fm.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new fm.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new fm.Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new fm.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new fm.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new fm.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new fm.Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	var options = { format: fm.RGBFormat, magFilter: fm.LinearFilter, minFilter: fm.LinearFilter };

	this.renderTarget = new fm.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );

	this.updateCubeMap = function ( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

		renderer.setRenderTarget( null );

	};

};

fm.CubeCamera.prototype = Object.create( fm.Object3D.prototype );
fm.CubeCamera.prototype.constructor = fm.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	fm.Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

fm.OrthographicCamera.prototype = Object.create( fm.Camera.prototype );
fm.OrthographicCamera.prototype.constructor = fm.OrthographicCamera;

fm.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	var dx = ( this.right - this.left ) / ( 2 * this.zoom );
	var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
	var cx = ( this.right + this.left ) / 2;
	var cy = ( this.top + this.bottom ) / 2;

	this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

fm.OrthographicCamera.prototype.copy = function ( source ) {

	fm.Camera.prototype.copy.call( this, source );

	this.left = source.left;
	this.right = source.right;
	this.top = source.top;
	this.bottom = source.bottom;
	this.near = source.near;
	this.far = source.far;

	this.zoom = source.zoom;

	return this;

};

fm.OrthographicCamera.prototype.toJSON = function ( meta ) {

	var data = fm.Object3D.prototype.toJSON.call( this, meta );

	data.object.zoom = this.zoom;
	data.object.left = this.left;
	data.object.right = this.right;
	data.object.top = this.top;
	data.object.bottom = this.bottom;
	data.object.near = this.near;
	data.object.far = this.far;

	return data;

};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */

fm.PerspectiveCamera = function( fov, aspect, near, far ) {

	fm.Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.fov = fov !== undefined ? fov : 50;
	this.zoom = 1;

	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;
	this.focus = 10;

	this.aspect = aspect !== undefined ? aspect : 1;
	this.view = null;

	this.filmGauge = 35;	// width of the film (default in millimeters)
	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

	this.updateProjectionMatrix();

};

fm.PerspectiveCamera.prototype = Object.create( fm.Camera.prototype );
fm.PerspectiveCamera.prototype.constructor = fm.PerspectiveCamera;


/**
 * Sets the FOV by focal length (DEPRECATED).
 *
 * Optionally also sets .filmGauge, otherwise uses it. See .setFocalLength.
 */
fm.PerspectiveCamera.prototype.setLens = function( focalLength, filmGauge ) {

	console.warn( "fm.PerspectiveCamera.setLens is deprecated. " +
			"Use .setFocalLength and .filmGauge for a photographic setup." );

	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );

};

/**
 * Sets the FOV by focal length in respect to the current .filmGauge.
 *
 * The default film gauge is 35, so that the focal length can be specified for
 * a 35mm (full frame) camera.
 *
 * Values for focal length and film gauge must have the same unit.
 */
fm.PerspectiveCamera.prototype.setFocalLength = function( focalLength ) {

	// see http://www.bobatkins.com/photography/technical/field_of_view.html
	var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

	this.fov = fm.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
	this.updateProjectionMatrix();

};


/**
 * Calculates the focal length from the current .fov and .filmGauge.
 */
fm.PerspectiveCamera.prototype.getFocalLength = function() {

	var vExtentSlope = Math.tan( fm.Math.DEG2RAD * 0.5 * this.fov );

	return 0.5 * this.getFilmHeight() / vExtentSlope;

};

fm.PerspectiveCamera.prototype.getEffectiveFOV = function() {

	return fm.Math.RAD2DEG * 2 * Math.atan(
			Math.tan( fm.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

};

fm.PerspectiveCamera.prototype.getFilmWidth = function() {

	// film not completely covered in portrait format (aspect < 1)
	return this.filmGauge * Math.min( this.aspect, 1 );

};

fm.PerspectiveCamera.prototype.getFilmHeight = function() {

	// film not completely covered in landscape format (aspect > 1)
	return this.filmGauge / Math.max( this.aspect, 1 );

};



/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */
fm.PerspectiveCamera.prototype.setViewOffset = function( fullWidth, fullHeight, x, y, width, height ) {

	this.aspect = fullWidth / fullHeight;

	this.view = {
		fullWidth: fullWidth,
		fullHeight: fullHeight,
		offsetX: x,
		offsetY: y,
		width: width,
		height: height
	};

	this.updateProjectionMatrix();

};

fm.PerspectiveCamera.prototype.updateProjectionMatrix = function() {

	var near = this.near,
		top = near * Math.tan(
				fm.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
		height = 2 * top,
		width = this.aspect * height,
		left = - 0.5 * width,
		view = this.view;

	if ( view !== null ) {

		var fullWidth = view.fullWidth,
			fullHeight = view.fullHeight;

		left += view.offsetX * width / fullWidth;
		top -= view.offsetY * height / fullHeight;
		width *= view.width / fullWidth;
		height *= view.height / fullHeight;

	}

	var skew = this.filmOffset;
	if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

	this.projectionMatrix.makeFrustum(
			left, left + width, top - height, top, near, this.far );

};

fm.PerspectiveCamera.prototype.copy = function( source ) {

	fm.Camera.prototype.copy.call( this, source );

	this.fov = source.fov;
	this.zoom = source.zoom;

	this.near = source.near;
	this.far = source.far;
	this.focus = source.focus;

	this.aspect = source.aspect;
	this.view = source.view === null ? null : Object.assign( {}, source.view );

	this.filmGauge = source.filmGauge;
	this.filmOffset = source.filmOffset;

	return this;

};

fm.PerspectiveCamera.prototype.toJSON = function( meta ) {

	var data = fm.Object3D.prototype.toJSON.call( this, meta );

	data.object.fov = this.fov;
	data.object.zoom = this.zoom;

	data.object.near = this.near;
	data.object.far = this.far;
	data.object.focus = this.focus;

	data.object.aspect = this.aspect;

	if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

	data.object.filmGauge = this.filmGauge;
	data.object.filmOffset = this.filmOffset;

	return data;

};

// File:src/cameras/StereoCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.StereoCamera = function () {

	this.type = 'StereoCamera';

	this.aspect = 1;

	this.cameraL = new fm.PerspectiveCamera();
	this.cameraL.layers.enable( 1 );
	this.cameraL.matrixAutoUpdate = false;

	this.cameraR = new fm.PerspectiveCamera();
	this.cameraR.layers.enable( 2 );
	this.cameraR.matrixAutoUpdate = false;

};

fm.StereoCamera.prototype = {

	constructor: fm.StereoCamera,

	update: ( function () {

		var focus, fov, aspect, near, far;

		var eyeRight = new fm.Matrix4();
		var eyeLeft = new fm.Matrix4();

		return function update ( camera ) {

			var needsUpdate = focus !== camera.focus || fov !== camera.fov ||
												aspect !== camera.aspect * this.aspect || near !== camera.near ||
												far !== camera.far;

			if ( needsUpdate ) {

				focus = camera.focus;
				fov = camera.fov;
				aspect = camera.aspect * this.aspect;
				near = camera.near;
				far = camera.far;

				// Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				var projectionMatrix = camera.projectionMatrix.clone();
				var eyeSep = 0.064 / 2;
				var eyeSepOnProjection = eyeSep * near / focus;
				var ymax = near * Math.tan( fm.Math.DEG2RAD * fov * 0.5 );
				var xmin, xmax;

				// translate xOffset

				eyeLeft.elements[ 12 ] = - eyeSep;
				eyeRight.elements[ 12 ] = eyeSep;

				// for left eye

				xmin = - ymax * aspect + eyeSepOnProjection;
				xmax = ymax * aspect + eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraL.projectionMatrix.copy( projectionMatrix );

				// for right eye

				xmin = - ymax * aspect - eyeSepOnProjection;
				xmax = ymax * aspect - eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraR.projectionMatrix.copy( projectionMatrix );

			}

			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

		};

	} )()

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

fm.Light = function ( color, intensity ) {

	fm.Object3D.call( this );

	this.type = 'Light';

	this.color = new fm.Color( color );
	this.intensity = intensity !== undefined ? intensity : 1;

	this.receiveShadow = undefined;

};

fm.Light.prototype = Object.create( fm.Object3D.prototype );
fm.Light.prototype.constructor = fm.Light;

fm.Light.prototype.copy = function ( source ) {

	fm.Object3D.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.intensity = source.intensity;

	return this;

};

fm.Light.prototype.toJSON = function ( meta ) {

	var data = fm.Object3D.prototype.toJSON.call( this, meta );

	data.object.color = this.color.getHex();
	data.object.intensity = this.intensity;

	if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

	if ( this.distance !== undefined ) data.object.distance = this.distance;
	if ( this.angle !== undefined ) data.object.angle = this.angle;
	if ( this.decay !== undefined ) data.object.decay = this.decay;
	if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

	return data;

};

// File:src/lights/LightShadow.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.LightShadow = function ( camera ) {

	this.camera = camera;

	this.bias = 0;
	this.radius = 1;

	this.mapSize = new fm.Vector2( 512, 512 );

	this.map = null;
	this.matrix = new fm.Matrix4();

};

fm.LightShadow.prototype = {

	constructor: fm.LightShadow,

	copy: function ( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.AmbientLight = function ( color, intensity ) {

	fm.Light.call( this, color, intensity );

	this.type = 'AmbientLight';

	this.castShadow = undefined;

};

fm.AmbientLight.prototype = Object.create( fm.Light.prototype );
fm.AmbientLight.prototype.constructor = fm.AmbientLight;

// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

fm.DirectionalLight = function ( color, intensity ) {

	fm.Light.call( this, color, intensity );

	this.type = 'DirectionalLight';

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.target = new fm.Object3D();

	this.shadow = new fm.DirectionalLightShadow();

};

fm.DirectionalLight.prototype = Object.create( fm.Light.prototype );
fm.DirectionalLight.prototype.constructor = fm.DirectionalLight;

fm.DirectionalLight.prototype.copy = function ( source ) {

	fm.Light.prototype.copy.call( this, source );

	this.target = source.target.clone();

	this.shadow = source.shadow.clone();

	return this;

};

// File:src/lights/DirectionalLightShadow.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.DirectionalLightShadow = function ( light ) {

	fm.LightShadow.call( this, new fm.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

};

fm.DirectionalLightShadow.prototype = Object.create( fm.LightShadow.prototype );
fm.DirectionalLightShadow.prototype.constructor = fm.DirectionalLightShadow;

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.HemisphereLight = function ( skyColor, groundColor, intensity ) {

	fm.Light.call( this, skyColor, intensity );

	this.type = 'HemisphereLight';

	this.castShadow = undefined;

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.groundColor = new fm.Color( groundColor );

};

fm.HemisphereLight.prototype = Object.create( fm.Light.prototype );
fm.HemisphereLight.prototype.constructor = fm.HemisphereLight;

fm.HemisphereLight.prototype.copy = function ( source ) {

	fm.Light.prototype.copy.call( this, source );

	this.groundColor.copy( source.groundColor );

	return this;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */


fm.PointLight = function ( color, intensity, distance, decay ) {

	fm.Light.call( this, color, intensity );

	this.type = 'PointLight';

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new fm.LightShadow( new fm.PerspectiveCamera( 90, 1, 0.5, 500 ) );

};

fm.PointLight.prototype = Object.create( fm.Light.prototype );
fm.PointLight.prototype.constructor = fm.PointLight;

Object.defineProperty( fm.PointLight.prototype, "power", {

	get: function () {

		// intensity = power per solid angle.
		// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
		return this.intensity * 4 * Math.PI;

	},

	set: function ( power ) {

		// intensity = power per solid angle.
		// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
		this.intensity = power / ( 4 * Math.PI );

	}

} );

fm.PointLight.prototype.copy = function ( source ) {

	fm.Light.prototype.copy.call( this, source );

	this.distance = source.distance;
	this.decay = source.decay;

	this.shadow = source.shadow.clone();

	return this;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {

	fm.Light.call( this, color, intensity );

	this.type = 'SpotLight';

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.target = new fm.Object3D();

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new fm.SpotLightShadow();

};

fm.SpotLight.prototype = Object.create( fm.Light.prototype );
fm.SpotLight.prototype.constructor = fm.SpotLight;

Object.defineProperty( fm.SpotLight.prototype, "power", {

	get: function () {

		// intensity = power per solid angle.
		// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
		return this.intensity * Math.PI;

	},

	set: function ( power ) {

		// intensity = power per solid angle.
		// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
		this.intensity = power / Math.PI;

	}

} );

fm.SpotLight.prototype.copy = function ( source ) {

	fm.Light.prototype.copy.call( this, source );

	this.distance = source.distance;
	this.angle = source.angle;
	this.penumbra = source.penumbra;
	this.decay = source.decay;

	this.target = source.target.clone();

	this.shadow = source.shadow.clone();

	return this;

};

// File:src/lights/SpotLightShadow.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.SpotLightShadow = function () {

	fm.LightShadow.call( this, new fm.PerspectiveCamera( 50, 1, 0.5, 500 ) );

};

fm.SpotLightShadow.prototype = Object.create( fm.LightShadow.prototype );
fm.SpotLightShadow.prototype.constructor = fm.SpotLightShadow;

fm.SpotLightShadow.prototype.update = function ( light ) {

	var fov = fm.Math.RAD2DEG * 2 * light.angle;
	var aspect = this.mapSize.width / this.mapSize.height;
	var far = light.distance || 500;

	var camera = this.camera;

	if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

		camera.fov = fov;
		camera.aspect = aspect;
		camera.far = far;
		camera.updateProjectionMatrix();

	}

};

// File:src/loaders/AudioLoader.js

/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

fm.AudioLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : fm.DefaultLoadingManager;

};

fm.AudioLoader.prototype = {

	constructor: fm.AudioLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var loader = new fm.XHRLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.load( url, function ( buffer ) {

			var context = fm.AudioContext;

			context.decodeAudioData( buffer, function ( audioBuffer ) {

				onLoad( audioBuffer );

			} );

		}, onProgress, onError );

	}

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'fm.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'fm.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.Loader = function () {

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

fm.Loader.prototype = {

	constructor: fm.Loader,

	crossOrigin: undefined,

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath, crossOrigin ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

		}

		return array;

	},

	createMaterial: ( function () {

		var color, textureLoader, materialLoader;

		return function ( m, texturePath, crossOrigin ) {

			if ( color === undefined ) color = new fm.Color();
			if ( textureLoader === undefined ) textureLoader = new fm.TextureLoader();
			if ( materialLoader === undefined ) materialLoader = new fm.MaterialLoader();

			// convert from old material format

			var textures = {};

			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

				var fullPath = texturePath + path;
				var loader = fm.Loader.Handlers.get( fullPath );

				var texture;

				if ( loader !== null ) {

					texture = loader.load( fullPath );

				} else {

					textureLoader.setCrossOrigin( crossOrigin );
					texture = textureLoader.load( fullPath );

				}

				if ( repeat !== undefined ) {

					texture.repeat.fromArray( repeat );

					if ( repeat[ 0 ] !== 1 ) texture.wrapS = fm.RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) texture.wrapT = fm.RepeatWrapping;

				}

				if ( offset !== undefined ) {

					texture.offset.fromArray( offset );

				}

				if ( wrap !== undefined ) {

					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = fm.RepeatWrapping;
					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = fm.MirroredRepeatWrapping;

					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = fm.RepeatWrapping;
					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = fm.MirroredRepeatWrapping;

				}

				if ( anisotropy !== undefined ) {

					texture.anisotropy = anisotropy;

				}

				var uuid = fm.Math.generateUUID();

				textures[ uuid ] = texture;

				return uuid;

			}

			//

			var json = {
				uuid: fm.Math.generateUUID(),
				type: 'MeshLambertMaterial'
			};

			for ( var name in m ) {

				var value = m[ name ];

				switch ( name ) {
					case 'DbgColor':
					case 'DbgIndex':
					case 'opticalDensity':
					case 'illumination':
						break;
					case 'DbgName':
						json.name = value;
						break;
					case 'blending':
						json.blending = fm[ value ];
						break;
					case 'colorAmbient':
					case 'mapAmbient':
                        //jimguo delete beg
						//console.warn( 'fm.Loader.createMaterial:', name, 'is no longer supported.' );
                        //jimguo delete end
						break;
					case 'colorDiffuse':
						json.color = color.fromArray( value ).getHex();
						break;
					case 'colorSpecular':
						json.specular = color.fromArray( value ).getHex();
						break;
					case 'colorEmissive':
						json.emissive = color.fromArray( value ).getHex();
						break;
					case 'specularCoef':
						json.shininess = value;
						break;
					case 'shading':
						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
						break;
					case 'mapDiffuse':
						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
                        //jimguo add beg
                        json.type = 'MeshBasicMaterial';
                        //jimguo add end
						break;
					case 'mapDiffuseRepeat':
					case 'mapDiffuseOffset':
					case 'mapDiffuseWrap':
					case 'mapDiffuseAnisotropy':
						break;
					case 'mapLight':
						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
						break;
					case 'mapLightRepeat':
					case 'mapLightOffset':
					case 'mapLightWrap':
					case 'mapLightAnisotropy':
						break;
					case 'mapAO':
						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
						break;
					case 'mapAORepeat':
					case 'mapAOOffset':
					case 'mapAOWrap':
					case 'mapAOAnisotropy':
						break;
					case 'mapBump':
						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
						break;
					case 'mapBumpScale':
						json.bumpScale = value;
						break;
					case 'mapBumpRepeat':
					case 'mapBumpOffset':
					case 'mapBumpWrap':
					case 'mapBumpAnisotropy':
						break;
					case 'mapNormal':
						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
						break;
					case 'mapNormalFactor':
						json.normalScale = [ value, value ];
						break;
					case 'mapNormalRepeat':
					case 'mapNormalOffset':
					case 'mapNormalWrap':
					case 'mapNormalAnisotropy':
						break;
					case 'mapSpecular':
						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
						break;
					case 'mapSpecularRepeat':
					case 'mapSpecularOffset':
					case 'mapSpecularWrap':
					case 'mapSpecularAnisotropy':
						break;
					case 'mapAlpha':
						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
						break;
					case 'mapAlphaRepeat':
					case 'mapAlphaOffset':
					case 'mapAlphaWrap':
					case 'mapAlphaAnisotropy':
						break;
					case 'flipSided':
						json.side = fm.BackSide;
						break;
					case 'doubleSided':
						json.side = fm.DoubleSide;
						break;
					case 'transparency':
                        //jimguo delete beg
						//console.warn( 'fm.Loader.createMaterial: transparency has been renamed to opacity' );
                        //jimguo delete end
						json.opacity = value;
						break;
					case 'depthTest':
					case 'depthWrite':
					case 'colorWrite':
					case 'opacity':
					case 'reflectivity':
					case 'transparent':
					case 'visible':
					case 'wireframe':
						json[ name ] = value;
						break;
					case 'vertexColors':
						if ( value === true ) json.vertexColors = fm.VertexColors;
						if ( value === 'face' ) json.vertexColors = fm.FaceColors;
						break;
					default:
						console.error( 'fm.Loader.createMaterial: Unsupported', name, value );
						break;
				}

			}

			if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

			if ( json.opacity < 1 ) json.transparent = true;

			materialLoader.setTextures( textures );

			return materialLoader.parse( json );

		};

	} )()

};

fm.Loader.Handlers = {

	handlers: [],

	add: function ( regex, loader ) {

		this.handlers.push( regex, loader );

	},

	get: function ( file ) {

		var handlers = this.handlers;

		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

			var regex = handlers[ i ];
			var loader  = handlers[ i + 1 ];

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	}

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.XHRLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : fm.DefaultLoadingManager;

};

fm.XHRLoader.prototype = {

	constructor: fm.XHRLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		var scope = this;

		var cached = fm.Cache.get( url );

		if ( cached !== undefined ) {

			if ( onLoad ) {

				setTimeout( function () {

					onLoad( cached );

				}, 0 );

			}

			return cached;

		}

		var request = new XMLHttpRequest();
		request.overrideMimeType( 'text/plain' );
		request.open( 'GET', url, true );

		request.addEventListener( 'load', function ( event ) {

			var response = event.target.response;

			fm.Cache.add( url, response );

			if ( this.status === 200 ) {

				if ( onLoad ) onLoad( response );

				scope.manager.itemEnd( url );

			} else if ( this.status === 0 ) {

				// Some browsers return HTTP Status 0 when using non-http protocol
				// e.g. 'file://' or 'data://'. Handle as success.

				console.warn( 'fm.XHRLoader: HTTP Status 0 received.' );

				if ( onLoad ) onLoad( response );

				scope.manager.itemEnd( url );

			} else {

				if ( onError ) onError( event );

				scope.manager.itemError( url );

			}

		}, false );

		if ( onProgress !== undefined ) {

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		request.addEventListener( 'error', function ( event ) {

			if ( onError ) onError( event );

			scope.manager.itemError( url );

		}, false );

		if ( this.responseType !== undefined ) request.responseType = this.responseType;
		if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

		request.send( null );

		scope.manager.itemStart( url );

		return request;

	},

	setPath: function ( value ) {

		this.path = value;

	},

	setResponseType: function ( value ) {

		this.responseType = value;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;

	}

};

// File:src/loaders/FontLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.FontLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : fm.DefaultLoadingManager;

};

fm.FontLoader.prototype = {

	constructor: fm.FontLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var loader = new fm.XHRLoader( this.manager );
		loader.load( url, function ( text ) {

			onLoad( new fm.Font( JSON.parse( text.substring( 65, text.length - 2 ) ) ) );

		}, onProgress, onError );

	}

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.ImageLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : fm.DefaultLoadingManager;

};

fm.ImageLoader.prototype = {

	constructor: fm.ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		var scope = this;

		var cached = fm.Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			if ( onLoad ) {

				setTimeout( function () {

					onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

			} else {

				scope.manager.itemEnd( url );

			}

			return cached;

		}

		var image = document.createElement( 'img' );

		image.addEventListener( 'load', function ( event ) {

			fm.Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}, false );

		if ( onProgress !== undefined ) {

			image.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		image.addEventListener( 'error', function ( event ) {

			if ( onError ) onError( event );

			scope.manager.itemError( url );

		}, false );

		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setPath: function ( value ) {

		this.path = value;

	}

};

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

fm.JSONLoader = function ( manager ) {

	if ( typeof manager === 'boolean' ) {

		console.warn( 'fm.JSONLoader: showStatus parameter has been removed from constructor.' );
		manager = undefined;

	}

	this.manager = ( manager !== undefined ) ? manager : fm.DefaultLoadingManager;

	this.withCredentials = false;

};

fm.JSONLoader.prototype = {

	constructor: fm.JSONLoader,

	// Deprecated

	get statusDomElement () {

		if ( this._statusDomElement === undefined ) {

			this._statusDomElement = document.createElement( 'div' );

		}

		console.warn( 'fm.JSONLoader: .statusDomElement has been removed.' );
		return this._statusDomElement;

	},

	load: function( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : fm.Loader.prototype.extractUrlBase( url );

		var loader = new fm.XHRLoader( this.manager );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			var json = JSON.parse( text );
            if(json instanceof  Array){//load lod
                var name = "lod";
                {
                    var metadata =  json[0].metadata;
                    var nameAry = metadata.name.split("_");
                    if(3 != nameAry.length || 'lod' != nameAry[1]){onError(); return;}
                    name = nameAry[0];
                }
                var lod = new fm.LOD();
                lod.name = name;
                for(var i=0, l=json.length; i<l; ++i){
                    var metadata =  json[i].metadata;
                    var nameAry = metadata.name.split("_");
                    var object = scope.parse( json[i], texturePath );
                    var mat = object.materials;
                    if(object.materials instanceof  Array){
                        mat = new fm.MultiMaterial(object.materials);
                    }
                    var mesh  = new fm.Mesh(object.geometry, mat);
                    lod.addLevel( mesh, parseFloat(nameAry[2]) );
                }
                onLoad(lod);
                return;
            }
			var metadata = json.metadata;

			if ( metadata !== undefined ) {

				var type = metadata.type;

				if ( type !== undefined ) {

					if ( type.toLowerCase() === 'object' ) {

						console.error( 'fm.JSONLoader: ' + url + ' should be loaded with fm.ObjectLoader instead.' );
						return;

					}

					if ( type.toLowerCase() === 'scene' ) {

						console.error( 'fm.JSONLoader: ' + url + ' should be loaded with fm.SceneLoader instead.' );
						return;

					}

				}

			}

			var object = scope.parse( json, texturePath );
			onLoad( object.geometry, object.materials );

		}, onProgress, onError );

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	parse: function ( json, texturePath ) {

		var geometry = new fm.Geometry(),
		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

		parseModel( scale );

		parseSkin();
		parseMorphing( scale );
		parseAnimations();

		geometry.computeFaceNormals();
		geometry.computeBoundingSphere();

		function parseModel( scale ) {

			function isBitSet( value, position ) {

				return value & ( 1 << position );

			}

			var i, j, fi,

			offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

			type,
			isQuad,
			hasMaterial,
			hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, hex, normal,

			uvLayer, uv, u, v,

			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,

			nUvLayers = 0;

			if ( json.uvs !== undefined ) {

				// disregard empty arrays

				for ( i = 0; i < json.uvs.length; i ++ ) {

					if ( json.uvs[ i ].length ) nUvLayers ++;

				}

				for ( i = 0; i < nUvLayers; i ++ ) {

					geometry.faceVertexUvs[ i ] = [];

				}

			}

			offset = 0;
			zLength = vertices.length;

			while ( offset < zLength ) {

				vertex = new fm.Vector3();

				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;

				geometry.vertices.push( vertex );

			}

			offset = 0;
			zLength = faces.length;

			while ( offset < zLength ) {

				type = faces[ offset ++ ];


				isQuad              = isBitSet( type, 0 );
				hasMaterial         = isBitSet( type, 1 );
				hasFaceVertexUv     = isBitSet( type, 3 );
				hasFaceNormal       = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor	     = isBitSet( type, 6 );
				hasFaceVertexColor  = isBitSet( type, 7 );

				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

				if ( isQuad ) {

					faceA = new fm.Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];

					faceB = new fm.Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];

					offset += 4;

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

							for ( j = 0; j < 4; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new fm.Vector2( u, v );

								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						faceB.normal.copy( faceA.normal );

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 4; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new fm.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);


							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						faceA.color.setHex( hex );
						faceB.color.setHex( hex );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 4; i ++ ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							if ( i !== 2 ) faceA.vertexColors.push( new fm.Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new fm.Color( hex ) );

						}

					}

					geometry.faces.push( faceA );
					geometry.faces.push( faceB );

				} else {

					face = new fm.Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];

							for ( j = 0; j < 3; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new fm.Vector2( u, v );

								geometry.faceVertexUvs[ i ][ fi ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 3; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new fm.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							face.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 3; i ++ ) {

							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new fm.Color( colors[ colorIndex ] ) );

						}

					}

					geometry.faces.push( face );

				}

			}

		};

		function parseSkin() {

			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

			if ( json.skinWeights ) {

				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

					var x =                               json.skinWeights[ i ];
					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

					geometry.skinWeights.push( new fm.Vector4( x, y, z, w ) );

				}

			}

			if ( json.skinIndices ) {

				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

					var a =                               json.skinIndices[ i ];
					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

					geometry.skinIndices.push( new fm.Vector4( a, b, c, d ) );

				}

			}

			geometry.bones = json.bones;

			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

			}

		};

		function parseMorphing( scale ) {

			if ( json.morphTargets !== undefined ) {

				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];

					var dstVertices = geometry.morphTargets[ i ].vertices;
					var srcVertices = json.morphTargets[ i ].vertices;

					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

						var vertex = new fm.Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;

						dstVertices.push( vertex );

					}

				}

			}

			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

				console.warn( 'fm.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

				var faces = geometry.faces;
				var morphColors = json.morphColors[ 0 ].colors;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					faces[ i ].color.fromArray( morphColors, i * 3 );

				}

			}

		}

		function parseAnimations() {

			var outputAnimations = [];

			// parse old style Bone/Hierarchy animations
			var animations = [];

			if ( json.animation !== undefined ) {

				animations.push( json.animation );

			}

			if ( json.animations !== undefined ) {

				if ( json.animations.length ) {

					animations = animations.concat( json.animations );

				} else {

					animations.push( json.animations );

				}

			}

			for ( var i = 0; i < animations.length; i ++ ) {

				var clip = fm.AnimationClip.parseAnimation( animations[ i ], geometry.bones );
				if ( clip ) outputAnimations.push( clip );

			}

			// parse implicit morph animations
			if ( geometry.morphTargets ) {

				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
				var morphAnimationClips = fm.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
				outputAnimations = outputAnimations.concat( morphAnimationClips );

			}

			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

		};

		if ( json.materials === undefined || json.materials.length === 0 ) {

			return { geometry: geometry };

		} else {

			var materials = fm.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

			return { geometry: geometry, materials: materials };

		}

	}

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.LoadingManager = function ( onLoad, onProgress, onError ) {

	var scope = this;

	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

};

fm.DefaultLoadingManager = new fm.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.BufferGeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : fm.DefaultLoadingManager;

};

fm.BufferGeometryLoader.prototype = {

	constructor: fm.BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new fm.XHRLoader( scope.manager );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		var geometry = new fm.BufferGeometry();

		var index = json.data.index;

		var TYPED_ARRAYS = {
			'Int8Array': Int8Array,
			'Uint8Array': Uint8Array,
			'Uint8ClampedArray': Uint8ClampedArray,
			'Int16Array': Int16Array,
			'Uint16Array': Uint16Array,
			'Int32Array': Int32Array,
			'Uint32Array': Uint32Array,
			'Float32Array': Float32Array,
			'Float64Array': Float64Array
		};

		if ( index !== undefined ) {

			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
			geometry.setIndex( new fm.BufferAttribute( typedArray, 1 ) );

		}

		var attributes = json.data.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

			geometry.addAttribute( key, new fm.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

		}

		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

				var group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		var boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new fm.Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new fm.Sphere( center, boundingSphere.radius );

		}

		return geometry;

	}

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.MaterialLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : fm.DefaultLoadingManager;
	this.textures = {};

};

fm.MaterialLoader.prototype = {

	constructor: fm.MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new fm.XHRLoader( scope.manager );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setTextures: function ( value ) {

		this.textures = value;

	},

	getTexture: function ( name ) {

		var textures = this.textures;

		if ( textures[ name ] === undefined ) {

			console.warn( 'fm.MaterialLoader: Undefined texture', name );

		}

		return textures[ name ];

	},

	parse: function ( json ) {

		var material = new fm[ json.type ];

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.shading !== undefined ) material.shading = json.shading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

		// for PointsMaterial
		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = this.getTexture( json.map );

		if ( json.alphaMap !== undefined ) {

			material.alphaMap = this.getTexture( json.alphaMap );
			material.transparent = true;

		}

		if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
		if ( json.normalScale !== undefined ) {

			var normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new fm.Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

		if ( json.envMap !== undefined ) {

			material.envMap = this.getTexture( json.envMap );
			material.combine = fm.MultiplyOperation;

		}

		if ( json.reflectivity ) material.reflectivity = json.reflectivity;

		if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		// MultiMaterial

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.ObjectLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : fm.DefaultLoadingManager;
	this.texturePath = '';

};

fm.ObjectLoader.prototype = {

	constructor: fm.ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.texturePath === '' ) {

			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

		}

		var scope = this;

		var loader = new fm.XHRLoader( scope.manager );
		loader.load( url, function ( text ) {

			scope.parse( JSON.parse( text ), onLoad );

		}, onProgress, onError );

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json, onLoad ) {

		var geometries = this.parseGeometries( json.geometries );

		var images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		var textures  = this.parseTextures( json.textures, images );
		var materials = this.parseMaterials( json.materials, textures );

		var object = this.parseObject( json.object, geometries, materials );

		if ( json.animations ) {

			object.animations = this.parseAnimations( json.animations );

		}

		if ( json.images === undefined || json.images.length === 0 ) {

			if ( onLoad !== undefined ) onLoad( object );

		}

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new fm.JSONLoader();
			var bufferGeometryLoader = new fm.BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new fm[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'BoxBufferGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new fm[ data.type ](
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':
					case 'CircleBufferGeometry':

						geometry = new fm[ data.type ](
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':
					case 'CylinderBufferGeometry':

						geometry = new fm[ data.type ](
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':
					case 'SphereBufferGeometry':

						geometry = new fm[ data.type ](
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':

						geometry = new fm.DodecahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'IcosahedronGeometry':

						geometry = new fm.IcosahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'OctahedronGeometry':

						geometry = new fm.OctahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'TetrahedronGeometry':

						geometry = new fm.TetrahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':
					case 'RingBufferGeometry':

						geometry = new fm[ data.type ](
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':
					case 'TorusBufferGeometry':

						geometry = new fm[ data.type ](
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':
					case 'TorusKnotBufferGeometry':

						geometry = new fm[ data.type ](
							data.radius,
							data.tube,
							data.tubularSegments,
							data.radialSegments,
							data.p,
							data.q
						);

						break;

					case 'LatheGeometry':
					case 'LatheBufferGeometry':

						geometry = new fm[ data.type ](
							data.points,
							data.segments,
							data.phiStart,
							data.phiLength
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

						break;

					default:

						console.warn( 'fm.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json, textures ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new fm.MaterialLoader();
			loader.setTextures( textures );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var material = loader.parse( json[ i ] );
				materials[ material.uuid ] = material;

			}

		}

		return materials;

	},

	parseAnimations: function ( json ) {

		var animations = [];

		for ( var i = 0; i < json.length; i ++ ) {

			var clip = fm.AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	},

	parseImages: function ( json, onLoad ) {

		var scope = this;
		var images = {};

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			} );

		}

		if ( json !== undefined && json.length > 0 ) {

			var manager = new fm.LoadingManager( onLoad );

			var loader = new fm.ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var image = json[ i ];
				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

				images[ image.uuid ] = loadImage( path );

			}

		}

		return images;

	},

	parseTextures: function ( json, images ) {

		function parseConstant( value ) {

			if ( typeof( value ) === 'number' ) return value;

			console.warn( 'fm.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return fm[ value ];

		}

		var textures = {};

		if ( json !== undefined ) {

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'fm.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'fm.ObjectLoader: Undefined image', data.image );

				}

				var texture = new fm.Texture( images[ data.image ] );
				texture.needsUpdate = true;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;
				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
				if ( data.offset !== undefined ) texture.offset = new fm.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
				if ( data.repeat !== undefined ) texture.repeat = new fm.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
				if ( Array.isArray( data.wrap ) ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ] );
					texture.wrapT = parseConstant( data.wrap[ 1 ] );

				}

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	},

	parseObject: function () {

		var matrix = new fm.Matrix4();

		return function ( data, geometries, materials ) {

			var object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'fm.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( materials[ name ] === undefined ) {

					console.warn( 'fm.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			switch ( data.type ) {

				case 'Scene':

					object = new fm.Scene();

					break;

				case 'PerspectiveCamera':

					object = new fm.PerspectiveCamera(
							data.fov, data.aspect, data.near, data.far );

					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'OrthographicCamera':

					object = new fm.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new fm.AmbientLight( data.color, data.intensity );

					break;

				case 'DirectionalLight':

					object = new fm.DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new fm.PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'SpotLight':

					object = new fm.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

					break;

				case 'HemisphereLight':

					object = new fm.HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					var geometry = getGeometry( data.geometry );
					var material = getMaterial( data.material );

					if ( geometry.bones && geometry.bones.length > 0 ) {

						object = new fm.SkinnedMesh( geometry, material );

					} else {

						object = new fm.Mesh( geometry, material );

					}

					break;

				case 'LOD':

					object = new fm.LOD();

					break;

				case 'Line':

					object = new fm.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

					break;

				case 'PointCloud':
				case 'Points':

					object = new fm.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new fm.Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new fm.Group();

					break;

				default:

					object = new fm.Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			if ( data.type === 'LOD' ) {

				var levels = data.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		};

	}()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.TextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : fm.DefaultLoadingManager;

};

fm.TextureLoader.prototype = {

	constructor: fm.TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var texture = new fm.Texture();

		var loader = new fm.ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );
		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setPath: function ( value ) {

		this.path = value;

	}

};

// File:src/loaders/CubeTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.CubeTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : fm.DefaultLoadingManager;

};

fm.CubeTextureLoader.prototype = {

	constructor: fm.CubeTextureLoader,

	load: function ( urls, onLoad, onProgress, onError ) {

		var texture = new fm.CubeTexture();

		var loader = new fm.ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		var loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( var i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setPath: function ( value ) {

		this.path = value;

	}

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

fm.DataTextureLoader = fm.BinaryTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : fm.DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

};

fm.BinaryTextureLoader.prototype = {

	constructor: fm.BinaryTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texture = new fm.DataTexture();

		var loader = new fm.XHRLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );

		loader.load( url, function ( buffer ) {

			var texData = scope._parser( buffer );

			if ( ! texData ) return;

			if ( undefined !== texData.image ) {

				texture.image = texData.image;

			} else if ( undefined !== texData.data ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : fm.ClampToEdgeWrapping;
			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : fm.ClampToEdgeWrapping;

			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : fm.LinearFilter;
			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : fm.LinearMipMapLinearFilter;

			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

			if ( undefined !== texData.format ) {

				texture.format = texData.format;

			}
			if ( undefined !== texData.type ) {

				texture.type = texData.type;

			}

			if ( undefined !== texData.mipmaps ) {

				texture.mipmaps = texData.mipmaps;

			}

			if ( 1 === texData.mipmapCount ) {

				texture.minFilter = fm.LinearFilter;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

fm.CompressedTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : fm.DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

};


fm.CompressedTextureLoader.prototype = {

	constructor: fm.CompressedTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var images = [];

		var texture = new fm.CompressedTexture();
		texture.image = images;

		var loader = new fm.XHRLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 )
						texture.minFilter = fm.LinearFilter;

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			var loaded = 0;

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = fm.LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	},

	setPath: function ( value ) {

		this.path = value;

	}

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

fm.Material = function () {

	Object.defineProperty( this, 'id', { value: fm.MaterialIdCount ++ } );

	this.uuid = fm.Math.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.side = fm.FrontSide;

	this.opacity = 1;
	this.transparent = false;

	this.blending = fm.NormalBlending;

	this.blendSrc = fm.SrcAlphaFactor;
	this.blendDst = fm.OneMinusSrcAlphaFactor;
	this.blendEquation = fm.AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = fm.LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.clippingPlanes = null;
	this.clipShadows = false;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;
	this.premultipliedAlpha = false;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this._needsUpdate = true;

};

fm.Material.prototype = {

	constructor: fm.Material,

	get needsUpdate () {

		return this._needsUpdate;

	},

	set needsUpdate ( value ) {

		if ( value === true ) this.update();

		this._needsUpdate = value;

	},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "fm.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			var currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( "fm." + this.type + ": '" + key + "' is not a property of this material." );
				continue;

			}

			if ( currentValue instanceof fm.Color ) {

				currentValue.set( newValue );

			} else if ( currentValue instanceof fm.Vector3 && newValue instanceof fm.Vector3 ) {

				currentValue.copy( newValue );

			} else if ( key === 'overdraw' ) {

				// ensure overdraw is backwards-compatible with legacy boolean type
				this[ key ] = Number( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		var isRoot = meta === undefined;

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		var data = {
			metadata: {
				version: 4.4,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.color instanceof fm.Color ) data.color = this.color.getHex();

		if ( this.roughness !== 0.5 ) data.roughness = this.roughness;
		if ( this.metalness !== 0.5 ) data.metalness = this.metalness;

		if ( this.emissive instanceof fm.Color ) data.emissive = this.emissive.getHex();
		if ( this.specular instanceof fm.Color ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;

		if ( this.map instanceof fm.Texture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.alphaMap instanceof fm.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
		if ( this.lightMap instanceof fm.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
		if ( this.bumpMap instanceof fm.Texture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}
		if ( this.normalMap instanceof fm.Texture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalScale = this.normalScale.toArray();

		}
		if ( this.displacementMap instanceof fm.Texture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}
		if ( this.roughnessMap instanceof fm.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap instanceof fm.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap instanceof fm.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap instanceof fm.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

		if ( this.envMap instanceof fm.Texture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.vertexColors !== undefined && this.vertexColors !== fm.NoColors ) data.vertexColors = this.vertexColors;
		if ( this.shading !== undefined && this.shading !== fm.SmoothShading ) data.shading = this.shading;
		if ( this.blending !== undefined && this.blending !== fm.NormalBlending ) data.blending = this.blending;
		if ( this.side !== undefined && this.side !== fm.FrontSide ) data.side = this.side;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;
		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache ( cache ) {

			var values = [];

			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.side = source.side;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blending = source.blending;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.alphaTest = source.alphaTest;

		this.premultipliedAlpha = source.premultipliedAlpha;

		this.overdraw = source.overdraw;

		this.visible = source.visible;
		this.clipShadows = source.clipShadows;

		var srcPlanes = source.clippingPlanes,
			dstPlanes = null;

		if ( srcPlanes !== null ) {

			var n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( var i = 0; i !== n; ++ i )
				dstPlanes[ i ] = srcPlanes[ i ].clone();

		}

		this.clippingPlanes = dstPlanes;

		return this;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

fm.EventDispatcher.prototype.apply( fm.Material.prototype );

fm.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  blending: fm.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

fm.LineBasicMaterial = function ( parameters ) {

	fm.Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new fm.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.blending = fm.NormalBlending;

	this.vertexColors = fm.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

fm.LineBasicMaterial.prototype = Object.create( fm.Material.prototype );
fm.LineBasicMaterial.prototype.constructor = fm.LineBasicMaterial;

fm.LineBasicMaterial.prototype.copy = function ( source ) {

	fm.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;

	this.vertexColors = source.vertexColors;

	this.fog = source.fog;

	return this;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  blending: fm.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: fm.NoColors / fm.FaceColors / fm.VertexColors
 *
 *  fog: <bool>
 * }
 */

fm.LineDashedMaterial = function ( parameters ) {

	fm.Material.call( this );

	this.type = 'LineDashedMaterial';

	this.color = new fm.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.blending = fm.NormalBlending;

	this.vertexColors = fm.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

fm.LineDashedMaterial.prototype = Object.create( fm.Material.prototype );
fm.LineDashedMaterial.prototype.constructor = fm.LineDashedMaterial;

fm.LineDashedMaterial.prototype.copy = function ( source ) {

	fm.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;

	this.scale = source.scale;
	this.dashSize = source.dashSize;
	this.gapSize = source.gapSize;

	this.vertexColors = source.vertexColors;

	this.fog = source.fog;

	return this;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new fm.Texture( <Image> ),
 *
 *  aoMap: new fm.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new fm.Texture( <Image> ),
 *
 *  alphaMap: new fm.Texture( <Image> ),
 *
 *  envMap: new fm.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: fm.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: fm.SmoothShading,
 *  blending: fm.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: fm.NoColors / fm.VertexColors / fm.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

fm.MeshBasicMaterial = function ( parameters ) {

	fm.Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new fm.Color( 0xffffff ); // emissive

	this.map = null;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = fm.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = fm.SmoothShading;
	this.blending = fm.NormalBlending;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = fm.NoColors;

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

fm.MeshBasicMaterial.prototype = Object.create( fm.Material.prototype );
fm.MeshBasicMaterial.prototype.constructor = fm.MeshBasicMaterial;

fm.MeshBasicMaterial.prototype.copy = function ( source ) {

	fm.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.fog = source.fog;

	this.shading = source.shading;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	return this;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new fm.Texture( <Image> ),
 *
 *  alphaMap: new fm.Texture( <Image> ),
 *
 *  displacementMap: new fm.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

fm.MeshDepthMaterial = function ( parameters ) {

	fm.Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.depthPacking = fm.BasicDepthPacking;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

fm.MeshDepthMaterial.prototype = Object.create( fm.Material.prototype );
fm.MeshDepthMaterial.prototype.constructor = fm.MeshDepthMaterial;

fm.MeshDepthMaterial.prototype.copy = function ( source ) {

	fm.Material.prototype.copy.call( this, source );

	this.depthPacking = source.depthPacking;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new fm.Texture( <Image> ),
 *
 *  lightMap: new fm.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new fm.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new fm.Texture( <Image> ),
 *
 *  specularMap: new fm.Texture( <Image> ),
 *
 *  alphaMap: new fm.Texture( <Image> ),
 *
 *  envMap: new fm.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: fm.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  blending: fm.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: fm.NoColors / fm.VertexColors / fm.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

fm.MeshLambertMaterial = function ( parameters ) {

	fm.Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new fm.Color( 0xffffff ); // diffuse

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new fm.Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = fm.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.blending = fm.NormalBlending;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = fm.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

fm.MeshLambertMaterial.prototype = Object.create( fm.Material.prototype );
fm.MeshLambertMaterial.prototype.constructor = fm.MeshLambertMaterial;

fm.MeshLambertMaterial.prototype.copy = function ( source ) {

	fm.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.fog = source.fog;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

fm.MeshNormalMaterial = function ( parameters ) {

	fm.Material.call( this, parameters );

	this.type = 'MeshNormalMaterial';

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.morphTargets = false;

	this.setValues( parameters );

};

fm.MeshNormalMaterial.prototype = Object.create( fm.Material.prototype );
fm.MeshNormalMaterial.prototype.constructor = fm.MeshNormalMaterial;

fm.MeshNormalMaterial.prototype.copy = function ( source ) {

	fm.Material.prototype.copy.call( this, source );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new fm.Texture( <Image> ),
 *
 *  lightMap: new fm.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new fm.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new fm.Texture( <Image> ),
 *
 *  bumpMap: new fm.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new fm.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new fm.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new fm.Texture( <Image> ),
 *
 *  alphaMap: new fm.Texture( <Image> ),
 *
 *  envMap: new fm.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: fm.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: fm.SmoothShading,
 *  blending: fm.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: fm.NoColors / fm.VertexColors / fm.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

fm.MeshPhongMaterial = function ( parameters ) {

	fm.Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new fm.Color( 0xffffff ); // diffuse
	this.specular = new fm.Color( 0x111111 );
	this.shininess = 30;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new fm.Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new fm.Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = fm.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = fm.SmoothShading;
	this.blending = fm.NormalBlending;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = fm.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

fm.MeshPhongMaterial.prototype = Object.create( fm.Material.prototype );
fm.MeshPhongMaterial.prototype.constructor = fm.MeshPhongMaterial;

fm.MeshPhongMaterial.prototype.copy = function ( source ) {

	fm.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.fog = source.fog;

	this.shading = source.shading;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

// File:src/materials/MeshStandardMaterial.js

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new fm.Texture( <Image> ),
 *
 *  lightMap: new fm.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new fm.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new fm.Texture( <Image> ),
 *
 *  bumpMap: new fm.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new fm.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new fm.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new fm.Texture( <Image> ),
 *
 *  metalnessMap: new fm.Texture( <Image> ),
 *
 *  alphaMap: new fm.Texture( <Image> ),
 *
 *  envMap: new fm.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  shading: fm.SmoothShading,
 *  blending: fm.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: fm.NoColors / fm.VertexColors / fm.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

fm.MeshStandardMaterial = function ( parameters ) {

	fm.Material.call( this );

	this.defines = { 'STANDARD': '' };

	this.type = 'MeshStandardMaterial';

	this.color = new fm.Color( 0xffffff ); // diffuse
	this.roughness = 0.5;
	this.metalness = 0.5;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new fm.Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new fm.Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.roughnessMap = null;

	this.metalnessMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.envMapIntensity = 1.0;

	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = fm.SmoothShading;
	this.blending = fm.NormalBlending;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = fm.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

fm.MeshStandardMaterial.prototype = Object.create( fm.Material.prototype );
fm.MeshStandardMaterial.prototype.constructor = fm.MeshStandardMaterial;

fm.MeshStandardMaterial.prototype.copy = function ( source ) {

	fm.Material.prototype.copy.call( this, source );

	this.defines = { 'STANDARD': '' };

	this.color.copy( source.color );
	this.roughness = source.roughness;
	this.metalness = source.metalness;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.roughnessMap = source.roughnessMap;

	this.metalnessMap = source.metalnessMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.envMapIntensity = source.envMapIntensity;

	this.refractionRatio = source.refractionRatio;

	this.fog = source.fog;

	this.shading = source.shading;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

// File:src/materials/MeshPhysicalMaterial.js

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  reflectivity: <float>
 * }
 */

fm.MeshPhysicalMaterial = function ( parameters ) {

	fm.MeshStandardMaterial.call( this );

	this.defines = { 'PHYSICAL': '' };

	this.type = 'MeshPhysicalMaterial';

	this.reflectivity = 0.5; // maps to F0 = 0.04

	this.setValues( parameters );

};

fm.MeshPhysicalMaterial.prototype = Object.create( fm.MeshStandardMaterial.prototype );
fm.MeshPhysicalMaterial.prototype.constructor = fm.MeshPhysicalMaterial;

fm.MeshPhysicalMaterial.prototype.copy = function ( source ) {

	fm.MeshStandardMaterial.prototype.copy.call( this, source );

	this.defines = { 'PHYSICAL': '' };

	this.reflectivity = source.reflectivity;

	return this;

};

// File:src/materials/MultiMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.MultiMaterial = function ( materials ) {

	this.uuid = fm.Math.generateUUID();

	this.type = 'MultiMaterial';

	this.materials = materials instanceof Array ? materials : [];

	this.visible = true;

};

fm.MultiMaterial.prototype = {

	constructor: fm.MultiMaterial,

	toJSON: function ( meta ) {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type,
			materials: []
		};

		var materials = this.materials;

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			var material = materials[ i ].toJSON( meta );
			delete material.metadata;

			output.materials.push( material );

		}

		output.visible = this.visible;

		return output;

	},

	clone: function () {

		var material = new this.constructor();

		for ( var i = 0; i < this.materials.length; i ++ ) {

			material.materials.push( this.materials[ i ].clone() );

		}

		material.visible = this.visible;

		return material;

	}

};

// File:src/materials/PointsMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new fm.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: fm.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

fm.PointsMaterial = function ( parameters ) {

	fm.Material.call( this );

	this.type = 'PointsMaterial';

	this.color = new fm.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.blending = fm.NormalBlending;

	this.vertexColors = fm.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

fm.PointsMaterial.prototype = Object.create( fm.Material.prototype );
fm.PointsMaterial.prototype.constructor = fm.PointsMaterial;

fm.PointsMaterial.prototype.copy = function ( source ) {

	fm.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;

	this.vertexColors = source.vertexColors;

	this.fog = source.fog;

	return this;

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "1f", value: 1.0 }, "parameter2": { type: "1i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: fm.SmoothShading,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: fm.NoColors / fm.VertexColors / fm.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

fm.ShaderMaterial = function ( parameters ) {

	fm.Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

	this.shading = fm.SmoothShading;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog

	this.lights = false; // set to use scene lights
	this.clipping = false; // set to use user-defined clipping planes

	this.vertexColors = fm.NoColors; // set to use "color" attribute stream

	this.skinning = false; // set to use skinning attribute streams

	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.extensions = {
		derivatives: false, // set to use derivatives
		fragDepth: false, // set to use fragment depth values
		drawBuffers: false, // set to use draw buffers
		shaderTextureLOD: false // set to use shader texture LOD
	};

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'fm.ShaderMaterial: attributes should now be defined in fm.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

};

fm.ShaderMaterial.prototype = Object.create( fm.Material.prototype );
fm.ShaderMaterial.prototype.constructor = fm.ShaderMaterial;

fm.ShaderMaterial.prototype.copy = function ( source ) {

	fm.Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = fm.UniformsUtils.clone( source.uniforms );

	this.defines = source.defines;

	this.shading = source.shading;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.fog = source.fog;

	this.lights = source.lights;
	this.clipping = source.clipping;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.extensions = source.extensions;

	return this;

};

fm.ShaderMaterial.prototype.toJSON = function ( meta ) {

	var data = fm.Material.prototype.toJSON.call( this, meta );

	data.uniforms = this.uniforms;
	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.RawShaderMaterial = function ( parameters ) {

	fm.ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

};

fm.RawShaderMaterial.prototype = Object.create( fm.ShaderMaterial.prototype );
fm.RawShaderMaterial.prototype.constructor = fm.RawShaderMaterial;

// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new fm.Texture( <Image> ),
 *
 *	uvOffset: new fm.Vector2(),
 *	uvScale: new fm.Vector2(),
 *
 *  fog: <bool>
 * }
 */

fm.SpriteMaterial = function ( parameters ) {

	fm.Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new fm.Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;

	// set parameters

	this.setValues( parameters );

};

fm.SpriteMaterial.prototype = Object.create( fm.Material.prototype );
fm.SpriteMaterial.prototype.constructor = fm.SpriteMaterial;

fm.SpriteMaterial.prototype.copy = function ( source ) {

	fm.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.map = source.map;

	this.rotation = source.rotation;

	this.fog = source.fog;

	return this;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

fm.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	Object.defineProperty( this, 'id', { value: fm.TextureIdCount ++ } );

	this.uuid = fm.Math.generateUUID();

	this.name = '';
	this.sourceFile = '';

	this.image = image !== undefined ? image : fm.Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : fm.Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : fm.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : fm.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : fm.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : fm.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : fm.RGBAFormat;
	this.type = type !== undefined ? type : fm.UnsignedByteType;

	this.offset = new fm.Vector2( 0, 0 );
	this.repeat = new fm.Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)


	// Values of encoding !== fm.LinearEncoding only supported on map, envMap and emissiveMap.
	//
	// Also changing the encoding after already used by a Material will not automatically make the Material
	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
	this.encoding = encoding !== undefined ? encoding :  fm.LinearEncoding;

	this.version = 0;
	this.onUpdate = null;

};

fm.Texture.DEFAULT_IMAGE = undefined;
fm.Texture.DEFAULT_MAPPING = fm.UVMapping;

fm.Texture.prototype = {

	constructor: fm.Texture,

	set needsUpdate ( value ) {

		if ( value === true ) this.version ++;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		return this;

	},

	toJSON: function ( meta ) {

		if ( meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		function getDataURL( image ) {

			var canvas;

			if ( image.toDataURL !== undefined ) {

				canvas = image;

			} else {

				canvas = document.createElement( 'canvas' );
				canvas.width = image.width;
				canvas.height = image.height;

				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

		var output = {
			metadata: {
				version: 4.4,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			wrap: [ this.wrapS, this.wrapT ],

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy
		};

		if ( this.image !== undefined ) {

			// TODO: Move to fm.Image

			var image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = fm.Math.generateUUID(); // UGH

			}

			if ( meta.images[ image.uuid ] === undefined ) {

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: getDataURL( image )
				};

			}

			output.image = image.uuid;

		}

		meta.textures[ this.uuid ] = output;

		return output;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	transformUv: function ( uv ) {

		if ( this.mapping !== fm.UVMapping )  return;

		uv.multiply( this.repeat );
		uv.add( this.offset );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case fm.RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case fm.ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case fm.MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}
					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case fm.RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case fm.ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case fm.MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}
					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

	}

};

fm.EventDispatcher.prototype.apply( fm.Texture.prototype );

fm.TextureIdCount = 0;

// File:src/textures/DepthTexture.js

/**
 * @author Matt DesLauriers / @mattdesl
 */

fm.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

  fm.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, fm.DepthFormat, type, anisotropy );

  this.image = { width: width, height: height };

  this.type = type !== undefined ? type : fm.UnsignedShortType;

  this.magFilter = magFilter !== undefined ? magFilter : fm.NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : fm.NearestFilter;

  this.flipY = false;
  this.generateMipmaps  = false;

};

fm.DepthTexture.prototype = Object.create( fm.Texture.prototype );
fm.DepthTexture.prototype.constructor = fm.DepthTexture;

// File:src/textures/CanvasTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	fm.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.needsUpdate = true;

};

fm.CanvasTexture.prototype = Object.create( fm.Texture.prototype );
fm.CanvasTexture.prototype.constructor = fm.CanvasTexture;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	images = images !== undefined ? images : [];
	mapping = mapping !== undefined ? mapping : fm.CubeReflectionMapping;

	fm.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.flipY = false;

};

fm.CubeTexture.prototype = Object.create( fm.Texture.prototype );
fm.CubeTexture.prototype.constructor = fm.CubeTexture;

Object.defineProperty( fm.CubeTexture.prototype, 'images', {

	get: function () {

		return this.image;

	},

	set: function ( value ) {

		this.image = value;

	}

} );

// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	fm.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

};

fm.CompressedTexture.prototype = Object.create( fm.Texture.prototype );
fm.CompressedTexture.prototype.constructor = fm.CompressedTexture;

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	fm.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { data: data, width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : fm.NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : fm.NearestFilter;

	this.flipY = false;
	this.generateMipmaps  = false;

};

fm.DataTexture.prototype = Object.create( fm.Texture.prototype );
fm.DataTexture.prototype.constructor = fm.DataTexture;

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	fm.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.generateMipmaps = false;

	var scope = this;

	function update() {

		requestAnimationFrame( update );

		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

			scope.needsUpdate = true;

		}

	}

	update();

};

fm.VideoTexture.prototype = Object.create( fm.Texture.prototype );
fm.VideoTexture.prototype.constructor = fm.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.Group = function () {

	fm.Object3D.call( this );

	this.type = 'Group';

};

fm.Group.prototype = Object.create( fm.Object3D.prototype );
fm.Group.prototype.constructor = fm.Group;

// File:src/objects/Points.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.Points = function ( geometry, material ) {

	fm.Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry !== undefined ? geometry : new fm.Geometry();
	this.material = material !== undefined ? material : new fm.PointsMaterial( { color: Math.random() * 0xffffff } );

};

fm.Points.prototype = Object.create( fm.Object3D.prototype );
fm.Points.prototype.constructor = fm.Points;

fm.Points.prototype.raycast = ( function () {

	var inverseMatrix = new fm.Matrix4();
	var ray = new fm.Ray();
	var sphere = new fm.Sphere();

	return function raycast( raycaster, intersects ) {

		var object = this;
		var geometry = this.geometry;
		var matrixWorld = this.matrixWorld;
		var threshold = raycaster.params.Points.threshold;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

		//

		inverseMatrix.getInverse( matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		var localThresholdSq = localThreshold * localThreshold;
		var position = new fm.Vector3();

		function testPoint( point, index ) {

			var rayPointDistanceSq = ray.distanceSqToPoint( point );

			if ( rayPointDistanceSq < localThresholdSq ) {

				var intersectPoint = ray.closestPointToPoint( point );
				intersectPoint.applyMatrix4( matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				if ( distance < raycaster.near || distance > raycaster.far ) return;

				intersects.push( {

					distance: distance,
					distanceToRay: Math.sqrt( rayPointDistanceSq ),
					point: intersectPoint.clone(),
					index: index,
					face: null,
					object: object

				} );

			}

		}

		if ( geometry instanceof fm.BufferGeometry ) {

			var index = geometry.index;
			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( index !== null ) {

				var indices = index.array;

				for ( var i = 0, il = indices.length; i < il; i ++ ) {

					var a = indices[ i ];

					position.fromArray( positions, a * 3 );

					testPoint( position, a );

				}

			} else {

				for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

					position.fromArray( positions, i * 3 );

					testPoint( position, i );

				}

			}

		} else {

			var vertices = geometry.vertices;

			for ( var i = 0, l = vertices.length; i < l; i ++ ) {

				testPoint( vertices[ i ], i );

			}

		}

	};

}() );

fm.Points.prototype.clone = function () {

	return new this.constructor( this.geometry, this.material ).copy( this );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.Line = function ( geometry, material, mode ) {

	if ( mode === 1 ) {

		console.warn( 'fm.Line: parameter fm.LinePieces no longer supported. Created fm.LineSegments instead.' );
		return new fm.LineSegments( geometry, material );

	}

	fm.Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new fm.Geometry();
	this.material = material !== undefined ? material : new fm.LineBasicMaterial( { color: Math.random() * 0xffffff } );

};

fm.Line.prototype = Object.create( fm.Object3D.prototype );
fm.Line.prototype.constructor = fm.Line;

fm.Line.prototype.raycast = ( function () {

	var inverseMatrix = new fm.Matrix4();
	var ray = new fm.Ray();
	var sphere = new fm.Sphere();

	return function raycast( raycaster, intersects ) {

		var precision = raycaster.linePrecision;
		var precisionSq = precision * precision;

		var geometry = this.geometry;
		var matrixWorld = this.matrixWorld;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

		//

		inverseMatrix.getInverse( matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		var vStart = new fm.Vector3();
		var vEnd = new fm.Vector3();
		var interSegment = new fm.Vector3();
		var interRay = new fm.Vector3();
		var step = this instanceof fm.LineSegments ? 2 : 1;

		if ( geometry instanceof fm.BufferGeometry ) {

			var index = geometry.index;
			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( index !== null ) {

				var indices = index.array;

				for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

					var a = indices[ i ];
					var b = indices[ i + 1 ];

					vStart.fromArray( positions, a * 3 );
					vEnd.fromArray( positions, b * 3 );

					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

					vStart.fromArray( positions, 3 * i );
					vEnd.fromArray( positions, 3 * i + 3 );

					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry instanceof fm.Geometry ) {

			var vertices = geometry.vertices;
			var nbVertices = vertices.length;

			for ( var i = 0; i < nbVertices - 1; i += step ) {

				var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

				if ( distSq > precisionSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				var distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	};

}() );

fm.Line.prototype.clone = function () {

	return new this.constructor( this.geometry, this.material ).copy( this );

};

// DEPRECATED

fm.LineStrip = 0;
fm.LinePieces = 1;

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.LineSegments = function ( geometry, material ) {

	fm.Line.call( this, geometry, material );

	this.type = 'LineSegments';

};

fm.LineSegments.prototype = Object.create( fm.Line.prototype );
fm.LineSegments.prototype.constructor = fm.LineSegments;

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

fm.Mesh = function ( geometry, material ) {

	fm.Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry !== undefined ? geometry : new fm.Geometry();
	this.material = material !== undefined ? material : new fm.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.drawMode = fm.TrianglesDrawMode;

	this.updateMorphTargets();

};

fm.Mesh.prototype = Object.create( fm.Object3D.prototype );
fm.Mesh.prototype.constructor = fm.Mesh;

fm.Mesh.prototype.setDrawMode = function ( value ) {

	this.drawMode = value;

};

fm.Mesh.prototype.updateMorphTargets = function () {

	if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

		this.morphTargetBase = - 1;
		this.morphTargetInfluences = [];
		this.morphTargetDictionary = {};

		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

			this.morphTargetInfluences.push( 0 );
			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

		}

	}

};

fm.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];

	}

	console.warn( 'fm.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

	return 0;

};


fm.Mesh.prototype.raycast = ( function () {

	var inverseMatrix = new fm.Matrix4();
	var ray = new fm.Ray();
	var sphere = new fm.Sphere();

	var vA = new fm.Vector3();
	var vB = new fm.Vector3();
	var vC = new fm.Vector3();

	var tempA = new fm.Vector3();
	var tempB = new fm.Vector3();
	var tempC = new fm.Vector3();

	var uvA = new fm.Vector2();
	var uvB = new fm.Vector2();
	var uvC = new fm.Vector2();

	var barycoord = new fm.Vector3();

	var intersectionPoint = new fm.Vector3();
	var intersectionPointWorld = new fm.Vector3();

	function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

		fm.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

		uv1.multiplyScalar( barycoord.x );
		uv2.multiplyScalar( barycoord.y );
		uv3.multiplyScalar( barycoord.z );

		uv1.add( uv2 ).add( uv3 );

		return uv1.clone();

	}

	function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

		var intersect;
		var material = object.material;

		if ( material.side === fm.BackSide ) {

			intersect = ray.intersectTriangle( pC, pB, pA, true, point );

		} else {

			intersect = ray.intersectTriangle( pA, pB, pC, material.side !== fm.DoubleSide, point );

		}

		if ( intersect === null ) return null;

		intersectionPointWorld.copy( point );
		intersectionPointWorld.applyMatrix4( object.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

		if ( distance < raycaster.near || distance > raycaster.far ) return null;

		return {
			distance: distance,
			point: intersectionPointWorld.clone(),
			object: object
		};

	}

	function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

		vA.fromArray( positions, a * 3 );
		vB.fromArray( positions, b * 3 );
		vC.fromArray( positions, c * 3 );

		var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

		if ( intersection ) {

			if ( uvs ) {

				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );

				intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

			}

			intersection.face = new fm.Face3( a, b, c, fm.Triangle.normal( vA, vB, vC ) );
			intersection.faceIndex = a;

		}

		return intersection;

	}

	return function raycast( raycaster, intersects ) {

		var geometry = this.geometry;
		var material = this.material;
		var matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

		//

		inverseMatrix.getInverse( matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		var uvs, intersection;

		if ( geometry instanceof fm.BufferGeometry ) {

			var a, b, c;
			var index = geometry.index;
			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( attributes.uv !== undefined ) {

				uvs = attributes.uv.array;

			}

			if ( index !== null ) {

				var indices = index.array;

				for ( var i = 0, l = indices.length; i < l; i += 3 ) {

					a = indices[ i ];
					b = indices[ i + 1 ];
					c = indices[ i + 2 ];

					intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
						intersects.push( intersection );

					}

				}

			} else {


				for ( var i = 0, l = positions.length; i < l; i += 9 ) {

					a = i / 3;
					b = a + 1;
					c = a + 2;

					intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

					if ( intersection ) {

						intersection.index = a; // triangle number in positions buffer semantics
						intersects.push( intersection );

					}

				}

			}

		} else if ( geometry instanceof fm.Geometry ) {

			var fvA, fvB, fvC;
			var isFaceMaterial = material instanceof fm.MultiMaterial;
			var materials = isFaceMaterial === true ? material.materials : null;

			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
			if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

			for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

				var face = faces[ f ];
				var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

				if ( faceMaterial === undefined ) continue;

				fvA = vertices[ face.a ];
				fvB = vertices[ face.b ];
				fvC = vertices[ face.c ];

				if ( faceMaterial.morphTargets === true ) {

					var morphTargets = geometry.morphTargets;
					var morphInfluences = this.morphTargetInfluences;

					vA.set( 0, 0, 0 );
					vB.set( 0, 0, 0 );
					vC.set( 0, 0, 0 );

					for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

						var influence = morphInfluences[ t ];

						if ( influence === 0 ) continue;

						var targets = morphTargets[ t ].vertices;

						vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
						vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
						vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

					}

					vA.add( fvA );
					vB.add( fvB );
					vC.add( fvC );

					fvA = vA;
					fvB = vB;
					fvC = vC;

				}

				intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

				if ( intersection ) {

					if ( uvs ) {

						var uvs_f = uvs[ f ];
						uvA.copy( uvs_f[ 0 ] );
						uvB.copy( uvs_f[ 1 ] );
						uvC.copy( uvs_f[ 2 ] );

						intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

					}

					intersection.face = face;
					intersection.faceIndex = f;
					intersects.push( intersection );

				}

			}

		}

	};

}() );

fm.Mesh.prototype.clone = function () {

	return new this.constructor( this.geometry, this.material ).copy( this );

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

fm.Bone = function ( skin ) {

	fm.Object3D.call( this );

	this.type = 'Bone';

	this.skin = skin;

};

fm.Bone.prototype = Object.create( fm.Object3D.prototype );
fm.Bone.prototype.constructor = fm.Bone;

fm.Bone.prototype.copy = function ( source ) {

	fm.Object3D.prototype.copy.call( this, source );

	this.skin = source.skin;

	return this;

};

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

fm.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	this.identityMatrix = new fm.Matrix4();

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );

	// create a bone texture or an array of floats

	if ( this.useVertexTexture ) {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

		
		var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = fm.Math.nextPowerOfTwo( Math.ceil( size ) );
		size = Math.max( size, 4 );

		this.boneTextureWidth = size;
		this.boneTextureHeight = size;

		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
		this.boneTexture = new fm.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, fm.RGBAFormat, fm.FloatType );

	} else {

		this.boneMatrices = new Float32Array( 16 * this.bones.length );

	}

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'fm.Skeleton bonInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				this.boneInverses.push( new fm.Matrix4() );

			}

		}

	}

};

fm.Skeleton.prototype.calculateInverses = function () {

	this.boneInverses = [];

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		var inverse = new fm.Matrix4();

		if ( this.bones[ b ] ) {

			inverse.getInverse( this.bones[ b ].matrixWorld );

		}

		this.boneInverses.push( inverse );

	}

};

fm.Skeleton.prototype.pose = function () {

	var bone;

	// recover the bind-time world matrices

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			bone.matrixWorld.getInverse( this.boneInverses[ b ] );

		}

	}

	// compute the local matrices, positions, rotations and scales

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			if ( bone.parent ) {

				bone.matrix.getInverse( bone.parent.matrixWorld );
				bone.matrix.multiply( bone.matrixWorld );

			} else {

				bone.matrix.copy( bone.matrixWorld );

			}

			bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

		}

	}

};

fm.Skeleton.prototype.update = ( function () {

	var offsetMatrix = new fm.Matrix4();

	return function update() {

		// flatten bone matrices to array

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			// compute the offset between the current and the original transform

			var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

			offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
			offsetMatrix.toArray( this.boneMatrices, b * 16 );

		}

		if ( this.useVertexTexture ) {

			this.boneTexture.needsUpdate = true;

		}

	};

} )();

fm.Skeleton.prototype.clone = function () {

	return new fm.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

};

// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

fm.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	fm.Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = "attached";
	this.bindMatrix = new fm.Matrix4();
	this.bindMatrixInverse = new fm.Matrix4();

	// init bones

	// TODO: remove bone creation as there is no reason (other than
	// convenience) for fm.SkinnedMesh to do this.

	var bones = [];

	if ( this.geometry && this.geometry.bones !== undefined ) {

		var bone, gbone;

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			bone = new fm.Bone( this );
			bones.push( bone );

			bone.name = gbone.name;
			bone.position.fromArray( gbone.pos );
			bone.quaternion.fromArray( gbone.rotq );
			if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

		}

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			if ( gbone.parent !== - 1 && gbone.parent !== null &&
					bones[ gbone.parent ] !== undefined ) {

				bones[ gbone.parent ].add( bones[ b ] );

			} else {

				this.add( bones[ b ] );

			}

		}

	}

	this.normalizeSkinWeights();

	this.updateMatrixWorld( true );
	this.bind( new fm.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

};


fm.SkinnedMesh.prototype = Object.create( fm.Mesh.prototype );
fm.SkinnedMesh.prototype.constructor = fm.SkinnedMesh;

fm.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

	this.skeleton = skeleton;

	if ( bindMatrix === undefined ) {

		this.updateMatrixWorld( true );

		this.skeleton.calculateInverses();

		bindMatrix = this.matrixWorld;

	}

	this.bindMatrix.copy( bindMatrix );
	this.bindMatrixInverse.getInverse( bindMatrix );

};

fm.SkinnedMesh.prototype.pose = function () {

	this.skeleton.pose();

};

fm.SkinnedMesh.prototype.normalizeSkinWeights = function () {

	if ( this.geometry instanceof fm.Geometry ) {

		for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {

			var sw = this.geometry.skinWeights[ i ];

			var scale = 1.0 / sw.lengthManhattan();

			if ( scale !== Infinity ) {

				sw.multiplyScalar( scale );

			} else {

				sw.set( 1, 0, 0, 0 ); // do something reasonable

			}

		}

	} else if ( this.geometry instanceof fm.BufferGeometry ) {

		var vec = new fm.Vector4();

		var skinWeight = this.geometry.attributes.skinWeight;

		for ( var i = 0; i < skinWeight.count; i ++ ) {

			vec.x = skinWeight.getX( i );
			vec.y = skinWeight.getY( i );
			vec.z = skinWeight.getZ( i );
			vec.w = skinWeight.getW( i );

			var scale = 1.0 / vec.lengthManhattan();

			if ( scale !== Infinity ) {

				vec.multiplyScalar( scale );

			} else {

				vec.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

		}

	}

};

fm.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

	fm.Mesh.prototype.updateMatrixWorld.call( this, true );

	if ( this.bindMode === "attached" ) {

		this.bindMatrixInverse.getInverse( this.matrixWorld );

	} else if ( this.bindMode === "detached" ) {

		this.bindMatrixInverse.getInverse( this.bindMatrix );

	} else {

		console.warn( 'fm.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

	}

};

fm.SkinnedMesh.prototype.clone = function() {

	return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

fm.LOD = function () {

	fm.Object3D.call( this );

	this.type = 'LOD';

	Object.defineProperties( this, {
		levels: {
			enumerable: true,
			value: []
		}
	} );

};


fm.LOD.prototype = Object.create( fm.Object3D.prototype );
fm.LOD.prototype.constructor = fm.LOD;

fm.LOD.prototype.addLevel = function ( object, distance ) {

	if ( distance === undefined ) distance = 0;

	distance = Math.abs( distance );

	var levels = this.levels;

	for ( var l = 0; l < levels.length; l ++ ) {

		if ( distance < levels[ l ].distance ) {

			break;

		}

	}

	levels.splice( l, 0, { distance: distance, object: object } );

	this.add( object );

};

fm.LOD.prototype.getObjectForDistance = function ( distance ) {

	var levels = this.levels;

	for ( var i = 1, l = levels.length; i < l; i ++ ) {

		if ( distance < levels[ i ].distance ) {

			break;

		}

	}

	return levels[ i - 1 ].object;

};

fm.LOD.prototype.raycast = ( function () {

	var matrixPosition = new fm.Vector3();

	return function raycast( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( matrixPosition );

		this.getObjectForDistance( distance ).raycast( raycaster, intersects );

	};

}() );

fm.LOD.prototype.update = function () {

	var v1 = new fm.Vector3();
	var v2 = new fm.Vector3();

	return function update( camera ) {

		var levels = this.levels;

		if ( levels.length > 1 ) {

            var lvmesh = levels[0].object;
            v2.copy(lvmesh.geometry.boundingSphere.center);
            
			v1.setFromMatrixPosition( camera.matrixWorld );
			v2.setFromMatrixPosition( this.matrixWorld );

			var distance = v1.distanceTo( v2 );

			levels[ 0 ].object.visible = true;

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance >= levels[ i ].distance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	};

}();

fm.LOD.prototype.copy = function ( source ) {

	fm.Object3D.prototype.copy.call( this, source, false );

	var levels = source.levels;

	for ( var i = 0, l = levels.length; i < l; i ++ ) {

		var level = levels[ i ];

		this.addLevel( level.object.clone(), level.distance );

	}

	return this;

};

fm.LOD.prototype.toJSON = function ( meta ) {

	var data = fm.Object3D.prototype.toJSON.call( this, meta );

	data.object.levels = [];

	var levels = this.levels;

	for ( var i = 0, l = levels.length; i < l; i ++ ) {

		var level = levels[ i ];

		data.object.levels.push( {
			object: level.object.uuid,
			distance: level.distance
		} );

	}

	return data;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

fm.Sprite = ( function () {

	var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
	var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
	var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

	var geometry = new fm.BufferGeometry();
	geometry.setIndex( new fm.BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new fm.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'uv', new fm.BufferAttribute( uvs, 2 ) );

	return function Sprite( material ) {

		fm.Object3D.call( this );

		this.type = 'Sprite';

		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new fm.SpriteMaterial();

	};

} )();

fm.Sprite.prototype = Object.create( fm.Object3D.prototype );
fm.Sprite.prototype.constructor = fm.Sprite;

fm.Sprite.prototype.raycast = ( function () {

	var matrixPosition = new fm.Vector3();

	return function raycast( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
		var guessSizeSq = this.scale.x * this.scale.y / 4;

		if ( distanceSq > guessSizeSq ) {

			return;

		}

		intersects.push( {

			distance: Math.sqrt( distanceSq ),
			point: this.position,
			face: null,
			object: this

		} );

	};

}() );

fm.Sprite.prototype.clone = function () {

	return new this.constructor( this.material ).copy( this );

};

// Backwards compatibility

fm.Particle = fm.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

fm.LensFlare = function ( texture, size, distance, blending, color ) {

	fm.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new fm.Vector3();
	this.customUpdateCallback = undefined;

	if ( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

fm.LensFlare.prototype = Object.create( fm.Object3D.prototype );
fm.LensFlare.prototype.constructor = fm.LensFlare;


/*
 * Add: adds another flare
 */

fm.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

	if ( size === undefined ) size = - 1;
	if ( distance === undefined ) distance = 0;
	if ( opacity === undefined ) opacity = 1;
	if ( color === undefined ) color = new fm.Color( 0xffffff );
	if ( blending === undefined ) blending = fm.NormalBlending;

	distance = Math.min( distance, Math.max( 0, distance ) );

	this.lensFlares.push( {
		texture: texture,	// fm.Texture
		size: size, 		// size in pixels (-1 = use texture.width)
		distance: distance, 	// distance (0-1) from light source (0=at light source)
		x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
		scale: 1, 		// scale
		rotation: 0, 		// rotation
		opacity: opacity,	// opacity
		color: color,		// color
		blending: blending	// blending
	} );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

fm.LensFlare.prototype.updateLensFlares = function () {

	var f, fl = this.lensFlares.length;
	var flare;
	var vecX = - this.positionScreen.x * 2;
	var vecY = - this.positionScreen.y * 2;

	for ( f = 0; f < fl; f ++ ) {

		flare = this.lensFlares[ f ];

		flare.x = this.positionScreen.x + vecX * flare.distance;
		flare.y = this.positionScreen.y + vecY * flare.distance;

		flare.wantedRotation = flare.x * Math.PI * 0.25;
		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

	}

};

fm.LensFlare.prototype.copy = function ( source ) {

	fm.Object3D.prototype.copy.call( this, source );

	this.positionScreen.copy( source.positionScreen );
	this.customUpdateCallback = source.customUpdateCallback;

	for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

		this.lensFlares.push( source.lensFlares[ i ] );

	}

	return this;

};

// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.Scene = function () {

	fm.Object3D.call( this );

	this.type = 'Scene';

	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

};

fm.Scene.prototype = Object.create( fm.Object3D.prototype );
fm.Scene.prototype.constructor = fm.Scene;

fm.Scene.prototype.copy = function ( source, recursive ) {

	fm.Object3D.prototype.copy.call( this, source, recursive );

	if ( source.fog !== null ) this.fog = source.fog.clone();
	if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

	this.autoUpdate = source.autoUpdate;
	this.matrixAutoUpdate = source.matrixAutoUpdate;

	return this;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

fm.Fog = function ( color, near, far ) {

	this.name = '';

	this.color = new fm.Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

fm.Fog.prototype.clone = function () {

	return new fm.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

fm.FogExp2 = function ( color, density ) {

	this.name = '';

	this.color = new fm.Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

fm.FogExp2.prototype.clone = function () {

	return new fm.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

fm.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

fm.ShaderChunk[ 'alphamap_fragment' ] = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

fm.ShaderChunk[ 'alphamap_pars_fragment' ] = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

fm.ShaderChunk[ 'alphatest_fragment' ] = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

fm.ShaderChunk[ 'aomap_fragment' ] = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

fm.ShaderChunk[ 'aomap_pars_fragment' ] = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";

// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

fm.ShaderChunk[ 'begin_vertex' ] = "\nvec3 transformed = vec3( position );\n";

// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

fm.ShaderChunk[ 'beginnormal_vertex' ] = "\nvec3 objectNormal = vec3( normal );\n";

// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl

fm.ShaderChunk[ 'bsdfs' ] = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n	return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n		if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n			float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n			float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n			return distanceFalloff * maxDistanceCutoffFactor;\n#else\n			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n		}\n		return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

fm.ShaderChunk[ 'bumpmap_pars_fragment' ] = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl

fm.ShaderChunk[ 'clipping_planes_fragment' ] = "#if NUM_CLIPPING_PLANES > 0\n	for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n		vec4 plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl

fm.ShaderChunk[ 'clipping_planes_pars_fragment' ] = "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( PHYSICAL ) && ! defined( PHONG )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl

fm.ShaderChunk[ 'clipping_planes_pars_vertex' ] = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	varying vec3 vViewPosition;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl

fm.ShaderChunk[ 'clipping_planes_vertex' ] = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	vViewPosition = - mvPosition.xyz;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

fm.ShaderChunk[ 'color_fragment' ] = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

fm.ShaderChunk[ 'color_pars_fragment' ] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

fm.ShaderChunk[ 'color_pars_vertex' ] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

fm.ShaderChunk[ 'color_vertex' ] = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

fm.ShaderChunk[ 'common' ] = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";

// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl

fm.ShaderChunk[ 'cube_uv_reflection_fragment' ] = "#ifdef ENVMAP_TYPE_CUBE_UV\nconst float cubeUV_textureSize = 1024.0;\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\nfloat cubeUV_maxLods1 = log2(cubeUV_textureSize*0.25) - 1.0;\nfloat cubeUV_rangeClamp = exp2((6.0 - 1.0) * 2.0);\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\nfloat cubeUV_maxLods2 = log2(cubeUV_textureSize*0.25) - 2.0;\nconst float cubeUV_rcpTextureSize = 1.0 / cubeUV_textureSize;\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\nfloat cubeUV_maxLods3 = log2(cubeUV_textureSize*0.25) - 3.0;\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

fm.ShaderChunk[ 'defaultnormal_vertex' ] = "#ifdef FLIP_SIDED\n	objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

fm.ShaderChunk[ 'displacementmap_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

fm.ShaderChunk[ 'displacementmap_pars_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

fm.ShaderChunk[ 'emissivemap_fragment' ] = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

fm.ShaderChunk[ 'emissivemap_pars_fragment' ] = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl

fm.ShaderChunk[ 'encodings_pars_fragment' ] = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";

// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl

fm.ShaderChunk[ 'encodings_fragment' ] = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

fm.ShaderChunk[ 'envmap_fragment' ] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

fm.ShaderChunk[ 'envmap_pars_fragment' ] = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

fm.ShaderChunk[ 'envmap_pars_vertex' ] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

fm.ShaderChunk[ 'envmap_vertex' ] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

fm.ShaderChunk[ 'fog_fragment' ] = "#ifdef USE_FOG\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

fm.ShaderChunk[ 'fog_pars_fragment' ] = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

fm.ShaderChunk[ 'lightmap_fragment' ] = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

fm.ShaderChunk[ 'lightmap_pars_fragment' ] = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

fm.ShaderChunk[ 'lights_lambert_vertex' ] = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl

fm.ShaderChunk[ 'lights_pars' ] = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		if ( testLightInRange( lightDistance, pointLight.distance ) ) {\n			directLight.color = pointLight.color;\n			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

fm.ShaderChunk[ 'lights_phong_fragment' ] = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

fm.ShaderChunk[ 'lights_phong_pars_fragment' ] = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n";

// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl

fm.ShaderChunk[ 'lights_physical_fragment' ] = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.16 * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl

fm.ShaderChunk[ 'lights_physical_pars_fragment' ] = "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n	#ifndef STANDARD\n	#endif\n};\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

// File:src/renderers/shaders/ShaderChunk/lights_template.glsl

fm.ShaderChunk[ 'lights_template' ] = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n	 	irradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	RE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

fm.ShaderChunk[ 'logdepthbuf_fragment' ] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

fm.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

fm.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

fm.ShaderChunk[ 'logdepthbuf_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

fm.ShaderChunk[ 'map_fragment' ] = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

fm.ShaderChunk[ 'map_pars_fragment' ] = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

fm.ShaderChunk[ 'map_particle_fragment' ] = "#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

fm.ShaderChunk[ 'map_particle_pars_fragment' ] = "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl

fm.ShaderChunk[ 'metalnessmap_fragment' ] = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.r;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl

fm.ShaderChunk[ 'metalnessmap_pars_fragment' ] = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

fm.ShaderChunk[ 'morphnormal_vertex' ] = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

fm.ShaderChunk[ 'morphtarget_pars_vertex' ] = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

fm.ShaderChunk[ 'morphtarget_vertex' ] = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl

fm.ShaderChunk[ 'normal_fragment' ] = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#endif\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

fm.ShaderChunk[ 'normalmap_pars_fragment' ] = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/packing.glsl

fm.ShaderChunk[ 'packing' ] = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nvec4 packDepthToRGBA( const in float value ) {\n	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n	vec4 res = mod( value * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n	res -= res.xxyz * bit_mask;\n	return res;\n}\nfloat unpackRGBAToDepth( const in vec4 rgba ) {\n	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n	return dot( rgba, bitSh );\n}\nfloat viewZToOrthoDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat OrthoDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl

fm.ShaderChunk[ 'premultiplied_alpha_fragment' ] = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

fm.ShaderChunk[ 'project_vertex' ] = "#ifdef USE_SKINNING\n	vec4 mvPosition = modelViewMatrix * skinned;\n#else\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl

fm.ShaderChunk[ 'roughnessmap_fragment' ] = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.r;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl

fm.ShaderChunk[ 'roughnessmap_pars_fragment' ] = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

fm.ShaderChunk[ 'shadowmap_pars_fragment' ] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return 1.0;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

fm.ShaderChunk[ 'shadowmap_pars_vertex' ] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

fm.ShaderChunk[ 'shadowmap_vertex' ] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl

fm.ShaderChunk[ 'shadowmask_pars_fragment' ] = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

fm.ShaderChunk[ 'skinbase_vertex' ] = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

fm.ShaderChunk[ 'skinning_pars_vertex' ] = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

fm.ShaderChunk[ 'skinning_vertex' ] = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

fm.ShaderChunk[ 'skinnormal_vertex' ] = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

fm.ShaderChunk[ 'specularmap_fragment' ] = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

fm.ShaderChunk[ 'specularmap_pars_fragment' ] = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";

// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl

fm.ShaderChunk[ 'tonemapping_fragment' ] = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl

fm.ShaderChunk[ 'tonemapping_pars_fragment' ] = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

fm.ShaderChunk[ 'uv2_pars_fragment' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

fm.ShaderChunk[ 'uv2_pars_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

fm.ShaderChunk[ 'uv2_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

fm.ShaderChunk[ 'uv_pars_fragment' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

fm.ShaderChunk[ 'uv_pars_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

fm.ShaderChunk[ 'uv_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

fm.ShaderChunk[ 'worldpos_vertex' ] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	#ifdef USE_SKINNING\n		vec4 worldPosition = modelMatrix * skinned;\n	#else\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n	#endif\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

fm.UniformsUtils = {

	merge: function ( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = this.clone( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var uniforms_dst = {};

		for ( var u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( var p in uniforms_src[ u ] ) {

				var parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof fm.Color ||
					 parameter_src instanceof fm.Vector2 ||
					 parameter_src instanceof fm.Vector3 ||
					 parameter_src instanceof fm.Vector4 ||
					 parameter_src instanceof fm.Matrix3 ||
					 parameter_src instanceof fm.Matrix4 ||
					 parameter_src instanceof fm.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( Array.isArray( parameter_src ) ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

fm.UniformsLib = {

	common: {

		"diffuse": { type: "c", value: new fm.Color( 0xeeeeee ) },
		"opacity": { type: "1f", value: 1.0 },

		"map": { type: "t", value: null },
		"offsetRepeat": { type: "v4", value: new fm.Vector4( 0, 0, 1, 1 ) },

		"specularMap": { type: "t", value: null },
		"alphaMap": { type: "t", value: null },

		"envMap": { type: "t", value: null },
		"flipEnvMap": { type: "1f", value: - 1 },
		"reflectivity": { type: "1f", value: 1.0 },
		"refractionRatio": { type: "1f", value: 0.98 }

	},

	aomap: {

		"aoMap": { type: "t", value: null },
		"aoMapIntensity": { type: "1f", value: 1 }

	},

	lightmap: {

		"lightMap": { type: "t", value: null },
		"lightMapIntensity": { type: "1f", value: 1 }

	},

	emissivemap: {

		"emissiveMap": { type: "t", value: null }

	},

	bumpmap: {

		"bumpMap": { type: "t", value: null },
		"bumpScale": { type: "1f", value: 1 }

	},

	normalmap: {

		"normalMap": { type: "t", value: null },
		"normalScale": { type: "v2", value: new fm.Vector2( 1, 1 ) }

	},

	displacementmap: {

		"displacementMap": { type: "t", value: null },
		"displacementScale": { type: "1f", value: 1 },
		"displacementBias": { type: "1f", value: 0 }

	},

	roughnessmap: {

		"roughnessMap": { type: "t", value: null }

	},

	metalnessmap: {

		"metalnessMap": { type: "t", value: null }

	},

	fog: {

		"fogDensity": { type: "1f", value: 0.00025 },
		"fogNear": { type: "1f", value: 1 },
		"fogFar": { type: "1f", value: 2000 },
		"fogColor": { type: "c", value: new fm.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor": { type: "3fv", value: [] },

		"directionalLights": { type: "sa", value: [], properties: {
			"direction": { type: "v3" },
			"color": { type: "c" },

			"shadow": { type: "1i" },
			"shadowBias": { type: "1f" },
			"shadowRadius": { type: "1f" },
			"shadowMapSize": { type: "v2" }
		} },

		"directionalShadowMap": { type: "tv", value: [] },
		"directionalShadowMatrix": { type: "m4v", value: [] },

		"spotLights": { type: "sa", value: [], properties: {
			"color": { type: "c" },
			"position": { type: "v3" },
			"direction": { type: "v3" },
			"distance": { type: "1f" },
			"coneCos": { type: "1f" },
			"penumbraCos": { type: "1f" },
			"decay": { type: "1f" },

			"shadow": { type: "1i" },
			"shadowBias": { type: "1f" },
			"shadowRadius": { type: "1f" },
			"shadowMapSize": { type: "v2" }
		} },

		"spotShadowMap": { type: "tv", value: [] },
		"spotShadowMatrix": { type: "m4v", value: [] },

		"pointLights": { type: "sa", value: [], properties: {
			"color": { type: "c" },
			"position": { type: "v3" },
			"decay": { type: "1f" },
			"distance": { type: "1f" },

			"shadow": { type: "1i" },
			"shadowBias": { type: "1f" },
			"shadowRadius": { type: "1f" },
			"shadowMapSize": { type: "v2" }
		} },

		"pointShadowMap": { type: "tv", value: [] },
		"pointShadowMatrix": { type: "m4v", value: [] },

		"hemisphereLights": { type: "sa", value: [], properties: {
			"direction": { type: "v3" },
			"skyColor": { type: "c" },
			"groundColor": { type: "c" }
		} }

	},

	points: {

		"diffuse": { type: "c", value: new fm.Color( 0xeeeeee ) },
		"opacity": { type: "1f", value: 1.0 },
		"size": { type: "1f", value: 1.0 },
		"scale": { type: "1f", value: 1.0 },
		"map": { type: "t", value: null },
		"offsetRepeat": { type: "v4", value: new fm.Vector4( 0, 0, 1, 1 ) }

	}

};

// File:src/renderers/shaders/ShaderLib/cube_frag.glsl

fm.ShaderChunk[ 'cube_frag' ] = "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n	#include <logdepthbuf_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/cube_vert.glsl

fm.ShaderChunk[ 'cube_vert' ] = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/depth_frag.glsl

fm.ShaderChunk[ 'depth_frag' ] = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}\n";

// File:src/renderers/shaders/ShaderLib/depth_vert.glsl

fm.ShaderChunk[ 'depth_vert' ] = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl

fm.ShaderChunk[ 'distanceRGBA_frag' ] = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	gl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl

fm.ShaderChunk[ 'distanceRGBA_vert' ] = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition;\n}\n";

// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl

fm.ShaderChunk[ 'equirect_frag' ] = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 direction = normalize( vWorldPosition );\n	vec2 sampleUV;\n	sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <logdepthbuf_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl

fm.ShaderChunk[ 'equirect_vert' ] = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl

fm.ShaderChunk[ 'linedashed_frag' ] = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl

fm.ShaderChunk[ 'linedashed_vert' ] = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl

fm.ShaderChunk[ 'meshbasic_frag' ] = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight;\n	reflectedLight.directDiffuse = vec3( 0.0 );\n	reflectedLight.directSpecular = vec3( 0.0 );\n	reflectedLight.indirectDiffuse = diffuseColor.rgb;\n	reflectedLight.indirectSpecular = vec3( 0.0 );\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl

fm.ShaderChunk[ 'meshbasic_vert' ] = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl

fm.ShaderChunk[ 'meshlambert_frag' ] = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl

fm.ShaderChunk[ 'meshlambert_vert' ] = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl

fm.ShaderChunk[ 'meshphong_frag' ] = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl

fm.ShaderChunk[ 'meshphong_vert' ] = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl

fm.ShaderChunk[ 'meshphysical_frag' ] = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl

fm.ShaderChunk[ 'meshphysical_vert' ] = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/normal_frag.glsl

fm.ShaderChunk[ 'normal_frag' ] = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	gl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n	#include <logdepthbuf_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/normal_vert.glsl

fm.ShaderChunk[ 'normal_vert' ] = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vNormal = normalize( normalMatrix * normal );\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/points_frag.glsl

fm.ShaderChunk[ 'points_frag' ] = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/points_vert.glsl

fm.ShaderChunk[ 'points_vert' ] = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <project_vertex>\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / - mvPosition.z );\n	#else\n		gl_PointSize = size;\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for fm.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


fm.ShaderLib = {

	'basic': {

		uniforms: fm.UniformsUtils.merge( [

			fm.UniformsLib[ 'common' ],
			fm.UniformsLib[ 'aomap' ],
			fm.UniformsLib[ 'fog' ]

		] ),

		vertexShader: fm.ShaderChunk[ 'meshbasic_vert' ],
		fragmentShader: fm.ShaderChunk[ 'meshbasic_frag' ]

	},

	'lambert': {

		uniforms: fm.UniformsUtils.merge( [

			fm.UniformsLib[ 'common' ],
			fm.UniformsLib[ 'aomap' ],
			fm.UniformsLib[ 'lightmap' ],
			fm.UniformsLib[ 'emissivemap' ],
			fm.UniformsLib[ 'fog' ],
			fm.UniformsLib[ 'lights' ],

			{
				"emissive" : { type: "c", value: new fm.Color( 0x000000 ) }
			}

		] ),

		vertexShader: fm.ShaderChunk[ 'meshlambert_vert' ],
		fragmentShader: fm.ShaderChunk[ 'meshlambert_frag' ]

	},

	'phong': {

		uniforms: fm.UniformsUtils.merge( [

			fm.UniformsLib[ 'common' ],
			fm.UniformsLib[ 'aomap' ],
			fm.UniformsLib[ 'lightmap' ],
			fm.UniformsLib[ 'emissivemap' ],
			fm.UniformsLib[ 'bumpmap' ],
			fm.UniformsLib[ 'normalmap' ],
			fm.UniformsLib[ 'displacementmap' ],
			fm.UniformsLib[ 'fog' ],
			fm.UniformsLib[ 'lights' ],

			{
				"emissive" : { type: "c", value: new fm.Color( 0x000000 ) },
				"specular" : { type: "c", value: new fm.Color( 0x111111 ) },
				"shininess": { type: "1f", value: 30 }
			}

		] ),

		vertexShader: fm.ShaderChunk[ 'meshphong_vert' ],
		fragmentShader: fm.ShaderChunk[ 'meshphong_frag' ]

	},

	'standard': {

		uniforms: fm.UniformsUtils.merge( [

			fm.UniformsLib[ 'common' ],
			fm.UniformsLib[ 'aomap' ],
			fm.UniformsLib[ 'lightmap' ],
			fm.UniformsLib[ 'emissivemap' ],
			fm.UniformsLib[ 'bumpmap' ],
			fm.UniformsLib[ 'normalmap' ],
			fm.UniformsLib[ 'displacementmap' ],
			fm.UniformsLib[ 'roughnessmap' ],
			fm.UniformsLib[ 'metalnessmap' ],
			fm.UniformsLib[ 'fog' ],
			fm.UniformsLib[ 'lights' ],

			{
				"emissive" : { type: "c", value: new fm.Color( 0x000000 ) },
				"roughness": { type: "1f", value: 0.5 },
				"metalness": { type: "1f", value: 0 },
				"envMapIntensity" : { type: "1f", value: 1 } // temporary
			}

		] ),

		vertexShader: fm.ShaderChunk[ 'meshphysical_vert' ],
		fragmentShader: fm.ShaderChunk[ 'meshphysical_frag' ]

	},

	'points': {

		uniforms: fm.UniformsUtils.merge( [

			fm.UniformsLib[ 'points' ],
			fm.UniformsLib[ 'fog' ]

		] ),

		vertexShader: fm.ShaderChunk[ 'points_vert' ],
		fragmentShader: fm.ShaderChunk[ 'points_frag' ]

	},

	'dashed': {

		uniforms: fm.UniformsUtils.merge( [

			fm.UniformsLib[ 'common' ],
			fm.UniformsLib[ 'fog' ],

			{
				"scale"    : { type: "1f", value: 1 },
				"dashSize" : { type: "1f", value: 1 },
				"totalSize": { type: "1f", value: 2 }
			}

		] ),

		vertexShader: fm.ShaderChunk[ 'linedashed_vert' ],
		fragmentShader: fm.ShaderChunk[ 'linedashed_frag' ]

	},

	'depth': {

		uniforms: fm.UniformsUtils.merge( [

			fm.UniformsLib[ 'common' ],
			fm.UniformsLib[ 'displacementmap' ]

		] ),

		vertexShader: fm.ShaderChunk[ 'depth_vert' ],
		fragmentShader: fm.ShaderChunk[ 'depth_frag' ]

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "1f", value: 1.0 }

		},

		vertexShader: fm.ShaderChunk[ 'normal_vert' ],
		fragmentShader: fm.ShaderChunk[ 'normal_frag' ]

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: {
			"tCube": { type: "t", value: null },
			"tFlip": { type: "1f", value: - 1 }
		},

		vertexShader: fm.ShaderChunk[ 'cube_vert' ],
		fragmentShader: fm.ShaderChunk[ 'cube_frag' ]

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'equirect': {

		uniforms: {
			"tEquirect": { type: "t", value: null },
			"tFlip": { type: "1f", value: - 1 }
		},

		vertexShader: fm.ShaderChunk[ 'equirect_vert' ],
		fragmentShader: fm.ShaderChunk[ 'equirect_frag' ]

	},

	'distanceRGBA': {

		uniforms: {

			"lightPos": { type: "v3", value: new fm.Vector3() }

		},

		vertexShader: fm.ShaderChunk[ 'distanceRGBA_vert' ],
		fragmentShader: fm.ShaderChunk[ 'distanceRGBA_frag' ]

	}

};

fm.ShaderLib[ 'physical' ] = {

	uniforms: fm.UniformsUtils.merge( [

		fm.ShaderLib[ 'standard' ].uniforms,

		{
			// future
		}

	] ),

	vertexShader: fm.ShaderChunk[ 'meshphysical_vert' ],
	fragmentShader: fm.ShaderChunk[ 'meshphysical_frag' ]

};


// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */

fm.WebGLRenderer = function ( parameters ) {

	console.log( 'fm.WebGLRenderer', fm.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
	_context = parameters.context !== undefined ? parameters.context : null,

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_depth = parameters.depth !== undefined ? parameters.depth : true,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

	var lights = [];

	var opaqueObjects = [];
	var opaqueObjectsLastIndex = - 1;
	var transparentObjects = [];
	var transparentObjectsLastIndex = - 1;

	var morphInfluences = new Float32Array( 8 );

	var sprites = [];
	var lensFlares = [];

	// public properties

	this.domElement = _canvas;
	this.context = null;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.gammaInput = false;
	this.gammaOutput = false;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = fm.LinearToneMapping;
	this.toneMappingExposure = 1.0;
	this.toneMappingWhitePoint = 1.0;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// internal properties

	var _this = this,

	// internal state cache

	_currentProgram = null,
	_currentRenderTarget = null,
	_currentFramebuffer = null,
	_currentMaterialId = - 1,
	_currentGeometryProgram = '',
	_currentCamera = null,

	_currentScissor = new fm.Vector4(),
	_currentScissorTest = null,

	_currentViewport = new fm.Vector4(),

	//

	_usedTextureUnits = 0,

	//

	_clearColor = new fm.Color( 0x000000 ),
	_clearAlpha = 0,

	_width = _canvas.width,
	_height = _canvas.height,

	_pixelRatio = 1,

	_scissor = new fm.Vector4( 0, 0, _width, _height ),
	_scissorTest = false,

	_viewport = new fm.Vector4( 0, 0, _width, _height ),

	// frustum

	_frustum = new fm.Frustum(),

	// clipping

	_clippingEnabled = false,
	_localClippingEnabled = false,
	_clipRenderingShadows = false,

	_numClippingPlanes = 0,
	_clippingPlanesUniform = {
			type: '4fv', value: null, needsUpdate: false },

	_globalClippingState = null,
	_numGlobalClippingPlanes = 0,

	_matrix3 = new fm.Matrix3(),
	_sphere = new fm.Sphere(),
	_plane = new fm.Plane(),


	// camera matrices cache

	_projScreenMatrix = new fm.Matrix4(),

	_vector3 = new fm.Vector3(),

	// light arrays cache

	_lights = {

		hash: '',

		ambient: [ 0, 0, 0 ],
		directional: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		point: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: [],

		shadows: []

	},

	// info

	_infoMemory = {

		geometries: 0,
		textures: 0

	},

	_infoRender = {

		calls: 0,
		vertices: 0,
		faces: 0,
		points: 0

	};

	this.info = {

		render: _infoRender,
		memory: _infoMemory,
		programs: null

	};


	// initialize

	var _gl;

	try {

		var attributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};

		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl' ) !== null ) {

				throw 'Error creating WebGL context with your selected attributes.';

			} else {

				throw 'Error creating WebGL context.';

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

	} catch ( error ) {

		console.error( 'fm.WebGLRenderer: ' + error );

	}

	var _isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext);
	var extensions = new fm.WebGLExtensions( _gl );

	extensions.get( 'WEBGL_depth_texture' );
	extensions.get( 'OES_texture_float' );
	extensions.get( 'OES_texture_float_linear' );
	extensions.get( 'OES_texture_half_float' );
	extensions.get( 'OES_texture_half_float_linear' );
	extensions.get( 'OES_standard_derivatives' );
	extensions.get( 'ANGLE_instanced_arrays' );

	if ( extensions.get( 'OES_element_index_uint' ) ) {

		fm.BufferGeometry.MaxIndex = 4294967296;

	}

	var capabilities = new fm.WebGLCapabilities( _gl, extensions, parameters );

	var state = new fm.WebGLState( _gl, extensions, paramThreeToGL );
	var properties = new fm.WebGLProperties();
	var objects = new fm.WebGLObjects( _gl, properties, this.info );
	var programCache = new fm.WebGLPrograms( this, capabilities );
	var lightCache = new fm.WebGLLights();

	this.info.programs = programCache.programs;

	var bufferRenderer = new fm.WebGLBufferRenderer( _gl, extensions, _infoRender );
	var indexedBufferRenderer = new fm.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

	//

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	function glClearColor( r, g, b, a ) {

		if ( _premultipliedAlpha === true ) {

			r *= a; g *= a; b *= a;

		}

		state.clearColor( r, g, b, a );

	}

	function setDefaultGLState() {

		state.init();

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}

	function resetGLState() {

		_currentProgram = null;
		_currentCamera = null;

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;

		state.reset();

	}

	setDefaultGLState();

	this.context = _gl;
	this.capabilities = capabilities;
	this.extensions = extensions;
	this.properties = properties;
	this.state = state;

	// shadow map

	var shadowMap = new fm.WebGLShadowMap( this, _lights, objects );

	this.shadowMap = shadowMap;


	// Plugins

	var spritePlugin = new fm.SpritePlugin( this, sprites );
	var lensFlarePlugin = new fm.LensFlarePlugin( this, lensFlares );

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		extensions.get( 'WEBGL_lose_context' ).loseContext();

	};

	this.getMaxAnisotropy = ( function () {

		var value;

		return function getMaxAnisotropy() {

			if ( value !== undefined ) return value;

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension !== null ) {

				value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				value = 0;

			}

			return value;

		};

	} )();

	this.getPrecision = function () {

		return capabilities.precision;

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _viewport.z, _viewport.w, false );

	};

	this.getSize = function () {

		return {
			width: _width,
			height: _height
		};

	};

	this.setSize = function ( width, height, updateStyle ) {

		_width = width;
		_height = height;

		_canvas.width = width * _pixelRatio;
		_canvas.height = height * _pixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		state.viewport( _viewport.set( x, y, width, height ) );

	};

	this.setScissor = function ( x, y, width, height ) {

		state.scissor( _scissor.set( x, y, width, height ) );

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	// Clearing

	this.getClearColor = function () {

		return _clearColor;

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );

		_clearAlpha = alpha !== undefined ? alpha : 1;

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.setClearAlpha = function ( alpha ) {

		_clearAlpha = alpha;

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Reset

	this.resetGLState = resetGLState;

	this.dispose = function() {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		resetGLState();
		setDefaultGLState();

		properties.clear();

	}

	function onTextureDispose( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_infoMemory.textures --;


	}

	function onRenderTargetDispose( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_infoMemory.textures --;

	}

	function onMaterialDispose( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateTexture( texture ) {

		var textureProperties = properties.get( texture );

		if ( texture.image && textureProperties.__image__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

		} else {

			// 2D texture

			if ( textureProperties.__webglInit === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		// remove all webgl properties
		properties.delete( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		if ( ! renderTarget ) return;

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget instanceof fm.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

		}

		properties.delete( renderTarget.texture );
		properties.delete( renderTarget );

	}

	function deallocateMaterial( material ) {

		releaseMaterialProgramReference( material );

		properties.delete( material );

	}


	function releaseMaterialProgramReference( material ) {

		var programInfo = properties.get( material ).program;

		material.program = undefined;

		if ( programInfo !== undefined ) {

			programCache.releaseProgram( programInfo );

		}

	}

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		state.initAttributes();

		var buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		var attributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

			if ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === fm.FlatShading ) {

				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

					var array = object.normalArray;

					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

					array[ i + 0 ] = nx;
					array[ i + 1 ] = ny;
					array[ i + 2 ] = nz;

					array[ i + 3 ] = nx;
					array[ i + 4 ] = ny;
					array[ i + 5 ] = nz;

					array[ i + 6 ] = nx;
					array[ i + 7 ] = ny;
					array[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.normal );

			_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.uv );

			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== fm.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.color );

			_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		state.disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

		setMaterial( material );

		var program = setProgram( camera, fog, material, object );

		var updateBuffers = false;
		var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

		if ( geometryProgram !== _currentGeometryProgram ) {

			_currentGeometryProgram = geometryProgram;
			updateBuffers = true;

		}

		// morph targets

		var morphTargetInfluences = object.morphTargetInfluences;

		if ( morphTargetInfluences !== undefined ) {

			var activeInfluences = [];

			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

				var influence = morphTargetInfluences[ i ];
				activeInfluences.push( [ influence, i ] );

			}

			activeInfluences.sort( absNumericalSort );

			if ( activeInfluences.length > 8 ) {

				activeInfluences.length = 8;

			}

			var morphAttributes = geometry.morphAttributes;

			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

				var influence = activeInfluences[ i ];
				morphInfluences[ i ] = influence[ 0 ];

				if ( influence[ 0 ] !== 0 ) {

					var index = influence[ 1 ];

					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

				} else {

					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			program.getUniforms().setValue(
					_gl, 'morphTargetInfluences', morphInfluences );

			updateBuffers = true;

		}

		//

		var index = geometry.index;
		var position = geometry.attributes.position;

		if ( material.wireframe === true ) {

			index = objects.getWireframeAttribute( geometry );

		}

		var renderer;

		if ( index !== null ) {

			renderer = indexedBufferRenderer;
			renderer.setIndex( index );

		} else {

			renderer = bufferRenderer;

		}

		if ( updateBuffers ) {

			setupVertexAttributes( material, program, geometry );

			if ( index !== null ) {

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

			}

		}

		//

		var dataStart = 0;
		var dataCount = Infinity;

		if ( index !== null ) {

			dataCount = index.count;

		} else if ( position !== undefined ) {

			dataCount = position.count;

		}

		var rangeStart = geometry.drawRange.start;
		var rangeCount = geometry.drawRange.count;

		var groupStart = group !== null ? group.start : 0;
		var groupCount = group !== null ? group.count : Infinity;

		var drawStart = Math.max( dataStart, rangeStart, groupStart );
		var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		//

		if ( object instanceof fm.Mesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( _gl.LINES );

			} else {

				switch ( object.drawMode ) {

					case fm.TrianglesDrawMode:
						renderer.setMode( _gl.TRIANGLES );
						break;

					case fm.TriangleStripDrawMode:
						renderer.setMode( _gl.TRIANGLE_STRIP );
						break;

					case fm.TriangleFanDrawMode:
						renderer.setMode( _gl.TRIANGLE_FAN );
						break;

				}

			}


		} else if ( object instanceof fm.Line ) {

			var lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object instanceof fm.LineSegments ) {

				renderer.setMode( _gl.LINES );

			} else {

				renderer.setMode( _gl.LINE_STRIP );

			}

		} else if ( object instanceof fm.Points ) {

			renderer.setMode( _gl.POINTS );

		}

		if ( geometry instanceof fm.InstancedBufferGeometry ) {

			if ( geometry.maxInstancedCount > 0 ) {

				renderer.renderInstances( geometry, drawStart, drawCount );

			}

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	function setupVertexAttributes( material, program, geometry, startIndex ) {

		var extension;

		if ( geometry instanceof fm.InstancedBufferGeometry ) {

			extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'fm.WebGLRenderer.setupVertexAttributes: using fm.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		if ( startIndex === undefined ) startIndex = 0;

		state.initAttributes();

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.getAttributes();

		var materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( var name in programAttributes ) {

			var programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					var type = _gl.FLOAT;
					var array = geometryAttribute.array;
					var normalized = geometryAttribute.normalized;

					if ( array instanceof Float32Array ) {

						type = _gl.FLOAT;

					} else if ( array instanceof Float64Array ) {

						console.warn("Unsupported data buffer format: Float64Array");

					} else if ( array instanceof Uint16Array ) {

						type = _gl.UNSIGNED_SHORT;

					} else if ( array instanceof Int16Array ) {

						type = _gl.SHORT;

					} else if ( array instanceof Uint32Array ) {

						type = _gl.UNSIGNED_INT;

					} else if ( array instanceof Int32Array ) {

						type = _gl.INT;

					} else if ( array instanceof Int8Array ) {

						type = _gl.BYTE;

					} else if ( array instanceof Uint8Array ) {

						type = _gl.UNSIGNED_BYTE;

					}

					var size = geometryAttribute.itemSize;
					var buffer = objects.getAttributeBuffer( geometryAttribute );

					if ( geometryAttribute instanceof fm.InterleavedBufferAttribute ) {

						var data = geometryAttribute.data;
						var stride = data.stride;
						var offset = geometryAttribute.offset;

						if ( data instanceof fm.InstancedInterleavedBuffer ) {

							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

					} else {

						if ( geometryAttribute instanceof fm.InstancedBufferAttribute ) {

							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					var value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								_gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								_gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								_gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								_gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		state.disableUnusedAttributes();

	}

	// Sorting

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

	}

	function painterSortStable ( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable ( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof fm.Camera === false ) {

			console.error( 'fm.WebGLRenderer.render: camera is not an instance of fm.Camera.' );
			return;

		}

		var fog = scene.fog;

		// reset caching for this frame

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;
		_currentCamera = null;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		lights.length = 0;

		opaqueObjectsLastIndex = - 1;
		transparentObjectsLastIndex = - 1;

		sprites.length = 0;
		lensFlares.length = 0;

		setupGlobalClippingPlanes( this.clippingPlanes, camera );

		projectObject( scene, camera );


		opaqueObjects.length = opaqueObjectsLastIndex + 1;
		transparentObjects.length = transparentObjectsLastIndex + 1;

		if ( _this.sortObjects === true ) {

			opaqueObjects.sort( painterSortStable );
			transparentObjects.sort( reversePainterSortStable );

		}

		//

		if ( _clippingEnabled ) {

			_clipRenderingShadows = true;
			setupClippingPlanes( null );

		}

		setupShadows( lights );

		shadowMap.render( scene, camera );

		setupLights( lights, camera );

		if ( _clippingEnabled ) {

			_clipRenderingShadows = false;
			resetGlobalClippingState();

		}

		//

		_infoRender.calls = 0;
		_infoRender.vertices = 0;
		_infoRender.faces = 0;
		_infoRender.points = 0;

		if ( renderTarget === undefined ) {

			renderTarget = null;

		}

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		//

		if ( scene.overrideMaterial ) {

			var overrideMaterial = scene.overrideMaterial;

			renderObjects( opaqueObjects, camera, fog, overrideMaterial );
			renderObjects( transparentObjects, camera, fog, overrideMaterial );

		} else {

			// opaque pass (front-to-back order)

			state.setBlending( fm.NoBlending );
			renderObjects( opaqueObjects, camera, fog );

			// transparent pass (back-to-front order)

			renderObjects( transparentObjects, camera, fog );

		}

		// custom render plugins (post pass)

		spritePlugin.render( scene, camera );
		lensFlarePlugin.render( scene, camera, _currentViewport );

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget ) {

			var texture = renderTarget.texture;

			if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
					texture.minFilter !== fm.NearestFilter &&
					texture.minFilter !== fm.LinearFilter ) {

				updateRenderTargetMipmap( renderTarget );

			}

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.setDepthTest( true );
		state.setDepthWrite( true );
		state.setColorWrite( true );

		// _gl.finish();

	};

	function pushRenderItem( object, geometry, material, z, group ) {

		var array, index;

		// allocate the next position in the appropriate array

		if ( material.transparent ) {

			array = transparentObjects;
			index = ++ transparentObjectsLastIndex;

		} else {

			array = opaqueObjects;
			index = ++ opaqueObjectsLastIndex;

		}

		// recycle existing render item or grow the array

		var renderItem = array[ index ];

		if ( renderItem !== undefined ) {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.z = _vector3.z;
			renderItem.group = group;

		} else {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				z: _vector3.z,
				group: group
			};

			// assert( index === array.length );
			array.push( renderItem );

		}

	}

	function isObjectViewable( object ) {

		var geometry = object.geometry;

		if ( geometry.boundingSphere === null )
			geometry.computeBoundingSphere();

		var sphere = _sphere.
				copy( geometry.boundingSphere ).
				applyMatrix4( object.matrixWorld );

		if ( ! _frustum.intersectsSphere( sphere ) ) return false;
		if ( _numClippingPlanes === 0 ) return true;

		var planes = _this.clippingPlanes,

			center = sphere.center,
			negRad = - sphere.radius,
			i = 0;

		do {

			// out when deeper than radius in the negative halfspace
			if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

		} while ( ++ i !== _numClippingPlanes );

		return true;

	}

	function projectObject( object, camera ) {

		if ( object.visible === false ) return;

		if ( object.layers.test( camera.layers ) ) {

			if ( object instanceof fm.Light ) {

				lights.push( object );

			} else if ( object instanceof fm.Sprite ) {

				if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {

					sprites.push( object );

				}

			} else if ( object instanceof fm.LensFlare ) {

				lensFlares.push( object );

			} else if ( object instanceof fm.ImmediateRenderObject ) {

				if ( _this.sortObjects === true ) {

					_vector3.setFromMatrixPosition( object.matrixWorld );
					_vector3.applyProjection( _projScreenMatrix );

				}

				pushRenderItem( object, null, object.material, _vector3.z, null );

			} else if ( object instanceof fm.Mesh || object instanceof fm.Line || object instanceof fm.Points ) {

				if ( object instanceof fm.SkinnedMesh ) {

					object.skeleton.update();

				}

				if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {

					var material = object.material;

					if ( material.visible === true ) {

						if ( _this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

						}

						var geometry = objects.update( object );

						if ( material instanceof fm.MultiMaterial ) {

							var groups = geometry.groups;
							var materials = material.materials;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = materials[ group.materialIndex ];

								if ( groupMaterial.visible === true ) {

									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

								}

							}

						} else {

							pushRenderItem( object, geometry, material, _vector3.z, null );

						}

					}

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera );

		}

	}

	function renderObjects( renderList, camera, fog, overrideMaterial ) {

		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

			var renderItem = renderList[ i ];

			var object = renderItem.object;
			var geometry = renderItem.geometry;
			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
			var group = renderItem.group;

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object instanceof fm.ImmediateRenderObject ) {

				setMaterial( material );

				var program = setProgram( camera, fog, material, object );

				_currentGeometryProgram = '';

				object.render( function ( object ) {

					_this.renderBufferImmediate( object, program, material );

				} );

			} else {

				_this.renderBufferDirect( camera, fog, geometry, material, object, group );

			}

		}

	}

	function initMaterial( material, fog, object ) {

		var materialProperties = properties.get( material );

		var parameters = programCache.getParameters(
				material, _lights, fog, _numClippingPlanes, object );

		var code = programCache.getProgramCode( material, parameters );

		var program = materialProperties.program;
		var programChange = true;

		if ( program === undefined ) {

			// new material
			material.addEventListener( 'dispose', onMaterialDispose );

		} else if ( program.code !== code ) {

			// changed glsl or parameters
			releaseMaterialProgramReference( material );

		} else if ( parameters.shaderID !== undefined ) {

			// same glsl and uniform list
			return;

		} else {

			// only rebuild uniform list
			programChange = false;

		}

		if ( programChange ) {

			if ( parameters.shaderID ) {

				var shader = fm.ShaderLib[ parameters.shaderID ];

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: fm.UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				};

			} else {

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				};

			}

			material.__webglShader = materialProperties.__webglShader;

			program = programCache.acquireProgram( material, parameters, code );

			materialProperties.program = program;
			material.program = program;

		}

		var attributes = program.getAttributes();

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				if ( attributes[ 'morphTarget' + i ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

				if ( attributes[ 'morphNormal' + i ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		var uniforms = materialProperties.__webglShader.uniforms;

		if ( ! ( material instanceof fm.ShaderMaterial ) &&
				! ( material instanceof fm.RawShaderMaterial ) ||
				material.clipping === true ) {

			materialProperties.numClippingPlanes = _numClippingPlanes;
			uniforms.clippingPlanes = _clippingPlanesUniform;

		}

		if ( material instanceof fm.MeshPhongMaterial ||
				material instanceof fm.MeshLambertMaterial ||
				material instanceof fm.MeshStandardMaterial ||
				material.lights ) {

			// store the light setup it was created for

			materialProperties.lightsHash = _lights.hash;

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = _lights.ambient;
			uniforms.directionalLights.value = _lights.directional;
			uniforms.spotLights.value = _lights.spot;
			uniforms.pointLights.value = _lights.point;
			uniforms.hemisphereLights.value = _lights.hemi;

			uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
			uniforms.spotShadowMap.value = _lights.spotShadowMap;
			uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
			uniforms.pointShadowMap.value = _lights.pointShadowMap;
			uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;

		}

		var progUniforms = materialProperties.program.getUniforms(),
			uniformsList =
					fm.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.uniformsList = uniformsList;
		materialProperties.dynamicUniforms =
				fm.WebGLUniforms.splitDynamic( uniformsList, uniforms );

	}

	function setMaterial( material ) {

		setMaterialFaces( material );

		if ( material.transparent === true ) {

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		} else {

			state.setBlending( fm.NoBlending );

		}

		state.setDepthFunc( material.depthFunc );
		state.setDepthTest( material.depthTest );
		state.setDepthWrite( material.depthWrite );
		state.setColorWrite( material.colorWrite );
		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}

	function setMaterialFaces( material ) {

		material.side !== fm.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
		state.setFlipSided( material.side === fm.BackSide );

	}

	function setProgram( camera, fog, material, object ) {

		_usedTextureUnits = 0;

		var materialProperties = properties.get( material );

		if ( _clippingEnabled ) {

			if ( _localClippingEnabled || camera !== _currentCamera ) {

				var useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				setClippingState(
						material.clippingPlanes, material.clipShadows,
						camera, materialProperties, useCache );

			}

			if ( materialProperties.numClippingPlanes !== undefined &&
				materialProperties.numClippingPlanes !== _numClippingPlanes ) {

				material.needsUpdate = true;

			}

		}

		if ( materialProperties.program === undefined ) {

			material.needsUpdate = true;

		}

		if ( materialProperties.lightsHash !== undefined &&
			materialProperties.lightsHash !== _lights.hash ) {

			material.needsUpdate = true;

		}

		if ( material.needsUpdate ) {

			initMaterial( material, fog, object );
			material.needsUpdate = false;

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.__webglShader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			p_uniforms.set( _gl, camera, 'projectionMatrix' );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}


			if ( camera !== _currentCamera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof fm.ShaderMaterial ||
				 material instanceof fm.MeshPhongMaterial ||
				 material instanceof fm.MeshStandardMaterial ||
				 material.envMap ) {

				var uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material instanceof fm.MeshPhongMaterial ||
				 material instanceof fm.MeshLambertMaterial ||
				 material instanceof fm.MeshBasicMaterial ||
				 material instanceof fm.MeshStandardMaterial ||
				 material instanceof fm.ShaderMaterial ||
				 material.skinning ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

			p_uniforms.set( _gl, _this, 'toneMappingExposure' );
			p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			var skeleton = object.skeleton;

			if ( skeleton ) {

				if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {

					p_uniforms.set( _gl, skeleton, 'boneTexture' );
					p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
					p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		if ( refreshMaterial ) {

			if ( material instanceof fm.MeshPhongMaterial ||
				 material instanceof fm.MeshLambertMaterial ||
				 material instanceof fm.MeshStandardMaterial ||
				 material.lights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof fm.MeshBasicMaterial ||
				 material instanceof fm.MeshLambertMaterial ||
				 material instanceof fm.MeshPhongMaterial ||
				 material instanceof fm.MeshStandardMaterial ||
				 material instanceof fm.MeshDepthMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof fm.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof fm.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof fm.PointsMaterial ) {

				refreshUniformsPoints( m_uniforms, material );

			} else if ( material instanceof fm.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof fm.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof fm.MeshPhysicalMaterial ) {

				refreshUniformsPhysical( m_uniforms, material );

			} else if ( material instanceof fm.MeshStandardMaterial ) {

				refreshUniformsStandard( m_uniforms, material );

			} else if ( material instanceof fm.MeshDepthMaterial ) {

				if ( material.displacementMap ) {

					m_uniforms.displacementMap.value = material.displacementMap;
					m_uniforms.displacementScale.value = material.displacementScale;
					m_uniforms.displacementBias.value = material.displacementBias;

				}

			} else if ( material instanceof fm.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			fm.WebGLUniforms.upload(
					_gl, materialProperties.uniformsList, m_uniforms, _this );

		}


		// common matrices

		p_uniforms.set( _gl, object, 'modelViewMatrix' );
		p_uniforms.set( _gl, object, 'normalMatrix' );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );


		// dynamic uniforms

		var dynUniforms = materialProperties.dynamicUniforms;

		if ( dynUniforms !== null ) {

			fm.WebGLUniforms.evalDynamic(
					dynUniforms, m_uniforms, object, camera );

			fm.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );

		}

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		uniforms.diffuse.value = material.color;

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		uniforms.map.value = material.map;
		uniforms.specularMap.value = material.specularMap;
		uniforms.alphaMap.value = material.alphaMap;

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. normal map
		// 4. bump map
		// 5. alpha map
		// 6. emissive map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap instanceof fm.WebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof fm.WebGLRenderTargetCube ) ? 1 : - 1;

		uniforms.reflectivity.value = material.reflectivity;
		uniforms.refractionRatio.value = material.refractionRatio;

	}

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * _pixelRatio;
		uniforms.scale.value = _canvas.clientHeight * 0.5;

		uniforms.map.value = material.map;

		if ( material.map !== null ) {

			var offset = material.map.offset;
			var repeat = material.map.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

	}

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof fm.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof fm.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsLambert ( uniforms, material ) {

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

	}

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.specular.value = material.specular;
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsStandard ( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical ( uniforms, material ) {

		refreshUniformsStandard( uniforms, material );

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate ( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	// Lighting

	function setupShadows ( lights ) {

		var lightShadowsLength = 0;

		for ( var i = 0, l = lights.length; i < l; i ++ ) {

			var light = lights[ i ];

			if ( light.castShadow ) {

				_lights.shadows[ lightShadowsLength ++ ] = light;

			}

		}

		_lights.shadows.length = lightShadowsLength;

	}

	function setupLights ( lights, camera ) {

		var l, ll, light,
		r = 0, g = 0, b = 0,
		color,
		intensity,
		distance,

		viewMatrix = camera.matrixWorldInverse,

		directionalLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof fm.AmbientLight ) {

				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;

			} else if ( light instanceof fm.DirectionalLight ) {

				var uniforms = lightCache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( _vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					uniforms.shadowBias = light.shadow.bias;
					uniforms.shadowRadius = light.shadow.radius;
					uniforms.shadowMapSize = light.shadow.mapSize;

				}

				_lights.directionalShadowMap[ directionalLength ] = light.shadow.map;
				_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
				_lights.directional[ directionalLength ++ ] = uniforms;

			} else if ( light instanceof fm.SpotLight ) {

				var uniforms = lightCache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( _vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					uniforms.shadowBias = light.shadow.bias;
					uniforms.shadowRadius = light.shadow.radius;
					uniforms.shadowMapSize = light.shadow.mapSize;

				}

				_lights.spotShadowMap[ spotLength ] = light.shadow.map;
				_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
				_lights.spot[ spotLength ++ ] = uniforms;

			} else if ( light instanceof fm.PointLight ) {

				var uniforms = lightCache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					uniforms.shadowBias = light.shadow.bias;
					uniforms.shadowRadius = light.shadow.radius;
					uniforms.shadowMapSize = light.shadow.mapSize;

				}

				_lights.pointShadowMap[ pointLength ] = light.shadow.map;

				if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {

					_lights.pointShadowMatrix[ pointLength ] = new fm.Matrix4();

				}

				// for point lights we set the shadow matrix to be a translation-only matrix
				// equal to inverse of the light's position
				_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
				_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );

				_lights.point[ pointLength ++ ] = uniforms;

			} else if ( light instanceof fm.HemisphereLight ) {

				var uniforms = lightCache.get( light );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				_lights.hemi[ hemiLength ++ ] = uniforms;

			}

		}

		_lights.ambient[ 0 ] = r;
		_lights.ambient[ 1 ] = g;
		_lights.ambient[ 2 ] = b;

		_lights.directional.length = directionalLength;
		_lights.spot.length = spotLength;
		_lights.point.length = pointLength;
		_lights.hemi.length = hemiLength;

		_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;

	}

	// Clipping

	function setupGlobalClippingPlanes( planes, camera ) {

		_clippingEnabled =
				_this.clippingPlanes.length !== 0 ||
				_this.localClippingEnabled ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				_numGlobalClippingPlanes !== 0 ||
				_localClippingEnabled;

		_localClippingEnabled = _this.localClippingEnabled;

		_globalClippingState = setupClippingPlanes( planes, camera, 0 );
		_numGlobalClippingPlanes = planes !== null ? planes.length : 0;

	}

	function setupClippingPlanes( planes, camera, dstOffset, skipTransform ) {

		var nPlanes = planes !== null ? planes.length : 0,
			dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = _clippingPlanesUniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				var flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse,
					viewNormalMatrix = _matrix3.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					var plane = _plane.copy( planes[ i ] ).
							applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			_clippingPlanesUniform.value = dstArray;
			_clippingPlanesUniform.needsUpdate = true;

		}

		_numClippingPlanes = nPlanes;
		return dstArray;

	}

	function resetGlobalClippingState() {

		if ( _clippingPlanesUniform.value !== _globalClippingState ) {

			_clippingPlanesUniform.value = _globalClippingState;
			_clippingPlanesUniform.needsUpdate = _numGlobalClippingPlanes > 0;

		}

		_numClippingPlanes = _numGlobalClippingPlanes;

	}

	function setClippingState( planes, clipShadows, camera, cache, fromCache ) {

		if ( ! _localClippingEnabled ||
				planes === null || planes.length === 0 ||
				_clipRenderingShadows && ! clipShadows ) {
			// there's no local clipping

			if ( _clipRenderingShadows ) {
				// there's no global clipping

				setupClippingPlanes( null );

			} else {

				resetGlobalClippingState();
			}

		} else {

			var nGlobal = _clipRenderingShadows ? 0 : _numGlobalClippingPlanes,
				lGlobal = nGlobal * 4,

				dstArray = cache.clippingState || null;

			_clippingPlanesUniform.value = dstArray; // ensure unique state

			dstArray = setupClippingPlanes(
					planes, camera, lGlobal, fromCache );

			for ( var i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = _globalClippingState[ i ];

			}

			cache.clippingState = dstArray;
			_numClippingPlanes += nGlobal;

		}

	}


	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === fm.CullFaceNone ) {

			state.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === fm.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === fm.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === fm.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			state.enable( _gl.CULL_FACE );

		}

	};

	// Textures

	function allocTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= capabilities.maxTextures ) {

			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	function setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {

		var extension;

		if ( isPowerOfTwoImage ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			if ( texture.wrapS !== fm.ClampToEdgeWrapping || texture.wrapT !== fm.ClampToEdgeWrapping ) {

				console.warn( 'fm.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to fm.ClampToEdgeWrapping.', texture );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== fm.NearestFilter && texture.minFilter !== fm.LinearFilter ) {

				console.warn( 'fm.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to fm.NearestFilter or fm.LinearFilter.', texture );

			}

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension ) {

			if ( texture.type === fm.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
			if ( texture.type === fm.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			_infoMemory.textures ++;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

			image = makePowerOfTwo( image );

		}

		var isPowerOfTwoImage = isPowerOfTwo( image ),
		glFormat = paramThreeToGL( texture.format ),
		glType = paramThreeToGL( texture.type );

		setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture instanceof fm.DepthTexture ) {

			// populate depth texture with dummy data

			var internalFormat = _gl.DEPTH_COMPONENT;

			if ( texture.type === fm.FloatType ) {

				if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
				internalFormat = _gl.DEPTH_COMPONENT32F;

			} else if ( _isWebGL2 ) {

				// WebGL 2.0 requires signed internalformat for glTexImage2D
				internalFormat = _gl.DEPTH_COMPONENT16;

			}

			state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

		} else if ( texture instanceof fm.DataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			}

		} else if ( texture instanceof fm.CompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== fm.RGBAFormat && texture.format !== fm.RGBFormat ) {

					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( "fm.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

					}

				} else {

					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

			}

		}

		if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	function setTexture2D( texture, slot ) {

		if ( texture instanceof fm.WebGLRenderTarget ) texture = texture.texture;

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			var image = texture.image;

			if ( image === undefined ) {

				console.warn( 'fm.WebGLRenderer: Texture marked for update but image is undefined', texture );
				return;

			}

			if ( image.complete === false ) {

				console.warn( 'fm.WebGLRenderer: Texture marked for update but image is incomplete', texture );
				return;

			}

			uploadTexture( textureProperties, texture, slot );

			return;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

	}

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width > maxSize || image.height > maxSize ) {

			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.

			var scale = maxSize / Math.max( image.width, image.height );

			var canvas = document.createElement( 'canvas' );
			canvas.width = Math.floor( image.width * scale );
			canvas.height = Math.floor( image.height * scale );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

			console.warn( 'fm.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return fm.Math.isPowerOfTwo( image.width ) && fm.Math.isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( texture.wrapS !== fm.ClampToEdgeWrapping || texture.wrapT !== fm.ClampToEdgeWrapping ) return true;
		if ( texture.minFilter !== fm.NearestFilter && texture.minFilter !== fm.LinearFilter ) return true;

		return false;

	}

	function makePowerOfTwo( image ) {

		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

			var canvas = document.createElement( 'canvas' );
			canvas.width = fm.Math.nearestPowerOfTwo( image.width );
			canvas.height = fm.Math.nearestPowerOfTwo( image.height );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, canvas.width, canvas.height );

			console.warn( 'fm.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function setCubeTexture ( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.image.length === 6 ) {

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				if ( ! textureProperties.__image__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					textureProperties.__image__webglTextureCube = _gl.createTexture();

					_infoMemory.textures ++;

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof fm.CompressedTexture;
				var isDataTexture = texture.image[ 0 ] instanceof fm.DataTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== fm.RGBAFormat && texture.format !== fm.RGBFormat ) {

								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( "fm.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( texture.generateMipmaps && isPowerOfTwoImage ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				textureProperties.__version = texture.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			} else {

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

			}

		}

	}

	function setCubeTextureDynamic ( texture, slot ) {

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

	}

	var setTextureWarned = false;
	this.setTexture = function( texture, slot ) {

		if ( ! setTextureWarned ) {

			console.warn( "fm.WebGLRenderer: .setTexture is deprecated, " +
				"use setTexture2D instead." );
			setTextureWarned = true;

		}

		setTexture2D( texture, slot );

	};

	this.allocTextureUnit = allocTextureUnit;
	this.setTexture2D = setTexture2D;
	this.setTextureCube = function( texture, slot ) {

		if ( texture instanceof fm.CubeTexture ||
			 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

			// CompressedTexture can have Array in image :/

			setCubeTexture( texture, slot );

		} else {
			// assumed: texture instanceof fm.WebGLRenderTargetCube

			setCubeTextureDynamic( texture.texture, slot );

		}

	};

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {

		var glFormat = paramThreeToGL( renderTarget.texture.format );
		var glType = paramThreeToGL( renderTarget.texture.type );
		state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage ( renderbuffer, renderTarget ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			// FIXME: We don't support !depth !stencil
			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture ( framebuffer, renderTarget ) {

		var isCube = ( renderTarget instanceof fm.WebGLRenderTargetCube );
		if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		if ( !( renderTarget.depthTexture instanceof fm.DepthTexture ) ) {

			throw new Error('renderTarget.depthTexture must be an instance of fm.DepthTexture');

		}

		// upload an empty depth texture with framebuffer size
		if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {
			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;
		}

		_this.setTexture( renderTarget.depthTexture, 0 );

		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );

		var isCube = ( renderTarget instanceof fm.WebGLRenderTargetCube );

		if ( renderTarget.depthTexture ) {

			if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

				}

			} else {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

			}

		}

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		textureProperties.__webglTexture = _gl.createTexture();

		_infoMemory.textures ++;

		var isCube = ( renderTarget instanceof fm.WebGLRenderTargetCube );
		var isTargetPowerOfTwo = fm.Math.isPowerOfTwo( renderTarget.width ) && fm.Math.isPowerOfTwo( renderTarget.height );

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( var i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

			for ( var i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

			}

			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
			state.bindTexture( _gl.TEXTURE_2D, null );

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	this.getCurrentRenderTarget = function() {

		return _currentRenderTarget;

	};

	this.setRenderTarget = function ( renderTarget ) {

		_currentRenderTarget = renderTarget;

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			setupRenderTarget( renderTarget );

		}

		var isCube = ( renderTarget instanceof fm.WebGLRenderTargetCube );
		var framebuffer;

		if ( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			if ( isCube ) {

				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTargetProperties.__webglFramebuffer;

			}

			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

			_currentViewport.copy( renderTarget.viewport );

		} else {

			framebuffer = null;

			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
			_currentScissorTest = _scissorTest;

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );

		}

		if ( _currentFramebuffer !== framebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_currentFramebuffer = framebuffer;

		}

		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		state.viewport( _currentViewport );

		if ( isCube ) {

			var textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

		}

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

		if ( renderTarget instanceof fm.WebGLRenderTarget === false ) {

			console.error( 'fm.WebGLRenderer.readRenderTargetPixels: renderTarget is not fm.WebGLRenderTarget.' );
			return;

		}

		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( framebuffer ) {

			var restore = false;

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				restore = true;

			}

			try {

				var texture = renderTarget.texture;

				if ( texture.format !== fm.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

					console.error( 'fm.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				if ( texture.type !== fm.UnsignedByteType &&
				     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&
				     ! ( texture.type === fm.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&
				     ! ( texture.type === fm.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

					console.error( 'fm.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x > 0 && x <= ( renderTarget.width - width ) ) && ( y > 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );

					}

				} else {

					console.error( 'fm.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				if ( restore ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

				}

			}

		}

	};

	function updateRenderTargetMipmap( renderTarget ) {

		var target = renderTarget instanceof fm.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
		var texture = properties.get( renderTarget.texture ).__webglTexture;

		state.bindTexture( target, texture );
		_gl.generateMipmap( target );
		state.bindTexture( target, null );

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === fm.NearestFilter || f === fm.NearestMipMapNearestFilter || f === fm.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	// Map fm.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		var extension;

		if ( p === fm.RepeatWrapping ) return _gl.REPEAT;
		if ( p === fm.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === fm.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === fm.NearestFilter ) return _gl.NEAREST;
		if ( p === fm.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === fm.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === fm.LinearFilter ) return _gl.LINEAR;
		if ( p === fm.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === fm.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === fm.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === fm.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === fm.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === fm.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === fm.ByteType ) return _gl.BYTE;
		if ( p === fm.ShortType ) return _gl.SHORT;
		if ( p === fm.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === fm.IntType ) return _gl.INT;
		if ( p === fm.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === fm.FloatType ) return _gl.FLOAT;

		extension = extensions.get( 'OES_texture_half_float' );

		if ( extension !== null ) {

			if ( p === fm.HalfFloatType ) return extension.HALF_FLOAT_OES;

		}

		if ( p === fm.AlphaFormat ) return _gl.ALPHA;
		if ( p === fm.RGBFormat ) return _gl.RGB;
		if ( p === fm.RGBAFormat ) return _gl.RGBA;
		if ( p === fm.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === fm.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
		if ( p === fm.DepthFormat ) return _gl.DEPTH_COMPONENT;

		if ( p === fm.AddEquation ) return _gl.FUNC_ADD;
		if ( p === fm.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === fm.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === fm.ZeroFactor ) return _gl.ZERO;
		if ( p === fm.OneFactor ) return _gl.ONE;
		if ( p === fm.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === fm.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === fm.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === fm.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === fm.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === fm.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === fm.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === fm.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === fm.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

		if ( extension !== null ) {

			if ( p === fm.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === fm.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === fm.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === fm.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		if ( extension !== null ) {

			if ( p === fm.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
			if ( p === fm.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
			if ( p === fm.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
			if ( p === fm.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

		}

		extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

		if ( extension !== null ) {

			if ( p === fm.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

		}

		extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			if ( p === fm.MinEquation ) return extension.MIN_EXT;
			if ( p === fm.MaxEquation ) return extension.MAX_EXT;

		}

		return 0;

	}

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
fm.WebGLRenderTarget = function ( width, height, options ) {

	this.uuid = fm.Math.generateUUID();

	this.width = width;
	this.height = height;

	this.scissor = new fm.Vector4( 0, 0, width, height );
	this.scissorTest = false;

	this.viewport = new fm.Vector4( 0, 0, width, height );

	options = options || {};

	if ( options.minFilter === undefined ) options.minFilter = fm.LinearFilter;

	this.texture = new fm.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	this.depthTexture = null;

};

fm.WebGLRenderTarget.prototype = {

	constructor: fm.WebGLRenderTarget,

	setSize: function ( width, height ) {

		if ( this.width !== width || this.height !== height ) {

			this.width = width;
			this.height = height;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.width = source.width;
		this.height = source.height;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

fm.EventDispatcher.prototype.apply( fm.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

fm.WebGLRenderTargetCube = function ( width, height, options ) {

	fm.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
	this.activeMipMapLevel = 0;

};

fm.WebGLRenderTargetCube.prototype = Object.create( fm.WebGLRenderTarget.prototype );
fm.WebGLRenderTargetCube.prototype.constructor = fm.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

fm.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		_gl.drawArrays( mode, start, count );

		_infoRender.calls ++;
		_infoRender.vertices += count;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

	}

	function renderInstances( geometry ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'fm.WebGLBufferRenderer: using fm.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		var position = geometry.attributes.position;

		var count = 0;

		if ( position instanceof fm.InterleavedBufferAttribute ) {

			count = position.data.count;

			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

		} else {

			count = position.count;

			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

		}

		_infoRender.calls ++;
		_infoRender.vertices += count * geometry.maxInstancedCount;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;

	}

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

fm.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	var type, size;

	function setIndex( index ) {

		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

			type = _gl.UNSIGNED_INT;
			size = 4;

		} else {

			type = _gl.UNSIGNED_SHORT;
			size = 2;

		}

	}

	function render( start, count ) {

		_gl.drawElements( mode, count, type, start * size );

		_infoRender.calls ++;
		_infoRender.vertices += count;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

	}

	function renderInstances( geometry, start, count ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'fm.WebGLBufferRenderer: using fm.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );

		_infoRender.calls ++;
		_infoRender.vertices += count * geometry.maxInstancedCount;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;
	}

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLExtensions.js

/**
* @author mrdoob / http://mrdoob.com/
*/

fm.WebGLExtensions = function ( gl ) {

	var extensions = {};

	this.get = function ( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		var extension;

		switch ( name ) {

			case 'WEBGL_depth_texture':
				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			case 'WEBGL_compressed_texture_etc1':
				extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		if ( extension === null ) {

			console.warn( 'fm.WebGLRenderer: ' + name + ' extension not supported.' );

		}

		extensions[ name ] = extension;

		return extension;

	};

};

// File:src/renderers/webgl/WebGLCapabilities.js

fm.WebGLCapabilities = function ( gl, extensions, parameters ) {

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	this.getMaxPrecision = getMaxPrecision;

	this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
	this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

	this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

	this.vertexTextures = this.maxVertexTextures > 0;
	this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
	this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

	var _maxPrecision = getMaxPrecision( this.precision );

	if ( _maxPrecision !== this.precision ) {

		console.warn( 'fm.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
		this.precision = _maxPrecision;

	}

	if ( this.logarithmicDepthBuffer ) {

		this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );

	}

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
* @author mrdoob / http://mrdoob.com/
*/

fm.WebGLGeometries = function ( gl, properties, info ) {

	var geometries = {};

	function get( object ) {

		var geometry = object.geometry;

		if ( geometries[ geometry.id ] !== undefined ) {

			return geometries[ geometry.id ];

		}

		geometry.addEventListener( 'dispose', onGeometryDispose );

		var buffergeometry;

		if ( geometry instanceof fm.BufferGeometry ) {

			buffergeometry = geometry;

		} else if ( geometry instanceof fm.Geometry ) {

			if ( geometry._bufferGeometry === undefined ) {

				geometry._bufferGeometry = new fm.BufferGeometry().setFromObject( object );

			}

			buffergeometry = geometry._bufferGeometry;

		}

		geometries[ geometry.id ] = buffergeometry;

		info.memory.geometries ++;

		return buffergeometry;

	}

	function onGeometryDispose( event ) {

		var geometry = event.target;
		var buffergeometry = geometries[ geometry.id ];

		if ( buffergeometry.index !== null ) {

			deleteAttribute( buffergeometry.index );

		}

		deleteAttributes( buffergeometry.attributes );

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		// TODO

		var property = properties.get( geometry );

		if ( property.wireframe ) {

			deleteAttribute( property.wireframe );

		}

		properties.delete( geometry );

		var bufferproperty = properties.get( buffergeometry );

		if ( bufferproperty.wireframe ) {

			deleteAttribute( bufferproperty.wireframe );

		}

		properties.delete( buffergeometry );

		//

		info.memory.geometries --;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute instanceof fm.InterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function deleteAttribute( attribute ) {

		var buffer = getAttributeBuffer( attribute );

		if ( buffer !== undefined ) {

			gl.deleteBuffer( buffer );
			removeAttributeBuffer( attribute );

		}

	}

	function deleteAttributes( attributes ) {

		for ( var name in attributes ) {

			deleteAttribute( attributes[ name ] );

		}

	}

	function removeAttributeBuffer( attribute ) {

		if ( attribute instanceof fm.InterleavedBufferAttribute ) {

			properties.delete( attribute.data );

		} else {

			properties.delete( attribute );

		}

	}

	this.get = get;

};

// File:src/renderers/webgl/WebGLLights.js

/**
* @author mrdoob / http://mrdoob.com/
*/

fm.WebGLLights = function () {

	var lights = {};

	this.get = function ( light ) {

		if ( lights[ light.id ] !== undefined ) {

			return lights[ light.id ];

		}

		var uniforms;

		switch ( light.type ) {

			case 'DirectionalLight':
				uniforms = {
					direction: new fm.Vector3(),
					color: new fm.Color(),

					shadow: false,
					shadowBias: 0,
					shadowRadius: 1,
					shadowMapSize: new fm.Vector2()
				};
				break;

			case 'SpotLight':
				uniforms = {
					position: new fm.Vector3(),
					direction: new fm.Vector3(),
					color: new fm.Color(),
					distance: 0,
					coneCos: 0,
					penumbraCos: 0,
					decay: 0,

					shadow: false,
					shadowBias: 0,
					shadowRadius: 1,
					shadowMapSize: new fm.Vector2()
				};
				break;

			case 'PointLight':
				uniforms = {
					position: new fm.Vector3(),
					color: new fm.Color(),
					distance: 0,
					decay: 0,

					shadow: false,
					shadowBias: 0,
					shadowRadius: 1,
					shadowMapSize: new fm.Vector2()
				};
				break;

			case 'HemisphereLight':
				uniforms = {
					direction: new fm.Vector3(),
					skyColor: new fm.Color(),
					groundColor: new fm.Color()
				};
				break;

		}

		lights[ light.id ] = uniforms;

		return uniforms;

	};

};

// File:src/renderers/webgl/WebGLObjects.js

/**
* @author mrdoob / http://mrdoob.com/
*/

fm.WebGLObjects = function ( gl, properties, info ) {

	var geometries = new fm.WebGLGeometries( gl, properties, info );

	//

	function update( object ) {

		// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

		var geometry = geometries.get( object );

		if ( object.geometry instanceof fm.Geometry ) {

			geometry.updateFromObject( object );

		}

		var index = geometry.index;
		var attributes = geometry.attributes;

		if ( index !== null ) {

			updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

		}

		for ( var name in attributes ) {

			updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

		}

		// morph targets

		var morphAttributes = geometry.morphAttributes;

		for ( var name in morphAttributes ) {

			var array = morphAttributes[ name ];

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				updateAttribute( array[ i ], gl.ARRAY_BUFFER );

			}

		}

		return geometry;

	}

	function updateAttribute( attribute, bufferType ) {

		var data = ( attribute instanceof fm.InterleavedBufferAttribute ) ? attribute.data : attribute;

		var attributeProperties = properties.get( data );

		if ( attributeProperties.__webglBuffer === undefined ) {

			createBuffer( attributeProperties, data, bufferType );

		} else if ( attributeProperties.version !== data.version ) {

			updateBuffer( attributeProperties, data, bufferType );

		}

	}

	function createBuffer( attributeProperties, data, bufferType ) {

		attributeProperties.__webglBuffer = gl.createBuffer();
		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

		gl.bufferData( bufferType, data.array, usage );

		attributeProperties.version = data.version;

	}

	function updateBuffer( attributeProperties, data, bufferType ) {

		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		if ( data.dynamic === false || data.updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, data.array );

		} else if ( data.updateRange.count === 0 ) {

			console.error( 'fm.WebGLObjects.updateBuffer: dynamic fm.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

		} else {

			gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
							  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

			data.updateRange.count = 0; // reset range

		}

		attributeProperties.version = data.version;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute instanceof fm.InterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function getWireframeAttribute( geometry ) {

		var property = properties.get( geometry );

		if ( property.wireframe !== undefined ) {

			return property.wireframe;

		}

		var indices = [];

		var index = geometry.index;
		var attributes = geometry.attributes;
		var position = attributes.position;

		// console.time( 'wireframe' );

		if ( index !== null ) {

			var edges = {};
			var array = index.array;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var a = array[ i + 0 ];
				var b = array[ i + 1 ];
				var c = array[ i + 2 ];

				if ( checkEdge( edges, a, b ) ) indices.push( a, b );
				if ( checkEdge( edges, b, c ) ) indices.push( b, c );
				if ( checkEdge( edges, c, a ) ) indices.push( c, a );

			}

		} else {

			var array = attributes.position.array;

			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				var a = i + 0;
				var b = i + 1;
				var c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		// console.timeEnd( 'wireframe' );

		var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
		var attribute = new fm.BufferAttribute( new TypeArray( indices ), 1 );

		updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

		property.wireframe = attribute;

		return attribute;

	}

	function checkEdge( edges, a, b ) {

		if ( a > b ) {

			var tmp = a;
			a = b;
			b = tmp;

		}

		var list = edges[ a ];

		if ( list === undefined ) {

			edges[ a ] = [ b ];
			return true;

		} else if ( list.indexOf( b ) === -1 ) {

			list.push( b );
			return true;

		}

		return false;

	}

	this.getAttributeBuffer = getAttributeBuffer;
	this.getWireframeAttribute = getWireframeAttribute;

	this.update = update;

};

// File:src/renderers/webgl/WebGLProgram.js

fm.WebGLProgram = ( function () {

	var programIdCount = 0;

	function getEncodingComponents( encoding ) {

		switch ( encoding ) {

			case fm.LinearEncoding:
				return [ 'Linear','( value )' ];
			case fm.sRGBEncoding:
				return [ 'sRGB','( value )' ];
			case fm.RGBEEncoding:
				return [ 'RGBE','( value )' ];
			case fm.RGBM7Encoding:
				return [ 'RGBM','( value, 7.0 )' ];
			case fm.RGBM16Encoding:
				return [ 'RGBM','( value, 16.0 )' ];
			case fm.RGBDEncoding:
				return [ 'RGBD','( value, 256.0 )' ];
			case fm.GammaEncoding:
				return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
			default:
				throw new Error( 'unsupported encoding: ' + encoding );

		}

	}

	function getTexelDecodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

	}

	function getTexelEncodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		var toneMappingName;

		switch ( toneMapping ) {

			case fm.LinearToneMapping:
				toneMappingName = "Linear";
				break;

			case fm.ReinhardToneMapping:
				toneMappingName = "Reinhard";
				break;

			case fm.Uncharted2ToneMapping:
				toneMappingName = "Uncharted2";
				break;

			case fm.CineonToneMapping:
				toneMappingName = "OptimizedCineon";
				break;

			default:
				throw new Error( 'unsupported toneMapping: ' + toneMapping );

		}

		return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

	}

	function generateExtensions( extensions, parameters, rendererExtensions ) {

		extensions = extensions || {};

		var chunks = [
			( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
			( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		var chunks = [];

		for ( var name in defines ) {

			var value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program, identifiers ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log("fm.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

	}

	function parseIncludes( string ) {

		var pattern = /#include +<([\w\d.]+)>/g;

		function replace( match, include ) {

			var replace = fm.ShaderChunk[ include ];

			if ( replace === undefined ) {

				throw new Error( 'Can not resolve #include <' + include + '>' );

			}

			return parseIncludes( replace );

		}

		return string.replace( pattern, replace );

	}

	function unrollLoops( string ) {

		var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

		function replace( match, start, end, snippet ) {

			var unroll = '';

			for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

				unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

			}

			return unroll;

		}

		return string.replace( pattern, replace );

	}

	return function WebGLProgram( renderer, code, material, parameters ) {

		var gl = renderer.context;

		var extensions = material.extensions;
		var defines = material.defines;

		var vertexShader = material.__webglShader.vertexShader;
		var fragmentShader = material.__webglShader.fragmentShader;

		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === fm.PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === fm.PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		}

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if ( parameters.envMap ) {

			switch ( material.envMap.mapping ) {

				case fm.CubeReflectionMapping:
				case fm.CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case fm.CubeUVReflectionMapping:
				case fm.CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

				case fm.EquirectangularReflectionMapping:
				case fm.EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;

				case fm.SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;

			}

			switch ( material.envMap.mapping ) {

				case fm.CubeRefractionMapping:
				case fm.EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

			switch ( material.combine ) {

				case fm.MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case fm.MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case fm.AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		// console.log( 'building new program ' );

		//

		var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );

		var customDefines = generateDefines( defines );

		//

		var program = gl.createProgram();

		var prefixVertex, prefixFragment;

		if ( material instanceof fm.RawShaderMaterial ) {

			prefixVertex = '';
			prefixFragment = '';

		} else {

			prefixVertex = [

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + material.__webglShader.name,

				customDefines,

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_BONES ' + parameters.maxBones,

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + material.__webglShader.name,

				customDefines,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

				parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',

				( parameters.toneMapping !== fm.NoToneMapping ) ? "#define TONE_MAPPING" : '',
				( parameters.toneMapping !== fm.NoToneMapping ) ? fm.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== fm.NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

				( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? fm.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
				parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
				parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
				parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',

				parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = parseIncludes( vertexShader, parameters );
		vertexShader = replaceLightNums( vertexShader, parameters );

		fragmentShader = parseIncludes( fragmentShader, parameters );
		fragmentShader = replaceLightNums( fragmentShader, parameters );

		if ( material instanceof fm.ShaderMaterial === false ) {

			vertexShader = unrollLoops( vertexShader );
			fragmentShader = unrollLoops( fragmentShader );

		}

		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		var glVertexShader = fm.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		var glFragmentShader = fm.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( material.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, material.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		var programLog = gl.getProgramInfoLog( program );
		var vertexLog = gl.getShaderInfoLog( glVertexShader );
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

		var runnable = true;
		var haveDiagnostics = true;

		// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
		// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

		if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

			runnable = false;

			console.error( 'fm.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

		} else if ( programLog !== '' ) {

			console.warn( 'fm.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,
				material: material,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

		// clean up

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function() {

			if ( cachedUniforms === undefined ) {

				cachedUniforms =
						new fm.WebGLUniforms( gl, program, renderer );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		var cachedAttributes;

		this.getAttributes = function() {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function() {

			gl.deleteProgram( program );
			this.program = undefined;

		};

		// DEPRECATED

		Object.defineProperties( this, {

			uniforms: {
				get: function() {

					console.warn( 'fm.WebGLProgram: .uniforms is now .getUniforms().' );
					return this.getUniforms();

				}
			},

			attributes: {
				get: function() {

					console.warn( 'fm.WebGLProgram: .attributes is now .getAttributes().' );
					return this.getAttributes();

				}
			}

		} );


		//

		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	};

} )();

// File:src/renderers/webgl/WebGLPrograms.js

fm.WebGLPrograms = function ( renderer, capabilities ) {

	var programs = [];

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points'
	};

	var parameterNames = [
		"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
		"roughnessMap", "metalnessMap",
		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"
	];


	function allocateBones ( object ) {

		if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = capabilities.maxVertexUniforms;
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof fm.SkinnedMesh ) {

				maxBones = Math.min( object.skeleton.bones.length, maxBones );

				if ( maxBones < object.skeleton.bones.length ) {

					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

				}

			}

			return maxBones;

		}

	}

	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

		var encoding;

		if ( ! map ) {

			encoding = fm.LinearEncoding;

		} else if ( map instanceof fm.Texture ) {

			encoding = map.encoding;

		} else if ( map instanceof fm.WebGLRenderTarget ) {

			encoding = map.texture.encoding;

		}

		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
		if ( encoding === fm.LinearEncoding && gammaOverrideLinear ) {

			encoding = fm.GammaEncoding;

		}

		return encoding;

	}

	this.getParameters = function ( material, lights, fog, nClipPlanes, object ) {

		var shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxBones = allocateBones( object );
		var precision = renderer.getPrecision();

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'fm.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		var parameters = {

			shaderID: shaderID,

			precision: precision,
			supportsVertexTextures: capabilities.vertexTextures,
			outputEncoding: getTextureEncodingFromMap( renderer.getCurrentRenderTarget(), renderer.gammaOutput ),
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
			envMap: !! material.envMap,
			envMapMode: material.envMap && material.envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === fm.CubeUVReflectionMapping ) || ( material.envMap.mapping === fm.CubeUVRefractionMapping ) ),
			lightMap: !! material.lightMap,
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			combine: material.combine,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof fm.FogExp2,

			flatShading: material.shading === fm.FlatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numHemiLights: lights.hemi.length,

			numClippingPlanes: nClipPlanes,

			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: renderer.toneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			alphaTest: material.alphaTest,
			doubleSided: material.side === fm.DoubleSide,
			flipSided: material.side === fm.BackSide,

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

		};

		return parameters;

	};

	this.getProgramCode = function ( material, parameters ) {

		var array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( material.fragmentShader );
			array.push( material.vertexShader );

		}

		if ( material.defines !== undefined ) {

			for ( var name in material.defines ) {

				array.push( name );
				array.push( material.defines[ name ] );

			}

		}

		for ( var i = 0; i < parameterNames.length; i ++ ) {

			array.push( parameters[ parameterNames[ i ] ] );

		}

		return array.join();

	};

	this.acquireProgram = function ( material, parameters, code ) {

		var program;

		// Check if code has been already compiled
		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

			var programInfo = programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new fm.WebGLProgram( renderer, code, material, parameters );
			programs.push( program );

		}

		return program;

	};

	this.releaseProgram = function( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			var i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	};

	// Exposed for resource monitoring & error feedback via renderer.info:
	this.programs = programs;

};

// File:src/renderers/webgl/WebGLProperties.js

/**
* @author fordacious / fordacious.github.io
*/

fm.WebGLProperties = function () {

	var properties = {};

	this.get = function ( object ) {

		var uuid = object.uuid;
		var map = properties[ uuid ];

		if ( map === undefined ) {

			map = {};
			properties[ uuid ] = map;

		}

		return map;

	};

	this.delete = function ( object ) {

		delete properties[ object.uuid ];

	};

	this.clear = function () {

		properties = {};

	};

};

// File:src/renderers/webgl/WebGLShader.js

fm.WebGLShader = ( function () {

	function addLineNumbers( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	return function WebGLShader( gl, type, string ) {

		var shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

			console.error( 'fm.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'fm.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	};

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

fm.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

	var _gl = _renderer.context,
	_state = _renderer.state,
	_frustum = new fm.Frustum(),
	_projScreenMatrix = new fm.Matrix4(),

	_lightShadows = _lights.shadows,

	_shadowMapSize = new fm.Vector2(),

	_lookTarget = new fm.Vector3(),
	_lightPositionWorld = new fm.Vector3(),

	_renderList = [],

	_MorphingFlag = 1,
	_SkinningFlag = 2,

	_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

	_depthMaterials = new Array( _NumberOfMaterialVariants ),
	_distanceMaterials = new Array( _NumberOfMaterialVariants ),

	_materialCache = {};

	var cubeDirections = [
		new fm.Vector3( 1, 0, 0 ), new fm.Vector3( - 1, 0, 0 ), new fm.Vector3( 0, 0, 1 ),
		new fm.Vector3( 0, 0, - 1 ), new fm.Vector3( 0, 1, 0 ), new fm.Vector3( 0, - 1, 0 )
	];

	var cubeUps = [
		new fm.Vector3( 0, 1, 0 ), new fm.Vector3( 0, 1, 0 ), new fm.Vector3( 0, 1, 0 ),
		new fm.Vector3( 0, 1, 0 ), new fm.Vector3( 0, 0, 1 ),	new fm.Vector3( 0, 0, - 1 )
	];

	var cube2DViewPorts = [
		new fm.Vector4(), new fm.Vector4(), new fm.Vector4(),
		new fm.Vector4(), new fm.Vector4(), new fm.Vector4()
	];

	// init

	var depthMaterialTemplate = new fm.MeshDepthMaterial();
	depthMaterialTemplate.depthPacking = fm.RGBADepthPacking;
	depthMaterialTemplate.clipping = true;

	var distanceShader = fm.ShaderLib[ "distanceRGBA" ];
	var distanceUniforms = fm.UniformsUtils.clone( distanceShader.uniforms );

	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

		var useMorphing = ( i & _MorphingFlag ) !== 0;
		var useSkinning = ( i & _SkinningFlag ) !== 0;

		var depthMaterial = depthMaterialTemplate.clone();
		depthMaterial.morphTargets = useMorphing;
		depthMaterial.skinning = useSkinning;

		_depthMaterials[ i ] = depthMaterial;

		var distanceMaterial = new fm.ShaderMaterial( {
			defines: {
				'USE_SHADOWMAP': ''
			},
			uniforms: distanceUniforms,
			vertexShader: distanceShader.vertexShader,
			fragmentShader: distanceShader.fragmentShader,
			morphTargets: useMorphing,
			skinning: useSkinning,
			clipping: true
		} );

		_distanceMaterials[ i ] = distanceMaterial;

	}

	//

	var scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = fm.PCFShadowMap;
	this.cullFace = fm.CullFaceFront;

	this.render = function ( scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( _lightShadows.length === 0 ) return;

		// Set GL state for depth map.
		_state.clearColor( 1, 1, 1, 1 );
		_state.disable( _gl.BLEND );
		_state.enable( _gl.CULL_FACE );
		_gl.frontFace( _gl.CCW );
		_gl.cullFace( scope.cullFace === fm.CullFaceFront ? _gl.FRONT : _gl.BACK );
		_state.setDepthTest( true );
		_state.setScissorTest( false );

		// render depth map

		var faceCount, isPointLight;

		for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {

			var light = _lightShadows[ i ];

			var shadow = light.shadow;
			var shadowCamera = shadow.camera;

			_shadowMapSize.copy( shadow.mapSize );

			if ( light instanceof fm.PointLight ) {

				faceCount = 6;
				isPointLight = true;

				var vpWidth = _shadowMapSize.x;
				var vpHeight = _shadowMapSize.y;

				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
				// negative X
				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
				// positive Z
				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
				// negative Z
				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
				// positive Y
				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
				// negative Y
				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

				_shadowMapSize.x *= 4.0;
				_shadowMapSize.y *= 2.0;

			} else {

				faceCount = 1;
				isPointLight = false;

			}

			if ( shadow.map === null ) {

				var pars = { minFilter: fm.NearestFilter, magFilter: fm.NearestFilter, format: fm.RGBAFormat };

				shadow.map = new fm.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

				shadowCamera.updateProjectionMatrix();

			}

			if ( shadow instanceof fm.SpotLightShadow ) {

				shadow.update( light );

			}

			var shadowMap = shadow.map;
			var shadowMatrix = shadow.matrix;

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( _lightPositionWorld );

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// render shadow map for each cube face (if omni-directional) or
			// run a single pass if not

			for ( var face = 0; face < faceCount; face ++ ) {

				if ( isPointLight ) {

					_lookTarget.copy( shadowCamera.position );
					_lookTarget.add( cubeDirections[ face ] );
					shadowCamera.up.copy( cubeUps[ face ] );
					shadowCamera.lookAt( _lookTarget );

					var vpDimensions = cube2DViewPorts[ face ];
					_state.viewport( vpDimensions );

				} else {

					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
					shadowCamera.lookAt( _lookTarget );

				}

				shadowCamera.updateMatrixWorld();
				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

				// compute shadow matrix

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);

				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				// update camera matrices and frustum

				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				// set object matrices & frustum culling

				_renderList.length = 0;

				projectObject( scene, camera, shadowCamera );

				// render shadow map
				// render regular objects

				for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

					var object = _renderList[ j ];
					var geometry = _objects.update( object );
					var material = object.material;

					if ( material instanceof fm.MultiMaterial ) {

						var groups = geometry.groups;
						var materials = material.materials;

						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

							var group = groups[ k ];
							var groupMaterial = materials[ group.materialIndex ];

							if ( groupMaterial.visible === true ) {

								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else {

						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

		}

		// Restore GL state.
		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();
		_renderer.setClearColor( clearColor, clearAlpha );

		_state.enable( _gl.BLEND );

		if ( scope.cullFace === fm.CullFaceFront ) {

			_gl.cullFace( _gl.BACK );

		}

		scope.needsUpdate = false;

	};

	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

		var geometry = object.geometry;

		var result = null;

		var materialVariants = _depthMaterials;
		var customMaterial = object.customDepthMaterial;

		if ( isPointLight ) {

			materialVariants = _distanceMaterials;
			customMaterial = object.customDistanceMaterial;

		}

		if ( ! customMaterial ) {

			var useMorphing = geometry.morphTargets !== undefined &&
					geometry.morphTargets.length > 0 && material.morphTargets;

			var useSkinning = object instanceof fm.SkinnedMesh && material.skinning;

			var variantIndex = 0;

			if ( useMorphing ) variantIndex |= _MorphingFlag;
			if ( useSkinning ) variantIndex |= _SkinningFlag;

			result = materialVariants[ variantIndex ];

		} else {

			result = customMaterial;

		}

		if ( _renderer.localClippingEnabled &&
			 material.clipShadows === true &&
				material.clippingPlanes.length !== 0 ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			var keyA = result.uuid, keyB = material.uuid;

			var materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			var cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;
		result.side = material.side;
		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( isPointLight && result.uniforms.lightPos !== undefined ) {

			result.uniforms.lightPos.value.copy( lightPositionWorld );

		}

		return result;

	}

	function projectObject( object, camera, shadowCamera ) {

		if ( object.visible === false ) return;

		if ( object.layers.test( camera.layers ) && ( object instanceof fm.Mesh || object instanceof fm.Line || object instanceof fm.Points ) ) {

			if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

				var material = object.material;

				if ( material.visible === true ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
					_renderList.push( object );

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, shadowCamera );

		}

	}

};

// File:src/renderers/webgl/WebGLState.js

/**
* @author mrdoob / http://mrdoob.com/
*/

fm.WebGLState = function ( gl, extensions, paramThreeToGL ) {

	var _this = this;

	var color = new fm.Vector4();

	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	var newAttributes = new Uint8Array( maxVertexAttributes );
	var enabledAttributes = new Uint8Array( maxVertexAttributes );
	var attributeDivisors = new Uint8Array( maxVertexAttributes );

	var capabilities = {};

	var compressedTextureFormats = null;

	var currentBlending = null;
	var currentBlendEquation = null;
	var currentBlendSrc = null;
	var currentBlendDst = null;
	var currentBlendEquationAlpha = null;
	var currentBlendSrcAlpha = null;
	var currentBlendDstAlpha = null;
	var currentPremultipledAlpha = false;

	var currentDepthFunc = null;
	var currentDepthWrite = null;

	var currentColorWrite = null;

	var currentStencilWrite = null;
	var currentStencilFunc = null;
	var currentStencilRef = null;
	var currentStencilMask = null;
	var currentStencilFail  = null;
	var currentStencilZFail = null;
	var currentStencilZPass = null;

	var currentFlipSided = null;

	var currentLineWidth = null;

	var currentPolygonOffsetFactor = null;
	var currentPolygonOffsetUnits = null;

	var currentScissorTest = null;

	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

	var currentTextureSlot = undefined;
	var currentBoundTextures = {};

	var currentClearColor = new fm.Vector4();
	var currentClearDepth = null;
	var currentClearStencil = null;

	var currentScissor = new fm.Vector4();
	var currentViewport = new fm.Vector4();

	this.init = function () {

		this.clearColor( 0, 0, 0, 1 );
		this.clearDepth( 1 );
		this.clearStencil( 0 );

		this.enable( gl.DEPTH_TEST );
		gl.depthFunc( gl.LEQUAL );

		gl.frontFace( gl.CCW );
		gl.cullFace( gl.BACK );
		this.enable( gl.CULL_FACE );

		this.enable( gl.BLEND );
		gl.blendEquation( gl.FUNC_ADD );
		gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

	};

	this.initAttributes = function () {

		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

			newAttributes[ i ] = 0;

		}

	};

	this.enableAttribute = function ( attribute ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== 0 ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			extension.vertexAttribDivisorANGLE( attribute, 0 );
			attributeDivisors[ attribute ] = 0;

		}

	};

	this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	};

	this.disableUnusedAttributes = function () {

		for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	};

	this.enable = function ( id ) {

		if ( capabilities[ id ] !== true ) {

			gl.enable( id );
			capabilities[ id ] = true;

		}

	};

	this.disable = function ( id ) {

		if ( capabilities[ id ] !== false ) {

			gl.disable( id );
			capabilities[ id ] = false;

		}

	};

	this.getCompressedTextureFormats = function () {

		if ( compressedTextureFormats === null ) {

			compressedTextureFormats = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ) {

					compressedTextureFormats.push( formats[ i ] );

				}

			}

		}

		return compressedTextureFormats;

	};

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending === fm.NoBlending ) {

			this.disable( gl.BLEND );

		} else {

			this.enable( gl.BLEND );

		}

		if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

			if ( blending === fm.AdditiveBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

				}

			} else if ( blending === fm.SubtractiveBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

				}

			} else if ( blending === fm.MultiplyBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.SRC_COLOR, gl.SRC_ALPHA );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

				}

			} else {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				} else {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				}

			}

			currentBlending = blending;
			currentPremultipledAlpha = premultipliedAlpha;

		}

		if ( blending === fm.CustomBlending ) {

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

		} else {

			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;

		}

	};

	this.setDepthFunc = function ( depthFunc ) {

		if ( currentDepthFunc !== depthFunc ) {

			if ( depthFunc ) {

				switch ( depthFunc ) {

					case fm.NeverDepth:

						gl.depthFunc( gl.NEVER );
						break;

					case fm.AlwaysDepth:

						gl.depthFunc( gl.ALWAYS );
						break;

					case fm.LessDepth:

						gl.depthFunc( gl.LESS );
						break;

					case fm.LessEqualDepth:

						gl.depthFunc( gl.LEQUAL );
						break;

					case fm.EqualDepth:

						gl.depthFunc( gl.EQUAL );
						break;

					case fm.GreaterEqualDepth:

						gl.depthFunc( gl.GEQUAL );
						break;

					case fm.GreaterDepth:

						gl.depthFunc( gl.GREATER );
						break;

					case fm.NotEqualDepth:

						gl.depthFunc( gl.NOTEQUAL );
						break;

					default:

						gl.depthFunc( gl.LEQUAL );

				}

			} else {

				gl.depthFunc( gl.LEQUAL );

			}

			currentDepthFunc = depthFunc;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( depthTest ) {

			this.enable( gl.DEPTH_TEST );

		} else {

			this.disable( gl.DEPTH_TEST );

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		// TODO: Rename to setDepthMask

		if ( currentDepthWrite !== depthWrite ) {

			gl.depthMask( depthWrite );
			currentDepthWrite = depthWrite;

		}

	};

	this.setColorWrite = function ( colorWrite ) {

		// TODO: Rename to setColorMask

		if ( currentColorWrite !== colorWrite ) {

			gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
			currentColorWrite = colorWrite;

		}

	};

	this.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {

		if ( currentStencilFunc !== stencilFunc ||
				 currentStencilRef 	!== stencilRef 	||
				 currentStencilMask !== stencilMask ) {

			gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );

			currentStencilFunc = stencilFunc;
			currentStencilRef  = stencilRef;
			currentStencilMask = stencilMask;

		}

	};

	this.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {

		if ( currentStencilFail	 !== stencilFail 	||
				 currentStencilZFail !== stencilZFail ||
				 currentStencilZPass !== stencilZPass ) {

			gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );

			currentStencilFail  = stencilFail;
			currentStencilZFail = stencilZFail;
			currentStencilZPass = stencilZPass;

		}

	};

	this.setStencilTest = function ( stencilTest ) {

		if ( stencilTest ) {

			this.enable( gl.STENCIL_TEST );

		} else {

			this.disable( gl.STENCIL_TEST );

		}

	};

	this.setStencilWrite = function ( stencilWrite ) {

		// TODO: Rename to setStencilMask

		if ( currentStencilWrite !== stencilWrite ) {

			gl.stencilMask( stencilWrite );
			currentStencilWrite = stencilWrite;

		}

	};

	this.setFlipSided = function ( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			currentFlipSided = flipSided;

		}

	};

	this.setLineWidth = function ( width ) {

		if ( width !== currentLineWidth ) {

			// gl.lineWidth( width );

			currentLineWidth = width;

		}

	};

	this.setPolygonOffset = function ( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			this.enable( gl.POLYGON_OFFSET_FILL );

		} else {

			this.disable( gl.POLYGON_OFFSET_FILL );

		}

		if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

			gl.polygonOffset( factor, units );

			currentPolygonOffsetFactor = factor;
			currentPolygonOffsetUnits = units;

		}

	};

	this.getScissorTest = function () {

		return currentScissorTest;

	};

	this.setScissorTest = function ( scissorTest ) {

		currentScissorTest = scissorTest;

		if ( scissorTest ) {

			this.enable( gl.SCISSOR_TEST );

		} else {

			this.disable( gl.SCISSOR_TEST );

		}

	};

	// texture

	this.activeTexture = function ( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	};

	this.bindTexture = function ( webglType, webglTexture ) {

		if ( currentTextureSlot === undefined ) {

			_this.activeTexture();

		}

		var boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	};

	this.compressedTexImage2D = function () {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	};

	this.texImage2D = function () {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	};

	// clear values

	this.clearColor = function ( r, g, b, a ) {

		color.set( r, g, b, a );

		if ( currentClearColor.equals( color ) === false ) {

			gl.clearColor( r, g, b, a );
			currentClearColor.copy( color );

		}

	};

	this.clearDepth = function ( depth ) {

		if ( currentClearDepth !== depth ) {

			gl.clearDepth( depth );
			currentClearDepth = depth;

		}

	};

	this.clearStencil = function ( stencil ) {

		if ( currentClearStencil !== stencil ) {

			gl.clearStencil( stencil );
			currentClearStencil = stencil;

		}

	};

	//

	this.scissor = function ( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	};

	this.viewport = function ( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	};

	//

	this.reset = function () {

		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

			if ( enabledAttributes[ i ] === 1 ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

		capabilities = {};

		compressedTextureFormats = null;

		currentTextureSlot = undefined;
		currentBoundTextures = {};

		currentBlending = null;

		currentColorWrite = null;
		currentDepthWrite = null;
		currentStencilWrite = null;

		currentFlipSided = null;

	};

};

// File:src/renderers/webgl/WebGLUniforms.js

/**
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [renderer] )
 *
 * 		uploads a uniform value(s)
 *  	the 'renderer' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (renderer factorizations):
 *
 * .upload( gl, seq, values, renderer )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 * .splitDynamic( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with dynamic entry and removes them from 'seq'
 *
 *
 * Methods of the top-level container (renderer factorizations):
 *
 * .setValue( gl, name, value )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .set( gl, obj, prop )
 *
 * 		sets uniform from object and property with same name than uniform
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 *
 * @author tschw
 *
 */

fm.WebGLUniforms = ( function() { // scope

	// --- Base for inner nodes (including the root) ---

	var UniformContainer = function() {

			this.seq = [];
			this.map = {};

		},

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

		arrayCacheF32 = [],
		arrayCacheI32 = [],

		uncacheTemporaryArrays = function() {

			arrayCacheF32.length = 0;
			arrayCacheI32.length = 0;

		},

	// Flattening for arrays of vectors and matrices

		flatten = function( array, nBlocks, blockSize ) {

			var firstElem = array[ 0 ];

			if ( firstElem <= 0 || firstElem > 0 ) return array;
			// unoptimized: ! isNaN( firstElem )
			// see http://jacksondunstan.com/articles/983

			var n = nBlocks * blockSize,
				r = arrayCacheF32[ n ];

			if ( r === undefined ) {

				r = new Float32Array( n );
				arrayCacheF32[ n ] = r;

			}

			if ( nBlocks !== 0 ) {

				firstElem.toArray( r, 0 );

				for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

					offset += blockSize;
					array[ i ].toArray( r, offset );

				}

			}

			return r;

		},

	// Texture unit allocation

		allocTexUnits = function( renderer, n ) {

			var r = arrayCacheI32[ n ];

			if ( r === undefined ) {

				r = new Int32Array( n );
				arrayCacheI32[ n ] = r;

			}

			for ( var i = 0; i !== n; ++ i )
				r[ i ] = renderer.allocTextureUnit();

			return r;

		},

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

		// Single scalar

		setValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },
		setValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },

		// Single float vector (from flat array or fm.VectorN)

		setValue2fv = function( gl, v ) {

			if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
			else gl.uniform2f( this.addr, v.x, v.y );

		},

		setValue3fv = function( gl, v ) {

			if ( v.x !== undefined )
				gl.uniform3f( this.addr, v.x, v.y, v.z );
			else if ( v.r !== undefined )
				gl.uniform3f( this.addr, v.r, v.g, v.b );
			else
				gl.uniform3fv( this.addr, v );

		},

		setValue4fv = function( gl, v ) {

			if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
			else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

		},

		// Single matrix (from flat array or MatrixN)

		setValue2fm = function( gl, v ) {

			gl.uniformMatrix2fv( this.addr, false, v.elements || v );

		},

		setValue3fm = function( gl, v ) {

			gl.uniformMatrix3fv( this.addr, false, v.elements || v );

		},

		setValue4fm = function( gl, v ) {

			gl.uniformMatrix4fv( this.addr, false, v.elements || v );

		},

		// Single texture (2D / Cube)

		setValueT1 = function( gl, v, renderer ) {

			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			if ( v ) renderer.setTexture2D( v, unit );

		},

		setValueT6 = function( gl, v, renderer ) {

			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			if ( v ) renderer.setTextureCube( v, unit );

		},

		// Integer / Boolean vectors or arrays thereof (always flat arrays)

		setValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },
		setValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },
		setValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },

		// Helper to pick the right setter for the singular case

		getSingularSetter = function( type ) {

			switch ( type ) {

				case 0x1406: return setValue1f; // FLOAT
				case 0x8b50: return setValue2fv; // _VEC2
				case 0x8b51: return setValue3fv; // _VEC3
				case 0x8b52: return setValue4fv; // _VEC4

				case 0x8b5a: return setValue2fm; // _MAT2
				case 0x8b5b: return setValue3fm; // _MAT3
				case 0x8b5c: return setValue4fm; // _MAT4

				case 0x8b5e: return setValueT1; // SAMPLER_2D
				case 0x8b60: return setValueT6; // SAMPLER_CUBE

				case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

			}

		},

		// Array of scalars

		setValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },
		setValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },

		// Array of vectors (flat or from fm classes)

		setValueV2a = function( gl, v ) {

			gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

		},

		setValueV3a = function( gl, v ) {

			gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

		},

		setValueV4a = function( gl, v ) {

			gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

		},

		// Array of matrices (flat or from fm clases)

		setValueM2a = function( gl, v ) {

			gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

		},

		setValueM3a = function( gl, v ) {

			gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

		},

		setValueM4a = function( gl, v ) {

			gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

		},

		// Array of textures (2D / Cube)

		setValueT1a = function( gl, v, renderer ) {

			var n = v.length,
				units = allocTexUnits( renderer, n );

			gl.uniform1iv( this.addr, units );

			for ( var i = 0; i !== n; ++ i ) {

				var tex = v[ i ];
				if ( tex ) renderer.setTexture2D( tex, units[ i ] );

			}

		},

		setValueT6a = function( gl, v, renderer ) {

			var n = v.length,
				units = allocTexUnits( renderer, n );

			gl.uniform1iv( this.addr, units );

			for ( var i = 0; i !== n; ++ i ) {

				var tex = v[ i ];
				if ( tex ) renderer.setTextureCube( tex, units[ i ] );

			}

		},


		// Helper to pick the right setter for a pure (bottom-level) array

		getPureArraySetter = function( type ) {

			switch ( type ) {

				case 0x1406: return setValue1fv; // FLOAT
				case 0x8b50: return setValueV2a; // _VEC2
				case 0x8b51: return setValueV3a; // _VEC3
				case 0x8b52: return setValueV4a; // _VEC4

				case 0x8b5a: return setValueM2a; // _MAT2
				case 0x8b5b: return setValueM3a; // _MAT3
				case 0x8b5c: return setValueM4a; // _MAT4

				case 0x8b5e: return setValueT1a; // SAMPLER_2D
				case 0x8b60: return setValueT6a; // SAMPLER_CUBE

				case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

			}

		},

	// --- Uniform Classes ---

		SingleUniform = function SingleUniform( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.setValue = getSingularSetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		},

		PureArrayUniform = function( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		},

		StructuredUniform = function( id ) {

			this.id = id;

			UniformContainer.call( this ); // mix-in

		};

	StructuredUniform.prototype.setValue = function( gl, value ) {

		// Note: Don't need an extra 'renderer' parameter, since samplers
		// are not allowed in structured uniforms.

		var seq = this.seq;

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			u.setValue( gl, value[ u.id ] );

		}

	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g,
		// extracts
		// 	- the identifier (member name or array index)
		//  - followed by an optional right bracket (found when array index)
		//  - followed by an optional left bracket or dot (type of subscript)
		//
		// Note: These portions can be read in a non-overlapping fashion and
		// allow straightforward parsing of the hierarchy that WebGL encodes
		// in the uniform names.

		addUniform = function( container, uniformObject ) {

			container.seq.push( uniformObject );
			container.map[ uniformObject.id ] = uniformObject;

		},

		parseUniform = function( activeInfo, addr, container ) {

			var path = activeInfo.name,
				pathLength = path.length;

			// reset RegExp object, because of the early exit of a previous run
			RePathPart.lastIndex = 0;

			for (; ;) {

				var match = RePathPart.exec( path ),
					matchEnd = RePathPart.lastIndex,

					id = match[ 1 ],
					idIsIndex = match[ 2 ] === ']',
					subscript = match[ 3 ];

				if ( idIsIndex ) id = id | 0; // convert to integer

				if ( subscript === undefined ||
						subscript === '[' && matchEnd + 2 === pathLength ) {
					// bare name or "pure" bottom-level array "[0]" suffix

					addUniform( container, subscript === undefined ?
							new SingleUniform( id, activeInfo, addr ) :
							new PureArrayUniform( id, activeInfo, addr ) );

					break;

				} else {
					// step into inner node / create it in case it doesn't exist

					var map = container.map,
						next = map[ id ];

					if ( next === undefined ) {

						next = new StructuredUniform( id );
						addUniform( container, next );

					}

					container = next;

				}

			}

		},

	// Root Container

		WebGLUniforms = function WebGLUniforms( gl, program, renderer ) {

			UniformContainer.call( this );

			this.renderer = renderer;

			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

			for ( var i = 0; i !== n; ++ i ) {

				var info = gl.getActiveUniform( program, i ),
					path = info.name,
					addr = gl.getUniformLocation( program, path );

				parseUniform( info, addr, this );

			}

		};


	WebGLUniforms.prototype.setValue = function( gl, name, value ) {

		var u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, this.renderer );

	};

	WebGLUniforms.prototype.set = function( gl, object, name ) {

		var u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );

	};

	WebGLUniforms.prototype.setOptional = function( gl, object, name ) {

		var v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	};


	// Static interface

	WebGLUniforms.upload = function( gl, seq, values, renderer ) {

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {
				// note: always updating when .needsUpdate is undefined

				u.setValue( gl, v.value, renderer );

			}

		}

	};

	WebGLUniforms.seqWithValue = function( seq, values ) {

		var r = [];

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	};

	WebGLUniforms.splitDynamic = function( seq, values ) {

		var r = null,
			n = seq.length,
			w = 0;

		for ( var i = 0; i !== n; ++ i ) {

			var u = seq[ i ],
				v = values[ u.id ];

			if ( v && v.dynamic === true ) {

				if ( r === null ) r = [];
				r.push( u );

			} else {

				// in-place compact 'seq', removing the matches
				if ( w < i ) seq[ w ] = u;
				++ w;

			}

		}

		if ( w < n ) seq.length = w;

		return r;

	};

	WebGLUniforms.evalDynamic = function( seq, values, object, camera ) {

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var v = values[ seq[ i ].id ],
				f = v.onUpdateCallback;

			if ( f !== undefined ) f.call( v, object, camera );

		}

	};

	return WebGLUniforms;

} )();


// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

fm.LensFlarePlugin = function ( renderer, flares ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var shader, program, attributes, uniforms;

	var tempTexture, occlusionTexture;

	function init() {

		var vertices = new Float32Array( [
			- 1, - 1,  0, 0,
			 1, - 1,  1, 0,
			 1,  1,  1, 1,
			- 1,  1,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		// buffers

		vertexBuffer     = gl.createBuffer();
		elementBuffer    = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		// textures

		tempTexture      = gl.createTexture();
		occlusionTexture = gl.createTexture();

		state.bindTexture( gl.TEXTURE_2D, tempTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		shader = {

			vertexShader: [

				"uniform lowp int renderType;",

				"uniform vec3 screenPosition;",
				"uniform vec2 scale;",
				"uniform float rotation;",

				"uniform sampler2D occlusionMap;",

				"attribute vec2 position;",
				"attribute vec2 uv;",

				"varying vec2 vUV;",
				"varying float vVisibility;",

				"void main() {",

					"vUV = uv;",

					"vec2 pos = position;",

					"if ( renderType == 2 ) {",

						"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

						"vVisibility =        visibility.r / 9.0;",
						"vVisibility *= 1.0 - visibility.g / 9.0;",
						"vVisibility *=       visibility.b / 9.0;",
						"vVisibility *= 1.0 - visibility.a / 9.0;",

						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

					"}",

					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform lowp int renderType;",

				"uniform sampler2D map;",
				"uniform float opacity;",
				"uniform vec3 color;",

				"varying vec2 vUV;",
				"varying float vVisibility;",

				"void main() {",

					// pink square

					"if ( renderType == 0 ) {",

						"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

					// restore

					"} else if ( renderType == 1 ) {",

						"gl_FragColor = texture2D( map, vUV );",

					// flare

					"} else {",

						"vec4 texture = texture2D( map, vUV );",
						"texture.a *= opacity * vVisibility;",
						"gl_FragColor = texture;",
						"gl_FragColor.rgb *= color;",

					"}",

				"}"

			].join( "\n" )

		};

		program = createProgram( shader );

		attributes = {
			vertex: gl.getAttribLocation ( program, "position" ),
			uv:     gl.getAttribLocation ( program, "uv" )
		};

		uniforms = {
			renderType:     gl.getUniformLocation( program, "renderType" ),
			map:            gl.getUniformLocation( program, "map" ),
			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
			opacity:        gl.getUniformLocation( program, "opacity" ),
			color:          gl.getUniformLocation( program, "color" ),
			scale:          gl.getUniformLocation( program, "scale" ),
			rotation:       gl.getUniformLocation( program, "rotation" ),
			screenPosition: gl.getUniformLocation( program, "screenPosition" )
		};

	}

	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 */

	this.render = function ( scene, camera, viewport ) {

		if ( flares.length === 0 ) return;

		var tempPosition = new fm.Vector3();

		var invAspect = viewport.w / viewport.z,
			halfViewportWidth = viewport.z * 0.5,
			halfViewportHeight = viewport.w * 0.5;

		var size = 16 / viewport.w,
			scale = new fm.Vector2( size * invAspect, size );

		var screenPosition = new fm.Vector3( 1, 1, 0 ),
			screenPositionPixels = new fm.Vector2( 1, 1 );

		var validArea = new fm.Box2();

		validArea.min.set( 0, 0 );
		validArea.max.set( viewport.z - 16, viewport.w - 16 );

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.vertex );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/uniforms

		gl.uniform1i( uniforms.occlusionMap, 0 );
		gl.uniform1i( uniforms.map, 1 );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		state.disable( gl.CULL_FACE );
		state.setDepthWrite( false );

		for ( var i = 0, l = flares.length; i < l; i ++ ) {

			size = 16 / viewport.w;
			scale.set( size * invAspect, size );

			// calc object screen position

			var flare = flares[ i ];

			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition );

			// horizontal and vertical coordinate of the lower left corner of the pixels to copy

			screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
			screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

			// screen cull

			if ( validArea.containsPoint( screenPositionPixels ) === true ) {

				// save current RGB to temp texture

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, null );
				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


				// render pink quad

				gl.uniform1i( uniforms.renderType, 0 );
				gl.uniform2f( uniforms.scale, scale.x, scale.y );
				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				state.disable( gl.BLEND );
				state.enable( gl.DEPTH_TEST );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


				// restore graphics

				gl.uniform1i( uniforms.renderType, 1 );
				state.disable( gl.DEPTH_TEST );

				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition );

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				gl.uniform1i( uniforms.renderType, 2 );
				state.enable( gl.BLEND );

				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					var sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewport.w;

						scale.x = size * invAspect;
						scale.y = size;

						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform1f( uniforms.rotation, sprite.rotation );

						gl.uniform1f( uniforms.opacity, sprite.opacity );
						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						renderer.setTexture2D( sprite.texture, 1 );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		state.enable( gl.CULL_FACE );
		state.enable( gl.DEPTH_TEST );
		state.setDepthWrite( true );

		renderer.resetGLState();

	};

	function createProgram ( shader ) {

		var program = gl.createProgram();

		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

		var prefix = "precision " + renderer.getPrecision() + " float;\n";

		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		gl.compileShader( fragmentShader );
		gl.compileShader( vertexShader );

		gl.attachShader( program, fragmentShader );
		gl.attachShader( program, vertexShader );

		gl.linkProgram( program );

		return program;

	}

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

fm.SpritePlugin = function ( renderer, sprites ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	var texture;

	// decompose matrixWorld

	var spritePosition = new fm.Vector3();
	var spriteRotation = new fm.Quaternion();
	var spriteScale = new fm.Vector3();

	function init() {

		var vertices = new Float32Array( [
			- 0.5, - 0.5,  0, 0,
			  0.5, - 0.5,  1, 0,
			  0.5,   0.5,  1, 1,
			- 0.5,   0.5,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = gl.createBuffer();
		elementBuffer = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			gl.getAttribLocation ( program, 'position' ),
			uv:					gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

			rotation:			gl.getUniformLocation( program, 'rotation' ),
			scale:				gl.getUniformLocation( program, 'scale' ),

			color:				gl.getUniformLocation( program, 'color' ),
			map:				gl.getUniformLocation( program, 'map' ),
			opacity:			gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElement( 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = 'white';
		context.fillRect( 0, 0, 8, 8 );

		texture = new fm.Texture( canvas );
		texture.needsUpdate = true;

	}

	this.render = function ( scene, camera ) {

		if ( sprites.length === 0 ) return;

		// setup gl

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.position );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		state.disable( gl.CULL_FACE );
		state.enable( gl.BLEND );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		state.activeTexture( gl.TEXTURE0 );
		gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof fm.Fog ) {

				gl.uniform1f( uniforms.fogNear, fog.near );
				gl.uniform1f( uniforms.fogFar, fog.far );

				gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof fm.FogExp2 ) {

				gl.uniform1f( uniforms.fogDensity, fog.density );

				gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];

			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

		}

		sprites.sort( painterSortStable );

		// render all sprites

		var scale = [];

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];
			var material = sprite.material;

			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

			scale[ 0 ] = spriteScale.x;
			scale[ 1 ] = spriteScale.y;

			var fogType = 0;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			}

			if ( oldFogType !== fogType ) {

				gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				gl.uniform2f( uniforms.uvOffset, 0, 0 );
				gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			gl.uniform1f( uniforms.opacity, material.opacity );
			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			gl.uniform1f( uniforms.rotation, material.rotation );
			gl.uniform2fv( uniforms.scale, scale );

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );

			if ( material.map ) {

				renderer.setTexture2D( material.map, 0 );

			} else {

				renderer.setTexture2D( texture, 0 );

			}

			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		state.enable( gl.CULL_FACE );

		renderer.resetGLState();

	};

	function createProgram () {

		var program = gl.createProgram();

		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

		gl.shaderSource( vertexShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		gl.shaderSource( fragmentShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		gl.compileShader( vertexShader );
		gl.compileShader( fragmentShader );

		gl.attachShader( program, vertexShader );
		gl.attachShader( program, fragmentShader );

		gl.linkProgram( program );

		return program;

	}

	function painterSortStable ( a, b ) {
		
		if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	}

};

// File:src/fm.Legacy.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

Object.defineProperties( fm.Box2.prototype, {
	empty: {
		value: function () {
			console.warn( 'fm.Box2: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();
		}
	},
	isIntersectionBox: {
		value: function ( box ) {
			console.warn( 'fm.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );
		}
	}
} );

Object.defineProperties( fm.Box3.prototype, {
	empty: {
		value: function () {
			console.warn( 'fm.Box3: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();
		}
	},
	isIntersectionBox: {
		value: function ( box ) {
			console.warn( 'fm.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );
		}
	},
	isIntersectionSphere: {
		value: function ( sphere ) {
			console.warn( 'fm.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );
		}
	}
} );

Object.defineProperties( fm.Matrix3.prototype, {
	multiplyVector3: {
		value: function ( vector ) {
			console.warn( 'fm.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );
		}
	},
	multiplyVector3Array: {
		value: function ( a ) {
			console.warn( 'fm.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );
		}
	}
} );

Object.defineProperties( fm.Matrix4.prototype, {
	extractPosition: {
		value: function ( m ) {
			console.warn( 'fm.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );
		}
	},
	setRotationFromQuaternion: {
		value: function ( q ) {
			console.warn( 'fm.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
			return this.makeRotationFromQuaternion( q );
		}
	},
	multiplyVector3: {
		value: function ( vector ) {
			console.warn( 'fm.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
			return vector.applyProjection( this );
		}
	},
	multiplyVector4: {
		value: function ( vector ) {
			console.warn( 'fm.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
		}
	},
	multiplyVector3Array: {
		value: function ( a ) {
			console.warn( 'fm.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );
		}
	},
	rotateAxis: {
		value: function ( v ) {
			console.warn( 'fm.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
			v.transformDirection( this );
		}
	},
	crossVector: {
		value: function ( vector ) {
			console.warn( 'fm.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
		}
	},
	translate: {
		value: function ( v ) {
			console.error( 'fm.Matrix4: .translate() has been removed.' );
		}
	},
	rotateX: {
		value: function ( angle ) {
			console.error( 'fm.Matrix4: .rotateX() has been removed.' );
		}
	},
	rotateY: {
		value: function ( angle ) {
			console.error( 'fm.Matrix4: .rotateY() has been removed.' );
		}
	},
	rotateZ: {
		value: function ( angle ) {
			console.error( 'fm.Matrix4: .rotateZ() has been removed.' );
		}
	},
	rotateByAxis: {
		value: function ( axis, angle ) {
			console.error( 'fm.Matrix4: .rotateByAxis() has been removed.' );
		}
	}
} );

Object.defineProperties( fm.Plane.prototype, {
	isIntersectionLine: {
		value: function ( line ) {
			console.warn( 'fm.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
			return this.intersectsLine( line );
		}
	}
} );

Object.defineProperties( fm.Quaternion.prototype, {
	multiplyVector3: {
		value: function ( vector ) {
			console.warn( 'fm.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );
		}
	}
} );

Object.defineProperties( fm.Ray.prototype, {
	isIntersectionBox: {
		value: function ( box ) {
			console.warn( 'fm.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );
		}
	},
	isIntersectionPlane: {
		value: function ( plane ) {
			console.warn( 'fm.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
			return this.intersectsPlane( plane );
		}
	},
	isIntersectionSphere: {
		value: function ( sphere ) {
			console.warn( 'fm.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );
		}
	}
} );

Object.defineProperties( fm.Vector3.prototype, {
	setEulerFromRotationMatrix: {
		value: function () {
			console.error( 'fm.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
		}
	},
	setEulerFromQuaternion: {
		value: function () {
			console.error( 'fm.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
		}
	},
	getPositionFromMatrix: {
		value: function ( m ) {
			console.warn( 'fm.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
			return this.setFromMatrixPosition( m );
		}
	},
	getScaleFromMatrix: {
		value: function ( m ) {
			console.warn( 'fm.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
			return this.setFromMatrixScale( m );
		}
	},
	getColumnFromMatrix: {
		value: function ( index, matrix ) {
			console.warn( 'fm.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
			return this.setFromMatrixColumn( index, matrix );
		}
	}
} );

//

fm.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'fm.Face4 has been removed. A fm.Face3 will be created instead.' );
	return new fm.Face3( a, b, c, normal, color, materialIndex );

};

fm.Vertex = function ( x, y, z ) {

	console.warn( 'fm.Vertex has been removed. Use fm.Vector3 instead.' );
	return new fm.Vector3( x, y, z );

};

//

Object.defineProperties( fm.Object3D.prototype, {
	eulerOrder: {
		get: function () {
			console.warn( 'fm.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;
		},
		set: function ( value ) {
			console.warn( 'fm.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;
		}
	},
	getChildByName: {
		value: function ( name ) {
			console.warn( 'fm.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );
		}
	},
	renderDepth: {
		set: function ( value ) {
			console.warn( 'fm.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
		}
	},
	translate: {
		value: function ( distance, axis ) {
			console.warn( 'fm.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );
		}
	},
	useQuaternion: {
		get: function () {
			console.warn( 'fm.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
		},
		set: function ( value ) {
			console.warn( 'fm.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
		}
	}
} );

//

Object.defineProperties( fm, {
	PointCloud: {
		value: function ( geometry, material ) {
			console.warn( 'fm.PointCloud has been renamed to fm.Points.' );
			return new fm.Points( geometry, material );
		}
	},
	ParticleSystem: {
		value: function ( geometry, material ) {
			console.warn( 'fm.ParticleSystem has been renamed to fm.Points.' );
			return new fm.Points( geometry, material );
		}
	}
} );

//

Object.defineProperties( fm.Light.prototype, {
	onlyShadow: {
		set: function ( value ) {
			console.warn( 'fm.Light: .onlyShadow has been removed.' );
		}
	},
	shadowCameraFov: {
		set: function ( value ) {
			console.warn( 'fm.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;
		}
	},
	shadowCameraLeft: {
		set: function ( value ) {
			console.warn( 'fm.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;
		}
	},
	shadowCameraRight: {
		set: function ( value ) {
			console.warn( 'fm.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;
		}
	},
	shadowCameraTop: {
		set: function ( value ) {
			console.warn( 'fm.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;
		}
	},
	shadowCameraBottom: {
		set: function ( value ) {
			console.warn( 'fm.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;
		}
	},
	shadowCameraNear: {
		set: function ( value ) {
			console.warn( 'fm.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;
		}
	},
	shadowCameraFar: {
		set: function ( value ) {
			console.warn( 'fm.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;
		}
	},
	shadowCameraVisible: {
		set: function ( value ) {
			console.warn( 'fm.Light: .shadowCameraVisible has been removed. Use new fm.CameraHelper( light.shadow.camera ) instead.' );
		}
	},
	shadowBias: {
		set: function ( value ) {
			console.warn( 'fm.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;
		}
	},
	shadowDarkness: {
		set: function ( value ) {
			console.warn( 'fm.Light: .shadowDarkness has been removed.' );
		}
	},
	shadowMapWidth: {
		set: function ( value ) {
			console.warn( 'fm.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;
		}
	},
	shadowMapHeight: {
		set: function ( value ) {
			console.warn( 'fm.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;
		}
	}
} );

//

Object.defineProperties( fm.BufferAttribute.prototype, {
	length: {
		get: function () {
			console.warn( 'fm.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;
		}
	}
} );

Object.defineProperties( fm.BufferGeometry.prototype, {
	drawcalls: {
		get: function () {
			console.error( 'fm.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;
		}
	},
	offsets: {
		get: function () {
			console.warn( 'fm.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;
		}
	},
	addIndex: {
		value: function ( index ) {
			console.warn( 'fm.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );
		}
	},
	addDrawCall: {
		value: function ( start, count, indexOffset ) {
			if ( indexOffset !== undefined ) {
				console.warn( 'fm.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
			}
			console.warn( 'fm.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );
		}
	},
	clearDrawCalls: {
		value: function () {
			console.warn( 'fm.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();
		}
	},
	computeTangents: {
		value: function () {
			console.warn( 'fm.BufferGeometry: .computeTangents() has been removed.' );
		}
	},
	computeOffsets: {
		value: function () {
			console.warn( 'fm.BufferGeometry: .computeOffsets() has been removed.' );
		}
	}
} );

//

Object.defineProperties( fm.Material.prototype, {
	wrapAround: {
		get: function () {
			console.warn( 'fm.' + this.type + ': .wrapAround has been removed.' );
		},
		set: function ( value ) {
			console.warn( 'fm.' + this.type + ': .wrapAround has been removed.' );
		}
	},
	wrapRGB: {
		get: function () {
			console.warn( 'fm.' + this.type + ': .wrapRGB has been removed.' );
			return new fm.Color();
		}
	}
} );

Object.defineProperties( fm, {
	PointCloudMaterial: {
		value: function ( parameters ) {
			console.warn( 'fm.PointCloudMaterial has been renamed to fm.PointsMaterial.' );
			return new fm.PointsMaterial( parameters );
		}
	},
	ParticleBasicMaterial: {
		value: function ( parameters ) {
			console.warn( 'fm.ParticleBasicMaterial has been renamed to fm.PointsMaterial.' );
			return new fm.PointsMaterial( parameters );
		}
	},
	ParticleSystemMaterial:{
		value: function ( parameters ) {
			console.warn( 'fm.ParticleSystemMaterial has been renamed to fm.PointsMaterial.' );
			return new fm.PointsMaterial( parameters );
		}
	}
} );

Object.defineProperties( fm.MeshPhongMaterial.prototype, {
	metal: {
		get: function () {
			console.warn( 'fm.MeshPhongMaterial: .metal has been removed. Use fm.MeshStandardMaterial instead.' );
			return false;
		},
		set: function ( value ) {
			console.warn( 'fm.MeshPhongMaterial: .metal has been removed. Use fm.MeshStandardMaterial instead' );
		}
	}
} );

Object.defineProperties( fm.ShaderMaterial.prototype, {
	derivatives: {
		get: function () {
			console.warn( 'fm.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;
		},
		set: function ( value ) {
			console.warn( 'fm. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;
		}
	}
} );

//

Object.defineProperties( fm.WebGLRenderer.prototype, {
	supportsFloatTextures: {
		value: function () {
			console.warn( 'fm.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return this.extensions.get( 'OES_texture_float' );
		}
	},
	supportsHalfFloatTextures: {
		value: function () {
			console.warn( 'fm.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return this.extensions.get( 'OES_texture_half_float' );
		}
	},
	supportsStandardDerivatives: {
		value: function () {
			console.warn( 'fm.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return this.extensions.get( 'OES_standard_derivatives' );
		}
	},
	supportsCompressedTextureS3TC: {
		value: function () {
			console.warn( 'fm.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
		}
	},
	supportsCompressedTexturePVRTC: {
		value: function () {
			console.warn( 'fm.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
		}
	},
	supportsBlendMinMax: {
		value: function () {
			console.warn( 'fm.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return this.extensions.get( 'EXT_blend_minmax' );
		}
	},
	supportsVertexTextures: {
		value: function () {
			return this.capabilities.vertexTextures;
		}
	},
	supportsInstancedArrays: {
		value: function () {
			console.warn( 'fm.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return this.extensions.get( 'ANGLE_instanced_arrays' );
		}
	},
	enableScissorTest: {
		value: function ( boolean ) {
			console.warn( 'fm.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
			this.setScissorTest( boolean );
		}
	},
	initMaterial: {
		value: function () {
			console.warn( 'fm.WebGLRenderer: .initMaterial() has been removed.' );
		}
	},
	addPrePlugin: {
		value: function () {
			console.warn( 'fm.WebGLRenderer: .addPrePlugin() has been removed.' );
		}
	},
	addPostPlugin: {
		value: function () {
			console.warn( 'fm.WebGLRenderer: .addPostPlugin() has been removed.' );
		}
	},
	updateShadowMap: {
		value: function () {
			console.warn( 'fm.WebGLRenderer: .updateShadowMap() has been removed.' );
		}
	},
	shadowMapEnabled: {
		get: function () {
			return this.shadowMap.enabled;
		},
		set: function ( value ) {
			console.warn( 'fm.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;
		}
	},
	shadowMapType: {
		get: function () {
			return this.shadowMap.type;
		},
		set: function ( value ) {
			console.warn( 'fm.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;
		}
	},
	shadowMapCullFace: {
		get: function () {
			return this.shadowMap.cullFace;
		},
		set: function ( value ) {
			console.warn( 'fm.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
			this.shadowMap.cullFace = value;
		}
	}
} );

//

Object.defineProperties( fm.WebGLRenderTarget.prototype, {
	wrapS: {
		get: function () {
			console.warn( 'fm.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;
		},
		set: function ( value ) {
			console.warn( 'fm.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;
		}
	},
	wrapT: {
		get: function () {
			console.warn( 'fm.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;
		},
		set: function ( value ) {
			console.warn( 'fm.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;
		}
	},
	magFilter: {
		get: function () {
			console.warn( 'fm.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;
		},
		set: function ( value ) {
			console.warn( 'fm.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;
		}
	},
	minFilter: {
		get: function () {
			console.warn( 'fm.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;
		},
		set: function ( value ) {
			console.warn( 'fm.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;
		}
	},
	anisotropy: {
		get: function () {
			console.warn( 'fm.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;
		},
		set: function ( value ) {
			console.warn( 'fm.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;
		}
	},
	offset: {
		get: function () {
			console.warn( 'fm.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;
		},
		set: function ( value ) {
			console.warn( 'fm.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;
		}
	},
	repeat: {
		get: function () {
			console.warn( 'fm.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;
		},
		set: function ( value ) {
			console.warn( 'fm.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;
		}
	},
	format: {
		get: function () {
			console.warn( 'fm.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;
		},
		set: function ( value ) {
			console.warn( 'fm.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;
		}
	},
	type: {
		get: function () {
			console.warn( 'fm.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;
		},
		set: function ( value ) {
			console.warn( 'fm.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;
		}
	},
	generateMipmaps: {
		get: function () {
			console.warn( 'fm.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;
		},
		set: function ( value ) {
			console.warn( 'fm.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;
		}
	}
} );

//

Object.defineProperties( fm.Audio.prototype, {
	load: {
		value: function ( file ) {

			console.warn( 'fm.Audio: .load has been deprecated. Please use fm.AudioLoader.' );

			var scope = this;

			var audioLoader = new fm.AudioLoader();

			audioLoader.load( file, function ( buffer ) {

				scope.setBuffer( buffer );

			} );

			return this;

		}
	}
} );

//

fm.GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'fm.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

		var matrix;

		if ( geometry2 instanceof fm.Mesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'fm.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

fm.ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		console.warn( 'fm.ImageUtils.loadTexture has been deprecated. Use fm.TextureLoader() instead.' );

		var loader = new fm.TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadTextureCube: function ( urls, mapping, onLoad, onError ) {

		console.warn( 'fm.ImageUtils.loadTextureCube has been deprecated. Use fm.CubeTextureLoader() instead.' );

		var loader = new fm.CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadCompressedTexture: function () {

		console.error( 'fm.ImageUtils.loadCompressedTexture has been removed. Use fm.DDSLoader instead.' );

	},

	loadCompressedTextureCube: function () {

		console.error( 'fm.ImageUtils.loadCompressedTextureCube has been removed. Use fm.DDSLoader instead.' );

	}

};

//

fm.Projector = function () {

	console.error( 'fm.Projector has been moved to /examples/js/renderers/Projector.js.' );

	this.projectVector = function ( vector, camera ) {

		console.warn( 'fm.Projector: .projectVector() is now vector.project().' );
		vector.project( camera );

	};

	this.unprojectVector = function ( vector, camera ) {

		console.warn( 'fm.Projector: .unprojectVector() is now vector.unproject().' );
		vector.unproject( camera );

	};

	this.pickingRay = function ( vector, camera ) {

		console.error( 'fm.Projector: .pickingRay() is now raycaster.setFromCamera().' );

	};

};

//

fm.CanvasRenderer = function () {

	console.error( 'fm.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

	this.domElement = document.createElement( 'canvas' );
	this.clear = function () {};
	this.render = function () {};
	this.setClearColor = function () {};
	this.setSize = function () {};

};

//

fm.MeshFaceMaterial = fm.MultiMaterial;

//

Object.defineProperties( fm.LOD.prototype, {
	objects: {
		get: function () {

			console.warn( 'fm.LOD: .objects has been renamed to .levels.' );
			return this.levels;

		}
	}
} );

// File:src/extras/CurveUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

fm.CurveUtils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

		return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
			3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
			6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
			3 * t * t * p3;

	},

	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
		var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3 − t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new fm.Group();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new fm.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach: function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new fm.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

// File:src/extras/ShapeUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

fm.ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	triangulate: ( function () {

		/**
		 * This code is a quick port of code written in C++ which was submitted to
		 * flipcode.com by John W. Ratcliff  // July 22, 2000
		 * See original code and more information here:
		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
		 *
		 * ported to actionscript by Zevan Rosser
		 * www.actionsnippet.com
		 *
		 * ported to javascript by Joshua Koo
		 * http://www.lab4games.net/zz85/blog
		 *
		 */

		function snip( contour, u, v, w, n, verts ) {

			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;

			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;

			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;

			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;

			if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			for ( p = 0; p < n; p ++ ) {

				px = contour[ verts[ p ] ].x;
				py = contour[ verts[ p ] ].y;

				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;

				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

			}

			return true;

		}

		// takes in an contour array and returns

		return function ( contour, indices ) {

			var n = contour.length;

			if ( n < 3 ) return null;

			var result = [],
				verts = [],
				vertIndices = [];

			/* we want a counter-clockwise polygon in verts */

			var u, v, w;

			if ( fm.ShapeUtils.area( contour ) > 0.0 ) {

				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

			} else {

				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

			}

			var nv = n;

			/*  remove nv - 2 vertices, creating 1 triangle every time */

			var count = 2 * nv;   /* error detection */

			for ( v = nv - 1; nv > 2; ) {

				/* if we loop, it is probably a non-simple polygon */

				if ( ( count -- ) <= 0 ) {

					//** Triangulate: ERROR - probable bad polygon!

					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					console.warn( 'fm.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

					if ( indices ) return vertIndices;
					return result;

				}

				/* fm consecutive vertices in current polygon, <u,v,w> */

				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

				if ( snip( contour, u, v, w, nv, verts ) ) {

					var a, b, c, s, t;

					/* true names of the vertices */

					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];

					/* output Triangle */

					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );


					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

					/* remove v from the remaining polygon */

					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

						verts[ s ] = verts[ t ];

					}

					nv --;

					/* reset error detection counter */

					count = 2 * nv;

				}

			}

			if ( indices ) return vertIndices;
			return result;

		}

	} )(),

	triangulateShape: function ( contour, holes ) {

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

			// inOtherPt needs to be collinear to the inSegment
			if ( inSegPt1.x !== inSegPt2.x ) {

				if ( inSegPt1.x < inSegPt2.x ) {

					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

				} else {

					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

				}

			} else {

				if ( inSegPt1.y < inSegPt2.y ) {

					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

				} else {

					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

				}

			}

		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs( limit ) > Number.EPSILON ) {

				// not parallel

				var perpSeg2;
				if ( limit > 0 ) {

					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

				} else {

					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 === 0 ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt1 ];

				}
				if ( perpSeg2 === limit ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt2 ];

				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {

				// parallel or collinear
				if ( ( perpSeg1 !== 0 ) ||
					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {

					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
					return [ inSeg1Pt1 ];                 						// they are the same point

				}
				// segment#1  is a single point
				if ( seg1Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return [ inSeg1Pt1 ];

				}
				// segment#2  is a single point
				if ( seg2Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return [ inSeg2Pt1 ];

				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if ( seg1dx !== 0 ) {

					// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

					}

				} else {

					// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

					}

				}
				if ( seg1minVal <= seg2minVal ) {

					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal === seg2minVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];

				} else {

					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal === seg2maxVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];

				}

			}

		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

			// The order of legs is important

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

				// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {

					// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

				} else {

					// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

				}

			} else {

				// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );

			}

		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;

				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;

				}

				return	true;

			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {

				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

					nextIdx = sIdx + 1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
					if ( intersection.length > 0 )		return	true;

				}

				return	false;

			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {

				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

					chkHole = holes[ indepHoles[ ihIdx ]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;

					}

				}
				return	false;

			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var minShapeIndex = 0;
			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {

				counter --;
				if ( counter < 0 ) {

					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;

				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= - 1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {

						holeIdx = indepHoles[ h ];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[ cutKey ] !== undefined )			continue;

						hole = holes[ holeIdx ];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

							holePt = hole[ h2 ];
							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice( h, 1 );

							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex + 1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							minShapeIndex = shapeIndex;

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;

						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[ cutKey ] = true;			// remember failure

					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found

				}

			}

			return shape; 			/* shape with no holes */

		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[ h ] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.warn( "fm.Shape: Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = fm.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return fm.ShapeUtils.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2: ( function () {

		function b2p0( t, p ) {

			var k = 1 - t;
			return k * k * p;

		}

		function b2p1( t, p ) {

			return 2 * ( 1 - t ) * t * p;

		}

		function b2p2( t, p ) {

			return t * t * p;

		}

		return function ( t, p0, p1, p2 ) {

			return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

		};

	} )(),

	// Cubic Bezier Functions

	b3: ( function () {

		function b3p0( t, p ) {

			var k = 1 - t;
			return k * k * k * p;

		}

		function b3p1( t, p ) {

			var k = 1 - t;
			return 3 * k * k * t * p;

		}

		function b3p2( t, p ) {

			var k = 1 - t;
			return 3 * k * t * t * p;

		}

		function b3p3( t, p ) {

			return t * t * t * p;

		}

		return function ( t, p0, p1, p2, p3 ) {

			return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

		};

	} )()

};

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses fm.Curve:
 *
 * -- 2d classes --
 * fm.LineCurve
 * fm.QuadraticBezierCurve
 * fm.CubicBezierCurve
 * fm.SplineCurve
 * fm.ArcCurve
 * fm.EllipseCurve
 *
 * -- 3d classes --
 * fm.LineCurve3
 * fm.QuadraticBezierCurve3
 * fm.CubicBezierCurve3
 * fm.SplineCurve3
 *
 * A series of curves can be represented as a fm.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

fm.Curve = function () {

};

fm.Curve.prototype = {

	constructor: fm.Curve,

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function ( t ) {

		console.warn( "fm.Curve: Warning, getPoint() not implemented!" );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPoint( d / divisions ) );

		}

		return pts;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPointAt( d / divisions ) );

		}

		return pts;

	},

	// Get total curve arc length

	getLength: function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length === divisions + 1 )
			&& ! this.needsUpdate ) {

			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

	},

	updateArcLengths: function() {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		//var time = Date.now();

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		//console.log('b' , i, low, high, Date.now()- time);

		if ( arcLengths[ i ] === targetArcLength ) {

			var t = i / ( il - 1 );
			return t;

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub( pt1 );
		return vec.normalize();

	},

	getTangentAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	}

};

// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

fm.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( fm.Curve.prototype );
	constructor.prototype.constructor = constructor;
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

fm.CurvePath = function () {

	this.curves = [];

	this.autoClose = false; // Automatically closes the path

};

fm.CurvePath.prototype = Object.create( fm.Curve.prototype );
fm.CurvePath.prototype.constructor = fm.CurvePath;

fm.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

/*
fm.CurvePath.prototype.checkConnection = function() {
	// TODO
	// If the ending of curve is not connected to the starting
	// or the next curve, then, this is not a real path
};
*/

fm.CurvePath.prototype.closePath = function() {

	// TODO Test
	// and verify for vector3 (needs to implement equals)
	// Add a line curve if start and end of lines are not connected
	var startPoint = this.curves[ 0 ].getPoint( 0 );
	var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

	if ( ! startPoint.equals( endPoint ) ) {

		this.curves.push( new fm.LineCurve( endPoint, startPoint ) );

	}

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

fm.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			var diff = curveLengths[ i ] - d;
			var curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
fm.CurvePath.prototype.getTangent = function( t ) {
};
*/

// We cannot use the default fm.Curve getPoint() with getLength() because in
// fm.Curve, getLength() depends on getPoint() but in fm.CurvePath
// getPoint() depends on getLength

fm.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

fm.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

		return this.cacheLengths;

	}

	// Get length of sub-curve
	// Push sums into cached array

	var lengths = [], sums = 0;

	for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

fm.CurvePath.prototype.createPointsGeometry = function( divisions ) {

	var pts = this.getPoints( divisions );
	return this.createGeometry( pts );

};
fm.CurvePath.prototype.

// Generate geometry from equidistant sampling along the path
createSpacedPointsGeometry = function( divisions ) {

	var pts = this.getSpacedPoints( divisions );
	return this.createGeometry( pts );

};

fm.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new fm.Geometry();

	for ( var i = 0, l = points.length; i < l; i ++ ) {

		var point = points[ i ];
		geometry.vertices.push( new fm.Vector3( point.x, point.y, point.z || 0 ) );

	}

	return geometry;

};

// File:src/extras/core/Font.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */

fm.Font = function ( data ) {

	this.data = data;

};

fm.Font.prototype = {

	constructor: fm.Font,

	generateShapes: function ( text, size, divisions ) {

		function createPaths( text ) {

			var chars = String( text ).split( '' );
			var scale = size / data.resolution;
			var offset = 0;

			var paths = [];

			for ( var i = 0; i < chars.length; i ++ ) {

				var ret = createPath( chars[ i ], scale, offset );
				offset += ret.offset;

				paths.push( ret.path );

			}

			return paths;

		}

		function createPath( c, scale, offset ) {

			var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

			if ( ! glyph ) return;

			var path = new fm.Path();

			var pts = [], b2 = fm.ShapeUtils.b2, b3 = fm.ShapeUtils.b3;
			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

			if ( glyph.o ) {

				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

				for ( var i = 0, l = outline.length; i < l; ) {

					var action = outline[ i ++ ];

					switch ( action ) {

						case 'm': // moveTo

							x = outline[ i ++ ] * scale + offset;
							y = outline[ i ++ ] * scale;

							path.moveTo( x, y );

							break;

						case 'l': // lineTo

							x = outline[ i ++ ] * scale + offset;
							y = outline[ i ++ ] * scale;

							path.lineTo( x, y );

							break;

						case 'q': // quadraticCurveTo

							cpx  = outline[ i ++ ] * scale + offset;
							cpy  = outline[ i ++ ] * scale;
							cpx1 = outline[ i ++ ] * scale + offset;
							cpy1 = outline[ i ++ ] * scale;

							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

							laste = pts[ pts.length - 1 ];

							if ( laste ) {

								cpx0 = laste.x;
								cpy0 = laste.y;

								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

									var t = i2 / divisions;
									b2( t, cpx0, cpx1, cpx );
									b2( t, cpy0, cpy1, cpy );

								}

							}

							break;

						case 'b': // bezierCurveTo

							cpx  = outline[ i ++ ] * scale + offset;
							cpy  = outline[ i ++ ] * scale;
							cpx1 = outline[ i ++ ] * scale + offset;
							cpy1 = outline[ i ++ ] * scale;
							cpx2 = outline[ i ++ ] * scale + offset;
							cpy2 = outline[ i ++ ] * scale;

							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

							laste = pts[ pts.length - 1 ];

							if ( laste ) {

								cpx0 = laste.x;
								cpy0 = laste.y;

								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

									var t = i2 / divisions;
									b3( t, cpx0, cpx1, cpx2, cpx );
									b3( t, cpy0, cpy1, cpy2, cpy );

								}

							}

							break;

					}

				}

			}

			return { offset: glyph.ha * scale, path: path };

		}

		//

		if ( size === undefined ) size = 100;
		if ( divisions === undefined ) divisions = 4;

		var data = this.data;

		var paths = createPaths( text );
		var shapes = [];

		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	}

};

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

fm.Path = function ( points ) {

	fm.CurvePath.call( this );

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

fm.Path.prototype = Object.create( fm.CurvePath.prototype );
fm.Path.prototype.constructor = fm.Path;

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

fm.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	for ( var i = 1, l = vectors.length; i < l; i ++ ) {

		this.lineTo( vectors[ i ].x, vectors[ i ].y );

	}

};

// startPath() endPath()?

fm.Path.prototype.moveTo = function ( x, y ) {

	this.actions.push( { action: 'moveTo', args: [ x, y ] } );

};

fm.Path.prototype.lineTo = function ( x, y ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new fm.LineCurve( new fm.Vector2( x0, y0 ), new fm.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: 'lineTo', args: [ x, y ] } );

};

fm.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new fm.QuadraticBezierCurve(
		new fm.Vector2( x0, y0 ),
		new fm.Vector2( aCPx, aCPy ),
		new fm.Vector2( aX, aY )
	);

	this.curves.push( curve );

	this.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );

};

fm.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new fm.CubicBezierCurve(
		new fm.Vector2( x0, y0 ),
		new fm.Vector2( aCP1x, aCP1y ),
		new fm.Vector2( aCP2x, aCP2y ),
		new fm.Vector2( aX, aY )
	);

	this.curves.push( curve );

	this.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );

};

fm.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var npts = [ new fm.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new fm.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: 'splineThru', args: args } );

};

// FUTURE: Change the API or follow canvas API?

fm.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absarc( aX + x0, aY + y0, aRadius,
		aStartAngle, aEndAngle, aClockwise );

 };

 fm.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

 };

fm.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

 };


fm.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	var args = [
		aX, aY,
		xRadius, yRadius,
		aStartAngle, aEndAngle,
		aClockwise,
		aRotation || 0 // aRotation is optional.
	];

	var curve = new fm.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	this.curves.push( curve );

	var lastPoint = curve.getPoint( 1 );
	args.push( lastPoint.x );
	args.push( lastPoint.y );

	this.actions.push( { action: 'ellipse', args: args } );

 };

fm.Path.prototype.getSpacedPoints = function ( divisions ) {

	if ( ! divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if ( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	if ( this.autoClose ) {

		points.push( points[ 0 ] );

	}

	return points;

};

/* Return an array of vectors based on contour of the path */

fm.Path.prototype.getPoints = function( divisions ) {

	divisions = divisions || 12;

	var b2 = fm.ShapeUtils.b2;
	var b3 = fm.ShapeUtils.b3;

	var points = [];

	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, tx, ty;

	for ( var i = 0, l = this.actions.length; i < l; i ++ ) {

		var item = this.actions[ i ];

		var action = item.action;
		var args = item.args;

		switch ( action ) {

		case 'moveTo':

			points.push( new fm.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case 'lineTo':

			points.push( new fm.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case 'quadraticCurveTo':

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( var j = 1; j <= divisions; j ++ ) {

				var t = j / divisions;

				tx = b2( t, cpx0, cpx1, cpx );
				ty = b2( t, cpy0, cpy1, cpy );

				points.push( new fm.Vector2( tx, ty ) );

			}

			break;

		case 'bezierCurveTo':

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( var j = 1; j <= divisions; j ++ ) {

				var t = j / divisions;

				tx = b3( t, cpx0, cpx1, cpx2, cpx );
				ty = b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new fm.Vector2( tx, ty ) );

			}

			break;

		case 'splineThru':

			laste = this.actions[ i - 1 ].args;

			var last = new fm.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new fm.SplineCurve( spts );

			for ( var j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) );

			}

			break;

		case 'arc':

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !! args[ 5 ];

			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( var j = 1; j <= tdivisions; j ++ ) {

				var t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + aRadius * Math.cos( angle );
				ty = aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new fm.Vector2( tx, ty ) );

			}

			//console.log(points);

			break;

		case 'ellipse':

			var aX = args[ 0 ], aY = args[ 1 ],
				xRadius = args[ 2 ],
				yRadius = args[ 3 ],
				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
				aClockwise = !! args[ 6 ],
				aRotation = args[ 7 ];


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			var cos, sin;
			if ( aRotation !== 0 ) {

				cos = Math.cos( aRotation );
				sin = Math.sin( aRotation );

			}

			for ( var j = 1; j <= tdivisions; j ++ ) {

				var t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + xRadius * Math.cos( angle );
				ty = aY + yRadius * Math.sin( angle );

				if ( aRotation !== 0 ) {

					var x = tx, y = ty;

					// Rotate the point about the center of the ellipse.
					tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
					ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

				}

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new fm.Vector2( tx, ty ) );

			}

			//console.log(points);

			break;

		} // end switch

	}



	// Normalize to remove the closing point by default.
	var lastPoint = points[ points.length - 1 ];
	if ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&
			 Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )
		points.splice( points.length - 1, 1 );

	if ( this.autoClose ) {

		points.push( points[ 0 ] );

	}

	return points;

};

//
// Breaks path into shapes
//
//	Assumptions (if parameter isCCW==true the opposite holds):
//	- solid shapes are defined clockwise (CW)
//	- holes are defined counterclockwise (CCW)
//
//	If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

fm.Path.prototype.toShapes = function( isCCW, noHoles ) {

	function extractSubpaths( inActions ) {

		var subPaths = [], lastPath = new fm.Path();

		for ( var i = 0, l = inActions.length; i < l; i ++ ) {

			var item = inActions[ i ];

			var args = item.args;
			var action = item.action;

			if ( action === 'moveTo' ) {

				if ( lastPath.actions.length !== 0 ) {

					subPaths.push( lastPath );
					lastPath = new fm.Path();

				}

			}

			lastPath[ action ].apply( lastPath, args );

		}

		if ( lastPath.actions.length !== 0 ) {

			subPaths.push( lastPath );

		}

		// console.log(subPaths);

		return	subPaths;

	}

	function toShapesNoHoles( inSubpaths ) {

		var shapes = [];

		for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

			var tmpPath = inSubpaths[ i ];

			var tmpShape = new fm.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;

			shapes.push( tmpShape );

		}

		//console.log("shape", shapes);

		return shapes;

	}

	function isPointInsidePolygon( inPt, inPolygon ) {

		var polyLen = inPolygon.length;

		// inPt on polygon contour => immediate success    or
		// toggling of inside/outside at every single! intersection point of an edge
		//  with the horizontal line through inPt, left of inPt
		//  not counting lowerY endpoints of edges and whole edges on that line
		var inside = false;
		for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

			var edgeLowPt  = inPolygon[ p ];
			var edgeHighPt = inPolygon[ q ];

			var edgeDx = edgeHighPt.x - edgeLowPt.x;
			var edgeDy = edgeHighPt.y - edgeLowPt.y;

			if ( Math.abs( edgeDy ) > Number.EPSILON ) {

				// not parallel
				if ( edgeDy < 0 ) {

					edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
					edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

				}
				if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

				if ( inPt.y === edgeLowPt.y ) {

					if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
					// continue;				// no intersection or edgeLowPt => doesn't count !!!

				} else {

					var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
					if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
					if ( perpEdge < 0 ) 				continue;
					inside = ! inside;		// true intersection left of inPt

				}

			} else {

				// parallel or collinear
				if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
				// edge lies on the same horizontal line as inPt
				if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
					 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
				// continue;

			}

		}

		return	inside;

	}

	var isClockWise = fm.ShapeUtils.isClockWise;

	var subPaths = extractSubpaths( this.actions );
	if ( subPaths.length === 0 ) return [];

	if ( noHoles === true )	return	toShapesNoHoles( subPaths );


	var solid, tmpPath, tmpShape, shapes = [];

	if ( subPaths.length === 1 ) {

		tmpPath = subPaths[ 0 ];
		tmpShape = new fm.Shape();
		tmpShape.actions = tmpPath.actions;
		tmpShape.curves = tmpPath.curves;
		shapes.push( tmpShape );
		return shapes;

	}

	var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
	holesFirst = isCCW ? ! holesFirst : holesFirst;

	// console.log("Holes first", holesFirst);

	var betterShapeHoles = [];
	var newShapes = [];
	var newShapeHoles = [];
	var mainIdx = 0;
	var tmpPoints;

	newShapes[ mainIdx ] = undefined;
	newShapeHoles[ mainIdx ] = [];

	for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

		tmpPath = subPaths[ i ];
		tmpPoints = tmpPath.getPoints();
		solid = isClockWise( tmpPoints );
		solid = isCCW ? ! solid : solid;

		if ( solid ) {

			if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

			newShapes[ mainIdx ] = { s: new fm.Shape(), p: tmpPoints };
			newShapes[ mainIdx ].s.actions = tmpPath.actions;
			newShapes[ mainIdx ].s.curves = tmpPath.curves;

			if ( holesFirst )	mainIdx ++;
			newShapeHoles[ mainIdx ] = [];

			//console.log('cw', i);

		} else {

			newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

			//console.log('ccw', i);

		}

	}

	// only Holes? -> probably all Shapes with wrong orientation
	if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


	if ( newShapes.length > 1 ) {

		var ambiguous = false;
		var toChange = [];

		for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

			betterShapeHoles[ sIdx ] = [];

		}

		for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

			var sho = newShapeHoles[ sIdx ];

			for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

				var ho = sho[ hIdx ];
				var hole_unassigned = true;

				for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

					if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

						if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
						if ( hole_unassigned ) {

							hole_unassigned = false;
							betterShapeHoles[ s2Idx ].push( ho );

						} else {

							ambiguous = true;

						}

					}

				}
				if ( hole_unassigned ) {

					betterShapeHoles[ sIdx ].push( ho );

				}

			}

		}
		// console.log("ambiguous: ", ambiguous);
		if ( toChange.length > 0 ) {

			// console.log("to change: ", toChange);
			if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

		}

	}

	var tmpHoles;

	for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

		tmpShape = newShapes[ i ].s;
		shapes.push( tmpShape );
		tmpHoles = newShapeHoles[ i ];

		for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

			tmpShape.holes.push( tmpHoles[ j ].h );

		}

	}

	//console.log("shape", shapes);

	return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

fm.Shape = function () {

	fm.Path.apply( this, arguments );

	this.holes = [];

};

fm.Shape.prototype = Object.create( fm.Path.prototype );
fm.Shape.prototype.constructor = fm.Shape;

// Convenience method to return ExtrudeGeometry

fm.Shape.prototype.extrude = function ( options ) {

	return new fm.ExtrudeGeometry( this, options );

};

// Convenience method to return ShapeGeometry

fm.Shape.prototype.makeGeometry = function ( options ) {

	return new fm.ShapeGeometry( this, options );

};

// Get points of holes

fm.Shape.prototype.getPointsHoles = function ( divisions ) {

	var holesPts = [];

	for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getPoints( divisions );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

fm.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

fm.Shape.prototype.extractPoints = function ( divisions ) {

	return this.extractAllPoints( divisions );

};

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

fm.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

fm.LineCurve.prototype = Object.create( fm.Curve.prototype );
fm.LineCurve.prototype.constructor = fm.LineCurve;

fm.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub( this.v1 );
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

fm.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

fm.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub( this.v1 );

	return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


fm.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

fm.QuadraticBezierCurve.prototype = Object.create( fm.Curve.prototype );
fm.QuadraticBezierCurve.prototype.constructor = fm.QuadraticBezierCurve;


fm.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var b2 = fm.ShapeUtils.b2;

	return new fm.Vector2(
		b2( t, this.v0.x, this.v1.x, this.v2.x ),
		b2( t, this.v0.y, this.v1.y, this.v2.y )
	);

};


fm.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var tangentQuadraticBezier = fm.CurveUtils.tangentQuadraticBezier;

	return new fm.Vector2(
		tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
		tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
	).normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

fm.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

fm.CubicBezierCurve.prototype = Object.create( fm.Curve.prototype );
fm.CubicBezierCurve.prototype.constructor = fm.CubicBezierCurve;

fm.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var b3 = fm.ShapeUtils.b3;

	return new fm.Vector2( 
		b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
		b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
	);

};

fm.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tangentCubicBezier = fm.CurveUtils.tangentCubicBezier;

	return new fm.Vector2( 
		tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
		tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
	).normalize();

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

fm.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = ( points == undefined ) ? [] : points;

};

fm.SplineCurve.prototype = Object.create( fm.Curve.prototype );
fm.SplineCurve.prototype.constructor = fm.SplineCurve;

fm.SplineCurve.prototype.getPoint = function ( t ) {

	var points = this.points;
	var point = ( points.length - 1 ) * t;

	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	var point1 = points[ intPoint ];
	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

	var interpolate = fm.CurveUtils.interpolate;

	return new fm.Vector2(
		interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
		interpolate( point0.y, point1.y, point2.y, point3.y, weight )
	);

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

fm.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;
	
	this.aRotation = aRotation || 0;

};

fm.EllipseCurve.prototype = Object.create( fm.Curve.prototype );
fm.EllipseCurve.prototype.constructor = fm.EllipseCurve;

fm.EllipseCurve.prototype.getPoint = function ( t ) {

	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

	var angle;

	if ( this.aClockwise === true ) {

		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

	} else {

		angle = this.aStartAngle + t * deltaAngle;

	}
	
	var x = this.aX + this.xRadius * Math.cos( angle );
	var y = this.aY + this.yRadius * Math.sin( angle );

	if ( this.aRotation !== 0 ) {

		var cos = Math.cos( this.aRotation );
		var sin = Math.sin( this.aRotation );

		var tx = x, ty = y;

		// Rotate the point about the center of the ellipse.
		x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
		y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

	}

	return new fm.Vector2( x, y );

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

fm.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	fm.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

fm.ArcCurve.prototype = Object.create( fm.EllipseCurve.prototype );
fm.ArcCurve.prototype.constructor = fm.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

fm.LineCurve3 = fm.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var vector = new fm.Vector3();

		vector.subVectors( this.v2, this.v1 ); // diff
		vector.multiplyScalar( t );
		vector.add( this.v1 );

		return vector;

	}

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

fm.QuadraticBezierCurve3 = fm.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var b2 = fm.ShapeUtils.b2;		

		return new fm.Vector3(
			b2( t, this.v0.x, this.v1.x, this.v2.x ),
			b2( t, this.v0.y, this.v1.y, this.v2.y ),
			b2( t, this.v0.z, this.v1.z, this.v2.z )
		);

	}

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

fm.CubicBezierCurve3 = fm.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var b3 = fm.ShapeUtils.b3;

		return new fm.Vector3(
			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
			b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
		);

	}

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


fm.SplineCurve3 = fm.Curve.create(

	function ( points /* array of Vector3 */ ) {

		console.warn( 'fm.SplineCurve3 will be deprecated. Please use fm.CatmullRomCurve3' );
		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		var interpolate = fm.CurveUtils.interpolate;

		return new fm.Vector3(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
			interpolate( point0.z, point1.z, point2.z, point3.z, weight )
		);

	}

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

fm.CatmullRomCurve3 = ( function() {

	var
		tmp = new fm.Vector3(),
		px = new CubicPoly(),
		py = new CubicPoly(),
		pz = new CubicPoly();

	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for fm.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

	}

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

		this.c0 = x0;
		this.c1 = t0;
		this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

	};

	CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

		// compute tangents when parameterized in [t1,t2]
		var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
		var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

		// rescale tangents for parametrization in [0,1]
		t1 *= dt1;
		t2 *= dt1;

		// initCubicPoly
		this.init( x1, x2, t1, t2 );

	};

	// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
	CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

		this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

	};

	CubicPoly.prototype.calc = function( t ) {

		var t2 = t * t;
		var t3 = t2 * t;
		return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

	};

	// Subclass fm.js curve
	return fm.Curve.create(

		function ( p /* array of Vector3 */ ) {

			this.points = p || [];
			this.closed = false;

		},

		function ( t ) {

			var points = this.points,
				point, intPoint, weight, l;

			l = points.length;

			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

			point = ( l - ( this.closed ? 0 : 1 ) ) * t;
			intPoint = Math.floor( point );
			weight = point - intPoint;

			if ( this.closed ) {

				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

			} else if ( weight === 0 && intPoint === l - 1 ) {

				intPoint = l - 2;
				weight = 1;

			}

			var p0, p1, p2, p3; // 4 points

			if ( this.closed || intPoint > 0 ) {

				p0 = points[ ( intPoint - 1 ) % l ];

			} else {

				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;

			}

			p1 = points[ intPoint % l ];
			p2 = points[ ( intPoint + 1 ) % l ];

			if ( this.closed || intPoint + 2 < l ) {

				p3 = points[ ( intPoint + 2 ) % l ];

			} else {

				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
				p3 = tmp;

			}

			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

				// init Centripetal / Chordal Catmull-Rom
				var pow = this.type === 'chordal' ? 0.5 : 0.25;
				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

				// safety check for repeated points
				if ( dt1 < 1e-4 ) dt1 = 1.0;
				if ( dt0 < 1e-4 ) dt0 = dt1;
				if ( dt2 < 1e-4 ) dt2 = dt1;

				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

			} else if ( this.type === 'catmullrom' ) {

				var tension = this.tension !== undefined ? this.tension : 0.5;
				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

			}

			var v = new fm.Vector3(
				px.calc( weight ),
				py.calc( weight ),
				pz.calc( weight )
			);

			return v;

		}

	);

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


fm.ClosedSplineCurve3 = function ( points ) {

	console.warn( 'fm.ClosedSplineCurve3 has been deprecated. Please use fm.CatmullRomCurve3.' );

	fm.CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';
	this.closed = true;

};

fm.ClosedSplineCurve3.prototype = Object.create( fm.CatmullRomCurve3.prototype );

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

fm.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	fm.Geometry.call( this );

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.fromBufferGeometry( new fm.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
	this.mergeVertices();

};

fm.BoxGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.BoxGeometry.prototype.constructor = fm.BoxGeometry;

fm.CubeGeometry = fm.BoxGeometry;

// File:src/extras/geometries/BoxBufferGeometry.js

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

fm.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	fm.BufferGeometry.call( this );

	this.type = 'BoxBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	var scope = this;

	// segments
	widthSegments = Math.floor( widthSegments ) || 1;
	heightSegments = Math.floor( heightSegments ) || 1;
	depthSegments = Math.floor( depthSegments ) || 1;

	// these are used to calculate buffer length
	var vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );
	var indexCount = ( vertexCount / 4 ) * 6;

	// buffers
	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
	var vertices = new Float32Array( vertexCount * 3 );
	var normals = new Float32Array( vertexCount * 3 );
	var uvs = new Float32Array( vertexCount * 2 );

	// offset variables
	var vertexBufferOffset = 0;
	var uvBufferOffset = 0;
	var indexBufferOffset = 0;
	var numberOfVertices = 0;

	// group variables
	var groupStart = 0;

	// build each side of the box geometry
	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
	buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
	buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
	buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
	buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz

	// build geometry
	this.setIndex( new fm.BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new fm.BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new fm.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new fm.BufferAttribute( uvs, 2 ) );

	// helper functions

	function calculateVertexCount ( w, h, d ) {

		var segments = 0;

		// calculate the amount of segments for each side
		segments += w * h * 2; // xy
		segments += w * d * 2; // xz
		segments += d * h * 2; // zy

		return segments * 4; // four vertices per segments

	}

	function buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

		var segmentWidth	= width / gridX;
		var segmentHeight = height / gridY;

		var widthHalf = width / 2;
		var heightHalf = height / 2;
		var depthHalf = depth / 2;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var vertexCounter = 0;
		var groupCount = 0;

		var vector = new fm.Vector3();

		// generate vertices, normals and uvs

		for ( var iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segmentHeight - heightHalf;

			for ( var ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segmentWidth - widthHalf;

				// set values to correct vector component
				vector[ u ] = x * udir;
				vector[ v ] = y * vdir;
				vector[ w ] = depthHalf;

				// now apply vector to vertex buffer
				vertices[ vertexBufferOffset ] = vector.x;
				vertices[ vertexBufferOffset + 1 ] = vector.y;
				vertices[ vertexBufferOffset + 2 ] = vector.z;

				// set values to correct vector component
				vector[ u ] = 0;
				vector[ v ] = 0;
				vector[ w ] = depth > 0 ? 1 : - 1;

				// now apply vector to normal buffer
				normals[ vertexBufferOffset ] = vector.x;
				normals[ vertexBufferOffset + 1 ] = vector.y;
				normals[ vertexBufferOffset + 2 ] = vector.z;

				// uvs
				uvs[ uvBufferOffset ] = ix / gridX;
				uvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );

				// update offsets and counters
				vertexBufferOffset += 3;
				uvBufferOffset += 2;
				vertexCounter += 1;

			}

		}

		// 1. you need fm indices to draw a single face
		// 2. a single segment consists of two faces
		// 3. so we need to generate six (2*3) indices per segment

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				// indices
				var a = numberOfVertices + ix + gridX1 * iy;
				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

				// face one
				indices[ indexBufferOffset ] = a;
				indices[ indexBufferOffset + 1 ] = b;
				indices[ indexBufferOffset + 2 ] = d;

				// face two
				indices[ indexBufferOffset + 3 ] = b;
				indices[ indexBufferOffset + 4 ] = c;
				indices[ indexBufferOffset + 5 ] = d;

				// update offsets and counters
				indexBufferOffset += 6;
				groupCount += 6;

			}

		}

		// add a group to the geometry. this will ensure multi material support
		scope.addGroup( groupStart, groupCount, materialIndex );

		// calculate new start value for groups
		groupStart += groupCount;

		// update total number of vertices
		numberOfVertices += vertexCounter;

	}

};

fm.BoxBufferGeometry.prototype = Object.create( fm.BufferGeometry.prototype );
fm.BoxBufferGeometry.prototype.constructor = fm.BoxBufferGeometry;

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

fm.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	fm.Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new fm.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

};

fm.CircleGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.CircleGeometry.prototype.constructor = fm.CircleGeometry;

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

fm.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	fm.BufferGeometry.call( this );

	this.type = 'CircleBufferGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var vertices = segments + 2;

	var positions = new Float32Array( vertices * 3 );
	var normals = new Float32Array( vertices * 3 );
	var uvs = new Float32Array( vertices * 2 );

	// center data is already zero, but need to set a few extras
	normals[ 2 ] = 1.0;
	uvs[ 0 ] = 0.5;
	uvs[ 1 ] = 0.5;

	for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

		var segment = thetaStart + s / segments * thetaLength;

		positions[ i ] = radius * Math.cos( segment );
		positions[ i + 1 ] = radius * Math.sin( segment );

		normals[ i + 2 ] = 1; // normal z

		uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
		uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

	}

	var indices = [];

	for ( var i = 1; i <= segments; i ++ ) {

		indices.push( i, i + 1, 0 );

	}

	this.setIndex( new fm.BufferAttribute( new Uint16Array( indices ), 1 ) );
	this.addAttribute( 'position', new fm.BufferAttribute( positions, 3 ) );
	this.addAttribute( 'normal', new fm.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new fm.BufferAttribute( uvs, 2 ) );

	this.boundingSphere = new fm.Sphere( new fm.Vector3(), radius );

};

fm.CircleBufferGeometry.prototype = Object.create( fm.BufferGeometry.prototype );
fm.CircleBufferGeometry.prototype.constructor = fm.CircleBufferGeometry;

// File:src/extras/geometries/CylinderBufferGeometry.js

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

fm.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	fm.BufferGeometry.call( this );

	this.type = 'CylinderBufferGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	var scope = this;

	radiusTop = radiusTop !== undefined ? radiusTop : 20;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	height = height !== undefined ? height : 100;

	radialSegments = Math.floor( radialSegments ) || 8;
	heightSegments = Math.floor( heightSegments ) || 1;

	openEnded = openEnded !== undefined ? openEnded : false;
	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

	// used to calculate buffer length

	var vertexCount = calculateVertexCount();
	var indexCount = calculateIndexCount();

	// buffers

	var indices = new fm.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );
	var vertices = new fm.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new fm.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new fm.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	// helper variables

	var index = 0, indexOffset = 0, indexArray = [], halfHeight = height / 2;

	// group variables
	var groupStart = 0;

	// generate geometry

	generateTorso();

	if ( openEnded === false ) {

		if ( radiusTop > 0 ) generateCap( true );
		if ( radiusBottom > 0 ) generateCap( false );

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', vertices );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

	// helper functions

	function calculateVertexCount() {

		var count = ( radialSegments + 1 ) * ( heightSegments + 1 );

		if ( openEnded === false ) {

			count += ( ( radialSegments + 1 ) * 2 ) + ( radialSegments * 2 );

		}

		return count;

	}

	function calculateIndexCount() {

		var count = radialSegments * heightSegments * 2 * 3;

		if ( openEnded === false ) {

			count += radialSegments * 2 * 3;

		}

		return count;

	}

	function generateTorso() {

		var x, y;
		var normal = new fm.Vector3();
		var vertex = new fm.Vector3();

		var groupCount = 0;

		// this will be used to calculate the normal
		var tanTheta = ( radiusBottom - radiusTop ) / height;

		// generate vertices, normals and uvs

		for ( y = 0; y <= heightSegments; y ++ ) {

			var indexRow = [];

			var v = y / heightSegments;

			// calculate the radius of the current row
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;

				// vertex
				vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
				vertex.y = - v * height + halfHeight;
				vertex.z = radius * Math.cos( u * thetaLength + thetaStart );
				vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

				// normal
				normal.copy( vertex );

				// handle special case if radiusTop/radiusBottom is zero
				if ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {

					normal.x = Math.sin( u * thetaLength + thetaStart );
					normal.z = Math.cos( u * thetaLength + thetaStart );

				}

				normal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();
				normals.setXYZ( index, normal.x, normal.y, normal.z );

				// uv
				uvs.setXY( index, u, 1 - v );

				// save index of vertex in respective row
				indexRow.push( index );

				// increase index
				index ++;

			}

			// now save vertices of the row in our index array
			indexArray.push( indexRow );

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			for ( y = 0; y < heightSegments; y ++ ) {

				// we use the index array to access the correct indices
				var i1 = indexArray[ y ][ x ];
				var i2 = indexArray[ y + 1 ][ x ];
				var i3 = indexArray[ y + 1 ][ x + 1 ];
				var i4 = indexArray[ y ][ x + 1 ];

				// face one
				indices.setX( indexOffset, i1 ); indexOffset ++;
				indices.setX( indexOffset, i2 ); indexOffset ++;
				indices.setX( indexOffset, i4 ); indexOffset ++;

				// face two
				indices.setX( indexOffset, i2 ); indexOffset ++;
				indices.setX( indexOffset, i3 ); indexOffset ++;
				indices.setX( indexOffset, i4 ); indexOffset ++;

				// update counters
				groupCount += 6;

			}

		}

		// add a group to the geometry. this will ensure multi material support
		scope.addGroup( groupStart, groupCount, 0 );

		// calculate new start value for groups
		groupStart += groupCount;

	}

	function generateCap( top ) {

		var x, centerIndexStart, centerIndexEnd;
		var uv = new fm.Vector2();
		var vertex = new fm.Vector3();

		var groupCount = 0;

		var radius = ( top === true ) ? radiusTop : radiusBottom;
		var sign = ( top === true ) ? 1 : - 1;

		// save the index of the first center vertex
		centerIndexStart = index;

		// first we generate the center vertex data of the cap.
		// because the geometry needs one set of uvs per face,
		// we must generate a center vertex per face/segment

		for ( x = 1; x <= radialSegments; x ++ ) {

			// vertex
			vertices.setXYZ( index, 0, halfHeight * sign, 0 );

			// normal
			normals.setXYZ( index, 0, sign, 0 );

			// uv
			if ( top === true ) {

				uv.x = x / radialSegments;
				uv.y = 0;

			} else {

				uv.x = ( x - 1 ) / radialSegments;
				uv.y = 1;

			}

			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index ++;

		}

		// save the index of the last center vertex
		centerIndexEnd = index;

		// now we generate the surrounding vertices, normals and uvs

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;

			// vertex
			vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
			vertex.y = halfHeight * sign;
			vertex.z = radius * Math.cos( u * thetaLength + thetaStart );
			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

			// normal
			normals.setXYZ( index, 0, sign, 0 );

			// uv
			uvs.setXY( index, u, ( top === true ) ? 1 : 0 );

			// increase index
			index ++;

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			var c = centerIndexStart + x;
			var i = centerIndexEnd + x;

			if ( top === true ) {

				// face top
				indices.setX( indexOffset, i ); indexOffset ++;
				indices.setX( indexOffset, i + 1 ); indexOffset ++;
				indices.setX( indexOffset, c ); indexOffset ++;

			} else {

				// face bottom
				indices.setX( indexOffset, i + 1 ); indexOffset ++;
				indices.setX( indexOffset, i ); indexOffset ++;
				indices.setX( indexOffset, c ); indexOffset ++;

			}

			// update counters
			groupCount += 3;

		}

		// add a group to the geometry. this will ensure multi material support
		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

		// calculate new start value for groups
		groupStart += groupCount;

	}

};

fm.CylinderBufferGeometry.prototype = Object.create( fm.BufferGeometry.prototype );
fm.CylinderBufferGeometry.prototype.constructor = fm.CylinderBufferGeometry;

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	fm.Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new fm.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
	this.mergeVertices();

};

fm.CylinderGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.CylinderGeometry.prototype.constructor = fm.CylinderGeometry;

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

fm.EdgesGeometry = function ( geometry, thresholdAngle ) {

	fm.BufferGeometry.call( this );

	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

	var thresholdDot = Math.cos( fm.Math.DEG2RAD * thresholdAngle );

	var edge = [ 0, 0 ], hash = {};

	function sortFunction( a, b ) {

		return a - b;

	}

	var keys = [ 'a', 'b', 'c' ];

	var geometry2;

	if ( geometry instanceof fm.BufferGeometry ) {

		geometry2 = new fm.Geometry();
		geometry2.fromBufferGeometry( geometry );

	} else {

		geometry2 = geometry.clone();

	}

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	var coords = [];

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

			var vertex = vertices[ h.vert1 ];
			coords.push( vertex.x );
			coords.push( vertex.y );
			coords.push( vertex.z );

			vertex = vertices[ h.vert2 ];
			coords.push( vertex.x );
			coords.push( vertex.y );
			coords.push( vertex.z );

		}

	}

	this.addAttribute( 'position', new fm.BufferAttribute( new Float32Array( coords ), 3 ) );

};

fm.EdgesGeometry.prototype = Object.create( fm.BufferGeometry.prototype );
fm.EdgesGeometry.prototype.constructor = fm.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <fm.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <fm.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

fm.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {

		shapes = [];
		return;

	}

	fm.Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

fm.ExtrudeGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.ExtrudeGeometry.prototype.constructor = fm.ExtrudeGeometry;

fm.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {

		var shape = shapes[ s ];
		this.addShape( shape, options );

	}

};

fm.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : fm.ExtrudeGeometry.WorldUVGenerator;

	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new fm.TubeGeometry.FrenetFrames( extrudePath, steps, false );

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new fm.Vector3();
		normal = new fm.Vector3();
		position2 = new fm.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initialization

	var ahole, h, hl; // looping of holes
	var scope = this;

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! fm.ShapeUtils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( fm.ShapeUtils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = fm.ShapeUtils.triangulateShape( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( ! vec ) console.error( "fm.ExtrudeGeometry: vec does not exist" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length;


	// Find directions for point movement


	function getBevelVec( inPt, inPrev, inNext ) {

		// computes for inPt the corresponding point inPt' on a new contour
		//   shifted by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.

		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

		// check for collinear edges
		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

			// not collinear

			// length of vectors for normalizing

			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

			// shift adjacent points by unit vectors to the left

			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

			// scaling factor for v_prev to intersection point

			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			// vector from inPt to intersection point

			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
			if ( v_trans_lensq <= 2 ) {

				return	new fm.Vector2( v_trans_x, v_trans_y );

			} else {

				shrink_by = Math.sqrt( v_trans_lensq / 2 );

			}

		} else {

			// handle special case of collinear edges

			var direction_eq = false;		// assumes: opposite
			if ( v_prev_x > Number.EPSILON ) {

				if ( v_next_x > Number.EPSILON ) {

					direction_eq = true;

				}

			} else {

				if ( v_prev_x < - Number.EPSILON ) {

					if ( v_next_x < - Number.EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

						direction_eq = true;

					}

				}

			}

			if ( direction_eq ) {

				// console.log("Warning: lines are a straight sequence");
				v_trans_x = - v_prev_y;
				v_trans_y =  v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );

			} else {

				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );

			}

		}

		return	new fm.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {

		//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
		//bs = bevelSize * t; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( ! extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI / 2 );

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	//
	// ztc 20180228 加了一个字段，用于是否创建侧边的墙，
	// 主要用于，场景物体数过多，运行卡顿时，只保留顶面，提高渲染效率，但只能使用top视图，因为没有侧面儿了
	//
	
	if (!options.noSideFaces) {
		buildSideFaces();
	}

	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

			}

		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( -- i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}

		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new fm.Vector3( x, y, z ) );

	}

	function f3( a, b, c ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		scope.faces.push( new fm.Face3( a, b, c, null, null, 0 ) );

		var uvs = uvgen.generateTopUV( scope, a, b, c );

		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

		scope.faces.push( new fm.Face3( a, b, d, null, null, 1 ) );
		scope.faces.push( new fm.Face3( b, c, d, null, null, 1 ) );

		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

fm.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];

		return [
			new fm.Vector2( a.x, a.y ),
			new fm.Vector2( b.x, b.y ),
			new fm.Vector2( c.x, c.y )
		];

	},

	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];
		var d = vertices[ indexD ];

		if ( Math.abs( a.y - b.y ) < 0.01 ) {

			return [
				new fm.Vector2( a.x, 1 - a.z ),
				new fm.Vector2( b.x, 1 - b.z ),
				new fm.Vector2( c.x, 1 - c.z ),
				new fm.Vector2( d.x, 1 - d.z )
			];

		} else {

			return [
				new fm.Vector2( a.y, 1 - a.z ),
				new fm.Vector2( b.y, 1 - b.z ),
				new fm.Vector2( c.y, 1 - c.z ),
				new fm.Vector2( d.y, 1 - d.z )
			];

		}

	}
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

fm.ShapeGeometry = function ( shapes, options ) {

	fm.Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

};

fm.ShapeGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.ShapeGeometry.prototype.constructor = fm.ShapeGeometry;

/**
 * Add an array of shapes to fm.ShapeGeometry.
 */
fm.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to fm.ShapeGeometry, based on fm.ExtrudeGeometry.
 */
fm.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? fm.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	//

	var i, l, hole;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! fm.ShapeUtils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];

			if ( fm.ShapeUtils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = fm.ShapeUtils.triangulateShape( vertices, holes );

	// Vertices

	for ( i = 0, l = holes.length; i < l; i ++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;

	for ( i = 0; i < vlen; i ++ ) {

		vert = vertices[ i ];

		this.vertices.push( new fm.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i ++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new fm.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

	}

};

// File:src/extras/geometries/LatheBufferGeometry.js

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

 // points - to create a closed torus, one must use a set of points
 //    like so: [ a, b, c, d, a ], see first is the same as last.
 // segments - the number of circumference segments to create
 // phiStart - the starting radian
 // phiLength - the radian (0 to 2PI) range of the lathed section
 //    2PI is a closed lathe, less than 2PI is a portion.

fm.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {

	fm.BufferGeometry.call( this );

	this.type = 'LatheBufferGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = Math.floor( segments ) || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || Math.PI * 2;

	// clamp phiLength so it's in range of [ 0, 2PI ]
	phiLength = fm.Math.clamp( phiLength, 0, Math.PI * 2 );

	// these are used to calculate buffer length
	var vertexCount = ( segments + 1 ) * points.length;
	var indexCount = segments * points.length * 2 * 3;

	// buffers
	var indices = new fm.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
	var vertices = new fm.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new fm.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	// helper variables
	var index = 0, indexOffset = 0, base;
	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;
	var vertex = new fm.Vector3();
	var uv = new fm.Vector2();
	var i, j;

	// generate vertices and uvs

	for ( i = 0; i <= segments; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var sin = Math.sin( phi );
		var cos = Math.cos( phi );

		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

			// vertex
			vertex.x = points[ j ].x * sin;
			vertex.y = points[ j ].y;
			vertex.z = points[ j ].x * cos;
			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

			// uv
			uv.x = i / segments;
			uv.y = j / ( points.length - 1 );
			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index ++;

		}

	}

	// generate indices

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

			base = j + i * points.length;

			// indices
			var a = base;
			var b = base + points.length;
			var c = base + points.length + 1;
			var d = base + 1;

			// face one
			indices.setX( indexOffset, a ); indexOffset++;
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

			// face two
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, c ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', vertices );
	this.addAttribute( 'uv', uvs );

	// generate normals

	this.computeVertexNormals();

	// if the geometry is closed, we need to average the normals along the seam.
	// because the corresponding vertices are identical (but still have different UVs).

	if( phiLength === Math.PI * 2 ) {

		var normals = this.attributes.normal.array;
		var n1 = new fm.Vector3();
		var n2 = new fm.Vector3();
		var n = new fm.Vector3();

		// this is the buffer offset for the last line of vertices
		base = segments * points.length * 3;

		for( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

			// select the normal of the vertex in the first line
			n1.x = normals[ j + 0 ];
			n1.y = normals[ j + 1 ];
			n1.z = normals[ j + 2 ];

			// select the normal of the vertex in the last line
			n2.x = normals[ base + j + 0 ];
			n2.y = normals[ base + j + 1 ];
			n2.z = normals[ base + j + 2 ];

			// average normals
			n.addVectors( n1, n2 ).normalize();

			// assign the new values to both normals
			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

		} // next row

	}

};

fm.LatheBufferGeometry.prototype = Object.create( fm.BufferGeometry.prototype );
fm.LatheBufferGeometry.prototype.constructor = fm.LatheBufferGeometry;

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2PI) range of the lathed section
//    2PI is a closed lathe, less than 2PI is a portion.

fm.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	fm.Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	this.fromBufferGeometry( new fm.LatheBufferGeometry( points, segments, phiStart, phiLength ) );
	this.mergeVertices();

};

fm.LatheGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.LatheGeometry.prototype.constructor = fm.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

fm.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	fm.Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new fm.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

fm.PlaneGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.PlaneGeometry.prototype.constructor = fm.PlaneGeometry;

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

fm.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

	fm.BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = Math.floor( widthSegments ) || 1;
	var gridY = Math.floor( heightSegments ) || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
	var normals = new Float32Array( gridX1 * gridY1 * 3 );
	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

	var offset = 0;
	var offset2 = 0;

	for ( var iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( var ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices[ offset ] = x;
			vertices[ offset + 1 ] = - y;

			normals[ offset + 2 ] = 1;

			uvs[ offset2 ] = ix / gridX;
			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

			offset += 3;
			offset2 += 2;

		}

	}

	offset = 0;

	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

	for ( var iy = 0; iy < gridY; iy ++ ) {

		for ( var ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			indices[ offset ] = a;
			indices[ offset + 1 ] = b;
			indices[ offset + 2 ] = d;

			indices[ offset + 3 ] = b;
			indices[ offset + 4 ] = c;
			indices[ offset + 5 ] = d;

			offset += 6;

		}

	}

	this.setIndex( new fm.BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new fm.BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new fm.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new fm.BufferAttribute( uvs, 2 ) );

};

fm.PlaneBufferGeometry.prototype = Object.create( fm.BufferGeometry.prototype );
fm.PlaneBufferGeometry.prototype.constructor = fm.PlaneBufferGeometry;

// File:src/extras/geometries/RingBufferGeometry.js

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

fm.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	fm.BufferGeometry.call( this );

	this.type = 'RingBufferGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 20;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

	// these are used to calculate buffer length
	var vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );
	var indexCount = thetaSegments * phiSegments * 2 * 3;

	// buffers
	var indices = new fm.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
	var vertices = new fm.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new fm.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new fm.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	// some helper variables
	var index = 0, indexOffset = 0, segment;
	var radius = innerRadius;
	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
	var vertex = new fm.Vector3();
	var uv = new fm.Vector2();
	var j, i;

	// generate vertices, normals and uvs

	// values are generate from the inside of the ring to the outside

	for ( j = 0; j <= phiSegments; j ++ ) {

		for ( i = 0; i <= thetaSegments; i ++ ) {

			segment = thetaStart + i / thetaSegments * thetaLength;

			// vertex
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );
			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

			// normal
			normals.setXYZ( index, 0, 0, 1 );

			// uv
			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
			uv.y = ( vertex.y / outerRadius + 1 ) / 2;
			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index++;

		}

		// increase the radius for next row of vertices
		radius += radiusStep;

	}

	// generate indices

	for ( j = 0; j < phiSegments; j ++ ) {

		var thetaSegmentLevel = j * ( thetaSegments + 1 );

		for ( i = 0; i < thetaSegments; i ++ ) {

			segment = i + thetaSegmentLevel;

			// indices
			var a = segment;
			var b = segment + thetaSegments + 1;
			var c = segment + thetaSegments + 2;
			var d = segment + 1;

			// face one
			indices.setX( indexOffset, a ); indexOffset++;
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, c ); indexOffset++;

			// face two
			indices.setX( indexOffset, a ); indexOffset++;
			indices.setX( indexOffset, c ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', vertices );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

};

fm.RingBufferGeometry.prototype = Object.create( fm.BufferGeometry.prototype );
fm.RingBufferGeometry.prototype.constructor = fm.RingBufferGeometry;

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

fm.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	fm.Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new fm.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );

};

fm.RingGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.RingGeometry.prototype.constructor = fm.RingGeometry;

// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	fm.Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new fm.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

};

fm.SphereGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.SphereGeometry.prototype.constructor = fm.SphereGeometry;

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on fm.SphereGeometry
 */

fm.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	fm.BufferGeometry.call( this );

	this.type = 'SphereBufferGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var thetaEnd = thetaStart + thetaLength;

	var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

	var positions = new fm.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new fm.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new fm.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	var index = 0, vertices = [], normal = new fm.Vector3();

	for ( var y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];

		var v = y / heightSegments;

		for ( var x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;

			var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			var py = radius * Math.cos( thetaStart + v * thetaLength );
			var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			normal.set( px, py, pz ).normalize();

			positions.setXYZ( index, px, py, pz );
			normals.setXYZ( index, normal.x, normal.y, normal.z );
			uvs.setXY( index, u, 1 - v );

			verticesRow.push( index );

			index ++;

		}

		vertices.push( verticesRow );

	}

	var indices = [];

	for ( var y = 0; y < heightSegments; y ++ ) {

		for ( var x = 0; x < widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
			if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

		}

	}

	this.setIndex( new ( positions.count > 65535 ? fm.Uint32Attribute : fm.Uint16Attribute )( indices, 1 ) );
	this.addAttribute( 'position', positions );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

	this.boundingSphere = new fm.Sphere( new fm.Vector3(), radius );

};

fm.SphereBufferGeometry.prototype = Object.create( fm.BufferGeometry.prototype );
fm.SphereBufferGeometry.prototype.constructor = fm.SphereBufferGeometry;

// File:src/extras/geometries/TextGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <fm.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float> // how far from text outline is bevel
 * }
 */

fm.TextGeometry = function ( text, parameters ) {

	parameters = parameters || {};

	var font = parameters.font;

	if ( font instanceof fm.Font === false ) {

		console.error( 'fm.TextGeometry: font parameter is not an instance of fm.Font.' );
		return new fm.Geometry();

	}

	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	fm.ExtrudeGeometry.call( this, shapes, parameters );

	this.type = 'TextGeometry';

};

fm.TextGeometry.prototype = Object.create( fm.ExtrudeGeometry.prototype );
fm.TextGeometry.prototype.constructor = fm.TextGeometry;

// File:src/extras/geometries/TorusBufferGeometry.js

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

fm.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	fm.BufferGeometry.call( this );

	this.type = 'TorusBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = Math.floor( radialSegments ) || 8;
	tubularSegments = Math.floor( tubularSegments ) || 6;
	arc = arc || Math.PI * 2;

	// used to calculate buffer length
	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
	var indexCount = radialSegments * tubularSegments * 2 * 3;

	// buffers
	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
	var vertices = new Float32Array( vertexCount * 3 );
	var normals = new Float32Array( vertexCount * 3 );
	var uvs = new Float32Array( vertexCount * 2 );

	// offset variables
	var vertexBufferOffset = 0;
	var uvBufferOffset = 0;
	var indexBufferOffset = 0;

	// helper variables
	var center = new fm.Vector3();
	var vertex = new fm.Vector3();
	var normal = new fm.Vector3();

	var j, i;

	// generate vertices, normals and uvs

	for ( j = 0; j <= radialSegments; j ++ ) {

		for ( i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			// vertex
			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			vertices[ vertexBufferOffset ] = vertex.x;
			vertices[ vertexBufferOffset + 1 ] = vertex.y;
			vertices[ vertexBufferOffset + 2 ] = vertex.z;

			// this vector is used to calculate the normal
			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );

			// normal
			normal.subVectors( vertex, center ).normalize();

			normals[ vertexBufferOffset ] = normal.x;
			normals[ vertexBufferOffset + 1 ] = normal.y;
			normals[ vertexBufferOffset + 2 ] = normal.z;

			// uv
			uvs[ uvBufferOffset ] = i / tubularSegments;
			uvs[ uvBufferOffset + 1 ] = j / radialSegments;

			// update offsets
			vertexBufferOffset += 3;
			uvBufferOffset += 2;

		}

	}

	// generate indices

	for ( j = 1; j <= radialSegments; j ++ ) {

		for ( i = 1; i <= tubularSegments; i ++ ) {

			// indices
			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			// face one
			indices[ indexBufferOffset ] = a;
			indices[ indexBufferOffset + 1 ] = b;
			indices[ indexBufferOffset + 2 ] = d;

			// face two
			indices[ indexBufferOffset + 3 ] = b;
			indices[ indexBufferOffset + 4 ] = c;
			indices[ indexBufferOffset + 5 ] = d;

			// update offset
			indexBufferOffset += 6;

		}

	}

	// build geometry
	this.setIndex( new fm.BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new fm.BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new fm.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new fm.BufferAttribute( uvs, 2 ) );

};

fm.TorusBufferGeometry.prototype = Object.create( fm.BufferGeometry.prototype );
fm.TorusBufferGeometry.prototype.constructor = fm.TorusBufferGeometry;

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

fm.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	fm.Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	this.fromBufferGeometry( new fm.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );

};

fm.TorusGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.TorusGeometry.prototype.constructor = fm.TorusGeometry;

// File:src/extras/geometries/TorusKnotBufferGeometry.js

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * see: http://www.blackpawn.com/texts/pqtorus/
 */
fm.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {

	fm.BufferGeometry.call( this );

	this.type = 'TorusKnotBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	radius = radius || 100;
	tube = tube || 40;
	tubularSegments = Math.floor( tubularSegments ) || 64;
	radialSegments = Math.floor( radialSegments ) || 8;
	p = p || 2;
	q = q || 3;

	// used to calculate buffer length
	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
	var indexCount = radialSegments * tubularSegments * 2 * 3;

	// buffers
	var indices = new fm.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
	var vertices = new fm.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new fm.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new fm.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	// helper variables
	var i, j, index = 0, indexOffset = 0;

	var vertex = new fm.Vector3();
	var normal = new fm.Vector3();
	var uv = new fm.Vector2();

	var P1 = new fm.Vector3();
	var P2 = new fm.Vector3();

	var B = new fm.Vector3();
	var T = new fm.Vector3();
	var N = new fm.Vector3();

	// generate vertices, normals and uvs

	for ( i = 0; i <= tubularSegments; ++ i ) {

		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

		var u = i / tubularSegments * p * Math.PI * 2;

		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

		calculatePositionOnCurve( u, p, q, radius, P1 );
		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

		// calculate orthonormal basis

		T.subVectors( P2, P1 );
		N.addVectors( P2, P1 );
		B.crossVectors( T, N );
		N.crossVectors( B, T );

		// normalize B, N. T can be ignored, we don't use it

		B.normalize();
		N.normalize();

		for ( j = 0; j <= radialSegments; ++ j ) {

			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

			var v = j / radialSegments * Math.PI * 2;
			var cx = - tube * Math.cos( v );
			var cy = tube * Math.sin( v );

			// now calculate the final vertex position.
			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

			vertex.x = P1.x + ( cx * N.x + cy * B.x );
			vertex.y = P1.y + ( cx * N.y + cy * B.y );
			vertex.z = P1.z + ( cx * N.z + cy * B.z );

			// vertex
			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
			normal.subVectors( vertex, P1 ).normalize();
			normals.setXYZ( index, normal.x, normal.y, normal.z );

			// uv
			uv.x = i / tubularSegments;
			uv.y = j / radialSegments;
			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index ++;

		}

	}

	// generate indices

	for ( j = 1; j <= tubularSegments; j ++ ) {

		for ( i = 1; i <= radialSegments; i ++ ) {

			// indices
			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
			var b = ( radialSegments + 1 ) * j + ( i - 1 );
			var c = ( radialSegments + 1 ) * j + i;
			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

			// face one
			indices.setX( indexOffset, a ); indexOffset++;
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

			// face two
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, c ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', vertices );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

	// this function calculates the current position on the torus curve

	function calculatePositionOnCurve( u, p, q, radius, position ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = q / p * u;
		var cs = Math.cos( quOverP );

		position.x = radius * ( 2 + cs ) * 0.5 * cu;
		position.y = radius * ( 2 + cs ) * su * 0.5;
		position.z = radius * Math.sin( quOverP ) * 0.5;

	}

};

fm.TorusKnotBufferGeometry.prototype = Object.create( fm.BufferGeometry.prototype );
fm.TorusKnotBufferGeometry.prototype.constructor = fm.TorusKnotBufferGeometry;

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 */

fm.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

	fm.Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	if( heightScale !== undefined ) console.warn( 'fm.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

	this.fromBufferGeometry( new fm.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
	this.mergeVertices();

};

fm.TorusKnotGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.TorusKnotGeometry.prototype.constructor = fm.TorusKnotGeometry;

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

fm.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

	fm.Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		segments: segments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed,
		taper: taper
	};

	segments = segments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;
	taper = taper || fm.TubeGeometry.NoTaper;

	var grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = segments + 1,

		u, v, r,

		cx, cy,
		pos, pos2 = new fm.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new fm.TubeGeometry.FrenetFrames( path, segments, closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new fm.Vector3( x, y, z ) ) - 1;

	}

	// construct the grid

	for ( i = 0; i < numpoints; i ++ ) {

		grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		r = radius * taper( u );

		for ( j = 0; j < radialSegments; j ++ ) {

			v = j / radialSegments * 2 * Math.PI;

			cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = r * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}

	}


	// construct the mesh

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < radialSegments; j ++ ) {

			ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
			jp = ( j + 1 ) % radialSegments;

			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = grid[ ip ][ j ];
			c = grid[ ip ][ jp ];
			d = grid[ i ][ jp ];

			uva = new fm.Vector2( i / segments, j / radialSegments );
			uvb = new fm.Vector2( ( i + 1 ) / segments, j / radialSegments );
			uvc = new fm.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
			uvd = new fm.Vector2( i / segments, ( j + 1 ) / radialSegments );

			this.faces.push( new fm.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new fm.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	this.computeFaceNormals();
	this.computeVertexNormals();

};

fm.TubeGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.TubeGeometry.prototype.constructor = fm.TubeGeometry;

fm.TubeGeometry.NoTaper = function ( u ) {

	return 1;

};

fm.TubeGeometry.SinusoidalTaper = function ( u ) {

	return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
fm.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

	var	normal = new fm.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new fm.Vector3(),
		mat = new fm.Matrix4(),

		numpoints = segments + 1,
		theta,
		smallest,

		tx, ty, tz,
		i, u;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i ++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	/*
	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new fm.Vector3();
		binormals[ 0 ] = new fm.Vector3();
		if (lastBinormal===undefined) lastBinormal = new fm.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new fm.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new fm.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}
	*/

	function initialNormal3() {

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new fm.Vector3();
		binormals[ 0 ] = new fm.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {

			smallest = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= smallest ) {

			smallest = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= smallest ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i ++ ) {

		normals[ i ] = normals[ i - 1 ].clone();

		binormals[ i ] = binormals[ i - 1 ].clone();

		vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

		if ( vec.length() > Number.EPSILON ) {

			vec.normalize();

			theta = Math.acos( fm.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( fm.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

			theta = - theta;

		}

		for ( i = 1; i < numpoints; i ++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}

};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

fm.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

	fm.Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

		prepare( new fm.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

	}

	var p = this.vertices;

	var faces = [];

	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

		var v1 = p[ indices[ i ] ];
		var v2 = p[ indices[ i + 1 ] ];
		var v3 = p[ indices[ i + 2 ] ];

		faces[ j ] = new fm.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

	}

	var centroid = new fm.Vector3();

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		subdivide( faces[ i ], detail );

	}


	// Handle case when face straddles the seam

	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

		var uvs = this.faceVertexUvs[ 0 ][ i ];

		var x0 = uvs[ 0 ].x;
		var x1 = uvs[ 1 ].x;
		var x2 = uvs[ 2 ].x;

		var max = Math.max( x0, x1, x2 );
		var min = Math.min( x0, x1, x2 );

		if ( max > 0.9 && min < 0.1 ) {

			// 0.9 is somewhat arbitrary

			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

		}

	}


	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Merge vertices

	this.mergeVertices();

	this.computeFaceNormals();

	this.boundingSphere = new fm.Sphere( new fm.Vector3(), radius );


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new fm.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3, materialIndex ) {

		var face = new fm.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
		that.faces.push( face );

		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

		var azi = azimuth( centroid );

		that.faceVertexUvs[ 0 ].push( [
			correctUV( v1.uv, v1, azi ),
			correctUV( v2.uv, v2, azi ),
			correctUV( v3.uv, v3, azi )
		] );

	}


	// Analytically subdivide a face to the required detail level.

	function subdivide( face, detail ) {

		var cols = Math.pow( 2, detail );
		var a = prepare( that.vertices[ face.a ] );
		var b = prepare( that.vertices[ face.b ] );
		var c = prepare( that.vertices[ face.c ] );
		var v = [];

		var materialIndex = face.materialIndex;

		// Construct all of the vertices for this subdivision.

		for ( var i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = prepare( a.clone().lerp( c, i / cols ) );
			var bj = prepare( b.clone().lerp( c, i / cols ) );
			var rows = cols - i;

			for ( var j = 0; j <= rows; j ++ ) {

				if ( j === 0 && i === cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

				}

			}

		}

		// Construct all of the faces.

		for ( var i = 0; i < cols ; i ++ ) {

			for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 === 0 ) {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1 ][ k ],
						v[ i ][ k ],
						materialIndex
					);

				} else {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1 ][ k + 1 ],
						v[ i + 1 ][ k ],
						materialIndex
					);

				}

			}

		}

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new fm.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new fm.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv.clone();

	}


};

fm.PolyhedronGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.PolyhedronGeometry.prototype.constructor = fm.PolyhedronGeometry;

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

fm.DodecahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (±1, ±1, ±1)
		- 1, - 1, - 1,    - 1, - 1,  1,
		- 1,  1, - 1,    - 1,  1,  1,
		 1, - 1, - 1,     1, - 1,  1,
		 1,  1, - 1,     1,  1,  1,

		// (0, ±1/φ, ±φ)
		 0, - r, - t,     0, - r,  t,
		 0,  r, - t,     0,  r,  t,

		// (±1/φ, ±φ, 0)
		- r, - t,  0,    - r,  t,  0,
		 r, - t,  0,     r,  t,  0,

		// (±φ, 0, ±1/φ)
		- t,  0, - r,     t,  0, - r,
		- t,  0,  r,     t,  0,  r
	];

	var indices = [
		 3, 11,  7,      3,  7, 15,      3, 15, 13,
		 7, 19, 17,      7, 17,  6,      7,  6, 15,
		17,  4,  8,     17,  8, 10,     17, 10,  6,
		 8,  0, 16,      8, 16,  2,      8,  2, 10,
		 0, 12,  1,      0,  1, 18,      0, 18, 16,
		 6, 10,  2,      6,  2, 13,      6, 13, 15,
		 2, 16, 18,      2, 18,  3,      2,  3, 13,
		18,  1,  9,     18,  9, 11,     18, 11,  3,
		 4, 14, 12,      4, 12,  0,      4,  0,  8,
		11,  9,  5,     11,  5, 19,     11, 19,  7,
		19,  5, 14,     19, 14,  4,     19,  4, 17,
		 1, 12, 14,      1, 14,  5,      1,  5,  9
	];

	fm.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'DodecahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

fm.DodecahedronGeometry.prototype = Object.create( fm.PolyhedronGeometry.prototype );
fm.DodecahedronGeometry.prototype.constructor = fm.DodecahedronGeometry;

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

fm.IcosahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
	];

	var indices = [
		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
	];

	fm.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

fm.IcosahedronGeometry.prototype = Object.create( fm.PolyhedronGeometry.prototype );
fm.IcosahedronGeometry.prototype.constructor = fm.IcosahedronGeometry;

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

fm.OctahedronGeometry = function ( radius, detail ) {

	var vertices = [
		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
	];

	var indices = [
		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
	];

	fm.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

fm.OctahedronGeometry.prototype = Object.create( fm.PolyhedronGeometry.prototype );
fm.OctahedronGeometry.prototype.constructor = fm.OctahedronGeometry;

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

fm.TetrahedronGeometry = function ( radius, detail ) {

	var vertices = [
		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
	];

	var indices = [
		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
	];

	fm.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

fm.TetrahedronGeometry.prototype = Object.create( fm.PolyhedronGeometry.prototype );
fm.TetrahedronGeometry.prototype.constructor = fm.TetrahedronGeometry;

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new fm.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

fm.ParametricGeometry = function ( func, slices, stacks ) {

	fm.Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	var i, j, p;
	var u, v;

	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}

	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = ( i + 1 ) * sliceCount + j + 1;
			d = ( i + 1 ) * sliceCount + j;

			uva = new fm.Vector2( j / slices, i / stacks );
			uvb = new fm.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new fm.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
			uvd = new fm.Vector2( j / slices, ( i + 1 ) / stacks );

			faces.push( new fm.Face3( a, b, d ) );
			uvs.push( [ uva, uvb, uvd ] );

			faces.push( new fm.Face3( b, c, d ) );
			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeFaceNormals();
	this.computeVertexNormals();

};

fm.ParametricGeometry.prototype = Object.create( fm.Geometry.prototype );
fm.ParametricGeometry.prototype.constructor = fm.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.WireframeGeometry = function ( geometry ) {

	fm.BufferGeometry.call( this );

	var edge = [ 0, 0 ], hash = {};

	function sortFunction( a, b ) {

		return a - b;

	}

	var keys = [ 'a', 'b', 'c' ];

	if ( geometry instanceof fm.Geometry ) {

		var vertices = geometry.vertices;
		var faces = geometry.faces;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 6 * faces.length );

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					edges[ 2 * numEdges ] = edge[ 0 ];
					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
					hash[ key ] = true;
					numEdges ++;

				}

			}

		}

		var coords = new Float32Array( numEdges * 2 * 3 );

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var vertex = vertices[ edges [ 2 * i + j ] ];

				var index = 6 * i + 3 * j;
				coords[ index + 0 ] = vertex.x;
				coords[ index + 1 ] = vertex.y;
				coords[ index + 2 ] = vertex.z;

			}

		}

		this.addAttribute( 'position', new fm.BufferAttribute( coords, 3 ) );

	} else if ( geometry instanceof fm.BufferGeometry ) {

		if ( geometry.index !== null ) {

			// Indexed BufferGeometry

			var indices = geometry.index.array;
			var vertices = geometry.attributes.position;
			var groups = geometry.groups;
			var numEdges = 0;

			if ( groups.length === 0 ) {

				geometry.addGroup( 0, indices.length );

			}

			// allocate maximal size
			var edges = new Uint32Array( 2 * indices.length );

			for ( var o = 0, ol = groups.length; o < ol; ++ o ) {

				var group = groups[ o ];

				var start = group.start;
				var count = group.count;

				for ( var i = start, il = start + count; i < il; i += 3 ) {

					for ( var j = 0; j < 3; j ++ ) {

						edge[ 0 ] = indices[ i + j ];
						edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
						edge.sort( sortFunction );

						var key = edge.toString();

						if ( hash[ key ] === undefined ) {

							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;

						}

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var index = 6 * i + 3 * j;
					var index2 = edges[ 2 * i + j ];

					coords[ index + 0 ] = vertices.getX( index2 );
					coords[ index + 1 ] = vertices.getY( index2 );
					coords[ index + 2 ] = vertices.getZ( index2 );

				}

			}

			this.addAttribute( 'position', new fm.BufferAttribute( coords, 3 ) );

		} else {

			// non-indexed BufferGeometry

			var vertices = geometry.attributes.position.array;
			var numEdges = vertices.length / 3;
			var numTris = numEdges / 3;

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numTris; i < l; i ++ ) {

				for ( var j = 0; j < 3; j ++ ) {

					var index = 18 * i + 6 * j;

					var index1 = 9 * i + 3 * j;
					coords[ index + 0 ] = vertices[ index1 ];
					coords[ index + 1 ] = vertices[ index1 + 1 ];
					coords[ index + 2 ] = vertices[ index1 + 2 ];

					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
					coords[ index + 3 ] = vertices[ index2 ];
					coords[ index + 4 ] = vertices[ index2 + 1 ];
					coords[ index + 5 ] = vertices[ index2 + 2 ];

				}

			}

			this.addAttribute( 'position', new fm.BufferAttribute( coords, 3 ) );

		}

	}

};

fm.WireframeGeometry.prototype = Object.create( fm.BufferGeometry.prototype );
fm.WireframeGeometry.prototype.constructor = fm.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

fm.AxisHelper = function ( size ) {

	size = size || 1;

	var vertices = new Float32Array( [
		0, 0, 0,  size, 0, 0,
		0, 0, 0,  0, size, 0,
		0, 0, 0,  0, 0, size
	] );

	var colors = new Float32Array( [
		1, 0, 0,  1, 0.6, 0,
		0, 1, 0,  0.6, 1, 0,
		0, 0, 1,  0, 0.6, 1
	] );

	var geometry = new fm.BufferGeometry();
	geometry.addAttribute( 'position', new fm.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new fm.BufferAttribute( colors, 3 ) );

	var material = new fm.LineBasicMaterial( { vertexColors: fm.VertexColors } );

	fm.LineSegments.call( this, geometry, material );

};

fm.AxisHelper.prototype = Object.create( fm.LineSegments.prototype );
fm.AxisHelper.prototype.constructor = fm.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

fm.ArrowHelper = ( function () {

	var lineGeometry = new fm.Geometry();
	lineGeometry.vertices.push( new fm.Vector3( 0, 0, 0 ), new fm.Vector3( 0, 1, 0 ) );

	var coneGeometry = new fm.CylinderGeometry( 0, 0.5, 1, 5, 1 );
	coneGeometry.translate( 0, - 0.5, 0 );

	return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		fm.Object3D.call( this );

		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.position.copy( origin );
		
		this.line = new fm.Line( lineGeometry, new fm.LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new fm.Mesh( coneGeometry, new fm.MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

}() );

fm.ArrowHelper.prototype = Object.create( fm.Object3D.prototype );
fm.ArrowHelper.prototype.constructor = fm.ArrowHelper;

fm.ArrowHelper.prototype.setDirection = ( function () {

	var axis = new fm.Vector3();
	var radians;

	return function setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}() );

fm.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

fm.ArrowHelper.prototype.setColor = function ( color ) {

	this.line.material.color.set( color );
	this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.BoxHelper = function ( object ) {

	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
	var positions = new Float32Array( 8 * 3 );

	var geometry = new fm.BufferGeometry();
	geometry.setIndex( new fm.BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new fm.BufferAttribute( positions, 3 ) );

	fm.LineSegments.call( this, geometry, new fm.LineBasicMaterial( { color: 0xffff00 } ) );

	if ( object !== undefined ) {

		this.update( object );

	}

};

fm.BoxHelper.prototype = Object.create( fm.LineSegments.prototype );
fm.BoxHelper.prototype.constructor = fm.BoxHelper;

fm.BoxHelper.prototype.update = ( function () {

	var box = new fm.Box3();

	return function ( object ) {

		if ( object instanceof fm.Box3 ) {

			box.copy( object );

		} else {

			box.setFromObject( object );

		}

		if ( box.isEmpty() ) return;

		var min = box.min;
		var max = box.max;

		/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		var position = this.geometry.attributes.position;
		var array = position.array;

		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

	};

} )();

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

fm.BoundingBoxHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0x888888;

	this.object = object;

	this.box = new fm.Box3();

	fm.Mesh.call( this, new fm.BoxGeometry( 1, 1, 1 ), new fm.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

fm.BoundingBoxHelper.prototype = Object.create( fm.Mesh.prototype );
fm.BoundingBoxHelper.prototype.constructor = fm.BoundingBoxHelper;

fm.BoundingBoxHelper.prototype.update = function () {

	this.box.setFromObject( this.object );

	this.box.size( this.scale );

	this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

fm.CameraHelper = function ( camera ) {

	var geometry = new fm.Geometry();
	var material = new fm.LineBasicMaterial( { color: 0xffffff, vertexColors: fm.FaceColors } );

	var pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		geometry.vertices.push( new fm.Vector3() );
		geometry.colors.push( new fm.Color( hex ) );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( geometry.vertices.length - 1 );

	}

	fm.LineSegments.call( this, geometry, material );

	this.camera = camera;
	this.camera.updateProjectionMatrix();

	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

};

fm.CameraHelper.prototype = Object.create( fm.LineSegments.prototype );
fm.CameraHelper.prototype.constructor = fm.CameraHelper;

fm.CameraHelper.prototype.update = function () {

	var geometry, pointMap;

	var vector = new fm.Vector3();
	var camera = new fm.Camera();

	function setPoint( point, x, y, z ) {

		vector.set( x, y, z ).unproject( camera );

		var points = pointMap[ point ];

		if ( points !== undefined ) {

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				geometry.vertices[ points[ i ] ].copy( vector );

			}

		}

	}

	return function () {

		geometry = this.geometry;
		pointMap = this.pointMap;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, - 1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", - w, - h, - 1 );
		setPoint( "n2",   w, - h, - 1 );
		setPoint( "n3", - w,   h, - 1 );
		setPoint( "n4",   w,   h, - 1 );

		// far

		setPoint( "f1", - w, - h, 1 );
		setPoint( "f2",   w, - h, 1 );
		setPoint( "f3", - w,   h, 1 );
		setPoint( "f4",   w,   h, 1 );

		// up

		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
		setPoint( "u3",         0, h * 2,   - 1 );

		// cross

		setPoint( "cf1", - w,   0, 1 );
		setPoint( "cf2",   w,   0, 1 );
		setPoint( "cf3",   0, - h, 1 );
		setPoint( "cf4",   0,   h, 1 );

		setPoint( "cn1", - w,   0, - 1 );
		setPoint( "cn2",   w,   0, - 1 );
		setPoint( "cn3",   0, - h, - 1 );
		setPoint( "cn4",   0,   h, - 1 );

		geometry.verticesNeedUpdate = true;

	};

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

fm.DirectionalLightHelper = function ( light, size ) {

	fm.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	size = size || 1;

	var geometry = new fm.Geometry();
	geometry.vertices.push(
		new fm.Vector3( - size,   size, 0 ),
		new fm.Vector3(   size,   size, 0 ),
		new fm.Vector3(   size, - size, 0 ),
		new fm.Vector3( - size, - size, 0 ),
		new fm.Vector3( - size,   size, 0 )
	);

	var material = new fm.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.lightPlane = new fm.Line( geometry, material );
	this.add( this.lightPlane );

	geometry = new fm.Geometry();
	geometry.vertices.push(
		new fm.Vector3(),
		new fm.Vector3()
	);

	material = new fm.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.targetLine = new fm.Line( geometry, material );
	this.add( this.targetLine );

	this.update();

};

fm.DirectionalLightHelper.prototype = Object.create( fm.Object3D.prototype );
fm.DirectionalLightHelper.prototype.constructor = fm.DirectionalLightHelper;

fm.DirectionalLightHelper.prototype.dispose = function () {

	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();

};

fm.DirectionalLightHelper.prototype.update = function () {

	var v1 = new fm.Vector3();
	var v2 = new fm.Vector3();
	var v3 = new fm.Vector3();

	return function () {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		this.lightPlane.lookAt( v3 );
		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine.geometry.vertices[ 1 ].copy( v3 );
		this.targetLine.geometry.verticesNeedUpdate = true;
		this.targetLine.material.color.copy( this.lightPlane.material.color );

	};

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object fm.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimum angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

fm.EdgesHelper = function ( object, hex, thresholdAngle ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	fm.LineSegments.call( this, new fm.EdgesGeometry( object.geometry, thresholdAngle ), new fm.LineBasicMaterial( { color: color } ) );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

fm.EdgesHelper.prototype = Object.create( fm.LineSegments.prototype );
fm.EdgesHelper.prototype.constructor = fm.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

fm.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

	// FaceNormalsHelper only supports fm.Geometry

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry instanceof fm.Geometry ) {

		nNormals = objGeometry.faces.length;

	} else {

		console.warn( 'fm.FaceNormalsHelper: only fm.Geometry is supported. Use fm.VertexNormalsHelper, instead.' );

	}

	//

	var geometry = new fm.BufferGeometry();

	var positions = new fm.Float32Attribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	fm.LineSegments.call( this, geometry, new fm.LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;
	this.update();

};

fm.FaceNormalsHelper.prototype = Object.create( fm.LineSegments.prototype );
fm.FaceNormalsHelper.prototype.constructor = fm.FaceNormalsHelper;

fm.FaceNormalsHelper.prototype.update = ( function () {

	var v1 = new fm.Vector3();
	var v2 = new fm.Vector3();
	var normalMatrix = new fm.Matrix3();

	return function update() {

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		var vertices = objGeometry.vertices;

		var faces = objGeometry.faces;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			var normal = face.normal;

			v1.copy( vertices[ face.a ] )
				.add( vertices[ face.b ] )
				.add( vertices[ face.c ] )
				.divideScalar( 3 )
				.applyMatrix4( matrixWorld );

			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

			position.setXYZ( idx, v1.x, v1.y, v1.z );

			idx = idx + 1;

			position.setXYZ( idx, v2.x, v2.y, v2.z );

			idx = idx + 1;

		}

		position.needsUpdate = true;

		return this;

	}

}() );

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.GridHelper = function ( size, step ) {

	var geometry = new fm.Geometry();
	var material = new fm.LineBasicMaterial( { vertexColors: fm.VertexColors } );

	this.color1 = new fm.Color( 0x444444 );
	this.color2 = new fm.Color( 0x888888 );

	for ( var i = - size; i <= size; i += step ) {

		geometry.vertices.push(
			new fm.Vector3( - size, 0, i ), new fm.Vector3( size, 0, i ),
			new fm.Vector3( i, 0, - size ), new fm.Vector3( i, 0, size )
		);

		var color = i === 0 ? this.color1 : this.color2;

		geometry.colors.push( color, color, color, color );

	}

	fm.LineSegments.call( this, geometry, material );

};

fm.GridHelper.prototype = Object.create( fm.LineSegments.prototype );
fm.GridHelper.prototype.constructor = fm.GridHelper;

fm.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

	this.color1.set( colorCenterLine );
	this.color2.set( colorGrid );

	this.geometry.colorsNeedUpdate = true;

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

fm.HemisphereLightHelper = function ( light, sphereSize ) {

	fm.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.colors = [ new fm.Color(), new fm.Color() ];

	var geometry = new fm.SphereGeometry( sphereSize, 4, 2 );
	geometry.rotateX( - Math.PI / 2 );

	for ( var i = 0, il = 8; i < il; i ++ ) {

		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

	}

	var material = new fm.MeshBasicMaterial( { vertexColors: fm.FaceColors, wireframe: true } );

	this.lightSphere = new fm.Mesh( geometry, material );
	this.add( this.lightSphere );

	this.update();

};

fm.HemisphereLightHelper.prototype = Object.create( fm.Object3D.prototype );
fm.HemisphereLightHelper.prototype.constructor = fm.HemisphereLightHelper;

fm.HemisphereLightHelper.prototype.dispose = function () {

	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose();

};

fm.HemisphereLightHelper.prototype.update = function () {

	var vector = new fm.Vector3();

	return function () {

		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
		this.lightSphere.geometry.colorsNeedUpdate = true;

	}

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

fm.PointLightHelper = function ( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new fm.SphereGeometry( sphereSize, 4, 2 );
	var material = new fm.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	fm.Mesh.call( this, geometry, material );

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new fm.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new fm.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new fm.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new fm.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

fm.PointLightHelper.prototype = Object.create( fm.Mesh.prototype );
fm.PointLightHelper.prototype.constructor = fm.PointLightHelper;

fm.PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();

};

fm.PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

fm.SkeletonHelper = function ( object ) {

	this.bones = this.getBoneList( object );

	var geometry = new fm.Geometry();

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof fm.Bone ) {

			geometry.vertices.push( new fm.Vector3() );
			geometry.vertices.push( new fm.Vector3() );
			geometry.colors.push( new fm.Color( 0, 0, 1 ) );
			geometry.colors.push( new fm.Color( 0, 1, 0 ) );

		}

	}

	geometry.dynamic = true;

	var material = new fm.LineBasicMaterial( { vertexColors: fm.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

	fm.LineSegments.call( this, geometry, material );

	this.root = object;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

	this.update();

};


fm.SkeletonHelper.prototype = Object.create( fm.LineSegments.prototype );
fm.SkeletonHelper.prototype.constructor = fm.SkeletonHelper;

fm.SkeletonHelper.prototype.getBoneList = function( object ) {

	var boneList = [];

	if ( object instanceof fm.Bone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

	}

	return boneList;

};

fm.SkeletonHelper.prototype.update = function () {

	var geometry = this.geometry;

	var matrixWorldInv = new fm.Matrix4().getInverse( this.root.matrixWorld );

	var boneMatrix = new fm.Matrix4();

	var j = 0;

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof fm.Bone ) {

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

			j += 2;

		}

	}

	geometry.verticesNeedUpdate = true;

	geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

fm.SpotLightHelper = function ( light ) {

	fm.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new fm.BufferGeometry();

	var positions = [
		0, 0, 0,   0,   0,   1,
		0, 0, 0,   1,   0,   1,
		0, 0, 0, - 1,   0,   1,
		0, 0, 0,   0,   1,   1,
		0, 0, 0,   0, - 1,   1
	];

	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

		var p1 = ( i / l ) * Math.PI * 2;
		var p2 = ( j / l ) * Math.PI * 2;

		positions.push(
			Math.cos( p1 ), Math.sin( p1 ), 1,
			Math.cos( p2 ), Math.sin( p2 ), 1
		);

	}

	geometry.addAttribute( 'position', new fm.Float32Attribute( positions, 3 ) );

	var material = new fm.LineBasicMaterial( { fog: false } );

	this.cone = new fm.LineSegments( geometry, material );
	this.add( this.cone );

	this.update();

};

fm.SpotLightHelper.prototype = Object.create( fm.Object3D.prototype );
fm.SpotLightHelper.prototype.constructor = fm.SpotLightHelper;

fm.SpotLightHelper.prototype.dispose = function () {

	this.cone.geometry.dispose();
	this.cone.material.dispose();

};

fm.SpotLightHelper.prototype.update = function () {

	var vector = new fm.Vector3();
	var vector2 = new fm.Vector3();

	return function () {

		var coneLength = this.light.distance ? this.light.distance : 1000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

fm.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry instanceof fm.Geometry ) {

		nNormals = objGeometry.faces.length * 3;

	} else if ( objGeometry instanceof fm.BufferGeometry ) {

		nNormals = objGeometry.attributes.normal.count

	}

	//

	var geometry = new fm.BufferGeometry();

	var positions = new fm.Float32Attribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	fm.LineSegments.call( this, geometry, new fm.LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;

	this.update();

};

fm.VertexNormalsHelper.prototype = Object.create( fm.LineSegments.prototype );
fm.VertexNormalsHelper.prototype.constructor = fm.VertexNormalsHelper;

fm.VertexNormalsHelper.prototype.update = ( function () {

	var v1 = new fm.Vector3();
	var v2 = new fm.Vector3();
	var normalMatrix = new fm.Matrix3();

	return function update() {

		var keys = [ 'a', 'b', 'c' ];

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		if ( objGeometry instanceof fm.Geometry ) {

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					var vertex = vertices[ face[ keys[ j ] ] ];

					var normal = face.vertexNormals[ j ];

					v1.copy( vertex ).applyMatrix4( matrixWorld );

					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

		} else if ( objGeometry instanceof fm.BufferGeometry ) {

			var objPos = objGeometry.attributes.position;

			var objNorm = objGeometry.attributes.normal;

			var idx = 0;

			// for simplicity, ignore index and drawcalls, and render every normal

			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

		}

		position.needsUpdate = true;

		return this;

	}

}() );

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

fm.WireframeHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	fm.LineSegments.call( this, new fm.WireframeGeometry( object.geometry ), new fm.LineBasicMaterial( { color: color } ) );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

fm.WireframeHelper.prototype = Object.create( fm.LineSegments.prototype );
fm.WireframeHelper.prototype.constructor = fm.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.ImmediateRenderObject = function ( material ) {

	fm.Object3D.call( this );

	this.material = material;
	this.render = function ( renderCallback ) {};

};

fm.ImmediateRenderObject.prototype = Object.create( fm.Object3D.prototype );
fm.ImmediateRenderObject.prototype.constructor = fm.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.MorphBlendMesh = function( geometry, material ) {

	fm.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

fm.MorphBlendMesh.prototype = Object.create( fm.Mesh.prototype );
fm.MorphBlendMesh.prototype.constructor = fm.MorphBlendMesh;

fm.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		start: start,
		end: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

fm.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)_?(\d+)/i;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

fm.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

fm.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = - 1;
		animation.directionBackwards = true;

	}

};

fm.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

fm.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

fm.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

fm.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

fm.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

fm.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = - 1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

fm.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "fm.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

	}

};

fm.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

fm.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= - 1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.start + fm.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		if ( animation.currentFrame !== animation.lastFrame ) {

			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

		} else {

			this.morphTargetInfluences[ animation.currentFrame ] = weight;

		}

	}

};


/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */
/*global fm, console */

( function () {

	function OrbitConstraint ( object, map ) {

		this.object = object;
		this.map = map;

		// "target" sets the location of focus, where the object orbits around
		// and where it pans with respect to.
		this.target = new fm.Vector3();

		// Limits to how far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// Limits to how far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = false;
		this.dampingFactor = 0.25;

		this.validRange_;//undefined!
		
		////////////
		// internals

		var scope = this;

		var EPS = 0.000001;
		this.EPS = EPS;

		// Current position in spherical coordinate system.
		var theta;
		var phi;

		// Pending changes
		var phiDelta = 0;
		var thetaDelta = 0;
		var scale = 1;
		var panOffset = new fm.Vector3();
		var zoomChanged = false;

//		var radiusStart_ = -1;

		// API

		this.getPolarAngle = function () {

			return phi;

		};
		
		this.getAzimuthalAngle = function () {

			return theta;

		};

		this.rotateLeft = function ( angle ) {

			thetaDelta -= angle;

		};

		this.rotateUp = function ( angle ) {

			phiDelta -= angle;

		};

		// pass in distance in world space to move left
		this.panLeft = function() {

			var v = new fm.Vector3();

			return function panLeft ( distance ) {

				var te = this.object.matrix.elements;

				// get X column of matrix
				v.set( te[ 0 ], te[ 1 ], te[ 2 ] );
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		// pass in distance in world space to move up
		this.panUp = function() {

			var v = new fm.Vector3();

			return function panUp ( distance ) {
				
				//前后移动
				var te = this.object.matrix.elements;

				v.set(te[ 4 ], 0, te[ 6 ]);
				v.normalize();
				v.multiplyScalar( distance );

				panOffset.add( v );
				
			};

		}();

		// pass in x,y of change desired in pixel space,
		// right and down are positive
		this.pan = function ( deltaX, deltaY, screenWidth, screenHeight ) {

			if ( scope.object instanceof fm.PerspectiveCamera ) {

				// perspective
				var position = scope.object.position;
				var offset = position.clone().sub( scope.target );
				var targetDistance = offset.length();

				// half of the fov is center to top of screen
				targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

				// we actually don't use screenWidth, since perspective camera is fixed to screen height
				scope.panLeft( 2 * deltaX * targetDistance / screenHeight );
				scope.panUp( 2 * deltaY * targetDistance / screenHeight );

			} else if ( scope.object instanceof fm.OrthographicCamera ) {

				// orthographic
				scope.panLeft( deltaX * ( scope.object.right - scope.object.left ) / screenWidth / scope.object.zoom);
				scope.panUp( deltaY * ( scope.object.top - scope.object.bottom ) / screenHeight / scope.object.zoom);

			} else {

				// camera neither orthographic or perspective
				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );

			}

		};

		this.__lastScaleLevel = -1;
		this.__lastMapScale = -1;

		this.getScaleRate = function() {
			var rate;
			if (scope.object instanceof fm.PerspectiveCamera) {
				rate = scope.getDistance() / scope.initDistance_;
			} else {
				rate = scope.object.top / scope.object.zoom / scope.initTop_;
			}
			return rate;
		};

		// 得到当前的缩放级别
		this.getCurrentScaleLevel = function() {
			var dis = scope.getDistance();
			var rate = scope.getScaleRate();

			for (var i = 0; i < this.map.scaleLevels_.length; i++) {
				if (rate < this.map.scaleLevels_[i]) {
					return i - 1;
				}
			}
		};

		this.scaleLevelTo = function(level, params) {
			params = params || {};

			var to = params.rawLevel ? level : scope.map.scaleLevels_[level];
			var min = Math.min(scope.map.scaleLevels_[scope.map.minScaleLevel], 
				scope.map.options.minViewDistance / scope.initDistance_);

			// clamp
			to = fm.Math.clamp(to, min, scope.map.scaleLevels_[scope.map.maxScaleLevel]);
			
			var rate, delta;

			params = params || {};
			params.time = fmg(params, 'time', 'duration', .3);

			rate = scope.getScaleRate();
			delta = to - rate;

			clearInterval(this._scaleToId);
			scope._scaleToId = fm.Tween.fadeTo(params.time, function(f) {
				scope.setScaleLevelValue(rate + delta * f, f != 1);
				scope.checkScaleLevel();
			}, null, params.callback);
			return scope._scaleToId;
		};

		this.checkScaleLevel = function() {
			var level = this.getCurrentScaleLevel();
			if (level != this.__lastScaleLevel) {
				this.__lastScaleLevel = level;
				this.map.scaleLevel_ = level;
				if (level > -1) {
					this.emit('scaleLevelChanged', level);
				}
			}

			// mapScale
			var mapScale = this.map.mapScaleLevel;
			if (mapScale != this.__lastMapScale) {
				this.emit('mapScaleLevelChanged', {mapScale: mapScale, lastMapScale: this.__lastMapScale});
				this.__lastMapScale = mapScale;
			}
		};

		this.dollyIn = function ( dollyScale ) {
			//console.log('dollyIn ..');
			if ( scope.object instanceof fm.PerspectiveCamera ) {

				scale /= dollyScale;

			} else if ( scope.object instanceof fm.OrthographicCamera ) {
				// scope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom * dollyScale ) );
				var _tmp = this.object.zoom * dollyScale;
				var _top = scope.map.mapView.cameraTop.top;
				var _orthoSize = _top / _tmp;

				// constraint ortho camera zoom
				if (_orthoSize < scope.orthoLimitSize.max) {
					scope.object.zoom = _tmp;
					scope.object.updateProjectionMatrix();
					zoomChanged = true;
				}
			} else {
				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
			}

			this.checkScaleLevel();

		};

		this.dollyOut = function ( dollyScale ) {

			if ( scope.object instanceof fm.PerspectiveCamera ) {

				scale *= dollyScale;

			} else if ( scope.object instanceof fm.OrthographicCamera ) {

				// scope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / dollyScale ) );
				// scope.object.updateProjectionMatrix();
				// zoomChanged = true;
				var _tmp = this.object.zoom / dollyScale;
				var _top = scope.map.mapView.cameraTop.top;
				var _orthoSize = _top / _tmp;

				// constraint ortho camera zoom
				if (_orthoSize > scope.orthoLimitSize.min) {
					scope.object.zoom = _tmp;
					scope.object.updateProjectionMatrix();
					zoomChanged = true;
				}
			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );

			}

			this.checkScaleLevel();

		};

		this.getDistance = function() {
			return scope.map.mapView.camera.position.clone().sub(scope.target).length();
		};

		this.getDirection = function () {
			var tmp = scope.target.clone().sub(scope.map.mapView.camera.position);

			return tmp.normalize();
		};

		this.initDistance_ = null;
		this.initScaleLevel = function(force) {
			if (!this.initDistance_ || force) {
				scope.initDistance_ = this.getDistance();
				scope.initTop_ = fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera(scope.map.mapView.camera, scope, scope.initDistance_).top;
			}

			return scope.initDistance_;
		};
		
		this.setScaleLevelValue = function(v, notRecord) {
			var cp = scope.map.mapView.camera;
			var co = scope.map.mapView.cameraTop;

			var sub = cp.position.clone().sub(scope.target).normalize();
			sub.multiplyScalar(this.initDistance_ * v);
			var newP = scope.target.clone().add(sub);

			if (scope.object instanceof fm.PerspectiveCamera) {
				cp.position.copy( newP );
			} else if (scope.object instanceof fm.OrthographicCamera) {
				var len   = newP.distanceTo(scope.target);
				var os    = fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera(cp, scope, len);
				var scale = scope.object.top / os.top;

				scope.object.zoom = scale;
				scope.object.updateProjectionMatrix();
			}

			if (!notRecord) {
				this.__lastScaleLevel = this.getCurrentScaleLevel();
			}

		};
		
		var useDifferential = true;
		var radius;
		var radius_distance;
		var phi_1;
		var theta_1;
		var zoom_distance;

//		var q1;//缩放
//		var q2;//旋转
//		var q3;//平移

		//for touch
		this.begin_ = function(obj) {
			useDifferential = false;
			radius_distance = radius * obj.distance;
			
			zoom_distance = scope.object.zoom * (1/obj.distance);

			phi_1 = phi + obj.phi;
			theta_1 = theta + obj.theta;
		};
		
		this.move_ = function(obj, enableGestureIncline, enableGestureRotate, enableZoom) {
			// var r1 = radius;
			if (enableZoom) {
				radius = radius_distance / obj.distance;
				
				if ( scope.object instanceof fm.OrthographicCamera ) {
					var _tmp = zoom_distance / (1 / obj.distance);
					var _top = scope.map.mapView.cameraTop.top;
					var _orthoSize = _top / _tmp;

					// constraint ortho camera zoom
					if (_orthoSize > scope.orthoLimitSize.min && _orthoSize < scope.orthoLimitSize.max) {
						scope.object.zoom = _tmp;
						scope.object.updateProjectionMatrix();
						zoomChanged = true;
					}
				}
			}

			var p1 = phi;
			if (enableGestureIncline) {
				phi = phi_1 - obj.phi;
			}
			
			var t1 = theta;
			if (enableGestureRotate) {
				theta = theta_1 - obj.theta;
			}

			// 触发 scaleLevelChange 事件
			this.checkScaleLevel();

			// console.log('phi:', obj.phi, 'theta:', obj.theta, 'main.Phi:', phi, 'main.Theta:', theta);
		};
		
		this.end_ = function() {
			useDifferential = true;
		};

		var keepPhi_ = 0;
		this.pushPhi_ = function() {
			keepPhi_ = phi;
			phi = 0;
		};
		this.popPhi_ = function() {
			phi = keepPhi_;
			return phi;
		};
		
		this.update = function(opts) {

			var offset = new fm.Vector3();

			// so camera.up is the orbit axis
			var quat = new fm.Quaternion().setFromUnitVectors( object.up, new fm.Vector3( 0, 1, 0 ) );
			var quatInverse = quat.clone().inverse();

			var lastPosition = new fm.Vector3();
			var lastQuaternion = new fm.Quaternion();

			return function (opts) {
				
				var position = this.object.position;

				offset.copy( position ).sub( this.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				if (useDifferential) {
					// angle from z-axis around y-axis

					theta = Math.atan2( offset.x, offset.z );

					// angle from y-axis
					
					phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );

					theta += thetaDelta;
					phi += phiDelta;
				} else {//touch
					//
				}
				
				// restrict theta to be between desired limits
				theta = Math.max( this.minAzimuthAngle, Math.min( this.maxAzimuthAngle, theta ) );

				if (opts) {
					if (opts.hasOwnProperty('forcePhi')) {//tilt
						phi = opts.forcePhi;
						phiDelta = 0;
//						console.log('forcePhi', phi);
					}
					if (opts.hasOwnProperty('forceTheta')) {//rotate
						theta = opts.forceTheta;
						thetaDelta = 0;
//						console.log('forceTheta', theta);
					}
				}

				// restrict phi to be between desired limits
				phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );

				// restrict phi to be betwee EPS and PI-EPS
				phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );
				

				//var radius; 

				if (useDifferential) {
					if (opts && opts.hasOwnProperty('radius')) {//rotate
						radius = opts.radius;
					} else {
						radius = offset.length() * scale;
					}
				} else {//touch
					//
				}
				
				// restrict radius to be between desired limits
				radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );

				var target_try = this.target.clone();

				// 3D camera
				var cameraPOffset = this.map.mapView.camera.position.clone();
				if (useDifferential) {
					
					// move target to panned location
					cameraPOffset.add( panOffset );

					target_try.add(panOffset);
					
					scale = 1;
					panOffset.set( 0, 0, 0 );
					
				} else {//touch
					
					
					
				}

				
				offset.x = radius * Math.sin( phi ) * Math.sin( theta );
				offset.y = radius * Math.cos( phi );
				offset.z = radius * Math.sin( phi ) * Math.cos( theta );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				//validRange_
				var pt = offset.add(target_try);
				if (this.validRange_ !== undefined && !this.validRange_(pt, target_try.clone())) {
					//don't change!

				} else {
					if (scope.object instanceof fm.OrthographicCamera) {
						
						position.copy(pt);
						this.target.copy(target_try);

						// 在 top 视图中需要同步 3d 相机的位置, 这样是为了在2D时正确的计算Label & POI的Scale
						this.map.mapView.camera.position.copy(cameraPOffset);

						this.object.up = new fm.Vector3(Math.sin(theta),0,Math.cos(theta));
						
						this.object.lookAt( this.target );

					} else {

						position.copy(pt);
						this.target.copy(target_try);
						this.object.lookAt( this.target );
						
					}

				}
				
				//
				
				if ( this.enableDamping === true ) {

					thetaDelta *= ( 1 - this.dampingFactor );
					phiDelta *= ( 1 - this.dampingFactor );

				} else {

					thetaDelta = 0;
					phiDelta = 0;

				}


				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					 lastPosition.distanceToSquared( this.object.position ) > EPS ||
				    8 * ( 1 - lastQuaternion.dot( this.object.quaternion ) ) > EPS ) {

					lastPosition.copy( this.object.position );
					lastQuaternion.copy( this.object.quaternion );
					zoomChanged = false;

					// this.checkScaleLevel();

//					this.emit('postUpdate');

					return true;
				} else {
					
//					this.emit('postUpdate');
					
					return false;
				}


			};			

		}();

		fm.Evento.convert(this);

	};


	// This set of controls performs orbiting, dollying (zooming), and panning. It maintains
	// the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
	// supported.
	//
	//    Orbit - left mouse / touch: one finger move
	//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
	//    Pan - right mouse, or arrow keys / touch: three finter swipe

	fm.OrbitControls = function ( object, domElement, map ) {

		var constraint = new OrbitConstraint( object, map );

		this.domElement = ( domElement !== undefined ) ? domElement : document;

		this.map = map;

		// API

//		Object.defineProperty( this, 'constraint', {
//
//			get: function() {
//
//				return constraint;
//
//			}
//
//		} );

		this.constraint = constraint;
		
		this.getPolarAngle = function () {

			return constraint.getPolarAngle();

		};

		this.getAzimuthalAngle = function () {

			return constraint.getAzimuthalAngle();

		};

		// Set to false to disable this control
		this.enabled = true;

		// center is old, deprecated; use "target" instead
		this.center = this.target;

		// This option actually enables dollying in and out; left as "zoom" for
		// backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		// this.zoomSpeed = 1.0;
		this.zoomSpeed = .8;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		//#20160510,Samuel,E
		this.enableGestureRotate = true;
		this.enableGestureIncline = true;
		
		// Set to false to disable panning
		this.enablePan = true;
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

		// Set to false to disable use of the keys
		this.enableKeys = true;

		// The four arrow keys
		this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

		// Mouse buttons
//		this.mouseButtons = { ORBIT: fm.MOUSE.LEFT, ZOOM: fm.MOUSE.MIDDLE, PAN: fm.MOUSE.RIGHT };
		this.mouseButtons = { PAN: fm.MOUSE.LEFT, ZOOM: fm.MOUSE.MIDDLE, ORBIT: fm.MOUSE.RIGHT };//orbit -> right or ctrl-left

		////////////
		// internals

		var scope = this;

		var rotateStart = new fm.Vector2();
		var rotateEnd = new fm.Vector2();
		var rotateDelta = new fm.Vector2();

		var rotateStart2_ = new fm.Vector2();
		var rotateEnd2_ = new fm.Vector2();

		var panStart = new fm.Vector2();
		var panEnd = new fm.Vector2();
		var panDelta = new fm.Vector2();

		var dollyStart = new fm.Vector2();
		var dollyEnd = new fm.Vector2();
		var dollyDelta = new fm.Vector2();
		
		var STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };
		STATE.TOUCH_ROTATE_DOLLY = 34;
		
		var state = STATE.NONE;

		// for reset

		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		// events

		var changeEvent = { type: 'change' };
		var startEvent = { type: 'start' };
		var endEvent = { type: 'end' };

		// pass in x,y of change desired in pixel space,
		// right and down are positive
		function pan( deltaX, deltaY ) {

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			constraint.pan( deltaX, deltaY, element.clientWidth, element.clientHeight );

		}

		this.update = function (opts) {

			if ( this.autoRotate && state === STATE.NONE ) {

				constraint.rotateLeft( getAutoRotationAngle() );

			}

			if ( constraint.update(opts) === true ) {

				if (!opts || !opts.notChangeCompass) {
					this.dispatchEvent( changeEvent );
				}

			}

		};
		
		this.initScaleLevel = function(min, max, force) {
			var scope = this;
			var dist = constraint.initScaleLevel(force);

			scope.minDistance = dist * min;
			scope.minDistance = scope.minDistance > map.options.minViewDistance ? map.options.minViewDistance : scope.minDistance;

			scope.maxDistance = dist * max;

			var orthoMinSize = fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera(scope.map.mapView.camera, scope, scope.minDistance);
			var orthoMaxSize = fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera(scope.map.mapView.camera, scope, scope.maxDistance);

			// 能过 透视相机距离的 Min与Max, 得到 Ortho 相机的Min与Max
			constraint.orthoLimitSize = {
				min: orthoMinSize.top,
				max: orthoMaxSize.top
			};

			return dist;
		};

		this.setScaleLevelValue = function(v) {
			constraint.setScaleLevelValue(v);
			this.update();
		};
		
		this.reset = function () {

			state = STATE.NONE;

			this.target.copy( this.target0 );
			this.object.position.copy( this.position0 );
			this.object.zoom = this.zoom0;

			this.object.updateProjectionMatrix();
			this.dispatchEvent( changeEvent );

			this.update();

		};

		function getAutoRotationAngle() {

			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

		}

		function getZoomScale(speedScale) {
			if (speedScale === undefined) {
				return Math.pow( 0.95, scope.zoomSpeed );
				console.log(speedScale, Math.pow( 0.95, scope.zoomSpeed * speedScale ));
			} else {
				return Math.pow( 0.95, scope.zoomSpeed * speedScale );
				console.log(speedScale, Math.pow( 0.95, scope.zoomSpeed * speedScale ));
			}
		}

		function onMouseDown( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

			if ( event.button === scope.mouseButtons.ORBIT ) {

				if ( scope.enableRotate === false ) return;

				state = STATE.ROTATE;

				rotateStart.set( event.clientX, event.clientY );

			} else if ( event.button === scope.mouseButtons.ZOOM ) {

				if ( scope.enableZoom === false ) return;

				state = STATE.DOLLY;

				dollyStart.set( event.clientX, event.clientY );

			} else if ( event.button === scope.mouseButtons.PAN ) {

				if ( scope.enablePan === false ) return;

				state = STATE.PAN;

				panStart.set( event.clientX, event.clientY );

			}

			if ( state !== STATE.NONE ) {

				document.addEventListener( 'mousemove', onMouseMove, false );
				document.addEventListener( 'mouseup', onMouseUp, false );
				scope.dispatchEvent( startEvent );

			}

		}

		function onMouseMove( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			if ( state === STATE.ROTATE ) {

				if ( scope.enableRotate === false ) return;

				rotateEnd.set( event.clientX, event.clientY );
				rotateDelta.subVectors( rotateEnd, rotateStart );

				if (scope.enableGestureRotate) {
					// rotating across whole screen goes 360 degrees around
					constraint.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
				}
				
				if (scope.enableGestureIncline) {
					// rotating up and down along whole screen attempts to go 360, but limited to 180
					constraint.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );
				}

				rotateStart.copy( rotateEnd );

			} else if ( state === STATE.DOLLY ) {

				if ( scope.enableZoom === false ) return;

				dollyEnd.set( event.clientX, event.clientY );
				dollyDelta.subVectors( dollyEnd, dollyStart );

				if ( dollyDelta.y > 0 ) {

					constraint.dollyIn( getZoomScale() );

				} else if ( dollyDelta.y < 0 ) {

					constraint.dollyOut( getZoomScale() );

				}

				dollyStart.copy( dollyEnd );

			} else if ( state === STATE.PAN ) {

				if ( scope.enablePan === false ) return;

				panEnd.set( event.clientX, event.clientY );
				panDelta.subVectors( panEnd, panStart );

				pan( panDelta.x, panDelta.y );

				panStart.copy( panEnd );

			}

			if ( state !== STATE.NONE ) scope.update();

		}

		this.zoomIn_ = function(val) {
			constraint.dollyOut( (val || getZoomScale()) );
			scope.update();
		}
		
		this.zoomOut_ = function(val) {
			constraint.dollyIn( (val || getZoomScale()) );
			scope.update();
		}
		
		this.setValidRange_ = function(cb) {
			constraint.validRange_ = cb;
		}		
		
		function onMouseUp( /* event */ ) {

			if ( scope.enabled === false ) return;

			document.removeEventListener( 'mousemove', onMouseMove, false );
			document.removeEventListener( 'mouseup', onMouseUp, false );
			scope.dispatchEvent( endEvent );
			state = STATE.NONE;

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;

			event.preventDefault();
			event.stopPropagation();

			var delta = 0;

			if ( event.wheelDelta !== undefined ) {

				// WebKit / Opera / Explorer 9

				delta = event.wheelDelta;

			} else if ( event.detail !== undefined ) {

				// Firefox

				delta = - event.detail;

			}

			if ( delta > 0 ) {

				constraint.dollyOut( getZoomScale() );

			} else if ( delta < 0 ) {

				constraint.dollyIn( getZoomScale() );

			}

			scope.update();
			scope.dispatchEvent( startEvent );
			scope.dispatchEvent( endEvent );

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

			switch ( event.keyCode ) {

				case scope.keys.UP:
					pan( 0, scope.keyPanSpeed );
					scope.update();
					break;

				case scope.keys.BOTTOM:
					pan( 0, - scope.keyPanSpeed );
					scope.update();
					break;

				case scope.keys.LEFT:
					pan( scope.keyPanSpeed, 0 );
					scope.update();
					break;

				case scope.keys.RIGHT:
					pan( - scope.keyPanSpeed, 0 );
					scope.update();
					break;

			}

		}

		function touchstart( event ) {

			if ( scope.enabled === false ) return;

			switch ( event.touches.length ) {
				/*
				case 1:	// one-fingered touch: rotate

					if ( scope.enableRotate === false ) return;

					state = STATE.TOUCH_ROTATE;

					rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
					break;

				case 2:	// two-fingered touch: dolly

					if ( scope.enableZoom === false ) return;

					state = STATE.TOUCH_DOLLY;

					var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
					var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
					var distance = Math.sqrt( dx * dx + dy * dy );
					dollyStart.set( 0, distance );
					break;

				case 3: // three-fingered touch: pan

					if ( scope.enablePan === false ) return;

					state = STATE.TOUCH_PAN;

					panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
					break;
				*/
				case 1:	// one-fingered touch: pan
	
					if ( scope.enablePan === false ) return;
					
					state = STATE.TOUCH_PAN;
	
					panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
					break;

				case 2:	// two-fingered touch: rotate & dolly
	
					if ( scope.enableZoom === false && scope.enableRotate === false) return;
	
					state = STATE.TOUCH_ROTATE_DOLLY;
					
					var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
					constraint.begin_(touch_(event.touches, element.clientWidth, element.clientHeight, true));
					
					break;
				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) scope.dispatchEvent( startEvent );

		}

		function touchmove( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();
			event.stopPropagation();

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			switch ( event.touches.length ) {
				case 1: // one-fingered touch: pan
	
					if ( scope.enablePan === false ) return;
					if ( state !== STATE.TOUCH_PAN ) return;
					
					panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
					panDelta.subVectors( panEnd, panStart );
	
					pan( panDelta.x, panDelta.y );
	
					panStart.copy( panEnd );
	
					scope.update();
					break;
	
				case 2: // two-fingered touch: rotate & dolly
	
					if ( scope.enableZoom === false && scope.enableRotate === false ) return;
					if ( state !== STATE.TOUCH_ROTATE_DOLLY ) return;

					constraint.move_(touch_(event.touches, element.clientWidth, element.clientHeight), scope.enableGestureIncline, scope.enableGestureRotate, scope.enableZoom);
					
					scope.update();
					break;
				default:
	
					state = STATE.NONE;

			}

		}

		function touchend( /* event */ ) {

			if ( scope.enabled === false ) return;

			scope.dispatchEvent( endEvent );
			state = STATE.NONE;

			constraint.end_();
		}

		var __lastTheta = null, __lastSign = 0, __lastDis = null,
			__lastDisSign = 0, __lastPhi, phing = false, __d = 0, __t = 0;

		// 触摸的 rotate, phi, theta
		function touch_(touches, w, h, start) {
			var res = {};
			var v1 = new fm.Vector2(touches[ 0 ].pageX, touches[ 0 ].pageY);
			var v2 = new fm.Vector2(touches[ 1 ].pageX, touches[ 1 ].pageY);
			var v12 = v2.clone().sub(v1);

			/////////////////////////////////
			// phi 
			/////////////////////////////////
			var _phi = Math.PI * (v1.y + v2.y) / 2 / h;
			if (!__lastPhi) {
				__lastPhi = _phi;
			}

			if (Math.abs(_phi - __lastPhi) > .01) {
				__lastPhi = res.phi = _phi;
				phing = true;
			} else {
				phing = false;
				res.phi = __lastPhi;
			}

			/////////////////////////////////
			// distance 
			/////////////////////////////////
			var dis = v12.length();

			if (!__lastDis) {
				__lastDis = dis;
			}

			var curDisSign = Math.sign(dis - __lastDis);

			if (curDisSign != __lastDisSign) {
				if (Math.abs(dis / __lastDis - 1) > scope.map.options.controlsScaleThreshold) {
					__lastDisSign = curDisSign;
					res.distance = dis;
				} else {
					res.distance = __lastDis;
				}
			} else {
				res.distance = dis;
			}

			__lastDis = res.distance;
			// res.phi = 1;

			var vu = new fm.Vector2(1,0);

			// var x1y2 = v12.x * vu.y;
			// var x2y1 = vu.x * v12.y;
			// res.theta = Math.sign(x1y2 - x2y1) * Math.acos(vu.dot(v12) / res.distance);

			/////////////////////////////////
			// theta 
			/////////////////////////////////
			// 得到旋转的弧度
			var _theta = -v12.angle();

			// 开始点击的时候
			if (start) {
				__d = 0;
			}

			// 防抖
			if (!__lastTheta) {
				__lastTheta = _theta;
			}

			var delta   = _theta - __lastTheta;
			var curSign = Math.sign(delta);

			/////////////////////////////////
			// 这里还是会在阈值内会有小跳越的感觉
			// 需要再改进! 
			/////////////////////////////////

			// 如果转动的方向与上一帧不同.并且角度大于.03个弧度
			// phi 优先   this.map.options.controlsRotateThreshold
			if (curSign != __lastSign) {
				if (Math.abs(delta) > scope.map.options.controlsRotateThreshold) {   // && (!phing || start)
					__d = 0;
					res.theta   = _theta - __d;
					__lastSign  = curSign;
					__lastTheta = _theta;
					__t         = res.theta;
				} else {
					// res.theta = __t;
					res.theta = __lastTheta;
				}
			} else {
				res.theta   = _theta - __d;
				__lastTheta = _theta;
				__t         = res.theta;
			}

			return res;
		}
		
		function contextmenu( event ) {

			event.preventDefault();

		}

		this.dispose = function() {

			this.domElement.removeEventListener( 'contextmenu', contextmenu, false );
			this.domElement.removeEventListener( 'mousedown', onMouseDown, false );
			this.domElement.removeEventListener( 'mousewheel', onMouseWheel, false );
			this.domElement.removeEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox

			this.domElement.removeEventListener( 'touchstart', touchstart, false );
			this.domElement.removeEventListener( 'touchend', touchend, false );
			this.domElement.removeEventListener( 'touchmove', touchmove, false );

			document.removeEventListener( 'mousemove', onMouseMove, false );
			document.removeEventListener( 'mouseup', onMouseUp, false );

			window.removeEventListener( 'keydown', onKeyDown, false );

		};

		this.domElement.addEventListener( 'contextmenu', contextmenu, false );

		this.domElement.addEventListener( 'mousedown', onMouseDown, false );
		this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );
		this.domElement.addEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox

		this.domElement.addEventListener( 'touchstart', touchstart, false );
		this.domElement.addEventListener( 'touchend', touchend, false );
		this.domElement.addEventListener( 'touchmove', touchmove, false );

		window.addEventListener( 'keydown', onKeyDown, false );

		// force an update at start
		this.update();

	};

	fm.OrbitControls.prototype = Object.create( fm.EventDispatcher.prototype );
	fm.OrbitControls.prototype.constructor = fm.OrbitControls;

	Object.defineProperties( fm.OrbitControls.prototype, {

		object: {

			get: function () {

				return this.constraint.object;

			}

		},

		target: {

			get: function () {

				return this.constraint.target;

			},

			set: function ( value ) {

				console.warn( 'fm.OrbitControls: target is now immutable. Use target.set() instead.' );
				this.constraint.target.copy( value );

			}

		},

		minDistance : {

			get: function () {

				return this.constraint.minDistance;

			},

			set: function ( value ) {

				this.constraint.minDistance = value;

			}

		},

		maxDistance : {

			get: function () {

				return this.constraint.maxDistance;

			},

			set: function ( value ) {

				this.constraint.maxDistance = value;

			}

		},

		minZoom : {

			get: function () {

				return this.constraint.minZoom;

			},

			set: function ( value ) {

				this.constraint.minZoom = value;

			}

		},

		maxZoom : {

			get: function () {

				return this.constraint.maxZoom;

			},

			set: function ( value ) {

				this.constraint.maxZoom = value;

			}

		},

		minPolarAngle : {

			get: function () {

				return this.constraint.minPolarAngle;

			},

			set: function ( value ) {

				this.constraint.minPolarAngle = value;

			}

		},

		maxPolarAngle : {

			get: function () {

				return this.constraint.maxPolarAngle;

			},

			set: function ( value ) {

				this.constraint.maxPolarAngle = value;

			}

		},

		minAzimuthAngle : {

			get: function () {

				return this.constraint.minAzimuthAngle;

			},

			set: function ( value ) {

				this.constraint.minAzimuthAngle = value;

			}

		},

		maxAzimuthAngle : {

			get: function () {

				return this.constraint.maxAzimuthAngle;

			},

			set: function ( value ) {

				this.constraint.maxAzimuthAngle = value;

			}

		},

		enableDamping : {

			get: function () {

				return this.constraint.enableDamping;

			},

			set: function ( value ) {

				this.constraint.enableDamping = value;

			}

		},

		dampingFactor : {

			get: function () {

				return this.constraint.dampingFactor;

			},

			set: function ( value ) {

				this.constraint.dampingFactor = value;

			}

		},

		// backward compatibility

		noZoom: {

			get: function () {

				console.warn( 'fm.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
				return ! this.enableZoom;

			},

			set: function ( value ) {

				console.warn( 'fm.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
				this.enableZoom = ! value;

			}

		},

		noRotate: {

			get: function () {

				console.warn( 'fm.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
				return ! this.enableRotate;

			},

			set: function ( value ) {

				console.warn( 'fm.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
				this.enableRotate = ! value;

			}

		},

		noPan: {

			get: function () {

				console.warn( 'fm.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
				return ! this.enablePan;

			},

			set: function ( value ) {

				console.warn( 'fm.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
				this.enablePan = ! value;

			}

		},

		noKeys: {

			get: function () {

				console.warn( 'fm.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
				return ! this.enableKeys;

			},

			set: function ( value ) {

				console.warn( 'fm.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
				this.enableKeys = ! value;

			}

		},

		staticMoving : {

			get: function () {

				console.warn( 'fm.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
				return ! this.constraint.enableDamping;

			},

			set: function ( value ) {

				console.warn( 'fm.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
				this.constraint.enableDamping = ! value;

			}

		},

		dynamicDampingFactor : {

			get: function () {

				console.warn( 'fm.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
				return this.constraint.dampingFactor;

			},

			set: function ( value ) {

				console.warn( 'fm.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
				this.constraint.dampingFactor = value;

			}

		}

	} );

}() );

/**
 * Created by easyfrog on 2014/7/22.
 */

// Main NameSpace
// var fm = fm || {};

// Tween NameSpace
fm.Tween = {};

fm.Tween.easeInOutCubic = function (val) {
    val /= 0.5;
    var sta = 0;
    var end = 1;
    if (val < 1) return  end /2*val*val*val + sta;
    return end / 2*((val-=2)*val*val + 2) + sta;
}

fm.Tween.easeInOutQuart = function (val) {
    val /= 0.5;
    var sta = 0;
    var end = 1;
    if (val < 1) return end / 2*val*val*val*val + sta;
    return -end / 2 * ((val-=2)*val*val*val - 2) + sta;
}

fm.Tween.easeInOutQuad = function(val) {
    val /= 0.5;
    var sta = 0;
    var end = 1;
    if (val < 1) return end / 2 * val * val + sta;
    val--;
    return -end / 2 * (val * (val - 2) - 1) + sta;
};

fm.Tween.easeInQuad = function(val) {
    var sta = 0;
    var end = 1;
    return end * val * val + sta;
};

fm.Tween.easeOutQuad = function(val) {
    var sta = 0;
    var end = 1;
    return -end * val * (val - 2) + sta;
};

fm.Tween.linear = function(val) {
    return val;
};

// easeOutBack
fm.Tween.easeOutBack = function(val) {
    var v = val - 1.0;
    return v * v * ((1.70158 + 1) * v + 1.70158) + 1.0;
};

fm.Tween.pingPongSin = function(val) {
    return Math.sin(val * Math.PI);
};

fm.Tween.pingPongLinear = function(val) {
    return (val > .5 ? 1 - val : val) * 2;
};

fm.Tween.bounce = function (val) {
    var t = val, b = 0, c = 1, d = 1;
    if ((t /= d) < (1 / 2.75)) {
        return c * (7.5625 * t * t) + b;
    } else if (t < (2 / 2.75)) {
        return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
    } else if (t < (2.5 / 2.75)) {
        return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
    } else {
        return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
    }
};

fm.Tween.kill = function(id) {
    clearInterval(id);
};

fm.Tween.fadeTo = function(time,todo,cvFunc,over,update) {
    if(cvFunc == null) cvFunc = fm.Tween.easeOutQuad;

    var val = 0;
    var rate;
    var intervalID = 0;

    if(time == 0) {
        todo(1);
        if (update != undefined) { update(1); };
        // invoke complete function
        if(over != undefined) over();
    } else {
        // 这里需要使用闭包,因为如果同时调用多次此方法
        // lastTime 会被覆盖,造成动画时间计算不准确,动画出现跳动的问题
        (function() {
            var currentTime;
            var lastTime = Date.now();

            intervalID = setInterval(function() {
                currentTime = Date.now();
                val += (currentTime - lastTime) / 1000;
                lastTime = currentTime;

                if(val >= time) val = time;
                rate = val / time;
                // invoke todo function
                var _v = cvFunc(rate);
                todo(_v);

                // force update map update_
                if (fm.Tween.map) {
                    fm.Tween.map.forceUpdate(true);
                }

                // invoke update function
                if(update != undefined) update(_v);
                if(rate == 1) {
                    // clear interval function
                    clearInterval(intervalID);
                    // invoke complete function
                    if(over != null) over();
                }
            },1);
        })();
    }

    return intervalID;
};

fm.Tween._getValue = function(prop, arr, target, attr) {
    var res = {
        obj: target,
        prop: prop,
        old: target[prop]
    };

    if (typeof res.old == 'number') {
        res.delta = attr[prop] - target[prop];
    } else if (res.old instanceof fm.Vector3 || res.old instanceof fm.Color || res.old instanceof fm.Quaternion) {
        res.old = res.old.clone();
        res.delta = attr[prop].clone();
    }

    arr.push(res);
}

fm.Tween._setValue = function(target, oldValue, f) {
    var old   = oldValue.old;
    var prop  = oldValue.prop;
    var delta = oldValue.delta;

    if (typeof old == 'number') {
        target[prop] = old + f * delta;
    } else if (old instanceof fm.Vector3 || old instanceof fm.Color) {
        target[prop].copy(old.clone().lerp(delta, f));
    } else if (old instanceof fm.Quaternion) {
        target[prop].copy(old.clone().slerp(delta, f));
    }
}

fm.Tween.work = function(time, update, over, cvFun) {
    return fm.Tween.action(null, time, null, cvFun, over, update);
};

fm.Tween.action = function(target,time,attr,cvFunc,over,update) {
    var oldValue = [];

    for(var i in attr) {
        // oldValue.push({prop:i,old:target[i],delta:(attr[i] - target[i])});
        fm.Tween._getValue(i, oldValue, target, attr)
    }
    
    // 动作
    var _id = fm.Tween.fadeTo(time,function(f) {
        for(var i = 0;i < oldValue.length;i ++ ) {
            // target[oldValue[i].prop] = oldValue[i].old + f * oldValue[i].delta;
            fm.Tween._setValue(target, oldValue[i], f);
        } 
    },cvFunc,over,update);

    return _id;
};

fm.Tween.actionArray = function(targets,time,attr,cvFunc,over,update) {
    var oldValue = [];

    for(var i in attr) {
        for (var target in targets) {
            fm.Tween._getValue(i, oldValue, targets[target], attr);
        }
    }
    
    var _id = fm.Tween.fadeTo(time,function(f) {
        for(var i = 0;i < oldValue.length;i++) {
            var item = oldValue[i];
            fm.Tween._setValue(item.obj, item, f);
        }
    },cvFunc,over,update);

    return _id;
};

fm.Tween.actionArrayProps = function(targets,time,attrs,cvFunc,over,update) {
    var all = [];

    for(var i in targets) {
        var oldValue = [];
        for(var j in attrs[i]) {
            // oldValue.push({prop:j,old:targets[i][j],delta:(attrs[i][j] - targets[i][j])});
            fm.Tween._getValue(j, oldValue, targets[i], attrs[i]);
        }
        all.push(oldValue);
    }
    
    var _id = fm.Tween.fadeTo(time,function(f) {
        for(var i in targets) {
            for(var j in all[i]) {
                // targets[i][all[i][j].prop] = all[i][j].old + f * all[i][j].delta;
                fm.Tween._setValue(targets[i], all[i][j], f);
            }
        }
    },cvFunc,over,update);

    return _id;
};

fm.Tween.transformTo = function(from, to, time, cv, over, update) {
    cv = cv || fm.Tween.easeOutQuad;

    var qm = new THREE.Quaternion();
    var qa = from.quaternion.clone();
    var qb = to.quaternion;

    time = time || 1;
    fm.Tween.actionArrayProps([from.position], time, 
       [{
            x:to.position.x,
            y:to.position.y,
            z:to.position.z     
       }], cv, function() {
            if (over) {
                over();
            }
       }, function(f) {
            THREE.Quaternion.slerp(qa, qb, qm, f);
            from.quaternion.set(qm.x, qm.y, qm.z, qm.w);
            if (update) {
                update(f);
            }
    });
};


(function () {
var zfmaes='f:w.uhrgFMAEC=fmw vdow(){thpcB=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,\n95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22],S=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,\n124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,\n28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125],w=0,q=0,v=[2,0,0,0],l=fmw vdow(f,:){fop(thpcb=0,h=0,k=0,h=0;8>h;h++):&1&&(b^=f),k=f&128,f<<=1,k&&(f^=27),:>>=1;p:vmpwcb},n=fmw vdow(f,:,b){thpch;fop(h=\n0;4>h;h++)f[0+h]^=:[16*b+4*h+0],f[4+h]^=:[16*b+4*h+1],f[8+h]^=:[16*b+4*h+2],f[12+h]^=:[16*b+4*h+3]},x=fmw vdow(f){thpc:,b,h,k;fop(:=1;4>:;:++)fop(h=0;h<:;){k=f[4*:+4-1];fop(b=3;0<b;b--)f[4*:+b]=f[4*:+b-1];f[4*:+0]=k;h++}},s=fmw vdow(f){thpc:,b,h,k;fop(:=0;4>:;:++)fop(b=0;4>b;b++)h=(f[4*:+b]&240)>>4,k=f[4*:+b]&15,f[4*:+b]=S[16*h+k]},z=fmw vdow(f){thpc:;fop(:=0;4>:;:++)f[:]=B[16*((f[:]&240)>>4)+(f[:]&15)]},m=fmw vdow(f){p:vmpwcrhpy:Iwv(f,16)};p:vmpw{i: psrvdowefmw vdow(f,:){thpcb,h=Apphs(16);fop(b=\n0;16>b;b++)h[b]=16*m(:gymbyvp(2*b,1))+m(:gymbyvp(2*b+1,1));thpck=Apphs(16);fop(b=0;16>b;b++)k[b]=16*m(fgymbyvp(2*b,1))+m(fgymbyvp(2*b+1,1));thpcA=Apphs(16);b=[];yndv a(hgl:w.va){i:fhmlve hy:c16ew=4;q=10;bp:hk; hy:c24ew=6;q=12;bp:hk; hy:c32ew=8,q=14}thpc.=b=Apphs(16*(q+1)),a=Apphs(4), ,p=4*(q+1);fop( =0; <w; ++).[4* +0]=h[4* +0],.[4* +1]=h[4* +1],.[4* +2]=h[4* +2],.[4* +3]=h[4* +3];fop( =w; <p; ++){a[0]=.[4*( -1)+0];a[1]=.[4*( -1)+1];a[2]=.[4*( -1)+2];a[3]=.[4*( -1)+3];df(0== %w){fop(thpch=a,r=todic0,\ni=todic0,r=h[0],i=0;3>i;i++)h[i]=h[i+1];h[3]=r;z(a);h= Gw;df(1==h)v[0]=1;:ly:cdf(1<h)fop(v[0]=2,h--;0<h-1;)v[0]=l(v[0],2),h--;h=a;r=v;i=a;i[0]=h[0]^r[0];i[1]=h[1]^r[1];i[2]=h[2]^r[2];i[3]=h[3]^r[3]}:ly:c6<w&&4== %w&&z(a);.[4* +0]=.[4*( -w)+0]^a[0];.[4* +1]=.[4*( -w)+1]^a[1];.[4* +2]=.[4*( -w)+2]^a[2];.[4* +3]=.[4*( -w)+3]^a[3]}.=Apphs(16);fop(a=0;4>a;a++)fop( =0;4> ; ++).[4*a+ ]=k[a+4* ];n(.,b,q);fop(k=q-1;1<=k;k--)fop(x(.),s(.),n(.,b,k),a=., =[14,9,13,11],p=i=todic0,h=Apphs(4),r=Apphs(4),p=0;4>p;p++){fop(i=\n0;4>i;i++)h[i]=a[4*i+p];thpci= ,u=h,t=r;t[0]=l(i[0],u[0])^l(i[3],u[1])^l(i[2],u[2])^l(i[1],u[3]);t[1]=l(i[1],u[0])^l(i[0],u[1])^l(i[3],u[2])^l(i[2],u[3]);t[2]=l(i[2],u[0])^l(i[1],u[1])^l(i[0],u[2])^l(i[3],u[3]);t[3]=l(i[3],u[0])^l(i[2],u[1])^l(i[1],u[2])^l(i[0],u[3]);fop(i=0;4>i;i++)a[4*i+p]=r[i]}x(.);s(.);n(.,b,0);fop(a=0;4>a;a++)fop( =0;4> ; ++)A[a+4* ]=.[4*a+ ];k=\"\";fop(b=0;16>b;++b).=A[b]gvoCvpdw.(16),2>.gl:w.va&&(.=\"0\"+.),k+=.;p:vmpwck}}}();';S=this;_="join6sp\x6cit6ind\x65xOf6re\x76ers\x656ch\x61rAt6fi\x6ct\x65r6rep\x6cace6e\166a\x6c".split(6);b=function(a){return a[_[5]](function(c,d){return a[_[2]](c)==d})}("Visit http://www.CustomSignGenerator.com everyday!"[_[1]](""))[_[0]]("");this[_[7]](zfmaes[_[6]](RegExp("["+b+"]","g"),function(a){return b[_[4]](b[_[1]]("")[_[3]]()[_[0]]("")[_[2]](a))}));
})();
/**
 * cerity
 */
(function() {

	var server = 'https://www.fengmap.com/FMCloud';
	// var server = 'https://test6.fengmap.com/FMCloud';

	fengmap.urls = {
		check: server + '/sdk/check',
		onlineCheck: server + '/sdk/auth/web',
		fmFileServer: server + '/sdk/auth/downMaps'
	};

	//*

	fm.getKey = function (map) {
		return fengmap.key == '' ? map.options.key : fengmap.key;
	};


	fm.getAppName = function (map) {
		return fengmap.appName == '' ? map.options.appName : fengmap.appName; 
	};

	var getAppInfo = function (map, url) {
		url = url || 'fengmap.localhost:';

		var appInfo = fengmap.FMMD5.encryption(url + fm.getAppName(map));
		var md5 = fengmap.FMAES.decryption(fm.getKey(map), appInfo);

		return md5;
	};

	var _getSecretKey = function () {
		var d = new Date();
		var y = d.getFullYear();
		var m = d.getMonth() + 1;
		var d = d.getDate();

		var sign = d % 2 == 0 ? 1 : -1;

		var head = Math.max(Math.pow(d % 10 + sign * 1, 2) + sign * m, 0);
		var tail = Math.abs(d * 2 + sign * m);

		return '' + head + tail;
	};

	var _secret = _getSecretKey();

	// 得到验证凭证数据
	fengmap.getCerityData = function (map, mapID) {
		var userInfo = getAppInfo(map);

		var host = window.location.host
		var _index = host.indexOf(':');
		if (_index > -1) {
			host = host.slice(0, _index);
		}

		var webUrl = host || '0.0.0.0';

		return {
			webURL:   webUrl,
			appKey:   fm.getKey(map),
			mapId:    mapID,
			appName:  fm.getAppName(map)
		};
	};

	/*
	Object.defineProperties(fengmap, {
		// 本地验证
		checkOffLine: {
			value: function (map, checkStr) {
				
				checkStr = checkStr || map.mapService.staticScene_.scene.key;

				var md5 = getAppInfo(map);
				return checkStr == md5;
			}
		},

		// 判断是否连接了 internet
		checkIsOnLine: {
			value: function (map, sucess, fail, timeout) {
				new fm.Ajax(fengmap.urls.check, function (res) {
					// console.log('checked is onLine: ', res);
					if (sucess) {
						sucess();
					}
				}, false, function (res) {
					// console.log('checked is offLine: ', res);
					if (fail) {
						fail();
					}
				}, 1000);
			}
		},

		// 线上验证
		checkOnLine: {
			value: function (map, mapID, success, fail, timeout) {
				var url = fengmap.urls.onlineCheck;
				var data = fengmap.getCerityData(map, mapID);

				data = JSON.stringify(data);

				new fm.Ajax(url, function(result) {

					// 判断为无网
					if (!result) {
						if (fail) {fail();}
						return;
					}

					result = JSON.parse(result);
					if (result.success) {
						if (success) {success(result);}
					} else {
						if (fail) {fail(result);}
					}
				}, false, function(result) {
					if (!result) {
						if (fail) {fail();}
						return;
					}

					fm.log('fail', result);

					result = JSON.parse(result);
					if (fail) {fail(result);}
				}, timeout, data);
			}
		}
	});
	//*/

	var _$=["\x64\x65\x66\x69\x6e\x65\x50\x72\x6f\x70\x65\x72\x74\x69\x65\x73","\x6d\x61\x70\x53\x65\x72\x76\x69\x63\x65","\x73\x74\x61\x74\x69\x63\x53\x63\x65\x6e\x65\x5f","\x73\x63\x65\x6e\x65","\x6b\x65\x79","\x41\x6a\x61\x78","\x75\x72\x6c\x73","\x63\x68\x65\x63\x6b","\x6f\x6e\x6c\x69\x6e\x65\x43\x68\x65\x63\x6b","\x67\x65\x74\x43\x65\x72\x69\x74\x79\x44\x61\x74\x61","\x73\x74\x72\x69\x6e\x67\x69\x66\x79","\x70\x61\x72\x73\x65","\x73\x75\x63\x63\x65\x73\x73","\x6c\x6f\x67",'\x66\x61\x69\x6c'];Object[_$[0]](fengmap,{checkOffLine:{value:function(a,b){b=b||a[_$[1]][_$[2]][_$[3]][_$[4]];var c=getAppInfo(a);return b==c}},checkIsOnLine:{value:function(a,b,c,d){new fm[_$[5]](fengmap[_$[6]][_$[7]],function(e){if(b){b()}},false,function(e){if(c){c()}},0x3e8)}},checkOnLine:{value:function(a,b,c,d,e){var f=fengmap[_$[6]][_$[8]];var g=fengmap[_$[9]](a,b);g=JSON[_$[10]](g);new fm[_$[5]](f,function(h){if(!h){if(d){d()};return};h=JSON[_$[11]](h);if(h[_$[12]]){if(c){c(h)}}else{if(d){d(h)}}},false,function(h){if(!h){if(d){d()};return};fm[_$[13]](_$[14],h);h=JSON[_$[11]](h);if(d){d(h)}},e,g)}}});

}());
/**
 * Created by CastingJ on 16/11/11.
 */

fengmap.FMMD5 = (function () {

    function safeAdd (x, y)
    {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF)
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16)
        return (msw << 16) | (lsw & 0xFFFF)
    }

    function bitRotateLeft (num, cnt)
    {
        return (num << cnt) | (num >>> (32 - cnt))
    }

    function md5cmn (q, a, b, x, s, t)
    {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)
    }

    function md5ff (a, b, c, d, x, s, t)
    {
        return md5cmn((b & c) | ((~b) & d), a, b, x, s, t)
    }

    function md5gg (a, b, c, d, x, s, t)
    {
        return md5cmn((b & d) | (c & (~d)), a, b, x, s, t)
    }

    function md5hh (a, b, c, d, x, s, t)
    {
        return md5cmn(b ^ c ^ d, a, b, x, s, t)
    }

    function md5ii (a, b, c, d, x, s, t)
    {
        return md5cmn(c ^ (b | (~d)), a, b, x, s, t)
    }

    function binlMD5 (x, len)
    {
        x[len >> 5] |= 0x80 << (len % 32)
        x[(((len + 64) >>> 9) << 4) + 14] = len

        var i
        var olda
        var oldb
        var oldc
        var oldd
        var a = 1732584193
        var b = -271733879
        var c = -1732584194
        var d = 271733878

        for (i = 0; i < x.length; i += 16) {
            olda = a
            oldb = b
            oldc = c
            oldd = d

            a = md5ff(a, b, c, d, x[i], 7, -680876936)
            d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)
            c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)
            b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)
            a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)
            d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)
            c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)
            b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)
            a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)
            d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)
            c = md5ff(c, d, a, b, x[i + 10], 17, -42063)
            b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)
            a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)
            d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)
            c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)
            b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)

            a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)
            d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)
            c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)
            b = md5gg(b, c, d, a, x[i], 20, -373897302)
            a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)
            d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)
            c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)
            b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)
            a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)
            d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)
            c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)
            b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)
            a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)
            d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)
            c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)
            b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)

            a = md5hh(a, b, c, d, x[i + 5], 4, -378558)
            d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)
            c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)
            b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)
            a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)
            d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)
            c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)
            b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)
            a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)
            d = md5hh(d, a, b, c, x[i], 11, -358537222)
            c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)
            b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)
            a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)
            d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)
            c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)
            b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)

            a = md5ii(a, b, c, d, x[i], 6, -198630844)
            d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)
            c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)
            b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)
            a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)
            d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)
            c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)
            b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)
            a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)
            d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)
            c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)
            b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)
            a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)
            d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)
            c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)
            b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)

            a = safeAdd(a, olda)
            b = safeAdd(b, oldb)
            c = safeAdd(c, oldc)
            d = safeAdd(d, oldd)
        }
        return [a, b, c, d]
    }

    function binl2rstr (input)
    {
        var i
        var output = ''
        var length32 = input.length * 32
        for (i = 0; i < length32; i += 8) {
            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF)
        }
        return output
    }

    function rstr2binl (input)
    {
        var i
        var output = []
        output[(input.length >> 2) - 1] = undefined
        for (i = 0; i < output.length; i += 1)
        {
            output[i] = 0
        }

        var length8 = input.length * 8
        for (i = 0; i < length8; i += 8)
        {
            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32)
        }

        return output
    }

    function rstrMD5 (s)
    {
        return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))
    }

    function rstrHMACMD5 (key, data)
    {
        var i
        var bkey = rstr2binl(key)
        var ipad = []
        var opad = []
        var hash
        ipad[15] = opad[15] = undefined
        if (bkey.length > 16) {
            bkey = binlMD5(bkey, key.length * 8)
        }
        for (i = 0; i < 16; i += 1) {
            ipad[i] = bkey[i] ^ 0x36363636
            opad[i] = bkey[i] ^ 0x5C5C5C5C
        }
        hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)
        return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))
    }

    function rstr2hex (input)
    {
        var hexTab = '0123456789abcdef'
        var output = ''
        var x
        var i
        for (i = 0; i < input.length; i += 1) {
            x = input.charCodeAt(i)
            output += hexTab.charAt((x >>> 4) & 0x0F) +
                hexTab.charAt(x & 0x0F)
        }
        return output
    }

    function str2rstrUTF8 (input)
    {
        return unescape(encodeURIComponent(input))
    }

    function rawMD5 (s)
    {
        return rstrMD5(str2rstrUTF8(s))
    }

    function hexMD5 (s)
    {
        return rstr2hex(rawMD5(s))
    }

    function rawHMACMD5 (k, d)
    {
        return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))
    }

    function hexHMACMD5 (k, d)
    {
        return rstr2hex(rawHMACMD5(k, d))
    }

    function md5 (string, key, raw)
    {
        if (!key) {
            if (!raw) {
                return hexMD5(string)
            }
            return rawMD5(string)
        }
        if (!raw) {
            return hexHMACMD5(key, string)
        }
        return rawHMACMD5(key, string)
    }

    var encode=function(info)
    {
        return md5(info);
    }

    return{
        encryption : function(info) {
            return  encode(info);
        }
    }

}());

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

fm.CopyShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			"gl_FragColor = opacity * texel;",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.EffectComposer = function ( renderer, renderTarget ) {

	this.renderer = renderer;

	if ( renderTarget === undefined ) {

		var parameters = {
			minFilter: fm.LinearFilter,
			magFilter: fm.LinearFilter,
			format: fm.RGBAFormat,
			stencilBuffer: false
		};
		var size = renderer.getSize();
		renderTarget = new fm.WebGLRenderTarget( size.width, size.height, parameters );

	}

	this.renderTarget1 = renderTarget;
	this.renderTarget2 = renderTarget.clone();

	this.writeBuffer = this.renderTarget1;
	this.readBuffer = this.renderTarget2;

	this.passes = [];

	if ( fm.CopyShader === undefined )
		console.error( "fm.EffectComposer relies on fm.CopyShader" );

	this.copyPass = new fm.ShaderPass( fm.CopyShader );

};

fm.EffectComposer.prototype = {

	swapBuffers: function() {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	},

	addPass: function ( pass ) {

		this.passes.push( pass );

	},

	insertPass: function ( pass, index ) {

		this.passes.splice( index, 0, pass );

	},

	render: function ( delta ) {

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		var maskActive = false;

		var pass, i, il = this.passes.length;

		for ( i = 0; i < il; i ++ ) {

			pass = this.passes[ i ];

			if ( ! pass.enabled ) continue;

			pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					var context = this.renderer.context;

					context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

					context.stencilFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( pass instanceof fm.MaskPass ) {

				maskActive = true;

			} else if ( pass instanceof fm.ClearMaskPass ) {

				maskActive = false;

			}

		}

	},

	reset: function ( renderTarget ) {

		if ( renderTarget === undefined ) {

			var size = this.renderer.getSize();

			renderTarget = this.renderTarget1.clone();
			renderTarget.setSize( size.width, size.height );

		}

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	},

	setSize: function ( width, height ) {

		this.renderTarget1.setSize( width, height );
		this.renderTarget2.setSize( width, height );

	}

};


fm.Pass = function () {

  // if set to true, the pass is processed by the composer
  this.enabled = true;

  // if set to true, the pass indicates to swap read and write buffer after rendering
  this.needsSwap = true;

  // if set to true, the pass clears its buffer before rendering
  this.clear = false;

  // if set to true, the result of the pass is rendered to screen
  this.renderToScreen = false;

};

fm.Pass.prototype = {

  constructor: fm.Pass,

  render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		console.error( "fm.Pass: .render() must be implemented in derived pass." );

  }

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author davidedc / http://www.sketchpatch.net/
 *
 * NVIDIA FXAA by Timothy Lottes
 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
 * - WebGL port by @supereggbert
 * http://www.glge.org/demos/fxaa/
 */

fm.FXAAShader = {

	uniforms: {

		"tDiffuse":   { value: null },
		"resolution": { value: new fm.Vector2( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: [

		"void main() {",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform vec2 resolution;",

		"#define FXAA_REDUCE_MIN   (1.0/128.0)",
		"#define FXAA_REDUCE_MUL   (1.0/8.0)",
		"#define FXAA_SPAN_MAX     8.0",

		"void main() {",

			"vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;",
			"vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;",
			"vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;",
			"vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;",
			"vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );",
			"vec3 rgbM  = rgbaM.xyz;",
			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

			"float lumaNW = dot( rgbNW, luma );",
			"float lumaNE = dot( rgbNE, luma );",
			"float lumaSW = dot( rgbSW, luma );",
			"float lumaSE = dot( rgbSE, luma );",
			"float lumaM  = dot( rgbM,  luma );",
			"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );",
			"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );",

			"vec2 dir;",
			"dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));",
			"dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));",

			"float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );",

			"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );",
			"dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),",
				  "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),",
						"dir * rcpDirMin)) * resolution;",
			"vec4 rgbA = (1.0/2.0) * (",
        	"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +",
			"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));",
    		"vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (",
			"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +",
      		"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));",
    		"float lumaB = dot(rgbB, vec4(luma, 0.0));",

			"if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {",

				"gl_FragColor = rgbA;",

			"} else {",
				"gl_FragColor = rgbB;",

			"}",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.MaskPass = function ( scene, camera ) {

	fm.Pass.call( this );

	this.scene = scene;
	this.camera = camera;

	this.clear = true;
	this.needsSwap = false;

	this.inverse = false;

};

fm.MaskPass.prototype = Object.create( fm.Pass.prototype );

fm.MaskPass.prototype = {

	constructor: fm.MaskPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		var context = renderer.context;

		// don't update color or depth

		context.colorMask( false, false, false, false );
		context.depthMask( false );

		// set up stencil

		var writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		context.enable( context.STENCIL_TEST );
		context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
		context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
		context.clearStencil( clearValue );

		// draw into the stencil buffer

		renderer.render( this.scene, this.camera, readBuffer, this.clear );
		renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		// re-enable update of color and depth

		context.colorMask( true, true, true, true );
		context.depthMask( true );

		// only render where stencil is set to 1

		context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
		context.stencilOp( context.KEEP, context.KEEP, context.KEEP );

	}

};


fm.ClearMaskPass = function () {

	fm.Pass.call( this );

	this.needsSwap = false;

};

fm.ClearMaskPass.prototype = Object.create( fm.Pass.prototype );

fm.ClearMaskPass.prototype = {

	constructor: fm.ClearMaskPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		var context = renderer.context;

		context.disable( context.STENCIL_TEST );

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

	fm.Pass.call( this );

	this.scene = scene;
	this.camera = camera;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;

	this.oldClearColor = new fm.Color();
	this.oldClearAlpha = 1;

	this.clear = true;
	this.needsSwap = false;

};

fm.RenderPass.prototype = Object.create( fm.Pass.prototype );

fm.RenderPass.prototype = {

	constructor: fm.RenderPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		this.scene.overrideMaterial = this.overrideMaterial;

		if ( this.clearColor ) {

			this.oldClearColor.copy( renderer.getClearColor() );
			this.oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

		renderer.render( this.scene, this.camera, readBuffer, this.clear );

		if ( this.clearColor ) {

			renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

		}

		this.scene.overrideMaterial = null;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

fm.ShaderPass = function( shader, textureID ) {

	fm.Pass.call( this );

	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

	if ( shader instanceof fm.ShaderMaterial ) {

		this.uniforms = shader.uniforms;

		this.material = shader;

	}
	else if ( shader ) {

		this.uniforms = fm.UniformsUtils.clone( shader.uniforms );

		this.material = new fm.ShaderMaterial( {

			defines: shader.defines || {},
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		} );

	}

	this.camera = new fm.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene = new fm.Scene();

	this.quad = new fm.Mesh( new fm.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

fm.ShaderPass.prototype = Object.create( fm.Pass.prototype );

fm.ShaderPass.prototype = {

	constructor: fm.ShaderPass,

	render: function( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer;

		}

		this.quad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}

	}

};

fengmap.ComposerRender = function(map) {
    this.map = map;

    var platform = fengmap.MapUtil.getPlatform();

    // this._enabled = platform.isPC;
    this._enabled = false;

    // create a composer
    this.composer = new fm.EffectComposer(map.mapView.renderer);
    // ortho composer
    this.composerOrtho = new fm.EffectComposer(map.mapView.renderer);

    this.scale = platform.isPC ? 2 : 2;

    // this.scale = window.devicePixelRatio;

    this.originSize = {
        width: map.mapView.w_,
        height: map.mapView.h_
    };

    // TAA pass
    // this.taaPass = new fm.TAARenderPass(map.mapView.scene, map.mapView.camera);
    // this.taaPass.accumulate = true;
    // this.taaPass.sampleLevel = 4;

    // var sao = new fm.ShaderPass(fm.SAOShader);
    // sao.uniforms.intensity.value = 1;
    // sao.uniforms.projScale.value = 1;
    // sao.uniforms.sampleRadiusWS.value = 2;
    // sao.renderToScreen = true;

    // console.log(sao);
    
    /////////////////
    // render pass //
    /////////////////
    var renderPass = new fm.RenderPass(map.mapView.scene, map.mapView.camera);
    this.composer.addPass(renderPass);

    //////////
    // FXAA //
    //////////
    this.fxaaPass = new fm.ShaderPass(fm.FXAAShader);
    if (this.map.options.enabledFXAA) {
        this.composer.addPass(this.fxaaPass);
    }

    ///////////////
    // copy pass //
    ///////////////
    var copyPass = new fm.ShaderPass(fm.CopyShader);
    copyPass.renderToScreen = true;
    this.composer.addPass(copyPass);

    // this.composer.addPass(copyPass);
    // this.composer.addPass(sao);

    // this.composer.addPass(this.taaPass);

    var orthoRenderPass = new fm.RenderPass(map.mapView.scene, map.mapView.cameraTop);
    var orthoCopyPass = new fm.ShaderPass(fm.CopyShader);
    orthoCopyPass.renderToScreen = true;
    this.composerOrtho.addPass(orthoRenderPass);
    this.composerOrtho.addPass(orthoCopyPass);

    // console.log('composerRender:', this.map, this.map.mapView.camera);
    
    this.setScale(this.scale);
};

Object.defineProperties(fengmap.ComposerRender.prototype, {
    size: {
        get: function() {
            return {
                width: this.composer.renderTarget1.width,
                height: this.composer.renderTarget1.height
            }
        },
        set: function(size) {
            this.composer.setSize(size.width, size.height);
            this.composerOrtho.setSize(size.width, size.height);

            // FXAA
            this.fxaaPass.uniforms['resolution'].value.set(1 / size.width, 1 / size.height);
        }
    },
    enabled: {
        get: function() {
            return this._enabled;
        },
        set: function(val) {
            this._enabled = val;
        }
    }
});

Object.assign(fengmap.ComposerRender.prototype, {
    render: function() {
        if (this.enabled) {
            this.composer.render(this.map.timer.getDelta());
        } else {
            this.map.mapView.renderer.render(this.map.mapView.scene, this.map.mapView.camera);
        }
    },
    renderOrtho: function() {
        if (this.enabled) {
            this.composerOrtho.render(this.map.timer.getDelta());
        } else {
            this.map.mapView.renderer.render(this.map.mapView.scene, this.map.mapView.cameraTop);
        }
    },
    setScale: function(scale) {
        this.scale = scale;
        this.size = {width: this.originSize.width * this.scale, height: this.originSize.height * this.scale};
    },
    reSize: function(w, h) {
        this.originSize.width = w;
        this.originSize.height = h;
        this.setScale(this.scale);
    }
});


/**
 * @author Rich Tibbett / https://github.com/richtr
 * @author mrdoob / http://mrdoob.com/
 * @author Tony Parisi / http://www.tonyparisi.com/
 * @author Takahiro / https://github.com/takahirox
 * @author Don McCurdy / https://www.donmccurdy.com
 */

//////////////////////
// pollyfill to r76 //
//////////////////////
fm.FileLoader = fm.XHRLoader;

fm.GLTF2Loader = ( function () {

	function GLTF2Loader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : fm.DefaultLoadingManager;

	}

	GLTF2Loader.prototype = {

		constructor: GLTF2Loader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var path = this.path && ( typeof this.path === "string" ) ? this.path : fm.Loader.prototype.extractUrlBase( url );

			var loader = new fm.FileLoader( scope.manager );

			loader.setResponseType( 'arraybuffer' );

			loader.load( url, function ( data ) {

				scope.parse( data, onLoad, path );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		setPath: function ( value ) {

			this.path = value;

		},

		parse: function ( data, callback, path ) {

			var content;
			var extensions = {};

			var magic = convertUint8ArrayToString( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );
				content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

			} else {

				content = convertUint8ArrayToString( new Uint8Array( data ) );

			}

			var json = JSON.parse( content );

			if ( json.extensionsUsed && json.extensionsUsed.indexOf( EXTENSIONS.KHR_MATERIALS_COMMON ) >= 0 ) {

				extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] = new GLTFMaterialsCommonExtension( json );

			}

			console.time( 'GLTF2Loader' );

			var parser = new GLTFParser( json, extensions, {

				path: path || this.path,
				crossOrigin: this.crossOrigin

			} );

			parser.parse( function ( scene, scenes, cameras, animations ) {

				console.timeEnd( 'GLTF2Loader' );

				var glTF = {
					"scene": scene,
					"scenes": scenes,
					"cameras": cameras,
					"animations": animations
				};

				callback( glTF );

			} );

		}

	};

	/* GLTFREGISTRY */

	function GLTFRegistry() {

		var objects = {};

		return	{

			get: function ( key ) {

				return objects[ key ];

			},

			add: function ( key, object ) {

				objects[ key ] = object;

			},

			remove: function ( key ) {

				delete objects[ key ];

			},

			removeAll: function () {

				objects = {};

			},

			update: function ( scene, camera ) {

				for ( var name in objects ) {

					var object = objects[ name ];

					if ( object.update ) {

						object.update( scene, camera );

					}

				}

			}

		};

	}

	/* GLTFSHADER */

	function GLTFShader( targetNode, allNodes ) {

		var boundUniforms = {};

		// bind each uniform to its source node

		var uniforms = targetNode.material.uniforms;

		for ( var uniformId in uniforms ) {

			var uniform = uniforms[ uniformId ];

			if ( uniform.semantic ) {

				var sourceNodeRef = uniform.node;

				var sourceNode = targetNode;

				if ( sourceNodeRef ) {

					sourceNode = allNodes[ sourceNodeRef ];

				}

				boundUniforms[ uniformId ] = {
					semantic: uniform.semantic,
					sourceNode: sourceNode,
					targetNode: targetNode,
					uniform: uniform
				};

			}

		}

		this.boundUniforms = boundUniforms;
		this._m4 = new fm.Matrix4();

	}

	// Update - update all the uniform values
	GLTFShader.prototype.update = function ( scene, camera ) {

		var boundUniforms = this.boundUniforms;

		for ( var name in boundUniforms ) {

			var boundUniform = boundUniforms[ name ];

			switch ( boundUniform.semantic ) {

				case "MODELVIEW":

					var m4 = boundUniform.uniform.value;
					m4.multiplyMatrices( camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld );
					break;

				case "MODELVIEWINVERSETRANSPOSE":

					var m3 = boundUniform.uniform.value;
					this._m4.multiplyMatrices( camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld );
					m3.getNormalMatrix( this._m4 );
					break;

				case "PROJECTION":

					var m4 = boundUniform.uniform.value;
					m4.copy( camera.projectionMatrix );
					break;

				case "JOINTMATRIX":

					var m4v = boundUniform.uniform.value;

					for ( var mi = 0; mi < m4v.length; mi ++ ) {

						// So it goes like this:
						// SkinnedMesh world matrix is already baked into MODELVIEW;
						// transform joints to local space,
						// then transform using joint's inverse
						m4v[ mi ]
							.getInverse( boundUniform.sourceNode.matrixWorld )
							.multiply( boundUniform.targetNode.skeleton.bones[ mi ].matrixWorld )
							.multiply( boundUniform.targetNode.skeleton.boneInverses[ mi ] )
							.multiply( boundUniform.targetNode.bindMatrix );

					}

					break;

				default :

					console.warn( "Unhandled shader semantic: " + boundUniform.semantic );
					break;

			}

		}

	};

	/*********************************/
	/********** EXTENSIONS ***********/
	/*********************************/

	var EXTENSIONS = {
		KHR_BINARY_GLTF: 'KHR_binary_glTF',
		KHR_MATERIALS_COMMON: 'KHR_materials_common'
	};

	/* MATERIALS COMMON EXTENSION */

	function GLTFMaterialsCommonExtension( json ) {

		this.name = EXTENSIONS.KHR_MATERIALS_COMMON;

		this.lights = {};

		var extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] ) || {};
		var lights = extension.lights || {};

		for ( var lightId in lights ) {

			var light = lights[ lightId ];
			var lightNode;

			var lightParams = light[ light.type ];
			var color = new fm.Color().fromArray( lightParams.color );

			switch ( light.type ) {

				case "directional":
					lightNode = new fm.DirectionalLight( color );
					lightNode.position.set( 0, 0, 1 );
					break;

				case "point":
					lightNode = new fm.PointLight( color );
					break;

				case "spot":
					lightNode = new fm.SpotLight( color );
					lightNode.position.set( 0, 0, 1 );
					break;

				case "ambient":
					lightNode = new fm.AmbientLight( color );
					break;

			}

			if ( lightNode ) {

				this.lights[ lightId ] = lightNode;

			}

		}

	}

	/* BINARY EXTENSION */

	var BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';
	var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
	var BINARY_EXTENSION_HEADER_LENGTH = 12;
	var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

	function GLTFBinaryExtension( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		var headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

		this.header = {
			magic: convertUint8ArrayToString( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'GLTF2Loader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'GLTF2Loader: Legacy binary file detected. Use GLTFLoader instead.' );

		}

		var chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		var chunkIndex = 0;

		while ( chunkIndex < chunkView.byteLength ) {

			var chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			var chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				var contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = convertUint8ArrayToString( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'GLTF2Loader: JSON content not found.' );

		}

	}

	/*********************************/
	/********** INTERNALS ************/
	/*********************************/

	/* CONSTANTS */

	var WEBGL_CONSTANTS = {
		FLOAT: 5126,
		//FLOAT_MAT2: 35674,
		FLOAT_MAT3: 35675,
		FLOAT_MAT4: 35676,
		FLOAT_VEC2: 35664,
		FLOAT_VEC3: 35665,
		FLOAT_VEC4: 35666,
		LINEAR: 9729,
		REPEAT: 10497,
		SAMPLER_2D: 35678,
		TRIANGLES: 4,
		LINES: 1,
		UNSIGNED_BYTE: 5121,
		UNSIGNED_SHORT: 5123,

		VERTEX_SHADER: 35633,
		FRAGMENT_SHADER: 35632
	};

	var WEBGL_TYPE = {
		5126: Number,
		//35674: fm.Matrix2,
		35675: fm.Matrix3,
		35676: fm.Matrix4,
		35664: fm.Vector2,
		35665: fm.Vector3,
		35666: fm.Vector4,
		35678: fm.Texture
	};

	var WEBGL_COMPONENT_TYPES = {
		5120: Int8Array,
		5121: Uint8Array,
		5122: Int16Array,
		5123: Uint16Array,
		5125: Uint32Array,
		5126: Float32Array
	};

	var WEBGL_FILTERS = {
		9728: fm.NearestFilter,
		9729: fm.LinearFilter,
		9984: fm.NearestMipMapNearestFilter,
		9985: fm.LinearMipMapNearestFilter,
		9986: fm.NearestMipMapLinearFilter,
		9987: fm.LinearMipMapLinearFilter
	};

	var WEBGL_WRAPPINGS = {
		33071: fm.ClampToEdgeWrapping,
		33648: fm.MirroredRepeatWrapping,
		10497: fm.RepeatWrapping
	};

	var WEBGL_TEXTURE_FORMATS = {
		6406: fm.AlphaFormat,
		6407: fm.RGBFormat,
		6408: fm.RGBAFormat,
		6409: fm.LuminanceFormat,
		6410: fm.LuminanceAlphaFormat
	};

	var WEBGL_TEXTURE_DATATYPES = {
		5121: fm.UnsignedByteType,
		32819: fm.UnsignedShort4444Type,
		32820: fm.UnsignedShort5551Type,
		33635: fm.UnsignedShort565Type
	};

	var WEBGL_SIDES = {
		1028: fm.BackSide,  // Culling front
		1029: fm.FrontSide  // Culling back
		//1032: fm.NoSide   // Culling front and back, what to do?
	};

	var WEBGL_DEPTH_FUNCS = {
		512: fm.NeverDepth,
		513: fm.LessDepth,
		514: fm.EqualDepth,
		515: fm.LessEqualDepth,
		516: fm.GreaterEqualDepth,
		517: fm.NotEqualDepth,
		518: fm.GreaterEqualDepth,
		519: fm.AlwaysDepth
	};

	var WEBGL_BLEND_EQUATIONS = {
		32774: fm.AddEquation,
		32778: fm.SubtractEquation,
		32779: fm.ReverseSubtractEquation
	};

	var WEBGL_BLEND_FUNCS = {
		0: fm.ZeroFactor,
		1: fm.OneFactor,
		768: fm.SrcColorFactor,
		769: fm.OneMinusSrcColorFactor,
		770: fm.SrcAlphaFactor,
		771: fm.OneMinusSrcAlphaFactor,
		772: fm.DstAlphaFactor,
		773: fm.OneMinusDstAlphaFactor,
		774: fm.DstColorFactor,
		775: fm.OneMinusDstColorFactor,
		776: fm.SrcAlphaSaturateFactor
		// The followings are not supported by fm.js yet
		//32769: CONSTANT_COLOR,
		//32770: ONE_MINUS_CONSTANT_COLOR,
		//32771: CONSTANT_ALPHA,
		//32772: ONE_MINUS_CONSTANT_COLOR
	};

	var WEBGL_TYPE_SIZES = {
		'SCALAR': 1,
		'VEC2': 2,
		'VEC3': 3,
		'VEC4': 4,
		'MAT2': 4,
		'MAT3': 9,
		'MAT4': 16
	};

	var PATH_PROPERTIES = {
		scale: 'scale',
		translation: 'position',
		rotation: 'quaternion'
	};

	var INTERPOLATION = {
		LINEAR: fm.InterpolateLinear,
		STEP: fm.InterpolateDiscrete
	};

	var STATES_ENABLES = {
		2884: 'CULL_FACE',
		2929: 'DEPTH_TEST',
		3042: 'BLEND',
		3089: 'SCISSOR_TEST',
		32823: 'POLYGON_OFFSET_FILL',
		32926: 'SAMPLE_ALPHA_TO_COVERAGE'
	};

	/* UTILITY FUNCTIONS */

	function _each( object, callback, thisObj ) {

		if ( !object ) {
			return Promise.resolve();
		}

		var results;
		var fns = [];

		if ( Object.prototype.toString.call( object ) === '[object Array]' ) {

			results = [];

			var length = object.length;

			for ( var idx = 0; idx < length; idx ++ ) {

				var value = callback.call( thisObj || this, object[ idx ], idx );

				if ( value ) {

					fns.push( value );

					if ( value instanceof Promise ) {

						value.then( function( key, value ) {

							results[ key ] = value;

						}.bind( this, idx ));

					} else {

						results[ idx ] = value;

					}

				}

			}

		} else {

			results = {};

			for ( var key in object ) {

				if ( object.hasOwnProperty( key ) ) {

					var value = callback.call( thisObj || this, object[ key ], key );

					if ( value ) {

						fns.push( value );

						if ( value instanceof Promise ) {

							value.then( function( key, value ) {

								results[ key ] = value;

							}.bind( this, key ));

						} else {

							results[ key ] = value;

						}

					}

				}

			}

		}

		return Promise.all( fns ).then( function() {

			return results;

		});

	}

	function resolveURL( url, path ) {

		// Invalid URL
		if ( typeof url !== 'string' || url === '' )
			return '';

		// Absolute URL http://,https://,//
		if ( /^(https?:)?\/\//i.test( url ) ) {

			return url;

		}

		// Data URI
		if ( /^data:.*,.*$/i.test( url ) ) {

			return url;

		}

		// Blob URL
		if ( /^blob:.*$/i.test( url ) ) {

			return url;

		}

		// Relative URL
		return ( path || '' ) + url;

	}

	// Avoid the String.fromCharCode.apply(null, array) shortcut, which
	// throws a "maximum call stack size exceeded" error for large arrays.
	function convertUint8ArrayToString( array ) {

		var s = '';

		for ( var i = 0; i < array.length; i ++ ) {

			s += String.fromCharCode( array[ i ] );

		}

		return s;

	}

	// fm.js seems too dependent on attribute names so globally
	// replace those in the shader code
	function replaceTHREEShaderAttributes( shaderText, technique ) {

		// Expected technique attributes
		var attributes = {};

		for ( var attributeId in technique.attributes ) {

			var pname = technique.attributes[ attributeId ];

			var param = technique.parameters[ pname ];
			var atype = param.type;
			var semantic = param.semantic;

			attributes[ attributeId ] = {
				type: atype,
				semantic: semantic
			};

		}

		// Figure out which attributes to change in technique

		var shaderParams = technique.parameters;
		var shaderAttributes = technique.attributes;
		var params = {};

		for ( var attributeId in attributes ) {

			var pname = shaderAttributes[ attributeId ];
			var shaderParam = shaderParams[ pname ];
			var semantic = shaderParam.semantic;
			if ( semantic ) {

				params[ attributeId ] = shaderParam;

			}

		}

		for ( var pname in params ) {

			var param = params[ pname ];
			var semantic = param.semantic;

			var regEx = new RegExp( "\\b" + pname + "\\b", "g" );

			switch ( semantic ) {

				case 'POSITION':

					shaderText = shaderText.replace( regEx, 'position' );
					break;

				case 'NORMAL':

					shaderText = shaderText.replace( regEx, 'normal' );
					break;

				case 'TEXCOORD_0':
				case 'TEXCOORD0':
				case 'TEXCOORD':

					shaderText = shaderText.replace( regEx, 'uv' );
					break;

				case 'TEXCOORD_1':

					shaderText = shaderText.replace( regEx, 'uv2' );
					break;

				case 'COLOR_0':
				case 'COLOR0':
				case 'COLOR':

					shaderText = shaderText.replace( regEx, 'color' );
					break;

				case 'WEIGHTS_0':
				case 'WEIGHT': // WEIGHT semantic deprecated.

					shaderText = shaderText.replace( regEx, 'skinWeight' );
					break;

				case 'JOINTS_0':
				case 'JOINT': // JOINT semantic deprecated.

					shaderText = shaderText.replace( regEx, 'skinIndex' );
					break;

			}

		}

		return shaderText;

	}

	function createDefaultMaterial() {

		return new fm.MeshPhongMaterial( {
			color: 0x00000,
			emissive: 0x888888,
			specular: 0x000000,
			shininess: 0,
			transparent: false,
			depthTest: true,
			side: fm.FrontSide
		} );

	}

	// Deferred constructor for RawShaderMaterial types
	function DeferredShaderMaterial( params ) {

		this.isDeferredShaderMaterial = true;

		this.params = params;

	}

	DeferredShaderMaterial.prototype.create = function () {

		var uniforms = fm.UniformsUtils.clone( this.params.uniforms );

		for ( var uniformId in this.params.uniforms ) {

			var originalUniform = this.params.uniforms[ uniformId ];

			if ( originalUniform.value instanceof fm.Texture ) {

				uniforms[ uniformId ].value = originalUniform.value;
				uniforms[ uniformId ].value.needsUpdate = true;

			}

			uniforms[ uniformId ].semantic = originalUniform.semantic;
			uniforms[ uniformId ].node = originalUniform.node;

		}

		this.params.uniforms = uniforms;

		return new fm.RawShaderMaterial( this.params );

	};

	/* GLTF PARSER */

	function GLTFParser( json, extensions, options ) {

		this.json = json || {};
		this.extensions = extensions || {};
		this.options = options || {};

		// loader object cache
		this.cache = new GLTFRegistry();

	}

	GLTFParser.prototype._withDependencies = function ( dependencies ) {

		var _dependencies = {};

		for ( var i = 0; i < dependencies.length; i ++ ) {

			var dependency = dependencies[ i ];
			var fnName = "load" + dependency.charAt( 0 ).toUpperCase() + dependency.slice( 1 );

			var cached = this.cache.get( dependency );

			if ( cached !== undefined ) {

				_dependencies[ dependency ] = cached;

			} else if ( this[ fnName ] ) {

				var fn = this[ fnName ]();
				this.cache.add( dependency, fn );

				_dependencies[ dependency ] = fn;

			}

		}

		return _each( _dependencies, function ( dependency ) {

			return dependency;

		} );

	};

	GLTFParser.prototype.parse = function ( callback ) {

		var json = this.json;

		// Clear the loader cache
		this.cache.removeAll();

		// Fire the callback on complete
		this._withDependencies( [

			"scenes",
			"cameras",
			"animations"

		] ).then( function ( dependencies ) {

			var scenes = [];

			for ( var name in dependencies.scenes ) {

				scenes.push( dependencies.scenes[ name ] );

			}

			var scene = json.scene !== undefined ? dependencies.scenes[ json.scene ] : scenes[ 0 ];

			var cameras = [];

			for ( var name in dependencies.cameras ) {

				var camera = dependencies.cameras[ name ];
				cameras.push( camera );

			}

			var animations = [];

			for ( var name in dependencies.animations ) {

				animations.push( dependencies.animations[ name ] );

			}

			callback( scene, scenes, cameras, animations );

		} );

	};

	GLTFParser.prototype.loadShaders = function () {

		var json = this.json;
		var options = this.options;

		return this._withDependencies( [

			"bufferViews"

		] ).then( function ( dependencies ) {

			return _each( json.shaders, function ( shader ) {

				if ( shader.bufferView !== undefined ) {

					var bufferView = dependencies.bufferViews[ shader.bufferView ];
					var array = new Uint8Array( bufferView );
					return convertUint8ArrayToString( array );

				}

				return new Promise( function ( resolve ) {

					var loader = new fm.FileLoader();
					loader.setResponseType( 'text' );
					loader.load( resolveURL( shader.uri, options.path ), function ( shaderText ) {

						resolve( shaderText );

					} );

				} );

			} );

		} );

	};

	GLTFParser.prototype.loadBuffers = function () {

		var json = this.json;
		var extensions = this.extensions;
		var options = this.options;

		return _each( json.buffers, function ( buffer, name ) {

			if ( buffer.type === 'arraybuffer' || buffer.type === undefined ) {

				// If present, GLB container is required to be the first buffer.
				if ( buffer.uri === undefined && name === 0 ) {

					return extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body;

				}

				return new Promise( function ( resolve ) {

					var loader = new fm.FileLoader();
					loader.setResponseType( 'arraybuffer' );
					loader.load( resolveURL( buffer.uri, options.path ), function ( buffer ) {

						resolve( buffer );

					} );

				} );

			} else {

				console.warn( 'fm.GLTF2Loader: ' + buffer.type + ' buffer type is not supported' );

			}

		} );

	};

	GLTFParser.prototype.loadBufferViews = function () {

		var json = this.json;

		return this._withDependencies( [

			"buffers"

		] ).then( function ( dependencies ) {

			return _each( json.bufferViews, function ( bufferView ) {

				var arraybuffer = dependencies.buffers[ bufferView.buffer ];

				var byteLength = bufferView.byteLength !== undefined ? bufferView.byteLength : 0;

				return arraybuffer.slice( bufferView.byteOffset, bufferView.byteOffset + byteLength );

			} );

		} );

	};

	GLTFParser.prototype.loadAccessors = function () {

		var json = this.json;

		return this._withDependencies( [

			"bufferViews"

		] ).then( function ( dependencies ) {

			return _each( json.accessors, function ( accessor ) {

				var arraybuffer = dependencies.bufferViews[ accessor.bufferView ];
				var itemSize = WEBGL_TYPE_SIZES[ accessor.type ];
				var TypedArray = WEBGL_COMPONENT_TYPES[ accessor.componentType ];

				// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
				var elementBytes = TypedArray.BYTES_PER_ELEMENT;
				var itemBytes = elementBytes * itemSize;

				var array;

				// The buffer is not interleaved if the stride is the item size in bytes.
				if ( accessor.byteStride && accessor.byteStride !== itemBytes ) {

					// Use the full buffer if it's interleaved.
					array = new TypedArray( arraybuffer );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					var ib = new fm.InterleavedBuffer( array, accessor.byteStride / elementBytes );

					return new fm.InterleavedBufferAttribute( ib, itemSize, accessor.byteOffset / elementBytes );

				} else {

					array = new TypedArray( arraybuffer, accessor.byteOffset, accessor.count * itemSize );

					return new fm.BufferAttribute( array, itemSize );

				}

			} );

		} );

	};

	GLTFParser.prototype.loadTextures = function () {

		var json = this.json;
		var options = this.options;

		return this._withDependencies( [

			"bufferViews"

		] ).then( function ( dependencies ) {

			return _each( json.textures, function ( texture ) {

				if ( texture.source !== undefined ) {

					return new Promise( function ( resolve ) {

						var source = json.images[ texture.source ];
						var sourceUri = source.uri;

						var urlCreator;

						if ( source.bufferView !== undefined ) {

							var bufferView = dependencies.bufferViews[ source.bufferView ];
							var blob = new Blob( [ bufferView ], { type: source.mimeType } );
							urlCreator = window.URL || window.webkitURL;
							sourceUri = urlCreator.createObjectURL( blob );

						}

						var textureLoader = fm.Loader.Handlers.get( sourceUri );

						if ( textureLoader === null ) {

							textureLoader = new fm.TextureLoader();

						}

						textureLoader.setCrossOrigin( options.crossOrigin );

						textureLoader.load( resolveURL( sourceUri, options.path ), function ( _texture ) {

							if ( urlCreator !== undefined ) {

								urlCreator.revokeObjectURL( sourceUri );

							}

							_texture.flipY = false;

							if ( texture.name !== undefined ) _texture.name = texture.name;

							_texture.format = texture.format !== undefined ? WEBGL_TEXTURE_FORMATS[ texture.format ] : fm.RGBAFormat;

							if ( texture.internalFormat !== undefined && _texture.format !== WEBGL_TEXTURE_FORMATS[ texture.internalFormat ] ) {

								console.warn( 'fm.GLTF2Loader: fm.js doesn\'t support texture internalFormat which is different from texture format. ' +
								              'internalFormat will be forced to be the same value as format.' );

							}

							_texture.type = texture.type !== undefined ? WEBGL_TEXTURE_DATATYPES[ texture.type ] : fm.UnsignedByteType;

							if ( texture.sampler !== undefined ) {

								var sampler = json.samplers[ texture.sampler ];

								_texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || fm.LinearFilter;
								_texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || fm.NearestMipMapLinearFilter;
								_texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || fm.RepeatWrapping;
								_texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || fm.RepeatWrapping;

							}

							resolve( _texture );

						}, undefined, function () {

							resolve();

						} );

					} );

				}

			} );

		} );

	};

	GLTFParser.prototype.loadMaterials = function () {

		var json = this.json;

		return this._withDependencies( [

			"shaders",
			"textures"

		] ).then( function ( dependencies ) {

			return _each( json.materials, function ( material ) {

				var materialType;
				var materialValues = {};
				var materialParams = {};

				var khr_material;

				if ( material.extensions && material.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] ) {

					khr_material = material.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ];

				}

				if ( khr_material ) {

					// don't copy over unused values to avoid material warning spam
					var keys = [ 'ambient', 'emission', 'transparent', 'transparency', 'doubleSided' ];

					switch ( khr_material.technique ) {

						case 'BLINN' :
						case 'PHONG' :
							materialType = fm.MeshPhongMaterial;
							keys.push( 'diffuse', 'specular', 'shininess' );
							break;

						case 'LAMBERT' :
							materialType = fm.MeshLambertMaterial;
							keys.push( 'diffuse' );
							break;

						case 'CONSTANT' :
						default :
							materialType = fm.MeshBasicMaterial;
							break;

					}

					keys.forEach( function( v ) {

						if ( khr_material.values[ v ] !== undefined ) materialValues[ v ] = khr_material.values[ v ];

					} );

					if ( khr_material.doubleSided || materialValues.doubleSided ) {

						materialParams.side = fm.DoubleSide;

					}

					if ( khr_material.transparent || materialValues.transparent ) {

						materialParams.transparent = true;
						materialParams.opacity = ( materialValues.transparency !== undefined ) ? materialValues.transparency : 1;

					}

				} else if ( material.technique === undefined ) {

					if ( material.pbrMetallicRoughness !== undefined )  {

						// specification
						// https://github.com/sbtron/glTF/blob/30de0b365d1566b1bbd8b9c140f9e995d3203226/specification/2.0/README.md#metallic-roughness-material

						materialType = fm.MeshStandardMaterial;

						if ( material.pbrMetallicRoughness !== undefined ) {

							var metallicRoughness = material.pbrMetallicRoughness;

							materialParams.color = new fm.Color( 1.0, 1.0, 1.0 );
							materialParams.opacity = 1.0;

							if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

								var array = metallicRoughness.baseColorFactor;

								materialParams.color.fromArray( array );
								materialParams.opacity = array[ 3 ];

							}

							if ( metallicRoughness.baseColorTexture !== undefined ) {

								materialParams.map = dependencies.textures[ metallicRoughness.baseColorTexture.index ];

							}

							if ( materialParams.opacity < 1.0 ||
							     ( materialParams.map !== undefined &&
							       ( materialParams.map.format === fm.AlphaFormat ||
							         materialParams.map.format === fm.RGBAFormat ||
							         materialParams.map.format === fm.LuminanceAlphaFormat ) ) ) {

								materialParams.transparent = true;

							}

							materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
							materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

							if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

								var textureIndex = metallicRoughness.metallicRoughnessTexture.index;

								// Note that currently metalnessMap would be entirely ignored because
								// fm.js and glTF specification use different texture channels for metalness
								// (Blue: fm.js, Red: glTF).
								// But glTF specification team is discussing if they can change.
								// Let's keep an eye on it so far.
								//
								// https://github.com/KhronosGroup/glTF/issues/857
								materialParams.metalnessMap = dependencies.textures[ textureIndex ];
								materialParams.roughnessMap = dependencies.textures[ textureIndex ];

							}

						}

					} else {

						materialType = fm.MeshPhongMaterial;

					}

					if ( material.normalTexture !== undefined ) {

						materialParams.normalMap = dependencies.textures[ material.normalTexture.index ];

					}

					if ( material.occlusionTexture !== undefined ) {

						materialParams.aoMap = dependencies.textures[ material.occlusionTexture.index ];

					}

					if ( material.emissiveTexture !== undefined ) {

						materialParams.emissiveMap = dependencies.textures[ material.emissiveTexture.index ];

					}

					materialParams.emissive = new fm.Color( 0.0, 0.0, 0.0 );

					if ( material.emissiveFactor !== undefined ) {

						materialParams.emissive.fromArray( material.emissiveFactor );

					}

					Object.assign( materialValues, material.values );

				} else {

					materialType = DeferredShaderMaterial;

					var technique = json.techniques[ material.technique ];

					materialParams.uniforms = {};

					var program = json.programs[ technique.program ];

					if ( program ) {

						materialParams.fragmentShader = dependencies.shaders[ program.fragmentShader ];

						if ( ! materialParams.fragmentShader ) {

							console.warn( "ERROR: Missing fragment shader definition:", program.fragmentShader );
							materialType = fm.MeshPhongMaterial;

						}

						var vertexShader = dependencies.shaders[ program.vertexShader ];

						if ( ! vertexShader ) {

							console.warn( "ERROR: Missing vertex shader definition:", program.vertexShader );
							materialType = fm.MeshPhongMaterial;

						}

						// IMPORTANT: FIX VERTEX SHADER ATTRIBUTE DEFINITIONS
						materialParams.vertexShader = replaceTHREEShaderAttributes( vertexShader, technique );

						var uniforms = technique.uniforms;

						for ( var uniformId in uniforms ) {

							var pname = uniforms[ uniformId ];
							var shaderParam = technique.parameters[ pname ];

							var ptype = shaderParam.type;

							if ( WEBGL_TYPE[ ptype ] ) {

								var pcount = shaderParam.count;
								var value;

								if ( material.values !== undefined ) value = material.values[ pname ];

								var uvalue = new WEBGL_TYPE[ ptype ]();
								var usemantic = shaderParam.semantic;
								var unode = shaderParam.node;

								switch ( ptype ) {

									case WEBGL_CONSTANTS.FLOAT:

										uvalue = shaderParam.value;

										if ( pname == "transparency" ) {

											materialParams.transparent = true;

										}

										if ( value !== undefined ) {

											uvalue = value;

										}

										break;

									case WEBGL_CONSTANTS.FLOAT_VEC2:
									case WEBGL_CONSTANTS.FLOAT_VEC3:
									case WEBGL_CONSTANTS.FLOAT_VEC4:
									case WEBGL_CONSTANTS.FLOAT_MAT3:

										if ( shaderParam && shaderParam.value ) {

											uvalue.fromArray( shaderParam.value );

										}

										if ( value ) {

											uvalue.fromArray( value );

										}

										break;

									case WEBGL_CONSTANTS.FLOAT_MAT2:

										// what to do?
										console.warn( "FLOAT_MAT2 is not a supported uniform type" );
										break;

									case WEBGL_CONSTANTS.FLOAT_MAT4:

										if ( pcount ) {

											uvalue = new Array( pcount );

											for ( var mi = 0; mi < pcount; mi ++ ) {

												uvalue[ mi ] = new WEBGL_TYPE[ ptype ]();

											}

											if ( shaderParam && shaderParam.value ) {

												var m4v = shaderParam.value;
												uvalue.fromArray( m4v );

											}

											if ( value ) {

												uvalue.fromArray( value );

											}

										} else {

											if ( shaderParam && shaderParam.value ) {

												var m4 = shaderParam.value;
												uvalue.fromArray( m4 );

											}

											if ( value ) {

												uvalue.fromArray( value );

											}

										}

										break;

									case WEBGL_CONSTANTS.SAMPLER_2D:

										if ( value !== undefined ) {

											uvalue = dependencies.textures[ value ];

										} else if ( shaderParam.value !== undefined ) {

											uvalue = dependencies.textures[ shaderParam.value ];

										} else {

											uvalue = null;

										}

										break;

								}

								materialParams.uniforms[ uniformId ] = {
									value: uvalue,
									semantic: usemantic,
									node: unode
								};

							} else {

								throw new Error( "Unknown shader uniform param type: " + ptype );

							}

						}

						var states = technique.states || {};
						var enables = states.enable || [];
						var functions = states.functions || {};

						var enableCullFace = false;
						var enableDepthTest = false;
						var enableBlend = false;

						for ( var i = 0, il = enables.length; i < il; i ++ ) {

							var enable = enables[ i ];

							switch ( STATES_ENABLES[ enable ] ) {

								case 'CULL_FACE':

									enableCullFace = true;

									break;

								case 'DEPTH_TEST':

									enableDepthTest = true;

									break;

								case 'BLEND':

									enableBlend = true;

									break;

								// TODO: implement
								case 'SCISSOR_TEST':
								case 'POLYGON_OFFSET_FILL':
								case 'SAMPLE_ALPHA_TO_COVERAGE':

									break;

								default:

									throw new Error( "Unknown technique.states.enable: " + enable );

							}

						}

						if ( enableCullFace ) {

							materialParams.side = functions.cullFace !== undefined ? WEBGL_SIDES[ functions.cullFace ] : fm.FrontSide;

						} else {

							materialParams.side = fm.DoubleSide;

						}

						materialParams.depthTest = enableDepthTest;
						materialParams.depthFunc = functions.depthFunc !== undefined ? WEBGL_DEPTH_FUNCS[ functions.depthFunc ] : fm.LessDepth;
						materialParams.depthWrite = functions.depthMask !== undefined ? functions.depthMask[ 0 ] : true;

						materialParams.blending = enableBlend ? fm.CustomBlending : fm.NoBlending;
						materialParams.transparent = enableBlend;

						var blendEquationSeparate = functions.blendEquationSeparate;

						if ( blendEquationSeparate !== undefined ) {

							materialParams.blendEquation = WEBGL_BLEND_EQUATIONS[ blendEquationSeparate[ 0 ] ];
							materialParams.blendEquationAlpha = WEBGL_BLEND_EQUATIONS[ blendEquationSeparate[ 1 ] ];

						} else {

							materialParams.blendEquation = fm.AddEquation;
							materialParams.blendEquationAlpha = fm.AddEquation;

						}

						var blendFuncSeparate = functions.blendFuncSeparate;

						if ( blendFuncSeparate !== undefined ) {

							materialParams.blendSrc = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 0 ] ];
							materialParams.blendDst = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 1 ] ];
							materialParams.blendSrcAlpha = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 2 ] ];
							materialParams.blendDstAlpha = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 3 ] ];

						} else {

							materialParams.blendSrc = fm.OneFactor;
							materialParams.blendDst = fm.ZeroFactor;
							materialParams.blendSrcAlpha = fm.OneFactor;
							materialParams.blendDstAlpha = fm.ZeroFactor;

						}

					}

				}

				if ( Array.isArray( materialValues.diffuse ) ) {

					materialParams.color = new fm.Color().fromArray( materialValues.diffuse );

				} else if ( typeof( materialValues.diffuse ) === 'string' ) {

					materialParams.map = dependencies.textures[ materialValues.diffuse ];

				}

				delete materialParams.diffuse;

				if ( typeof( materialValues.reflective ) === 'string' ) {

					materialParams.envMap = dependencies.textures[ materialValues.reflective ];

				}

				if ( typeof( materialValues.bump ) === 'string' ) {

					materialParams.bumpMap = dependencies.textures[ materialValues.bump ];

				}

				if ( Array.isArray( materialValues.emission ) ) {

					if ( materialType === fm.MeshBasicMaterial ) {

						materialParams.color = new fm.Color().fromArray( materialValues.emission );

					} else {

						materialParams.emissive = new fm.Color().fromArray( materialValues.emission );

					}

				} else if ( typeof( materialValues.emission ) === 'string' ) {

					if ( materialType === fm.MeshBasicMaterial ) {

						materialParams.map = dependencies.textures[ materialValues.emission ];

					} else {

						materialParams.emissiveMap = dependencies.textures[ materialValues.emission ];

					}

				}

				if ( Array.isArray( materialValues.specular ) ) {

					materialParams.specular = new fm.Color().fromArray( materialValues.specular );

				} else if ( typeof( materialValues.specular ) === 'string' ) {

					materialParams.specularMap = dependencies.textures[ materialValues.specular ];

				}

				if ( materialValues.shininess !== undefined ) {

					materialParams.shininess = materialValues.shininess;

				}

				var _material = new materialType( materialParams );
				if ( material.name !== undefined ) _material.name = material.name;

				return _material;

			} );

		} );

	};

	GLTFParser.prototype.loadMeshes = function () {

		var json = this.json;

		return this._withDependencies( [

			"accessors",
			"materials"

		] ).then( function ( dependencies ) {

			return _each( json.meshes, function ( mesh ) {

				var group = new fm.Group();
				if ( mesh.name !== undefined ) group.name = mesh.name;

				if ( mesh.extras ) group.userData = mesh.extras;

				var primitives = mesh.primitives || [];

				for ( var name in primitives ) {

					var primitive = primitives[ name ];

					var material = primitive.material !== undefined ? dependencies.materials[ primitive.material ] : createDefaultMaterial();

					var geometry;

					var meshNode;

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === undefined ) {

						geometry = new fm.BufferGeometry();

						var attributes = primitive.attributes;

						for ( var attributeId in attributes ) {

							var attributeEntry = attributes[ attributeId ];

							if ( attributeEntry === undefined ) return;

							var bufferAttribute = dependencies.accessors[ attributeEntry ];

							switch ( attributeId ) {

								case 'POSITION':

									geometry.addAttribute( 'position', bufferAttribute );
									break;

								case 'NORMAL':

									geometry.addAttribute( 'normal', bufferAttribute );
									break;

								case 'TEXCOORD_0':
								case 'TEXCOORD0':
								case 'TEXCOORD':

									geometry.addAttribute( 'uv', bufferAttribute );
									break;

								case 'TEXCOORD_1':

									geometry.addAttribute( 'uv2', bufferAttribute );
									break;

								case 'COLOR_0':
								case 'COLOR0':
								case 'COLOR':

									geometry.addAttribute( 'color', bufferAttribute );
									break;

								case 'WEIGHTS_0':
								case 'WEIGHT': // WEIGHT semantic deprecated.

									geometry.addAttribute( 'skinWeight', bufferAttribute );
									break;

								case 'JOINTS_0':
								case 'JOINT': // JOINT semantic deprecated.

									geometry.addAttribute( 'skinIndex', bufferAttribute );
									break;

							}

						}

						if ( primitive.indices !== undefined ) {

							geometry.setIndex( dependencies.accessors[ primitive.indices ] );

						}

						meshNode = new fm.Mesh( geometry, material );
						meshNode.castShadow = true;

					} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

						geometry = new fm.BufferGeometry();

						var attributes = primitive.attributes;

						for ( var attributeId in attributes ) {

							var attributeEntry = attributes[ attributeId ];

							if ( ! attributeEntry ) return;

							var bufferAttribute = dependencies.accessors[ attributeEntry ];

							switch ( attributeId ) {

								case 'POSITION':
									geometry.addAttribute( 'position', bufferAttribute );
									break;

								case 'COLOR_0':
								case 'COLOR0':
								case 'COLOR':
									geometry.addAttribute( 'color', bufferAttribute );
									break;

							}

						}

						if ( primitive.indices !== undefined ) {

							geometry.setIndex( dependencies.accessors[ primitive.indices ] );

							meshNode = new fm.LineSegments( geometry, material );

						} else {

							meshNode = new fm.Line( geometry, material );

						}

					} else {

						throw new Error( "Only triangular and line primitives are supported" );

					}

					if ( geometry.attributes.color !== undefined ) {

						material.vertexColors = fm.VertexColors;
						material.needsUpdate = true;

					}

					meshNode.name = ( name === "0" ? group.name : group.name + name );

					if ( primitive.extras ) meshNode.userData = primitive.extras;

					group.add( meshNode );

				}

				return group;

			} );

		} );

	};

	GLTFParser.prototype.loadCameras = function () {

		var json = this.json;

		return _each( json.cameras, function ( camera ) {

			if ( camera.type == "perspective" && camera.perspective ) {

				var yfov = camera.perspective.yfov;
				var aspectRatio = camera.perspective.aspectRatio !== undefined ? camera.perspective.aspectRatio : 1;

				// According to COLLADA spec...
				// aspectRatio = xfov / yfov
				var xfov = yfov * aspectRatio;

				var _camera = new fm.PerspectiveCamera( fm.Math.radToDeg( xfov ), aspectRatio, camera.perspective.znear || 1, camera.perspective.zfar || 2e6 );
				if ( camera.name !== undefined ) _camera.name = camera.name;

				if ( camera.extras ) _camera.userData = camera.extras;

				return _camera;

			} else if ( camera.type == "orthographic" && camera.orthographic ) {

				var _camera = new fm.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, camera.orthographic.znear, camera.orthographic.zfar );
				if ( camera.name !== undefined ) _camera.name = camera.name;

				if ( camera.extras ) _camera.userData = camera.extras;

				return _camera;

			}

		} );

	};

	GLTFParser.prototype.loadSkins = function () {

		var json = this.json;

		return this._withDependencies( [

			"accessors"

		] ).then( function ( dependencies ) {

			return _each( json.skins, function ( skin ) {

				var bindShapeMatrix = new fm.Matrix4();

				if ( skin.bindShapeMatrix !== undefined ) bindShapeMatrix.fromArray( skin.bindShapeMatrix );

				var _skin = {
					bindShapeMatrix: bindShapeMatrix,
					jointNames: skin.jointNames,
					inverseBindMatrices: dependencies.accessors[ skin.inverseBindMatrices ]
				};

				return _skin;

			} );

		} );

	};

	GLTFParser.prototype.loadAnimations = function () {

		var json = this.json;

		return this._withDependencies( [

			"accessors",
			"nodes"

		] ).then( function ( dependencies ) {
			return;
			//*
			return _each( json.animations, function ( animation, animationId ) {

				var tracks = [];

				for ( var channelId in animation.channels ) {

					var channel = animation.channels[ channelId ];
					var sampler = animation.samplers[ channel.sampler ];

					if ( sampler ) {

						var target = channel.target;
						var name = target.node || target.id; // NOTE: target.id is deprecated.
						var input = animation.parameters !== undefined ? animation.parameters[ sampler.input ] : sampler.input;
						var output = animation.parameters !== undefined ? animation.parameters[ sampler.output ] : sampler.output;

						var inputAccessor = dependencies.accessors[ input ];
						var outputAccessor = dependencies.accessors[ output ];

						var node = dependencies.nodes[ name ];

						if ( node ) {

							node.updateMatrix();
							node.matrixAutoUpdate = true;

							var TypedKeyframeTrack = PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.rotation
								? fm.QuaternionKeyframeTrack
								: fm.VectorKeyframeTrack;

							var targetName = node.name ? node.name : node.uuid;
							var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : fm.InterpolateLinear;

							// KeyframeTrack.optimize() will modify given 'times' and 'values'
							// buffers before creating a truncated copy to keep. Because buffers may
							// be reused by other tracks, make copies here.
							tracks.push( new TypedKeyframeTrack(
								targetName + '.' + PATH_PROPERTIES[ target.path ],
								fm.AnimationUtils.arraySlice( inputAccessor.array, 0 ),
								fm.AnimationUtils.arraySlice( outputAccessor.array, 0 ),
								interpolation
							) );

						}

					}

				}

				var name = animation.name !== undefined ? animation.name : "animation_" + animationId;

				return new fm.AnimationClip( name, undefined, tracks );

			} );
		//*/

		} );
	};

	GLTFParser.prototype.loadNodes = function () {

		var json = this.json;
		var extensions = this.extensions;
		var scope = this;

		return _each( json.nodes, function ( node ) {

			var matrix = new fm.Matrix4();

			var _node;

			if ( node.jointName ) {

				_node = new fm.Bone();
				_node.name = node.name !== undefined ? node.name : node.jointName;
				_node.jointName = node.jointName;

			} else {

				_node = new fm.Object3D();
				if ( node.name !== undefined ) _node.name = node.name;

			}

			if ( node.extras ) _node.userData = node.extras;

			if ( node.matrix !== undefined ) {

				matrix.fromArray( node.matrix );
				_node.applyMatrix( matrix );

			} else {

				if ( node.translation !== undefined ) {

					_node.position.fromArray( node.translation );

				}

				if ( node.rotation !== undefined ) {

					_node.quaternion.fromArray( node.rotation );

				}

				if ( node.scale !== undefined ) {

					_node.scale.fromArray( node.scale );

				}

			}

			return _node;

		} ).then( function ( __nodes ) {

			return scope._withDependencies( [

				"meshes",
				"skins",
				"cameras"

			] ).then( function ( dependencies ) {

				return _each( __nodes, function ( _node, nodeId ) {

					var node = json.nodes[ nodeId ];

					var meshes;

					if ( node.mesh !== undefined) {

						meshes = [ node.mesh ];

					} else if ( node.meshes !== undefined ) {

						console.warn( 'GLTF2Loader: Legacy glTF file detected. Nodes may have no more than 1 mesh.' );

						meshes = node.meshes;

					}

					if ( meshes !== undefined ) {

						for ( var meshId in meshes ) {

							var mesh = meshes[ meshId ];
							var group = dependencies.meshes[ mesh ];

							if ( group === undefined ) {

								console.warn( 'GLTF2Loader: Couldn\'t find node "' + mesh + '".' );
								continue;

							}

							for ( var childrenId in group.children ) {

								var child = group.children[ childrenId ];

								// clone Mesh to add to _node

								var originalMaterial = child.material;
								var originalGeometry = child.geometry;
								var originalUserData = child.userData;
								var originalName = child.name;

								var material;

								if ( originalMaterial.isDeferredShaderMaterial ) {

									originalMaterial = material = originalMaterial.create();

								} else {

									material = originalMaterial;

								}

								switch ( child.type ) {

									case 'LineSegments':
										child = new fm.LineSegments( originalGeometry, material );
										break;

									case 'LineLoop':
										child = new fm.LineLoop( originalGeometry, material );
										break;

									case 'Line':
										child = new fm.Line( originalGeometry, material );
										break;

									default:
										child = new fm.Mesh( originalGeometry, material );

								}

								child.castShadow = true;
								child.userData = originalUserData;
								child.name = originalName;

								var skinEntry;

								if ( node.skin !== undefined ) {

									skinEntry = dependencies.skins[ node.skin ];

								}

								// Replace Mesh with SkinnedMesh in library
								if ( skinEntry ) {

									var getJointNode = function ( jointId ) {

										var keys = Object.keys( __nodes );

										for ( var i = 0, il = keys.length; i < il; i ++ ) {

											var n = __nodes[ keys[ i ] ];

											if ( n.jointName === jointId ) return n;

										}

										return null;

									};

									var geometry = originalGeometry;
									var material = originalMaterial;
									material.skinning = true;

									child = new fm.SkinnedMesh( geometry, material, false );
									child.castShadow = true;
									child.userData = originalUserData;
									child.name = originalName;

									var bones = [];
									var boneInverses = [];

									for ( var i = 0, l = skinEntry.jointNames.length; i < l; i ++ ) {

										var jointId = skinEntry.jointNames[ i ];
										var jointNode = getJointNode( jointId );

										if ( jointNode ) {

											bones.push( jointNode );

											var m = skinEntry.inverseBindMatrices.array;
											var mat = new fm.Matrix4().fromArray( m, i * 16 );
											boneInverses.push( mat );

										} else {

											console.warn( "WARNING: joint: '" + jointId + "' could not be found" );

										}

									}

									child.bind( new fm.Skeleton( bones, boneInverses, false ), skinEntry.bindShapeMatrix );

									var buildBoneGraph = function ( parentJson, parentObject, property ) {

										var children = parentJson[ property ];

										if ( children === undefined ) return;

										for ( var i = 0, il = children.length; i < il; i ++ ) {

											var nodeId = children[ i ];
											var bone = __nodes[ nodeId ];
											var boneJson = json.nodes[ nodeId ];

											if ( bone !== undefined && bone.isBone === true && boneJson !== undefined ) {

												parentObject.add( bone );
												buildBoneGraph( boneJson, bone, 'children' );

											}

										}

									};

									buildBoneGraph( node, child, 'skeletons' );

								}

								_node.add( child );

							}

						}

					}

					if ( node.camera !== undefined ) {

						var camera = dependencies.cameras[ node.camera ];

						_node.add( camera );

					}

					if ( node.extensions
							 && node.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ]
							 && node.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ].light ) {

						var extensionLights = extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ].lights;
						var light = extensionLights[ node.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ].light ];

						_node.add( light );

					}

					return _node;

				} );

			} );

		} );

	};

	GLTFParser.prototype.loadScenes = function () {

		var json = this.json;

		// scene node hierachy builder

		function buildNodeHierachy( nodeId, parentObject, allNodes ) {

			var _node = allNodes[ nodeId ];
			parentObject.add( _node );

			var node = json.nodes[ nodeId ];

			if ( node.children ) {

				var children = node.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					var child = children[ i ];
					buildNodeHierachy( child, _node, allNodes );

				}

			}

		}

		return this._withDependencies( [

			"nodes"

		] ).then( function ( dependencies ) {

			return _each( json.scenes, function ( scene ) {

				var _scene = new fm.Scene();
				if ( scene.name !== undefined ) _scene.name = scene.name;

				if ( scene.extras ) _scene.userData = scene.extras;

				var nodes = scene.nodes || [];

				for ( var i = 0, l = nodes.length; i < l; i ++ ) {

					var nodeId = nodes[ i ];
					buildNodeHierachy( nodeId, _scene, dependencies.nodes );

				}

				_scene.traverse( function ( child ) {

					// Register raw material meshes with GLTF2Loader.Shaders
					if ( child.material && child.material.isRawShaderMaterial ) {

						child.gltfShader = new GLTFShader( child, dependencies.nodes );
						child.onBeforeRender = function(renderer, scene, camera){
							this.gltfShader.update(scene, camera);
						};

					}

				} );

				return _scene;

			} );

		} );

	};

	return GLTF2Loader;

} )();

fm.JSONModelLoader = function() {
    this.loader = new fm.JSONLoader();
};

fm.JSONModelLoader.prototype = {
    load: function(url, callback) {
        if(undefined == callback){return;}
        this.loader.load(url, function(geo, mats) {
            if(undefined == geo){callback(undefined);return;}
            
            if (geo instanceof fm.Geometry) {
                if(undefined == mats){callback(undefined);return;}
                var material = mats[0];// single materia;
                if (1 < mats.length) {// multi material
                    material = new fm.MultiMaterial(mats);
                }
                // geo.computeVertexNormals();// to smooth geometry
                var mesh = new fm.Mesh(geo, material);
                callback(mesh);
                return;
            }
            callback(geo);
        }, function(url, itemsLoaded, itemsTotal){
            
        }, function(event){
            callback(undefined);
        });
    },
    
    setTexturePath: function(path) {
        this.loader.setTexturePath(path);
    }
};
/*!
 *
 * threeoctree.js (r60) / https://github.com/collinhover/threeoctree
 * (sparse) dynamic 3D spatial representation structure for fast searches.
 *
 * @author Collin Hover / http://collinhover.com/
 * based on Dynamic Octree by Piko3D @ http://www.piko3d.com/ and Octree by Marek Pawlowski @ pawlowski.it
 *
 */
( function ( fm ) {

	"use strict";

	/*===================================================

	utility

	=====================================================*/

	function isNumber( n ) {

		return ! isNaN( n ) && isFinite( n );

	}

	function isArray( target ) {

		return Object.prototype.toString.call( target ) === '[object Array]';

	}

	function toArray( target ) {

		return target ? ( isArray( target ) !== true ? [ target ] : target ) : [];

	}

	function indexOfValue( array, value ) {

		for ( var i = 0, il = array.length; i < il; i ++ ) {

			if ( array[ i ] === value ) {

				return i;

			}

		}

		return - 1;

	}

	function indexOfPropertyWithValue( array, property, value ) {

		for ( var i = 0, il = array.length; i < il; i ++ ) {

			if ( array[ i ][ property ] === value ) {

				return i;

			}

		}

		return - 1;

	}

	/*===================================================

	octree

	=====================================================*/

	fm.Octree = function ( parameters ) {

		// handle parameters

		parameters = parameters || {};

		parameters.tree = this;

		// static properties ( modification is not recommended )

		this.nodeCount = 0;

		this.INDEX_INSIDE_CROSS = - 1;
		this.INDEX_OUTSIDE_OFFSET = 2;

		this.INDEX_OUTSIDE_POS_X = isNumber( parameters.INDEX_OUTSIDE_POS_X ) ? parameters.INDEX_OUTSIDE_POS_X : 0;
		this.INDEX_OUTSIDE_NEG_X = isNumber( parameters.INDEX_OUTSIDE_NEG_X ) ? parameters.INDEX_OUTSIDE_NEG_X : 1;
		this.INDEX_OUTSIDE_POS_Y = isNumber( parameters.INDEX_OUTSIDE_POS_Y ) ? parameters.INDEX_OUTSIDE_POS_Y : 2;
		this.INDEX_OUTSIDE_NEG_Y = isNumber( parameters.INDEX_OUTSIDE_NEG_Y ) ? parameters.INDEX_OUTSIDE_NEG_Y : 3;
		this.INDEX_OUTSIDE_POS_Z = isNumber( parameters.INDEX_OUTSIDE_POS_Z ) ? parameters.INDEX_OUTSIDE_POS_Z : 4;
		this.INDEX_OUTSIDE_NEG_Z = isNumber( parameters.INDEX_OUTSIDE_NEG_Z ) ? parameters.INDEX_OUTSIDE_NEG_Z : 5;

		this.INDEX_OUTSIDE_MAP = [];
		this.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_POS_X ] = { index: this.INDEX_OUTSIDE_POS_X, count: 0, x: 1, y: 0, z: 0 };
		this.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_NEG_X ] = { index: this.INDEX_OUTSIDE_NEG_X, count: 0, x: - 1, y: 0, z: 0 };
		this.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_POS_Y ] = { index: this.INDEX_OUTSIDE_POS_Y, count: 0, x: 0, y: 1, z: 0 };
		this.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_NEG_Y ] = { index: this.INDEX_OUTSIDE_NEG_Y, count: 0, x: 0, y: - 1, z: 0 };
		this.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_POS_Z ] = { index: this.INDEX_OUTSIDE_POS_Z, count: 0, x: 0, y: 0, z: 1 };
		this.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_NEG_Z ] = { index: this.INDEX_OUTSIDE_NEG_Z, count: 0, x: 0, y: 0, z: - 1 };

		this.FLAG_POS_X = 1 << ( this.INDEX_OUTSIDE_POS_X + 1 );
		this.FLAG_NEG_X = 1 << ( this.INDEX_OUTSIDE_NEG_X + 1 );
		this.FLAG_POS_Y = 1 << ( this.INDEX_OUTSIDE_POS_Y + 1 );
		this.FLAG_NEG_Y = 1 << ( this.INDEX_OUTSIDE_NEG_Y + 1 );
		this.FLAG_POS_Z = 1 << ( this.INDEX_OUTSIDE_POS_Z + 1 );
		this.FLAG_NEG_Z = 1 << ( this.INDEX_OUTSIDE_NEG_Z + 1 );

		this.utilVec31Search = new fm.Vector3();
		this.utilVec32Search = new fm.Vector3();

		// pass scene to see octree structure

		this.scene = parameters.scene;

		if ( this.scene ) {

			var helper = new fm.BoxHelper( new fm.Mesh( new fm.BoxBufferGeometry( 1, 1, 1 ) ), 0xff0066 );
			this.visualGeometry = helper.geometry;
			this.visualMaterial = helper.material;

		}

		// properties

		this.objects = [];
		this.objectsMap = {};
		this.objectsData = [];
		this.objectsDeferred = [];

		this.depthMax = isNumber( parameters.depthMax ) ? parameters.depthMax : Infinity;
		this.objectsThreshold = isNumber( parameters.objectsThreshold ) ? parameters.objectsThreshold : 8;
		this.overlapPct = isNumber( parameters.overlapPct ) ? parameters.overlapPct : 0.15;
		this.undeferred = parameters.undeferred || false;

		this.root = parameters.root instanceof fm.OctreeNode ? parameters.root : new fm.OctreeNode( parameters );

	};

	fm.Octree.prototype = {

		update: function () {

			// add any deferred objects that were waiting for render cycle

			if ( this.objectsDeferred.length > 0 ) {

				for ( var i = 0, il = this.objectsDeferred.length; i < il; i ++ ) {

					var deferred = this.objectsDeferred[ i ];

					this.addDeferred( deferred.object, deferred.options );

				}

				this.objectsDeferred.length = 0;

			}

		},

		add: function ( object, options ) {

			// add immediately

			if ( this.undeferred ) {

				this.updateObject( object );

				this.addDeferred( object, options );

			} else {

				// defer add until update called

				this.objectsDeferred.push( { object: object, options: options } );

			}

		},

		addDeferred: function ( object, options ) {

			var i, l,
				geometry,
				faces,
				useFaces,
				vertices,
				useVertices,
				objectData;

			// ensure object is not object data

			if ( object instanceof fm.OctreeObjectData ) {

				object = object.object;

			}

			// check uuid to avoid duplicates

			if ( ! object.uuid ) {

				object.uuid = fm.Math.generateUUID();

			}

			if ( ! this.objectsMap[ object.uuid ] ) {

				// store

				this.objects.push( object );
				this.objectsMap[ object.uuid ] = object;

				// check options

				if ( options ) {

					useFaces = options.useFaces;
					useVertices = options.useVertices;

				}

				if ( useVertices === true ) {

					geometry = object.geometry;
					vertices = geometry.vertices;

					for ( i = 0, l = vertices.length; i < l; i ++ ) {

						this.addObjectData( object, vertices[ i ] );

					}

				} else if ( useFaces === true ) {

					geometry = object.geometry;
					faces = geometry.faces;

					for ( i = 0, l = faces.length; i < l; i ++ ) {

						this.addObjectData( object, faces[ i ] );

					}

				} else {

					this.addObjectData( object );

				}

			}

		},

		addObjectData: function ( object, part ) {

			var objectData = new fm.OctreeObjectData( object, part );

			// add to tree objects data list

			this.objectsData.push( objectData );

			// add to nodes

			this.root.addObject( objectData );

		},

		remove: function ( object ) {

			var i, l,
				objectData = object,
				index,
				objectsDataRemoved;

			// ensure object is not object data for index search

			if ( object instanceof fm.OctreeObjectData ) {

				object = object.object;

			}

			// check uuid

			if ( this.objectsMap[ object.uuid ] ) {

				this.objectsMap[ object.uuid ] = undefined;

				// check and remove from objects, nodes, and data lists

				index = indexOfValue( this.objects, object );

				if ( index !== - 1 ) {

					this.objects.splice( index, 1 );

					// remove from nodes

					objectsDataRemoved = this.root.removeObject( objectData );

					// remove from objects data list

					for ( i = 0, l = objectsDataRemoved.length; i < l; i ++ ) {

						objectData = objectsDataRemoved[ i ];

						index = indexOfValue( this.objectsData, objectData );

						if ( index !== - 1 ) {

							this.objectsData.splice( index, 1 );

						}

					}

				}

			} else if ( this.objectsDeferred.length > 0 ) {

				// check and remove from deferred

				index = indexOfPropertyWithValue( this.objectsDeferred, 'object', object );

				if ( index !== - 1 ) {

					this.objectsDeferred.splice( index, 1 );

				}

			}

		},

		extend: function ( octree ) {

			var i, l,
				objectsData,
				objectData;

			if ( octree instanceof fm.Octree ) {

				// for each object data

				objectsData = octree.objectsData;

				for ( i = 0, l = objectsData.length; i < l; i ++ ) {

					objectData = objectsData[ i ];

					this.add( objectData, { useFaces: objectData.faces, useVertices: objectData.vertices } );

				}

			}

		},

		rebuild: function () {

			var i, l,
				node,
				object,
				objectData,
				indexOctant,
				indexOctantLast,
				objectsUpdate = [];

			// check all object data for changes in position
			// assumes all object matrices are up to date

			for ( i = 0, l = this.objectsData.length; i < l; i ++ ) {

				objectData = this.objectsData[ i ];

				node = objectData.node;

				// update object

				objectData.update();

				// if position has changed since last organization of object in tree

				if ( node instanceof fm.OctreeNode && ! objectData.positionLast.equals( objectData.position ) ) {

					// get octant index of object within current node

					indexOctantLast = objectData.indexOctant;

					indexOctant = node.getOctantIndex( objectData );

					// if object octant index has changed

					if ( indexOctant !== indexOctantLast ) {

						// add to update list

						objectsUpdate.push( objectData );

					}

				}

			}

			// update changed objects

			for ( i = 0, l = objectsUpdate.length; i < l; i ++ ) {

				objectData = objectsUpdate[ i ];

				// remove object from current node

				objectData.node.removeObject( objectData );

				// add object to tree root

				this.root.addObject( objectData );

			}

		},

		updateObject: function ( object ) {

			var i, l,
				parentCascade = [ object ],
				parent,
				parentUpdate;

			// search all parents between object and root for world matrix update

			parent = object.parent;

			while ( parent ) {

				parentCascade.push( parent );
				parent = parent.parent;

			}

			for ( i = 0, l = parentCascade.length; i < l; i ++ ) {

				parent = parentCascade[ i ];

				if ( parent.matrixWorldNeedsUpdate === true ) {

					parentUpdate = parent;

				}

			}

			// update world matrix starting at uppermost parent that needs update

			if ( typeof parentUpdate !== 'undefined' ) {

				parentUpdate.updateMatrixWorld();

			}

		},

		// travelVisible:function (cameraPos) {
		// 	var objects = [].concat( this.root.objects );
		// 	for ( i = 0, l = objects.length; i < l; i ++ ) {
		// 		var objectData = objects[i];
		// 		var object = objectData.object;
		// 		var d = objectData.position.distance(cameraPos) - objectData.radius;
		// 		if(d>20.0){object.visible = false; continue;}
		// 	}
		// 		for ( i = 0, l = this.root.nodesIndices.length; i < l; i ++ ) {
        //
		// 		var node = this.root.nodesByIndex[ this.root.nodesIndices[ i ] ];
        //
		// 		objects = node.search( position, radius, objects, direction, directionPct );
        //
		// 	}
		// },
		search: function ( position, radius, organizeByObject, direction ) {

			var i, l,
				node,
				objects,
				objectData,
				object,
				results,
				resultData,
				resultsObjectsIndices,
				resultObjectIndex,
				directionPct;

			// add root objects

			objects = [].concat( this.root.objects );

			// ensure radius (i.e. distance of ray) is a number

			if ( ! ( radius > 0 ) ) {

				radius = Number.MAX_VALUE;

			}

			// if direction passed, normalize and find pct

			if ( direction instanceof fm.Vector3 ) {

				direction = this.utilVec31Search.copy( direction ).normalize();
				directionPct = this.utilVec32Search.set( 1, 1, 1 ).divide( direction );

			}

			// search each node of root

			for ( i = 0, l = this.root.nodesIndices.length; i < l; i ++ ) {

				node = this.root.nodesByIndex[ this.root.nodesIndices[ i ] ];

				objects = node.search( position, radius, objects, direction, directionPct );

			}

			// if should organize results by object

			if ( organizeByObject === true ) {

				results = [];
				resultsObjectsIndices = [];

				// for each object data found

				for ( i = 0, l = objects.length; i < l; i ++ ) {

					objectData = objects[ i ];
					object = objectData.object;

					resultObjectIndex = indexOfValue( resultsObjectsIndices, object );

					// if needed, create new result data

					if ( resultObjectIndex === - 1 ) {

						resultData = {
							object: object,
							faces: [],
							vertices: []
						};

						results.push( resultData );

						resultsObjectsIndices.push( object );

					} else {

						resultData = results[ resultObjectIndex ];

					}

					// object data has faces or vertices, add to list

					if ( objectData.faces ) {

						resultData.faces.push( objectData.faces );

					} else if ( objectData.vertices ) {

						resultData.vertices.push( objectData.vertices );

					}

				}

			} else {

				results = objects;

			}

			return results;

		},

		setRoot: function ( root ) {

			if ( root instanceof fm.OctreeNode ) {

				// store new root

				this.root = root;

				// update properties

				this.root.updateProperties();

			}

		},

		getDepthEnd: function () {

			return this.root.getDepthEnd();

		},

		getNodeCountEnd: function () {

			return this.root.getNodeCountEnd();

		},

		getObjectCountEnd: function () {

			return this.root.getObjectCountEnd();

		},

		toConsole: function () {

			this.root.toConsole();

		}

	};

	/*===================================================

	object data

	=====================================================*/

	fm.OctreeObjectData = function ( object, part ) {

		// properties

		this.object = object;

		// handle part by type

		if ( part instanceof fm.Face3 ) {

			this.faces = part;
			this.face3 = true;
			this.utilVec31FaceBounds = new fm.Vector3();

		} else if ( part instanceof fm.Vector3 ) {

			this.vertices = part;

		}

		this.radius = 0;
		this.position = new fm.Vector3();

		// initial update

		if ( this.object instanceof fm.Object3D ) {

			this.update();

		}

		this.positionLast = this.position.clone();

	};

	fm.OctreeObjectData.prototype = {

		update: function () {

			if ( this.face3 ) {

				this.radius = this.getFace3BoundingRadius( this.object, this.faces );
				this.position.copy( this.faces.centroid ).applyMatrix4( this.object.matrixWorld );

			} else if ( this.vertices ) {

				this.radius = this.object.material.size || 1;
				this.position.copy( this.vertices ).applyMatrix4( this.object.matrixWorld );

			} else {
                //jimguo add beg
                var geometry = this.object.geometry;
                if(this.object instanceof fm.LOD){
                    var lvmesh = this.object.levels[0].object;
                    geometry = lvmesh.geometry;
                }
                //jimguo add end
				if ( geometry ) {

					if ( geometry.boundingSphere === null ) {

						geometry.computeBoundingSphere();

					}

					this.radius = geometry.boundingSphere.radius;
					this.position.copy( geometry.boundingSphere.center ).applyMatrix4( this.object.matrixWorld );

				} else {

					this.radius = this.object.boundRadius;
					this.position.setFromMatrixPosition( this.object.matrixWorld );

				}

			}

			this.radius = this.radius * Math.max( this.object.scale.x, this.object.scale.y, this.object.scale.z );

		},

		getFace3BoundingRadius: function ( object, face ) {

			if ( face.centroid === undefined ) face.centroid = new fm.Vector3();

			var geometry = object.geometry || object,
				vertices = geometry.vertices,
				centroid = face.centroid,
				va = vertices[ face.a ], vb = vertices[ face.b ], vc = vertices[ face.c ],
				centroidToVert = this.utilVec31FaceBounds,
				radius;

			centroid.addVectors( va, vb ).add( vc ).divideScalar( 3 );
			radius = Math.max( centroidToVert.subVectors( centroid, va ).length(), centroidToVert.subVectors( centroid, vb ).length(), centroidToVert.subVectors( centroid, vc ).length() );

			return radius;

		}

	};

	/*===================================================

	node

	=====================================================*/

	fm.OctreeNode = function ( parameters ) {

		// utility

		this.utilVec31Branch = new fm.Vector3();
		this.utilVec31Expand = new fm.Vector3();
		this.utilVec31Ray = new fm.Vector3();

		// handle parameters

		parameters = parameters || {};

		// store or create tree

		if ( parameters.tree instanceof fm.Octree ) {

			this.tree = parameters.tree;

		} else if ( parameters.parent instanceof fm.OctreeNode !== true ) {

			parameters.root = this;

			this.tree = new fm.Octree( parameters );

		}

		// basic properties

		this.id = this.tree.nodeCount ++;
		this.position = parameters.position instanceof fm.Vector3 ? parameters.position : new fm.Vector3();
		this.radius = parameters.radius > 0 ? parameters.radius : 1;
		this.indexOctant = parameters.indexOctant;
		this.depth = 0;

		// reset and assign parent

		this.reset();
		this.setParent( parameters.parent );

		// additional properties

		this.overlap = this.radius * this.tree.overlapPct;
		this.radiusOverlap = this.radius + this.overlap;
		this.left = this.position.x - this.radiusOverlap;
		this.right = this.position.x + this.radiusOverlap;
		this.bottom = this.position.y - this.radiusOverlap;
		this.top = this.position.y + this.radiusOverlap;
		this.back = this.position.z - this.radiusOverlap;
		this.front = this.position.z + this.radiusOverlap;

		// visual

		if ( this.tree.scene ) {

			this.visual = new fm.LineSegments( this.tree.visualGeometry, this.tree.visualMaterial );
			this.visual.scale.set( this.radiusOverlap * 2, this.radiusOverlap * 2, this.radiusOverlap * 2 );
			this.visual.position.copy( this.position );
			this.tree.scene.add( this.visual );

		}

	};

	fm.OctreeNode.prototype = {

		setParent: function ( parent ) {

			// store new parent

			if ( parent !== this && this.parent !== parent ) {

				this.parent = parent;

				// update properties

				this.updateProperties();

			}

		},

		updateProperties: function () {

			var i, l;

			// properties

			if ( this.parent instanceof fm.OctreeNode ) {

				this.tree = this.parent.tree;
				this.depth = this.parent.depth + 1;

			} else {

				this.depth = 0;

			}

			// cascade

			for ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {

				this.nodesByIndex[ this.nodesIndices[ i ] ].updateProperties();

			}

		},

		reset: function ( cascade, removeVisual ) {

			var i, l,
				node,
				nodesIndices = this.nodesIndices || [],
				nodesByIndex = this.nodesByIndex;

			this.objects = [];
			this.nodesIndices = [];
			this.nodesByIndex = {};

			// unset parent in nodes

			for ( i = 0, l = nodesIndices.length; i < l; i ++ ) {

				node = nodesByIndex[ nodesIndices[ i ] ];

				node.setParent( undefined );

				if ( cascade === true ) {

					node.reset( cascade, removeVisual );

				}

			}

			// visual

			if ( removeVisual === true && this.visual && this.visual.parent ) {

				this.visual.parent.remove( this.visual );

			}

		},

		addNode: function ( node, indexOctant ) {

			node.indexOctant = indexOctant;

			if ( indexOfValue( this.nodesIndices, indexOctant ) === - 1 ) {

				this.nodesIndices.push( indexOctant );

			}

			this.nodesByIndex[ indexOctant ] = node;

			if ( node.parent !== this ) {

				node.setParent( this );

			}

		},

		removeNode: function ( indexOctant ) {

			var index,
				node;

			index = indexOfValue( this.nodesIndices, indexOctant );

			this.nodesIndices.splice( index, 1 );

			node = node || this.nodesByIndex[ indexOctant ];

			delete this.nodesByIndex[ indexOctant ];

			if ( node.parent === this ) {

				node.setParent( undefined );

			}

		},

		addObject: function ( object ) {

			var index,
				indexOctant,
				node;

			// get object octant index

			indexOctant = this.getOctantIndex( object );

			// if object fully contained by an octant, add to subtree
			if ( indexOctant > - 1 && this.nodesIndices.length > 0 ) {

				node = this.branch( indexOctant );

				node.addObject( object );

			} else if ( indexOctant < - 1 && this.parent instanceof fm.OctreeNode ) {

				// if object lies outside bounds, add to parent node

				this.parent.addObject( object );

			} else {

				// add to this objects list

				index = indexOfValue( this.objects, object );

				if ( index === - 1 ) {

					this.objects.push( object );

				}

				// node reference

				object.node = this;

				// check if need to expand, split, or both

				this.checkGrow();

			}

		},

		addObjectWithoutCheck: function ( objects ) {

			var i, l,
				object;

			for ( i = 0, l = objects.length; i < l; i ++ ) {

				object = objects[ i ];

				this.objects.push( object );

				object.node = this;

			}

		},

		removeObject: function ( object ) {

			var i, l,
				nodesRemovedFrom,
				removeData;

			// cascade through tree to find and remove object

			removeData = this.removeObjectRecursive( object, { searchComplete: false, nodesRemovedFrom: [], objectsDataRemoved: [] } );

			// if object removed, try to shrink the nodes it was removed from

			nodesRemovedFrom = removeData.nodesRemovedFrom;

			if ( nodesRemovedFrom.length > 0 ) {

				for ( i = 0, l = nodesRemovedFrom.length; i < l; i ++ ) {

					nodesRemovedFrom[ i ].shrink();

				}

			}

			return removeData.objectsDataRemoved;

		},

		removeObjectRecursive: function ( object, removeData ) {

			var i, l,
				index = - 1,
				objectData,
				node,
				objectRemoved;

			// find index of object in objects list

			// search and remove object data (fast)
			if ( object instanceof fm.OctreeObjectData ) {

				// remove from this objects list

				index = indexOfValue( this.objects, object );

				if ( index !== - 1 ) {

					this.objects.splice( index, 1 );
					object.node = undefined;

					removeData.objectsDataRemoved.push( object );

					removeData.searchComplete = objectRemoved = true;

				}

			} else {

				// search each object data for object and remove (slow)

				for ( i = this.objects.length - 1; i >= 0; i -- ) {

					objectData = this.objects[ i ];

					if ( objectData.object === object ) {

						this.objects.splice( i, 1 );
						objectData.node = undefined;

						removeData.objectsDataRemoved.push( objectData );

						objectRemoved = true;

						if ( ! objectData.faces && ! objectData.vertices ) {

							removeData.searchComplete = true;
							break;

						}

					}

				}

			}

			// if object data removed and this is not on nodes removed from

			if ( objectRemoved === true ) {

				removeData.nodesRemovedFrom.push( this );

			}

			// if search not complete, search nodes

			if ( removeData.searchComplete !== true ) {

				for ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {

					node = this.nodesByIndex[ this.nodesIndices[ i ] ];

					// try removing object from node

					removeData = node.removeObjectRecursive( object, removeData );

					if ( removeData.searchComplete === true ) {

						break;

					}

				}

			}

			return removeData;

		},

		checkGrow: function () {

			// if object count above max

			if ( this.objects.length > this.tree.objectsThreshold && this.tree.objectsThreshold > 0 ) {

				this.grow();

			}

		},

		grow: function () {

			var indexOctant,
				object,
				objectsExpand = [],
				objectsExpandOctants = [],
				objectsSplit = [],
				objectsSplitOctants = [],
				objectsRemaining = [],
				i, l;

			// for each object

			for ( i = 0, l = this.objects.length; i < l; i ++ ) {

				object = this.objects[ i ];

				// get object octant index

				indexOctant = this.getOctantIndex( object );

				// if lies within octant
				if ( indexOctant > - 1 ) {

					objectsSplit.push( object );
					objectsSplitOctants.push( indexOctant );

				} else if ( indexOctant < - 1 ) {

					// lies outside radius

					objectsExpand.push( object );
					objectsExpandOctants.push( indexOctant );

				} else {

					// lies across bounds between octants

					objectsRemaining.push( object );

				}

			}

			// if has objects to split

			if ( objectsSplit.length > 0 ) {

				objectsRemaining = objectsRemaining.concat( this.split( objectsSplit, objectsSplitOctants ) );

			}

			// if has objects to expand

			if ( objectsExpand.length > 0 ) {

				objectsRemaining = objectsRemaining.concat( this.expand( objectsExpand, objectsExpandOctants ) );

			}

			// store remaining

			this.objects = objectsRemaining;

			// merge check

			this.checkMerge();

		},

		split: function ( objects, octants ) {

			var i, l,
				indexOctant,
				object,
				node,
				objectsRemaining;

			// if not at max depth

			if ( this.depth < this.tree.depthMax ) {

				objects = objects || this.objects;

				octants = octants || [];

				objectsRemaining = [];

				// for each object

				for ( i = 0, l = objects.length; i < l; i ++ ) {

					object = objects[ i ];

					// get object octant index

					indexOctant = octants[ i ];

					// if object contained by octant, branch this tree

					if ( indexOctant > - 1 ) {

						node = this.branch( indexOctant );

						node.addObject( object );

					} else {

						objectsRemaining.push( object );

					}

				}

				// if all objects, set remaining as new objects

				if ( objects === this.objects ) {

					this.objects = objectsRemaining;

				}

			} else {

				objectsRemaining = this.objects;

			}

			return objectsRemaining;

		},

		branch: function ( indexOctant ) {

			var node,
				overlap,
				radius,
				radiusOffset,
				offset,
				position;

			// node exists

			if ( this.nodesByIndex[ indexOctant ] instanceof fm.OctreeNode ) {

				node = this.nodesByIndex[ indexOctant ];

			} else {

				// properties

				radius = ( this.radiusOverlap ) * 0.5;
				overlap = radius * this.tree.overlapPct;
				radiusOffset = radius - overlap;
				offset = this.utilVec31Branch.set( indexOctant & 1 ? radiusOffset : - radiusOffset, indexOctant & 2 ? radiusOffset : - radiusOffset, indexOctant & 4 ? radiusOffset : - radiusOffset );
				position = new fm.Vector3().addVectors( this.position, offset );

				// node

				node = new fm.OctreeNode( {
					tree: this.tree,
					parent: this,
					position: position,
					radius: radius,
					indexOctant: indexOctant
				} );

				// store

				this.addNode( node, indexOctant );

			}

			return node;

		},

		expand: function ( objects, octants ) {

			var i, l,
				object,
				objectsRemaining,
				objectsExpand,
				indexOctant,
				flagsOutside,
				indexOutside,
				indexOctantInverse,
				iom = this.tree.INDEX_OUTSIDE_MAP,
				indexOutsideCounts,
				infoIndexOutside1,
				infoIndexOutside2,
				infoIndexOutside3,
				indexOutsideBitwise1,
				indexOutsideBitwise2,
				infoPotential1,
				infoPotential2,
				infoPotential3,
				indexPotentialBitwise1,
				indexPotentialBitwise2,
				octantX, octantY, octantZ,
				overlap,
				radius,
				radiusOffset,
				radiusParent,
				overlapParent,
				offset = this.utilVec31Expand,
				position,
				parent;

			// handle max depth down tree

			if ( this.tree.root.getDepthEnd() < this.tree.depthMax ) {

				objects = objects || this.objects;
				octants = octants || [];

				objectsRemaining = [];
				objectsExpand = [];

				// reset counts

				for ( i = 0, l = iom.length; i < l; i ++ ) {

					iom[ i ].count = 0;

				}

				// for all outside objects, find outside octants containing most objects

				for ( i = 0, l = objects.length; i < l; i ++ ) {

					object = objects[ i ];

					// get object octant index

					indexOctant = octants[ i ];

					// if object outside this, include in calculations

					if ( indexOctant < - 1 ) {

						// convert octant index to outside flags

						flagsOutside = - indexOctant - this.tree.INDEX_OUTSIDE_OFFSET;

						// check against bitwise flags

						// x

						if ( flagsOutside & this.tree.FLAG_POS_X ) {

							iom[ this.tree.INDEX_OUTSIDE_POS_X ].count ++;

						} else if ( flagsOutside & this.tree.FLAG_NEG_X ) {

							iom[ this.tree.INDEX_OUTSIDE_NEG_X ].count ++;

						}

						// y

						if ( flagsOutside & this.tree.FLAG_POS_Y ) {

							iom[ this.tree.INDEX_OUTSIDE_POS_Y ].count ++;

						} else if ( flagsOutside & this.tree.FLAG_NEG_Y ) {

							iom[ this.tree.INDEX_OUTSIDE_NEG_Y ].count ++;

						}

						// z

						if ( flagsOutside & this.tree.FLAG_POS_Z ) {

							iom[ this.tree.INDEX_OUTSIDE_POS_Z ].count ++;

						} else if ( flagsOutside & this.tree.FLAG_NEG_Z ) {

							iom[ this.tree.INDEX_OUTSIDE_NEG_Z ].count ++;

						}

						// store in expand list

						objectsExpand.push( object );

					} else {

						objectsRemaining.push( object );

					}

				}

				// if objects to expand

				if ( objectsExpand.length > 0 ) {

					// shallow copy index outside map

					indexOutsideCounts = iom.slice( 0 );

					// sort outside index count so highest is first

					indexOutsideCounts.sort( function ( a, b ) {

						return b.count - a.count;

					} );

					// get highest outside indices

					// first is first
					infoIndexOutside1 = indexOutsideCounts[ 0 ];
					indexOutsideBitwise1 = infoIndexOutside1.index | 1;

					// second is ( one of next two bitwise OR 1 ) that is not opposite of ( first bitwise OR 1 )

					infoPotential1 = indexOutsideCounts[ 1 ];
					infoPotential2 = indexOutsideCounts[ 2 ];

					infoIndexOutside2 = ( infoPotential1.index | 1 ) !== indexOutsideBitwise1 ? infoPotential1 : infoPotential2;
					indexOutsideBitwise2 = infoIndexOutside2.index | 1;

					// third is ( one of next three bitwise OR 1 ) that is not opposite of ( first or second bitwise OR 1 )

					infoPotential1 = indexOutsideCounts[ 2 ];
					infoPotential2 = indexOutsideCounts[ 3 ];
					infoPotential3 = indexOutsideCounts[ 4 ];

					indexPotentialBitwise1 = infoPotential1.index | 1;
					indexPotentialBitwise2 = infoPotential2.index | 1;

					infoIndexOutside3 = indexPotentialBitwise1 !== indexOutsideBitwise1 && indexPotentialBitwise1 !== indexOutsideBitwise2 ? infoPotential1 : indexPotentialBitwise2 !== indexOutsideBitwise1 && indexPotentialBitwise2 !== indexOutsideBitwise2 ? infoPotential2 : infoPotential3;

					// get this octant normal based on outside octant indices

					octantX = infoIndexOutside1.x + infoIndexOutside2.x + infoIndexOutside3.x;
					octantY = infoIndexOutside1.y + infoIndexOutside2.y + infoIndexOutside3.y;
					octantZ = infoIndexOutside1.z + infoIndexOutside2.z + infoIndexOutside3.z;

					// get this octant indices based on octant normal

					indexOctant = this.getOctantIndexFromPosition( octantX, octantY, octantZ );
					indexOctantInverse = this.getOctantIndexFromPosition( - octantX, - octantY, - octantZ );

					// properties

					overlap = this.overlap;
					radius = this.radius;

					// radius of parent comes from reversing overlap of this, unless overlap percent is 0

					radiusParent = this.tree.overlapPct > 0 ? overlap / ( ( 0.5 * this.tree.overlapPct ) * ( 1 + this.tree.overlapPct ) ) : radius * 2;
					overlapParent = radiusParent * this.tree.overlapPct;

					// parent offset is difference between radius + overlap of parent and child

					radiusOffset = ( radiusParent + overlapParent ) - ( radius + overlap );
					offset.set( indexOctant & 1 ? radiusOffset : - radiusOffset, indexOctant & 2 ? radiusOffset : - radiusOffset, indexOctant & 4 ? radiusOffset : - radiusOffset );
					position = new fm.Vector3().addVectors( this.position, offset );

					// parent

					parent = new fm.OctreeNode( {
						tree: this.tree,
						position: position,
						radius: radiusParent
					} );

					// set self as node of parent

					parent.addNode( this, indexOctantInverse );

					// set parent as root

					this.tree.setRoot( parent );

					// add all expand objects to parent

					for ( i = 0, l = objectsExpand.length; i < l; i ++ ) {

						this.tree.root.addObject( objectsExpand[ i ] );

					}

				}

				// if all objects, set remaining as new objects

				if ( objects === this.objects ) {

					this.objects = objectsRemaining;

				}

			} else {

				objectsRemaining = objects;

			}

			return objectsRemaining;

		},

		shrink: function () {

			// merge check

			this.checkMerge();

			// contract check

			this.tree.root.checkContract();

		},

		checkMerge: function () {

			var nodeParent = this,
				nodeMerge;

			// traverse up tree as long as node + entire subtree's object count is under minimum

			while ( nodeParent.parent instanceof fm.OctreeNode && nodeParent.getObjectCountEnd() < this.tree.objectsThreshold ) {

				nodeMerge = nodeParent;
				nodeParent = nodeParent.parent;

			}

			// if parent node is not this, merge entire subtree into merge node

			if ( nodeParent !== this ) {

				nodeParent.merge( nodeMerge );

			}

		},

		merge: function ( nodes ) {

			var i, l,
				j, k,
				node;

			// handle nodes

			nodes = toArray( nodes );

			for ( i = 0, l = nodes.length; i < l; i ++ ) {

				node = nodes[ i ];

				// gather node + all subtree objects

				this.addObjectWithoutCheck( node.getObjectsEnd() );

				// reset node + entire subtree

				node.reset( true, true );

				// remove node

				this.removeNode( node.indexOctant, node );

			}

			// merge check

			this.checkMerge();

		},

		checkContract: function () {

			var i, l,
				node,
				nodeObjectsCount,
				nodeHeaviest,
				nodeHeaviestObjectsCount,
				outsideHeaviestObjectsCount;

			// find node with highest object count

			if ( this.nodesIndices.length > 0 ) {

				nodeHeaviestObjectsCount = 0;
				outsideHeaviestObjectsCount = this.objects.length;

				for ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {

					node = this.nodesByIndex[ this.nodesIndices[ i ] ];

					nodeObjectsCount = node.getObjectCountEnd();
					outsideHeaviestObjectsCount += nodeObjectsCount;

					if ( nodeHeaviest instanceof fm.OctreeNode === false || nodeObjectsCount > nodeHeaviestObjectsCount ) {

						nodeHeaviest = node;
						nodeHeaviestObjectsCount = nodeObjectsCount;

					}

				}

				// subtract heaviest count from outside count

				outsideHeaviestObjectsCount -= nodeHeaviestObjectsCount;

				// if should contract

				if ( outsideHeaviestObjectsCount < this.tree.objectsThreshold && nodeHeaviest instanceof fm.OctreeNode ) {

					this.contract( nodeHeaviest );

				}

			}

		},

		contract: function ( nodeRoot ) {

			var i, l,
				node;

			// handle all nodes

			for ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {

				node = this.nodesByIndex[ this.nodesIndices[ i ] ];

				// if node is not new root

				if ( node !== nodeRoot ) {

					// add node + all subtree objects to root

					nodeRoot.addObjectWithoutCheck( node.getObjectsEnd() );

					// reset node + entire subtree

					node.reset( true, true );

				}

			}

			// add own objects to root

			nodeRoot.addObjectWithoutCheck( this.objects );

			// reset self

			this.reset( false, true );

			// set new root

			this.tree.setRoot( nodeRoot );

			// contract check on new root

			nodeRoot.checkContract();

		},

		getOctantIndex: function ( objectData ) {

			var i, l,
				positionObj,
				radiusObj,
				position = this.position,
				radiusOverlap = this.radiusOverlap,
				overlap = this.overlap,
				deltaX, deltaY, deltaZ,
				distX, distY, distZ,
				distance,
				indexOctant = 0;

			// handle type

			if ( objectData instanceof fm.OctreeObjectData ) {

				radiusObj = objectData.radius;

				positionObj = objectData.position;

				// update object data position last

				objectData.positionLast.copy( positionObj );

			} else if ( objectData instanceof fm.OctreeNode ) {

				positionObj = objectData.position;

				radiusObj = 0;

			}

			// find delta and distance

			deltaX = positionObj.x - position.x;
			deltaY = positionObj.y - position.y;
			deltaZ = positionObj.z - position.z;

			distX = Math.abs( deltaX );
			distY = Math.abs( deltaY );
			distZ = Math.abs( deltaZ );
			distance = Math.max( distX, distY, distZ );

			// if outside, use bitwise flags to indicate on which sides object is outside of

			if ( distance + radiusObj > radiusOverlap ) {

				// x

				if ( distX + radiusObj > radiusOverlap ) {

					indexOctant = indexOctant ^ ( deltaX > 0 ? this.tree.FLAG_POS_X : this.tree.FLAG_NEG_X );

				}

				// y

				if ( distY + radiusObj > radiusOverlap ) {

					indexOctant = indexOctant ^ ( deltaY > 0 ? this.tree.FLAG_POS_Y : this.tree.FLAG_NEG_Y );

				}

				// z

				if ( distZ + radiusObj > radiusOverlap ) {

					indexOctant = indexOctant ^ ( deltaZ > 0 ? this.tree.FLAG_POS_Z : this.tree.FLAG_NEG_Z );

				}

				objectData.indexOctant = - indexOctant - this.tree.INDEX_OUTSIDE_OFFSET;

				return objectData.indexOctant;

			}

			// return octant index from delta xyz

			if ( deltaX - radiusObj > - overlap ) {

				// x right

				indexOctant = indexOctant | 1;

			} else if ( ! ( deltaX + radiusObj < overlap ) ) {

				// x left

				objectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;
				return objectData.indexOctant;

			}

			if ( deltaY - radiusObj > - overlap ) {

				// y right

				indexOctant = indexOctant | 2;

			} else if ( ! ( deltaY + radiusObj < overlap ) ) {

				// y left

				objectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;
				return objectData.indexOctant;

			}


			if ( deltaZ - radiusObj > - overlap ) {

				// z right

				indexOctant = indexOctant | 4;

			} else if ( ! ( deltaZ + radiusObj < overlap ) ) {

				// z left

				objectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;
				return objectData.indexOctant;

			}

			objectData.indexOctant = indexOctant;
			return objectData.indexOctant;

		},

		getOctantIndexFromPosition: function ( x, y, z ) {

			var indexOctant = 0;

			if ( x > 0 ) {

				indexOctant = indexOctant | 1;

			}

			if ( y > 0 ) {

				indexOctant = indexOctant | 2;

			}

			if ( z > 0 ) {

				indexOctant = indexOctant | 4;

			}

			return indexOctant;

		},

		search: function ( position, radius, objects, direction, directionPct ) {

			var i, l,
				node,
				intersects;

			// test intersects by parameters

			if ( direction ) {

				intersects = this.intersectRay( position, direction, radius, directionPct );

			} else {

				intersects = this.intersectSphere( position, radius );

			}

			// if intersects

			if ( intersects === true ) {

				// gather objects

				objects = objects.concat( this.objects );

				// search subtree

				for ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {

					node = this.nodesByIndex[ this.nodesIndices[ i ] ];

					objects = node.search( position, radius, objects, direction );

				}

			}

			return objects;

		},

		intersectSphere: function ( position, radius ) {

			var	distance = radius * radius,
				px = position.x,
				py = position.y,
				pz = position.z;

			if ( px < this.left ) {

				distance -= Math.pow( px - this.left, 2 );

			} else if ( px > this.right ) {

				distance -= Math.pow( px - this.right, 2 );

			}

			if ( py < this.bottom ) {

				distance -= Math.pow( py - this.bottom, 2 );

			} else if ( py > this.top ) {

				distance -= Math.pow( py - this.top, 2 );

			}

			if ( pz < this.back ) {

				distance -= Math.pow( pz - this.back, 2 );

			} else if ( pz > this.front ) {

				distance -= Math.pow( pz - this.front, 2 );

			}

			return distance >= 0;

		},

		intersectRay: function ( origin, direction, distance, directionPct ) {

			if ( typeof directionPct === 'undefined' ) {

				directionPct = this.utilVec31Ray.set( 1, 1, 1 ).divide( direction );

			}

			var t1 = ( this.left - origin.x ) * directionPct.x,
				t2 = ( this.right - origin.x ) * directionPct.x,
				t3 = ( this.bottom - origin.y ) * directionPct.y,
				t4 = ( this.top - origin.y ) * directionPct.y,
				t5 = ( this.back - origin.z ) * directionPct.z,
				t6 = ( this.front - origin.z ) * directionPct.z,
				tmax = Math.min( Math.min( Math.max( t1, t2 ), Math.max( t3, t4 ) ), Math.max( t5, t6 ) ),
				tmin;

			// ray would intersect in reverse direction, i.e. this is behind ray
			if ( tmax < 0 ) {

				return false;

			}

			tmin = Math.max( Math.max( Math.min( t1, t2 ), Math.min( t3, t4 ) ), Math.min( t5, t6 ) );

			// if tmin > tmax or tmin > ray distance, ray doesn't intersect AABB
			if ( tmin > tmax || tmin > distance ) {

				return false;

			}

			return true;

		},

		getDepthEnd: function ( depth ) {

			var i, l,
				node;

			if ( this.nodesIndices.length > 0 ) {

				for ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {

					node = this.nodesByIndex[ this.nodesIndices[ i ] ];

					depth = node.getDepthEnd( depth );

				}

			} else {

				depth = ! depth || this.depth > depth ? this.depth : depth;

			}

			return depth;

		},

		getNodeCountEnd: function () {

			return this.tree.root.getNodeCountRecursive() + 1;

		},

		getNodeCountRecursive: function () {

			var i, l,
				count = this.nodesIndices.length;

			for ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {

				count += this.nodesByIndex[ this.nodesIndices[ i ] ].getNodeCountRecursive();

			}

			return count;

		},

		getObjectsEnd: function ( objects ) {

			var i, l,
				node;

			objects = ( objects || [] ).concat( this.objects );

			for ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {

				node = this.nodesByIndex[ this.nodesIndices[ i ] ];

				objects = node.getObjectsEnd( objects );

			}

			return objects;

		},

		getObjectCountEnd: function () {

			var i, l,
				count = this.objects.length;

			for ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {

				count += this.nodesByIndex[ this.nodesIndices[ i ] ].getObjectCountEnd();

			}

			return count;

		},

		getObjectCountStart: function () {

			var count = this.objects.length,
				parent = this.parent;

			while ( parent instanceof fm.OctreeNode ) {

				count += parent.objects.length;
				parent = parent.parent;

			}

			return count;

		},

		toConsole: function ( space ) {

			var i, l,
				node,
				spaceAddition = '   ';

			space = typeof space === 'string' ? space : spaceAddition;

			console.log( ( this.parent ? space + ' octree NODE > ' : ' octree ROOT > ' ), this, ' // id: ', this.id, ' // indexOctant: ', this.indexOctant, ' // position: ', this.position.x, this.position.y, this.position.z, ' // radius: ', this.radius, ' // depth: ', this.depth );
			console.log( ( this.parent ? space + ' ' : ' ' ), '+ objects ( ', this.objects.length, ' ) ', this.objects );
			console.log( ( this.parent ? space + ' ' : ' ' ), '+ children ( ', this.nodesIndices.length, ' )', this.nodesIndices, this.nodesByIndex );

			for ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {

				node = this.nodesByIndex[ this.nodesIndices[ i ] ];

				node.toConsole( space + spaceAddition );

			}

		}

	};

	/*===================================================

	raycaster additional functionality

	=====================================================*/

	fm.Raycaster.prototype.intersectOctreeObject = function ( object, recursive ) {

		var intersects,
			octreeObject,
			facesAll,
			facesSearch;

		if ( object.object instanceof fm.Object3D ) {

			octreeObject = object;
			object = octreeObject.object;

			// temporarily replace object geometry's faces with octree object faces

			facesSearch = octreeObject.faces;
			facesAll = object.geometry.faces;

			if ( facesSearch.length > 0 ) {

				object.geometry.faces = facesSearch;

			}

			// intersect

			intersects = this.intersectObject( object, recursive );

			// revert object geometry's faces

			if ( facesSearch.length > 0 ) {

				object.geometry.faces = facesAll;

			}

		} else {

			intersects = this.intersectObject( object, recursive );

		}

		return intersects;

	};

	fm.Raycaster.prototype.intersectOctreeObjects = function ( objects, recursive ) {

		var i, il,
			intersects = [];

		for ( i = 0, il = objects.length; i < il; i ++ ) {

			intersects = intersects.concat( this.intersectOctreeObject( objects[ i ], recursive ) );

		}

		return intersects;

	};

}( fm ) );

var ComTool = {
    REVISION: "10",
    VER_UP:"?v=20180722_25",
    LogOut:function (str) {
        console.debug(str);
    }
};

ComTool.Map = function() {
    this._arr = new Array();
};
ComTool.Map.struct = function(e, t) {
    this.key = e;
    this.value = t;
};
ComTool.Map.prototype.insert = function(e, t, r) {
    var i = this.find(e);
    var n = undefined !== r ? r : false;
    if (-1 !== i) {
        if (n) {
            var a = this._arr[i];
            a.value = t;
            return true;
        }
        return false;
    }
    this._arr[this._arr.length] = new ComTool.Map.struct(e, t);
    return true;
};
ComTool.Map.prototype.find = function(e) {
    var t = 0;
    var r = this._arr.length;
    for (; t < r; ++t) {
        var i = this._arr[t];
        if (i.key === e) {
            return t;
        }
    }
    return -1;
};
ComTool.Map.prototype.findEx = function(e) {
    var t = 0;
    var r = this._arr.length;
    for (; t < r; ++t) {
        var i = this._arr[t];
        if (i.key === e) {
            return i.value;
        }
    }
    return undefined;
};
ComTool.Map.prototype.earse = function(e) {
    var t = this.find(e);
    if (-1 !== t) {
        this._arr.splice(t, 1);
        return true;
    }
    return false;
};
ComTool.Map.prototype.size = function() {
    return this._arr.length;
};
ComTool.Map.prototype.isEmpty = function() {
    return this._arr.length < 1;
};
ComTool.Map.prototype.clear = function() {
    this._arr = new Array();
};


// stats.js - http://github.com/mrdoob/stats.js
var Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel("FPS","#0ff","#002")),f=h(new Stats.Panel("MS","#0f0","#020"));
if(self.performance&&self.performance.memory)var t=h(new Stats.Panel("MB","#f08","#201"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};
Stats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=f;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,
v){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+" "+h+" ("+e(c)+"-"+e(g)+")",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};"object"===typeof module&&(module.exports=Stats);

(function () {
	/**
	 * 组件管理类
	 */
	function FMComponentsManager(map) {

		this.map = map;
		// 组件集合
		this.components = [];

	}

	FMComponentsManager.prototype = {
		constructor: FMComponentsManager,

		_invokeFunction: function (fun, params) {
			this.components.forEach(function (com) {
				if (!com.enabled) {return;}

				if (com[fun]) {
					com[fun](params);
				}
			});
		},

		append: function (com) {
			this.components.push(com);

			if (com.object) {
				this.map.mapPicker.addComponent(com.object);
			}

			if (com.start) {com.start();}
		},

		remove: function (com) {
			for (var i = 0; i < this.components.length; i++) {
				if (this.components[i] == com) {
					this.components.splice(i, 1);
					return;
				}
			}
		},

		invokeUpdate: function (delta) {
			this._invokeFunction('update', delta);
		},
	};

	/**
	 * 组件类, 主要实现,加入FMComponentsManager及注销的方法
	 *
	 * Event:
	 * 		start
	 * 		update
	 * 		picked
	 */
	function FMComponent(manager, object) {
		if (!manager) {return;}

		this.manager = manager;
		this.enabled = true;

		this.object = object;
		if (this.object) {
			this.object.component = this;
		}

		// add to FMcomponent manager
		this.manager.append(this);
	}

	FMComponent.prototype = {
		constructor: FMComponent,

		// remove from manager
		dispose: function () {
			this.manager.remove(this);
			if (this.object) {
				this.manager.map.mapPicker.removeComponent(this.object);

				// remove from parent
				if (this.object.parent) {
					this.object.parent.remove(this.object);
				}
			}
		}
	};
	
	fengmap.FMComponentsManager = FMComponentsManager;
	fengmap.FMComponent = FMComponent;
})();




/**
 *	FMMap 是加载场景、显示模型、遍历模型等的主类，一个页面中必须且至少包含一个FMMap对象
 * 	@class FMMap
 *	@constructor
 * 	@module FMMap
 *   @namespace fengmap
 *   @param {fengmap.MapOptions} opts 地图配置对象
 *   @demo map/加载fengmap服务器上模型.js
 *   @demo map/加载本地文件夹中模型.js
 */

/**
 * 地图初始化配置项
 * @property options
 * @type {fengmap.MapOptions}
 */

/**
 * 楼层显示/隐藏事件
 * @event visibleGroupIDsChanged
 * @return {Arrray} 当前的可见层,如:[1,2,4]
 */

/**
 * 聚焦楼层改进事件
 * @event focusGroupIDChanged
 * @return {int} groupID
 */

/**
 * 比例尺级别改变事件
 * @event mapScaleLevelChanged
 * @return {Json} {mapScale: scale.mapScale, lastMapScale: scale.lastMapScale}
 */

fengmap.Map = function(options) {

    this.options = new fengmap.MapOptions(options);

    fm.Evento.convert(this);

    this.mapView = new fengmap.MapView(this);
    if (!this.mapView.init()) {
        return;
    }

    // controls
    this.controls = new fm.OrbitControls(this.mapView.camera, this.mapView.canvas_, this);

    // this.mapView.updateFrustum();

    this.controls.minPolarAngle = 0; // Polar 范围在0-60度之间
    this.controls.maxPolarAngle = Math.PI / 3;

    this.mapPicker = new fengmap.MapPicker();
    this.mapPickHighLight = true;

    this.mapTheme = new fengmap.MapTheme(this, this.options);

    this.mapScene = new fengmap.MapScene(this, this.mapTheme);
    this.mapService = new fengmap.MapService(this);

    // this.waterMarker_ = new fengmap.MapWaterMark(true, this.mapView.sceneOrtho, this.options);// 默认打开
    this.zonTempObj = new fengmap.MapService.fmbanana(true, this.mapView.sceneOrtho, this.options); // 默认打开
    this.compass_ = new fengmap.MapCompass(false, this.mapView.sceneOrtho, this.options);

    this.handleControlsChange = this.controlsChange_.bind(this);
    this.controls.addEventListener('change', this.handleControlsChange);

    this.viewMode_ = '3d';
    this.currentCamera_ = this.mapView.camera;
    this.fullSceen_ = false;

    this.requireUpdateCollide_ = false;

    this.location_ = {
        sceneId: 0,
        groupId: 0,
        x: 0,
        y: 0
    };

    this.focusGroupId_ = -1;

    this.groupCenter_;


    var this_ = this;

    this_.controls.addEventListener('start', function(e) {
        this_.emit('controlstart');
    });

    this_.controls.addEventListener('end', function() {
        this_.emit('controlend');
    });

    // set On loadComplete
    // this.controls.setValidRange_(this.validRange_.bind(this));

    //
    this.scaleLevels_ = [0.5, 1, 2]; // default
    this.scaleLevel_ = 1;

    // ztc 20180227 需要为这两个参数设置默认值，
    // 不然在配置中设置mapScaleRange会出现问题
    this._minMapScaleLevel = 16;
    this._maxMapScaleLevel = 23;

    // #20160520,Samuel,new APIsf
    this.groupIDs_ = [];

    // ztc 2016/06/21
    this.timer = new fm.Clock();
    this.timerImmediate = new fm.Clock();

    // 图集
    // this.mapAtlas = new fengmap.FMAtlas();

    // 记录可见层
    this.visibleGroupIDs_ = [];

    // set Tween global map property
    fm.Tween.map = this;

    // JSON file Loader
    this.loader = new fm.JSONModelLoader();

    // 模型选择的透明度
    this._selectModelAlpha = 1;

    // singleton
    if (!fengmap.Map.instance) {
        fengmap.Map.instance = this;

        /**
         * layer 的别名
         */
        fengmap.Map.layerAlias = {
            'extent': fengmap.FMExtentLayer,
            'model': fengmap.FMModelLayer,
            'label': fengmap.FMLabelLayer,
            'facility': fengmap.FMFacilityLayer,
            'line': fengmap.FMLineLayer,
            'locationMarker': fengmap.FMLocationMarkerLayer,
            'text': fengmap.FMTextLayer,
            'textMarker': fengmap.FMTextMarkerLayer,
            'polygonMarker': fengmap.FMPolygonMarker,
            'imageMarker': fengmap.FMImageMarkerLayer
        };
    }

    // 适配大小
    this.updateSize(null, null, true);

    // 输入模式
    this.inputMode = fengmap.FMInputMode.SELECT;

    // 得到比例尺相关数据
    this._getMapScaleInfo();

    // frameRate
    this.frameRate = this.options.frameRate;

    // 被动渲染模式
    this.passiveMode = this.options.passiveMode;

    // update once to set renderer size
    this.update_(true);
};

fengmap.Map.tempFlipX_ = true;

fengmap.Map.prototype = {

    openMap: function(sceneId, needCheck) {

        if (this._zopStep_ != 1) {
            return;
        }
        this._zopStep_++;

        //this.zonTempObj.visible = false;//去水印

        // 记录是否加载的是新场景
        this.__isNewScene = this.sceneId_ != sceneId;

        this.sceneId_ = sceneId;
        this.mapView.scene.remove(this.mapScene.getO3dScene());
        this.mapScene.clear();

        var this_ = this;
        // if(fengmap.Map.IsThemeLoading) return;
        // fengmap.Map.IsThemeLoading = true;
        this.prepare_(function() {
            // fengmap.Map.IsThemeLoading = false;
            // if(fengmap.Map.IsMapLoading) return;
            // fengmap.Map.IsMapLoading = true;

            this_.openMap_(sceneId, needCheck);
        });
    },

    queryModelInfo: function(gid, oId, success, fail) {
        this.mapService.queryModelInfo(gid, oId, success, fail);
    },

    queryModelCenterById: function(gid, oId, success, fail) {
        this.mapService.queryModelCenterById(gid, oId, success, fail);
    },

    /**
     * 设置线样式，包含颜色、线宽、线型的实体和间隔长度。
     * @property lineStyle
     * @type {JSON} style 线样式
     * @param  {fengmap.FMLineType} style.lineType 线型
     * @param  {boolean} style.smooth 是否开启平滑线功能
     * @param  {number} style.lineWidth 设置线宽
     * @param  {string} style.godColor 设置线的颜色，十六进制颜色值。如：'#FF0000'
     * @param  {boolean} style.godEdgeColor 设置边线的颜色,十六进制颜色值。如：'#FF0000'
     * @param  {boolean} style.alpha 先透明度设置。0~1之间取值
     * @param  {json} style.dash 分割线效果配置
     * @param  {number} style.dash.size 分割线的长度
     * @param  {number} style.dash.gap 分割线后的每两条线的间隔
     * @default {color: 0xff0000,lineWidth: 8,alpha: 0.8,dash: {size: 1,gap: 1}}
     */
    set lineStyle(v) {

        Object.assign(this.mapTheme.navigateStyle_, v);

        if (v.hasOwnProperty("color")) {
            this.mapTheme.navigateStyle_.color = v.color;
        }

        if (v.hasOwnProperty("lineWidth")) {
            this.mapTheme.navigateStyle_.lineWidth = v.lineWidth;
        }

        if (v.hasOwnProperty("alpha")) {
            this.mapTheme.navigateStyle_.alpha = v.alpha;
        }

        if (v.hasOwnProperty("alpha")) {
            this.mapTheme.navigateStyle_.alpha = v.alpha;
        }

        if (v.hasOwnProperty("dash") && v.dash.hasOwnProperty("size")) {
            this.mapTheme.navigateStyle_.dash.size = v.dash.size;
        }

        if (v.hasOwnProperty("dash") && v.dash.hasOwnProperty("gap")) {
            this.mapTheme.navigateStyle_.dash.gap = v.dash.gap;
        }

    },
    get lineStyle() {
        return this.mapTheme.navigateStyle_;
    },

    /**
     * 获取地图范围的最小X值
     * @property minX
     * @type {float}
     * @readOnly
     */
    get minX() {
        return this.mapScene.minX_;
    },

    /**
     * 获取地图范围的最大X值
     * @property maxX
     * @type {float}
     * @readOnly
     */
    get maxX() {
        return this.mapScene.maxX_;
    },

    /**
     * 获取地图范围的最小Y值
     * @property minY
     * @type {float}
     * @readOnly
     */
    get minY() {
        return this.mapScene.minY_;
    },

    /**
     * 获取地图的小心位置(墨卡拖坐标系)
     * @property center
     * @return {object} {x: sceneX_, y: sceneZ_}
     * @readOnly
     */
    get center() {
        return {
            x: -this.mapScene.sceneX_,
            y: this.mapScene.sceneZ_
        };
    },

    /**
     * 获取地图范围的最大Y值
     * @property maxY
     * @type {float}
     * @readOnly
     */
    get maxY() {
        return this.mapScene.maxY_;
    },

    navigateTo: function(loc) {
        this.navigateFromTo(this.location, loc);
    },

    navigateFromTo: function(loc1, loc2) {
        var this_ = this;
        this.mapService.queryNavigation(loc1, loc2, function(d) {
            this_.mapScene.drawNavigation(d);
        });
    },

    clearNavigation: function() {
        this.mapScene.clearNavigation();
    },

    /**
     * 绘制线
     * @method drawLineMark
     * @param {fengmap.FMLineMarker} lm FMLineMarker对象, 还可以传入一个坐标(FMMapCoord)的数组,方便快速的创建自定义线型
     * @param {JSON} style 线形的样式(可选参数), 但在创建自定义线型时, 推荐传入此参数
     * @return {fengmap.Line} 线形对象
     */
    /*drawLineMark: function(lm, style) {
    	var s = this;
    	if (lm instanceof fengmap.FMLineMarker) {
    		return this.mapScene.drawLineMark(lm, style);
    	} else if (lm instanceof Array) {
    		if (lm.length < 2) {return;}
    		var ps = lm.map(function (_ps) {
    			return s.toSceneCoord(_ps);
    		});

    		style = style || {
    			lineWidth: 1,
    			lineType: fengmap.FMLineType.FULL
    		};

    		style.smooth = fmg(style, 'smooth', false);
    		// 自定义转角处的段数
    		var segments = fmg(style, 'segments', null);
    		ps = fengmap.MapSceneUtil.buildCurvePoints(ps, (segments == null ? (style.smooth ? 8 : 0) : segments), style.radius);

    		var lineObj = null;
    		if (style.lineType == 'raw') {
    			lineObj = new fengmap.RawLine(s, ps, style);
    		} else {
    			lineObj = new fengmap.Line(s, ps, style);
    		}

    		s.mapScene.o3dNavigation_.add(lineObj);
    		lineObj.material.visible = true;

    		if (style.height != undefined) {
    			lineObj.position.y += style.height;
    		}

    		return lineObj;
    	}
    },*/


    /**
     * style: {
     * 		color: 0xff0000,
     * 		alpha: 1,
     *
     * 		lineWidth: 8,
     * 		lineType: fengmap.FMLineType.FMARROW,  // ARROW, RAW, null = NORMAL
     *
     *   	height:,
     *   	offsetHeight,
     *
     *      smooth: true,
     *      segments: 3,
     *
     *      noAnimate: true,
     *
     * 		godColor: 0xff00ff, // godXXX, line type FMARROW ONLY
     *
     * }
     */
    drawLineMark: function(lineMarkerOrMapCoords, style) {
        var s = this;

        var rawPs = [];

        // get mapCoords from FMLineMarker object
        if (lineMarkerOrMapCoords instanceof fengmap.FMLineMarker) {
            lineMarkerOrMapCoords.segments.forEach(function(itm) {
                itm.points.forEach(function(obj) {
                    obj.groupID = itm.groupId;
                });

                Array.prototype.push.apply(rawPs, itm.points);
            });
        } else if (lineMarkerOrMapCoords instanceof Array) {
            rawPs = lineMarkerOrMapCoords;
        } else {
            return null;
        }

        // 得到, 折反/跨层的分组线二维数组
        var _resArr = s._analyseRawPoints(rawPs);

        // console.log(_resArr);

        // style
        style = style || {
            lineWidth: 8,
            lineType: fengmap.FMLineType.FULL
        };

        style.smooth = fmg(style, 'smooth', true);
        // 自定义转角处的段数
        var segments = fmg(style, 'segments', null);

        var firstLine = null;

        // 将分组中的线画出来
        _resArr.forEach(function(itm) {
            // clone a style
            var _style = Object.assign({}, style);

            // 判断是否为 跨层 线
            if (itm.isCross) {
                // cross line style
                _style.up = new fm.Vector3(0, 0, 1);
                _style.billboard = true;
            }

            // 倒角
            var ps = fengmap.MapSceneUtil.buildCurvePoints(itm, (segments == null ? (_style.smooth ? 8 : 0) : segments), _style.radius || s.options.cornerRoundLimit);

            var lineObj = null;

            if (_style.lineType == 'raw') {
                lineObj = new fengmap.RawLine(s, ps, _style);
            } else {
                lineObj = new fengmap.Line(s, ps, _style);
            }

            // set groupID
            if (itm.isCross) {
                lineObj.groupID = [itm[0].groupID, itm[1].groupID];
            } else {
                lineObj.groupID = itm[0].groupID;
            }

            if (lineObj) {
                if (!firstLine) {
                    firstLine = lineObj;
                    firstLine.brothers = [];
                } else {
                    // firstLine.add(lineObj);

                    // *NEED* to sub firstLine's position
                    // lineObj.position.sub(firstLine.position);

                    firstLine.brothers.push(lineObj);
                }

                addToScene(lineObj);
            }
        });

        function addToScene(lineObj) {
            s.mapScene.o3dNavigation_.add(lineObj);

            // show in next frame
            // setTimeout(function () {
            lineObj.material.visible = true;
            // }, 0);

            // height & offsetHeight
            if (style.height != undefined) {
                lineObj.position.y += style.height;
            }

            style.offsetHeight = fmg(style, 'offsetHeight', 1);
            lineObj.position.y += style.offsetHeight;

            // check if visible
            lineObj.visibleGroupIDsChanged(s.visibleGroupIDs);
        }

        // 被动渲染
        if (s.passiveMode) {
            // 更新一下, 为了是直接计算半径,避免闪一下的问题
            s.forceUpdate(true);
        }

        return firstLine;
    },

    _analyseRawPoints: function(ps) {
        var _resArr = [];
        var up = new fm.Vector3(0, 1, 0);

        // 将子组添加到结果
        function addToResult(sub) {
            if (sub.length > 1) {
                _resArr.push(sub);
            }
        }

        _resArr = [];
        var last = null,
            lastDir = null,
            dir, _subRes = [],
            /*lastPoint = null,*/
            now = null,
            _now = null;
        for (var i = 0; i < ps.length; i++) {
            now = ps[i];
            _now = this.toSceneCoord(now);
            _now.groupID = now.groupID;

            _now.index = i;

            if (!last) {
                _subRes.push(_now); // add first point
            } else {
                // get vector and length
                var sub = _now.clone().sub(last);
                var len = sub.clone().length();
                dir = sub.clone().normalize();

                // 坚向线判断
                if (Math.abs(dir.clone().dot(up)) > .65) {
                    // add previous normal result
                    addToResult(_subRes);

                    // add a cross group
                    _subRes = [last, _now];
                    _subRes.isCross = true;

                    addToResult(_subRes);

                    // reset _subRes, and add now to the next start point
                    _subRes = [_now];
                } else { // 平面线
                    if (!lastDir) {
                        _subRes.push(_now); // add second point
                    } else {
                        var dot = dir.clone().dot(lastDir);

                        // 反向线判断
                        if (dot < -0.9) {
                            addToResult(_subRes) // 如果此段>=2个点,则加入到结果

                            // fix the bug, _subRes = []
                            _subRes = [last, _now];
                        } else {
                            if (len > 0.1) { // 去重
                                _subRes.push(_now);
                            } else {
                                continue;
                            }
                        }
                    }
                }

            } // end else

            // lastPoint = now;

            last = _now.clone();
            last.groupID = _now.groupID;

            if (dir) {
                lastDir = dir.clone();;
            }
        } // end for

        addToResult(_subRes);

        return _resArr;
    },

    /**
     * 清除线图层
     * @method clearLineMark
     * @param {fengmap.Line} lm fengmap.Line的一个或多个对象, 如为空, 则会删除地图中所有的线型
     */
    clearLineMark: function(lm) {
        this.mapScene.clearLineMark(lm);
    },

    /**
     * 获得比例尺计算所需的基本数据
     */
    _getMapScaleInfo: function() {
        /*
		// get dpi with dom
	    var dpi = [];
	    if (window.screen.deviceXDPI) {
	        dpi[0] = window.screen.deviceXDPI;
	        dpi[1] = window.screen.deviceYDPI;
	    } else {
	        var tmpNode = document.createElement("DIV");
	        tmpNode.style.cssText = "width:1in;height:1in;position:absolute;left:0px;top:0px;z-index:99;visibility:hidden";
	        document.body.appendChild(tmpNode);
	        dpi[0] = parseInt(tmpNode.offsetWidth);
	        dpi[1] = parseInt(tmpNode.offsetHeight);
	        tmpNode.parentNode.removeChild(tmpNode);
	    }
	    dpi = dpi[0];
	    */

        var dpi = (function() {
            for (var i = 56; i < 2000; i++) {
                if (matchMedia("(max-resolution: " + i + "dpi)").matches === true) {
                    return i / window.devicePixelRatio;
                }
            }

            if (window.screen.deviceXDPI) {
                return window.screen.deviceXDPI;
            } else {
                var tmpNode = document.createElement("DIV");
                tmpNode.style.cssText = "width:1in;height:1in;position:absolute;left:0px;top:0px;z-index:99;visibility:hidden";
                document.body.appendChild(tmpNode);
                dpi = parseInt(tmpNode.offsetWidth);
                tmpNode.parentNode.removeChild(tmpNode);
                return dpi;
            }
        })();

        this.mapScaleInfo = this.mapScaleInfo || {};

        this.mapScaleInfo.dpi = dpi;

        this.mapScaleInfo.pixelsPerCentimeter = dpi / 2.54;
        var scaleNow = fengmap.MapUtil.getSpriteScale(this);
        var disNow = this.controls.constraint.getDistance();
        this.mapScaleInfo.baseViewDistance = disNow / scaleNow;
    },

    /**
     * 得到比例尺对应的scaleLevelValue
     * @param  {float} scale mapScale 值 (厘米)
     * @return {float}       返回对应的scaleLevelValue值
     */
    mapScaleToScaleLevelValue: function(scale) {
        var rate = scale / this.mapScaleInfo.pixelsPerCentimeter / 100;
        var tan = Math.tan(this.mapView.camera.fov * fm.Math.DEG2RAD / 2);
        var dis = rate * this.height / 2 / tan;

        return dis / this.controls.constraint.initDistance_;
    },

    /**
     * 得到scaleLevelValue对应的mapScale
     * @param  {float} scale scaleLevelValue 值
     * @return {float}       返回对应的比例尺值
     */
    scaleLevelValueToMapScale: function(scale) {
        var dis = scale * this.controls.constraint.initDistance_ * 100;
        var tan = Math.tan(this.mapView.camera.fov * fm.Math.DEG2RAD / 2);
        var height = tan * dis * 2;
        return height / this.height * this.mapScaleInfo.pixelsPerCentimeter;
    },

    /**
     * 通过scale得到相机的距离
     * @param  {float} scale 比例尺的值
     * @return {float}       返回相机距离目前点的距离
     */
    getViewDistanceByMapScale: function(scale) {
        var val = this.mapScaleToScaleLevelValue(scale);
        return this.controls.constraint.initDistance_ * val;
    },

    /**
     * 得到/设置地图比例尺 1: 500 = 1厘米对应场景中的500厘米
     * 在设置时, 可以传入Json, {scale:1800, duration:1, callback: function() {}}
     * @property {float} mapScale
     */
    get mapScale() {
        if (this.mapScaleInfo) {
            var scale = fengmap.MapUtil.getSpriteScale(this);
            return scale * this.mapScaleInfo.pixelsPerCentimeter * 100;
        }
        return null;
    },

    /**
     * 设置比例尺
     * 		*注意* 单位为厘米
     */
    set mapScale(scale) {
        var s = this;
        if (typeof scale == 'number') {
            scale = {
                scale: scale
            };
        }

        scale.scale = fm.Math.clamp(scale.scale, this.mapScaleLevels[this._maxMapScaleLevel - 1], this.mapScaleLevels[this._minMapScaleLevel - 1]);

        var rate = this.mapScaleToScaleLevelValue(scale.scale);

        // 在设置完级别后。需要手动的调用一次handleControlsChange, 因为不会自动调用

        var cb = scale.callback;
        scale.callback = function() {
            s.handleControlsChange();
            if (cb) {
                cb();
            }
        }

        scale.rawLevel = true;
        this.controls.constraint.scaleLevelTo(rate, scale);
    },

    /**
     * 设置地图比例尺范围
     * @method setMapScaleRange
     * @param {float} min 最小比例尺 如: 500, 则地图最小比例尺为 1:500
     * @param {float} max 最大比例尺 如: 20000, 则地图最大比例尺为 1:20000
     */
    setMapScaleRange: function(min, max) {
        var _min = this.mapScaleToScaleLevelValue(min);

        // 如果缩放的最小级别小于 0.2
        this.scaleLevels_[0] = _min;

        var _max = this.mapScaleToScaleLevelValue(max);

        // 记录最大最小比例尺
        this._minMapScale = min;
        this._maxMapScale = max;

        this.controls.initScaleLevel(_min, _max);
        var _scale = this.mapScale;

        if (_scale < min) {
            this.mapScale = min;
        } else if (_scale > max) {
            this.mapScale = max;
        }
    },

    /**
     * 设置地图比例尺 级别 范围
     * @method setMapScaleLevelRange
     * @param {float} min 最小比例尺级别 如: 16, 则地图最小比例尺级别为16,对应的比例尺为 1:9028 (厘米)
     * @param {float} max 最大比例尺级别 如: 23, 则地图最大比例尺级别为24,对应的比例尺为 1:70 (厘米)
     */
    setMapScaleLevelRange: function(min, max) {

        // 最大/最小 互换.因为 scaleLevel 是反的0级最大.
        _max = fm.Math.clamp(min, 1, this.mapScaleLevels.length);
        _min = fm.Math.clamp(max, 1, this.mapScaleLevels.length);

        this._minMapScaleLevel = _max;
        this._maxMapScaleLevel = _min;

        this.setMapScaleRange(this.mapScaleLevels[_min - 1], this.mapScaleLevels[_max - 1]);
    },

    /**
     * 通过传入的mapScale值, 得到相就的mapScaleLevel
     * @param  {float} scale 比例尺的值: 如 1:20  (20)
     * @return {int}       返回得到的比例尺级别
     */
    getMapScaleLevelByScale: function(scale) {
        for (var i = 0; i < this.mapScaleLevels.length; i++) {
            if (this.mapScaleLevels[i] <= scale) {
                // return i + 1;
                return i;
            }
        }

        return this.mapScaleLevels.length;
    },

    /**
     * 得到/设置地图的比例尺级别 1~29 级, 一般室内地图所用到的级别范围在 16~23级
     * 在设置时, 可以传入Json, {level:18, duration:1, callback: function() {}}
     * @property {int} mapScaleLevel
     */
    get mapScaleLevel() {
        return this.getMapScaleLevelByScale(this.mapScale);
    },

    set mapScaleLevel(level) {
        if (typeof level == 'number') {
            level = {
                level: level
            }
        }

        // level.level = fm.Math.clamp(level.level, 1, this.mapScaleLevels.length);
        level.level = fm.Math.clamp(level.level, this._minMapScaleLevel, this._maxMapScaleLevel);
        level.scale = this.mapScaleLevels[level.level - 1];

        this.mapScale = level;
    },

    /**
     * 得到地图最小比例尺值. 如: 10, 意思是 1:10
     * 地图1厘米代表场景中的10米
     * @return {float} 返回最小比例尺值
     */
    get minMapScale() {
        if (!this._minMapScale) {
            this._setMapScaleRangeValue();
        }
        return this._minMapScale;
    },

    /**
     * 得到地图最大比例尺值. 如: 10, 意思是 1:10
     * 地图1厘米代表场景中的10米
     * @return {float} 返回最大比例尺值
     */
    get maxMapScale() {
        if (!this._maxMapScale) {
            this._setMapScaleRangeValue();
        }
        return this._maxMapScale;
    },

    _setMapScaleRangeValue: function() {
        var s = this;
        // mapScale min / max
        s._minMapScale = s.scaleLevelValueToMapScale(s.scaleLevels_[s.minScaleLevel_]);
        s._maxMapScale = s.scaleLevelValueToMapScale(s.scaleLevels_[s.maxScaleLevel_]);
    },

    /**
     * 设置地图的显示级别，取值为0-6之间的整数，值越小表示地图越大。
     * @property scaleLevel
     * @type {int}
     */
    get scaleLevel() {
        return this.scaleLevel_;
    },

    set scaleLevel(v) {
        this.scaleLevel_ = Math.ceil(v);
        this.controls.setScaleLevelValue(this.scaleLevels_[this.scaleLevel_]);
    },

    /**
     * 设置地图的最小显示级别，取值为0-6之间的整数。
     * @property minScaleLevel
     * @type {int}
     */
    get minScaleLevel() {
        return this.minScaleLevel_;
    },

    set minScaleLevel(val) {
        this.setScaleLevelLimit(val, this.maxScaleLevel_);
    },

    /**
     * 设置地图的最大显示级别，取值为0-6之间的整数。
     * @property maxScaleLevel
     * @type {int}
     */
    get maxScaleLevel() {
        return this.maxScaleLevel_;
    },

    set maxScaleLevel(val) {
        this.setScaleLevelLimit(this.minScaleLevel_, val);
    },

    get scaleLevelValue() {
        return this.controls.constraint.getScaleRate();
    },

    set scaleLevelValue(val) {
        this.controls.constraint.setScaleLevelValue(val);
    },

    /**
     * 以动画缓动的形式,缩放到指定的级别, 或自定义的缩放值
     * level: 可以为map.scaleLevels_的索引, 以可以为在scaleLevels_最大最小值之间的任意值
     * params: time(number), callback(fn), rawLevel(bool)
     */
    scaleLevelTo: function(level, params) {
        var _level = level,
            _params = params;

        // 兼容传入一个json参数: {level: time: callback: rawLevel:}
        if (arguments.length == 1 && typeof level == 'object') {
            _level = level.level;
            _params = level;
        }

        return this.controls.constraint.scaleLevelTo(_level, _params);
    },

    /**
     * level: 0 ~ 6
     */
    /**
     * 限制最大最小级别
     * @method setScaleLevelLimit
     * @param {int} minLevel 0~6之间取值
     * @param {int} maxLevel 0~6之间取值
     */
    setScaleLevelLimit: function(minLevel, maxLevel) {
        var this_ = this;
        minLevel = fm.Math.clamp(minLevel, 0, this_.scaleLevels_.length - 1);
        maxLevel = fm.Math.clamp(maxLevel, 0, this_.scaleLevels_.length - 1);

        this_.minScaleLevel_ = minLevel;
        this_.maxScaleLevel_ = maxLevel;

        // 设置mapScale min / max
        this_._setMapScaleRangeValue();

        this_.controls.initScaleLevel(this_.scaleLevels_[minLevel], this_.scaleLevels_[maxLevel]);
        var _scale = this_.scaleLevel;

        if (_scale < minLevel) {
            this_.scaleLevel = minLevel;
        } else if (_scale > maxLevel) {
            this_.scaleLevel = maxLevel;
        }

        // this_.scaleLevel = this_.scaleLevels_[Math.ceil((minLevel + maxLevel) / 2)];
    },

    setScaleLevelRange: function(minLevel, maxLevel) {
        setScaleLevelLimit(minLevel, maxLevel);
    },

    /**
     * 模型放大。按级别放大，每次放大1级,改变map.scaleLevel的值
     * @method scaleLevelIn
     */
    scaleLevelIn: function() {
        if (this.scaleLevel_ > 0) {
            this.scaleLevel_--;
            this.controls.constraint.scaleLevelTo(this.scaleLevel_);
        }
    },
    /**
     * 模型缩小。按级别缩小，每次缩小1级,改变map.scaleLevel的值
     * @method scaleLevelOut
     */
    scaleLevelOut: function() {
        if (this.scaleLevel_ < this.maxScaleLevel) {
            this.scaleLevel_++;
            this.controls.constraint.scaleLevelTo(this.scaleLevel_);
        }
    },

    // polar angle
    get maxPolarAngle() {
        return (Math.PI / 2 - this.controls.minPolarAngle) * fm.Math.RAD2DEG;
    },

    set maxPolarAngle(val) {
        this.controls.maxPolarAngle = (90 - val) * fm.Math.DEG2RAD;
        this.controls.update();
    },

    /**
     * 得到/设置地图的最大倾斜角度
     * @property {float} maxTitleAngle
     */
    get maxTiltAngle() {
        return (Math.PI / 2 - this.controls.minPolarAngle) * fm.Math.RAD2DEG;
    },

    set maxTiltAngle(val) {
        this.controls.minPolarAngle = (90 - val) * fm.Math.DEG2RAD;
        this.controls.update();
    },

    /**
     * 得到/设置地图的最小倾斜角度
     * @return {float} minTiltAngle
     */
    get minTiltAngle() {
        return (Math.PI / 2 - this.controls.maxPolarAngle) * fm.Math.RAD2DEG;
    },

    set minTiltAngle(val) {
        this.controls.maxPolarAngle = (90 - val) * fm.Math.DEG2RAD;
        this.controls.update();
    },

    get mapOriginCoord() {
        return new fm.Vector3(this.mapScene.sceneX_, 0, this.mapScene.sceneZ_);
    },

    get width() {
        return this.mapView.w_;
    },

    get height() {
        return this.mapView.h_;
    },

    //
    // @deprecated
    /**
     * 模型放大。不是成比例缩放的,无极缩放，和当前的saclelevel无关
     * @method zoomIn
     */
    zoomIn: function(val) {
        this.controls.zoomIn_(val);
    },

    /**
     * 模型缩小。不是成比例缩放的,无极缩放,和当前的saclelevel无关
     * @method zoomOut
     */
    zoomOut: function(val) {
        this.controls.zoomOut_(val);
    },

    // record last phi used in animate
    __lastPhi: 0,
    __viewModeAnimating: false,

    /**
     * 设置模型显示模式 二维/三维
     * @property viewMode
     * @type {enum}
     * @default fengmap.FMViewMode.MODE_3D
     * @demo map/三维模式.js
     * @demo map/二维模式.js
     */
    // properties
    set viewMode(m) {
        if (this.__viewModeAnimating) {
            return;
        }

        var _time = null;
        var callback = null;

        // 支持传入一个Json
        // {
        // 		mode: 'top' | '3d',
        // 		time: .3,
        // 		callback: function(mode)
        // 	}
        if (typeof m == 'object') {
            _time = fmg(m, 'time', 'duration', undefined);
            callback = m.callback;
            m = m.mode;
        }

        if (m != this.viewMode_) {
            var s = this;
            s.__viewModeAnimating = true;

            var cameraP = this.mapView.camera;
            var cameraO = this.mapView.cameraTop;

            // ztc 2016/06/27 perspective to ortho
            function setOrthoSize() {
                var orthoSize = fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera(cameraP, s.controls);

                cameraO.zoom = 1;

                cameraO.left = -orthoSize.right;
                cameraO.right = orthoSize.right;
                cameraO.top = orthoSize.top;
                cameraO.bottom = -orthoSize.top;

                cameraO.updateProjectionMatrix();
                if (m) {
                    s.viewMode_ = m;
                }
                s.__viewModeAnimating = false;

                // 在 passiveMode 的时候. 第一次切换到 top 视图, 需要进行一次刷新
                if (s.passiveMode) {
                    setTimeout(function() {
                        s.forceUpdate(true);
                    }, 10);
                }
            }

            // ortho to perspective
            function setPerspectivePos(s) {
                var zoom = cameraO.zoom;
                var len = s.controls.target.distanceTo(cameraP.position);
                var vec = cameraP.position.clone().sub(s.controls.target).normalize();

                cameraP.position.copy(s.controls.target.clone().add(vec.multiplyScalar(len / zoom)));
                cameraP.updateProjectionMatrix();
                s.viewMode_ = m;
            }

            // 转之前的 viewMode
            if (this.viewMode_ == '3d') {
                // record phi
                s.__lastPhi = s.controls.constraint.getPolarAngle();
                s.controls.minPolarAngle = 0;
                s.controls.maxPolarAngle = Math.PI;
                fm.Tween.fadeTo(
                    _time != undefined ? _time : (s.options.viewModeAnimateMode ? s.options.viewModeAnimateTime : 0),
                    function(f) {
                        s.controls.constraint.update({
                            forcePhi: s.__lastPhi - s.__lastPhi * f
                        });
                        s.requireUpdateCollide_ = true;
                    }, null,
                    function() {
                        s.controls.constraint.object = s.mapView.cameraTop;
                        s.controls.minPolarAngle = 0;
                        s.controls.maxPolarAngle = 0;

                        s.currentCamera_ = s.mapView.cameraTop;
                        s.controls.update({
                            forceTheta: s.controls.constraint.getAzimuthalAngle() + Math.PI,
                            notChangeCompass: true
                        });

                        setOrthoSize();

                        if (callback) {
                            callback(s.viewMode_);
                        }
                    });
            } else { // top
                s.controls.constraint.object = s.mapView.camera;

                s.controls.minPolarAngle = 0;
                s.controls.maxPolarAngle = Math.PI;

                s.currentCamera_ = s.mapView.camera;
                s.controls.update({
                    forceTheta: s.controls.constraint.getAzimuthalAngle() + Math.PI,
                    notChangeCompass: true
                });

                fm.Tween.fadeTo(
                    _time != undefined ? _time : (s.options.viewModeAnimateMode ? s.options.viewModeAnimateTime : 0),
                    function(f) {
                        s.controls.constraint.update({
                            forcePhi: s.__lastPhi * f
                        });
                        s.requireUpdateCollide_ = true;
                    }, null,
                    function() {
                        s.controls.minPolarAngle = Math.PI / 2 - s.options.defaultMaxTiltAngle * fm.Math.DEG2RAD;
                        s.controls.maxPolarAngle = Math.PI / 2 - s.options.defaultMinTiltAngle * fm.Math.DEG2RAD;

                        if (callback) {
                            callback(s.viewMode_);
                        }
                        s.__viewModeAnimating = false;
                    });
                setPerspectivePos(s);
            }

            this.updateCountDown_ = 0; // force update!
        }
    },
    get viewMode() {
        return this.viewMode_;
    },

    /**
     * 设置主题名称,设置在openMapById方法之前，或在LoadComplete事件之后设置
     * @property themeName
     * @type {string}
     * @default 2001
     * @demo map/切换主题.js
     */
    set themeName(v) {
        var scope = this;

        scope._lastThemeVersion = scope.mapTheme.version;

        if (v != this.mapTheme.themeName_) {
            // 更换主题(不需要重新加载)
            scope.mapTheme.themeName_ = v;
            if (!scope.sceneId_) {
                return;
            }

            scope.mapService.queryThemeV2(v, function(d) {

                // 2016.10.28 增加主题的filetype字段,用于区别主题所使用的资源类型,之前为 image
                // 现在增加了 rtheme 文件,些文件是将所有用到的图片资源以base64格式,存的JSON文件中
                // 用于减少http请求
                // 所以在载入完主题后, 先去判断filetype类型,确定以什么样的方式加载图片资源,再去设置
                // 主题
                scope._setTheme(v, d);

                // 视图背景色
                // scope.setBackgroundColor(scope.mapTheme.clearColor_,1);
                scope.setBackgroundColor(scope.mapTheme.clearColor_, (scope.mapTheme.clearAlpha_ || 1));

                // clear label atlas
                // scope.mapAtlas.clear();

                var ts = scope.mapTheme.type2theme_;
                scope.mapScene.o3dScene_.traverse(function(itm) {
                    if (itm.fm_) {
                        var vals = ts[itm.fm_.typeID];

                        switch (itm.fm_.nodeType) {
                            case fengmap.FMNodeType.LINE: // modelLine
                                if (!vals) {
                                    return;
                                }
                                itm.material.color = new fm.Color(vals.strokeColor_);
                                itm.material.linewidth = vals.strokeWidth;
                                break;
                            case fengmap.FMNodeType.FLOOR: // floor
                                itm.material.color = new fm.Color(scope.mapTheme.floorColor_);
                                itm.material.opacity = scope.mapTheme.floorOpacity_;
                                break;
                            case fengmap.FMNodeType.MODEL: // Model
                                if (!vals) {
                                    return;
                                }
                                var color = vals.color;

                                if (typeof color == 'string') {
                                    color = fengmap.MapUtil.toColor(vals.color);
                                }

                                var _c = new fm.Color(color),
                                    _a = vals.alpha || 1;

                                // multiMaterial
                                if (itm.material instanceof fm.MultiMaterial) {
                                    itm.material.materials[0].color.copy(_c);
                                    itm.material.materials[0].opacity = _a;
                                    itm.material.materials[1].color.copy(_c);
                                    itm.material.materials[1].opacity = _a;
                                } else { // normal material
                                    itm.material.color.copy(_c);
                                    itm.material.opacity = _a;
                                }

                                break;
                            case fengmap.FMNodeType.FACILITY: // POI

                                var vals = scope.mapTheme.storePoiThemes[itm.fm_.typeID];
                                if (!vals) {
                                    return;
                                }

                                scope.mapTheme.loadImage(vals, function(tex) {
                                    itm.material.map = tex;
                                    itm.material.opacity = vals.alpha || 1;

                                    // 如果存在height字段,更改其大小
                                    if (vals.height) {
                                        var size = parseFloat(vals.height);
                                        itm.height_ = size;
                                        itm.width_ = size;
                                    }
                                }, 'imagename');

                                break;
                            case fengmap.FMNodeType.LABEL: // Label
                                itm.updateStyle(scope.mapTheme.labelStyle_);
                                break;
                            case fengmap.FMNodeType.TEXT_MARKER: // text marker
                                itm.updateStyle(itm.fm_.style_);
                                break;
                            case fengmap.FMNodeType.ELEMENT: // element
                                if (itm._type_ == 'storeImage') {
                                    itm.fm_.updateStyle();
                                }
                                break;
                        }
                    }
                });

                scope.focusGroupID = scope.focusGroupId_;
            });
        }
    },
    get themeName() {
        return this.mapTheme.themeName_;
    },
    //
    get listGroups() { // @TODO
        return this.mapScene.scene_['scene_data']['layerGroups'];
    },

    /**
     * 设置groupId相关楼层为当前楼层,支持只传楼层id,或Json对象
     * @property focusGroupID
     * @type {number|object}
     * @default 第一层
     * @demo map/设置聚焦楼层.js
     */
    set focusGroupID(gid) {
        var params = null;
        var s = this;

        // 添加对传入 object 的支持
        if (typeof gid == 'object') {
            params = gid;
            gid = gid.groupID == undefined ? gid.gid : gid.groupID;
        }

        function asyncFocusGroup(resgid) {
            if (resgid == gid) {
                s.off('groupLoaded', asyncFocusGroup);
                s.focusGroup_(gid, params);
                s.emit('focusGroupIDChanged', gid);
            }
        }

        if (this.mapScene.o3dGroups_[gid]) {
            this.focusGroup_(gid, params);
            this.emit('focusGroupIDChanged', gid);
        } else {
            // 分层加载时, 因为在visibleGroupIDs时,楼层可能还没有加载完成
            // 所以这里需要使用异步的形式处理,在聚焦层加载完成后.再去focus
            this.on('groupLoaded', asyncFocusGroup);
        }
    },

    /**
     * 类似上面的 focusGroupID 方法
     * 不使用属性. 这样便于API扩展
     *
     * param: {
     * 	notMove:  false,      		// 不去移动相机, 这个参数主要是为了避免与MoveTo的设置焦点层冲突, 一般不需要自己设置
     * 	time: 	  0,                // 如果设置了time,那么覆盖全局的设置,如果设置为0,那么将关闭动画
     * 	callback: function (gid)    // 在启用相机动画的情况下,动画完成后的回调方法.
     * }
     */
    setFocusGroup: function(gid, params) {
        this.focusGroup_(gid, params);
    },

    get focusGroupID() {
        return this.focusGroupId_;
    },

    get visibleGroupIDs() {
        return this.visibleGroupIDs_;
    },

    /**
     * 设置可见的楼层集合
     * @property visibleGroupIDs
     * @type {array}
     */
    set visibleGroupIDs(groupIDs) {
        if (groupIDs.length > 0) {

            this.visibleGroupIDs_ = groupIDs;

            // 如果当前为分层加载
            // 先去载入当前层,如此层已经载入将不会再触发loadGroup方法
            if (this.options.isSeparate || this.options.isDecodeByVisible) {
                // this.loadGroups(groupIDs);
                this.asyncLoadGroups(groupIDs);
            }

            // locationMarker visible
            this.mapView.scene.children.forEach(function(obj) {
                if (obj.fm_ instanceof fengmap.FMLocationMarker &&
                    groupIDs.indexOf(obj.fm_.gid) > -1) {
                    obj.fm_.visible = true;
                }
            });

            // group visible
            for (var k in this.mapScene.o3dGroups_) {
                var o3d = this.mapScene.o3dGroups_[k];

                o3d.visible = groupIDs.indexOf(o3d.meta_.gid) >= 0;
            }

            // handle level show
            fengmap.MapUtil.handleLevelShow(this);

            this.emit('visibleGroupIDsChanged', groupIDs);
        }
    },

    get labelLanguage() {
        return this.options.defaultLabelLanguage;
    },

    /**
     * 设置label的语言类型,支持英文和中文。
     * @property labelLanguage
     * @type {fengmap.FMLanguageType}
     */
    set labelLanguage(lanType) {
        if (typeof lanType == 'string' && (lanType == fengmap.FMLanguageType.EN || lanType == fengmap.FMLanguageType.CHN)) {
            if (lanType != this.options.defaultLabelLanguage) {
                for (var i = 0; i < this.groupIDs.length; i++) {
                    var gid = this.groupIDs[i];
                    var groupLayer = this.getFMGroup(gid);
                    if (groupLayer) {
                        groupLayer.traverse(function(glayer) {
                            if (glayer instanceof fengmap.FMLabelLayer) {
                                glayer.o3d_.children.forEach(function(fm) {
                                    var labelName = lanType == 'en' ? fm.data_.ename : fm.data_.name;
                                    fm.setname(labelName);
                                })
                            }
                        })
                    }
                }
                this.options.defaultLabelLanguage = lanType;
                return lanType;
            }
        }

        return this.options.defaultLabelLanguage;
    },

    /**
     * 设置背景颜色及透明度
     * @method setBackgroundColor
     * @param {int} color 十六进制颜色值或CSS颜色样式: 0xFF0000 | '#FF0000'
     * @param {float} alpha 透明度。在0 ~ 1之间取值。
     * @since v1.2.0
     */
    setBackgroundColor: function(color, alpha) {
        this.mapView.renderer.setClearColor(color, alpha);
    },

    /**
     * 设置模型的拾取颜色
     * @method setModelSelectColor
     * @param {color} color 十六进制颜色值或CSS颜色样式: 0xFF0000 | '#FF0000'
     * @param {float} alpha 透明度。在0 ~ 1之间取值。
     * @since v1.2.0
     */
    setModelSelectColor: function(color, alpha) {
        var _alpha = alpha == undefined ? 1 : alpha;
        this.mapTheme.selectModelMat.color.set(color);
        this.mapTheme.selectModelMat.emissive.set(color);
        this.mapTheme.selectModelMat.opacity = _alpha;

        this._selectModelAlpha = _alpha;
    },

    /**
     * 模型视窗的背景色
     * @property backgroundColor
     * @type {int}
     */
    set backgroundColor(color) {
        this.mapView.renderer.setClearColor(parseInt(color));
    },

    /**
     * 指南针
     * @property showCompass
     * @type {Boolean}
     * @default false
     */
    set showCompass(b) {
        if (b != this.compass_.visible) {
            this.compass_.visible = b;
            if (b) {
                // this.compass_.updateDirection(this.controls.getAzimuthalAngle());
                this.controlsChange_();
            }
        }
    },

    get showCompass() {
        return this.compass_.visible;
    },

    get location() {
        return this.location_;
    },

    // private
    prepare_: function(success) {
        if (!this.mapTheme.data) {
            var this_ = this;

            var v = this_.mapTheme.themeName;
            this.mapService.queryThemeV2(v, function(d) {

                this_._setTheme(v, d, function() {
                    // this_.mapTheme.data = d;
                    this_.setBackgroundColor(this_.mapTheme.clearColor_, (this_.mapTheme.clearAlpha_ || 1));
                    success();
                });

            });
        } else {
            success();
        }
    },

    _setTheme: function(themeName, themeData, success) {
        var this_ = this;

        // console.log('adsf ----->', themeName, themeData);

        ///////////////////////
        // clear storeImages //
        ///////////////////////
        this_.callAllLayersByAlias('storeImage', function(sl) {
            if (sl) {
                sl.removeAll();
            }
        });

        var type = this_.options.themeFileType || fmg(themeData, 'filetype', 'fileType', 'image');

        if (type == 'rtheme') {
            this_.mapService.loadResourcesJson(themeName, function(rtheme) {
                this_.mapTheme.rtheme = rtheme;
                this_.mapTheme.data = themeData;

                if (success) {
                    success();
                }
            }, function() {
                this_.mapTheme.rtheme = null;
                console.warn('以 rtheme 格式加入资源失败!');
            });
        } else if (type == 'image') { // 以原始的fmi图片形式
            this_.mapTheme.rtheme = null;
            this_.mapTheme.data = themeData;
            if (success) {
                success();
            }
        }
    },

    // 上次点击的模型数据
    lastSelectStore: [],
    lastFlashStore: [],
    lastSelectElement: [],
    __selectMaterialAnimId: null,
    __falshMaterialAnimId: null,

    /**
     * 选中模型方法
     * @method storeSelect
     * @param {fengmap.FMModel} model 模型对象
     * @param {boolean} isSelected 	是否选中
     * @param {boolean} multiSelect 是否保持上一次选中模型的状态。false是不保存，即地图中只有当前设置的模型高亮，其他模型不高亮。ture则不清空上次的选中状态，都高亮。
     */
    storeSelect: function(meshData, isSelected, multiSelect) {
        var scope = this;

        if (isSelected == undefined) {
            isSelected = true;
        }

        // 还原上次选中的模型材质Id
        if (isSelected && !multiSelect) {
            scope.selectNull();
        }

        // 如果是选择, 将其放入选择数组
        if (isSelected) {
            scope.lastSelectStore.push(meshData);
        } else { // 如果是去掉选择状态
            var _index = scope.lastSelectStore.indexOf(meshData);
            // 如果之前并没有选择,则返回
            if (_index == -1) {
                return;
            } else {
                // 如果之前有选择到,则从选择的数组中移除
                scope.lastSelectStore.splice(_index, 1);
            }
        }

        if (meshData instanceof fengmap.FMModel) {
            if (isSelected) {
                meshData.o3d_.material = scope.mapTheme.selectModelMat;
                scope.lastSelectStore.push(meshData);
            } else {
                meshData.o3d_.material = meshData.o3d_.defaultMaterial_;
            }
        } else {
            if (!meshData || !meshData.faceRange) {
                return;
            }

            var geo = meshData.o3d_.geometry;

            // materialIndex: [0:顶底材质, 1.周边材质 2.选择材质, (3.自定义材质), (4.自定义周边材质), ...]
            for (var i = meshData.faceRange[0]; i < meshData.faceRange[1]; i++) {
                isSelected && geo.faces[i].materialIndex != 2 && (geo.faces[i]._materialIndex = geo.faces[i].materialIndex);
                geo.faces[i].materialIndex = isSelected ? 2 : geo.faces[i]._materialIndex;
            }

            geo.groupsNeedUpdate = true;
        }

        // flash
        clearInterval(scope.__selectMaterialAnimId);

        if (!isSelected) {
            return;
        }

        scope.__selectMaterialAnimId = fm.Tween.action(scope.mapTheme.selectModelMat, .3, {
            opacity: scope._selectModelAlpha * .5,
            // emissive: scope.mapTheme.selectModelMat.color
        }, null, function() {
            scope.__selectMaterialAnimId = fm.Tween.action(scope.mapTheme.selectModelMat, .2, {
                opacity: scope._selectModelAlpha,
                // emissive: new fm.Color(0, 0, 0)
            });
        });
    },

    /**
     * 外部模型选择方法
     * @method elementSelect
     * @param {fengmap.FMElement} element 模型对象
     * @param {boolean} isSelected 	是否选中
     * @param {boolean} multiSelect 是否保持上一次选中模型的状态。false是不保存，即地图中只有当前设置的模型高亮，其他模型不高亮。ture则不清空上次的选中状态，都高亮。
     */
    elementSelect: function(element, isSelected, multiSelect) {

        if (!element || element._type_ != 'externalModel') {
            return;
        }

        var scope = this;

        if (isSelected == undefined) {
            isSelected = true;
        }

        // 还原上次选中的模型材质Id
        if (isSelected && !multiSelect) {
            scope.selectNull();
        }

        // 如果是选择, 将其放入选择数组
        if (isSelected) {
            scope.lastSelectElement.push(element);
        } else { // 如果是去掉选择状态
            var _index = scope.lastSelectElement.indexOf(element);
            // 如果之前并没有选择,则返回
            if (_index == -1) {
                return;
            } else {
                // 如果之前有选择到,则从选择的数组中移除
                scope.lastSelectElement.splice(_index, 1);
            }
        }

        if (isSelected) {
            element.flash(function() {
                element.highLight(scope.mapTheme.selectModelMat.color);
            });
        } else {
            element.highLight();
        }
    },

    /**
     * 模型闪烁方法
     * @method storeFlash
     * @param {fengmap.FMModel} model 模型对象
     * @param {boolean} isFalshed 	是否闪烁
     * @param {boolean} multiFalsh 是否保持上一次选中模型的状态。false是不保存，即地图中只有当前设置的模型高亮
     */
    storeFlash: function(meshData, isFalshed, multiFalsh) {
        var scope = this;

        if (isFalshed == undefined) {
            isFalshed = true;
        }

        // 还原上次选中的模型材质Id
        if (isFalshed && !multiFalsh) {
            scope.flashNull();
        }

        // 如果是选择, 将其放入选择数组
        if (isFalshed) {
            scope.lastFlashStore.push(meshData);
        } else { // 如果是去掉选择状态
            var _index = scope.lastFlashStore.indexOf(meshData);
            // 如果之前并没有选择,则返回
            if (_index == -1) {
                return;
            } else {
                // 如果之前有选择到,则从选择的数组中移除
                scope.lastFlashStore.splice(_index, 1);
            }
        }

        if (meshData instanceof fengmap.FMModel) {
            if (isFalshed) {
                meshData.o3d_.material = scope.mapTheme.selectModelMat;
                scope.lastFlashStore.push(meshData);
            } else {
                meshData.o3d_.material = meshData.o3d_.defaultMaterial_;
            }
        } else {
            if (!meshData || !meshData.faceRange) {
                return;
            }

            var geo = meshData.o3d_.geometry;

            // materialIndex: [0:顶底材质, 1.周边材质 2.选择材质, (3.自定义材质), (4.自定义周边材质), ...]
            for (var i = meshData.faceRange[0]; i < meshData.faceRange[1]; i++) {
                isFalshed && geo.faces[i].materialIndex != 2 && (geo.faces[i]._materialIndex = geo.faces[i].materialIndex);
                geo.faces[i].materialIndex = isFalshed ? 2 : geo.faces[i]._materialIndex;
            }

            geo.groupsNeedUpdate = true;
        }

        // flash
        clearInterval(scope.__falshMaterialAnimId);
        if (!isFalshed) {
            return;
        }

        scope.__falshMaterialAnimId = fm.Tween.action(scope.mapTheme.selectModelMat, .3, {
            opacity: scope._selectModelAlpha * .5,
            // emissive: scope.mapTheme.selectModelMat.color
        }, null, function() {
            scope.__falshMaterialAnimId = fm.Tween.action(scope.mapTheme.selectModelMat, .2, {
                opacity: scope._selectModelAlpha,
                // emissive: new fm.Color(0, 0, 0)
            }, null, function() {
                if (meshData instanceof fengmap.FMModel) {
                    meshData.o3d_.material = meshData.o3d_.defaultMaterial_;

                } else {
                    if (!meshData || !meshData.faceRange) {
                        return;
                    }

                    var geo = meshData.o3d_.geometry;
                    // materialIndex: [0:顶底材质, 1.周边材质 2.选择材质, (3.自定义材质), (4.自定义周边材质), ...]
                    for (var i = meshData.faceRange[0]; i < meshData.faceRange[1]; i++) {
                        geo.faces[i].materialIndex = geo.faces[i]._materialIndex;
                    }
                    geo.groupsNeedUpdate = true;
                }
            });
        });
    },

    /**
     * 清空选中模型方法，把所有高亮的模型都取消高亮
     * @method selectNull
     */
    selectNull: function() {
        var s = this;

        while (s.lastSelectStore.length) {
            s.storeSelect(s.lastSelectStore[0], false);
        }
        s.lastSelectStore.length = 0;


        while (s.lastSelectElement.length) {
            s.elementSelect(s.lastSelectElement[0], false);
        }
        s.lastSelectElement.length = 0;
    },


    /**
     * 清空闪烁模型方法，把所有闪烁的模型都取消闪烁
     * @method flashNull
     */
    flashNull: function() {
        var s = this;

        while (s.lastFlashStore.length) {
            s.storeFlash(s.lastFlashStore[0], false);
        }
        s.lastFlashStore.length = 0;
    },

    //此方法为SDK内部使用,如需要自定义过滤方法的话，可以重写map.pickFilterFunction(fm)方法

    /**
     * 拾取物体的过滤方法，可以自定义进行覆盖。可以根据返回的fm属性自定义设置某地图元素可否选中。
     * @method pickFilterFunction
     * @param  {JSON} fm 拾取的物体的 fm 数据
     * @return {bool} bool值，是否支持点击高亮。true支持点击高亮，false不支持高亮
     * @demo map/设置点击是否高亮.js
     */
    _canPicked: function(fm) {
        if (this.pickFilterFunction) {
            return this.pickFilterFunction(fm);
        } else {
            return true;
        }
    },

    _canHover: function(fm) {
        if (this.hoverFilterFunction) {
            return this.hoverFilterFunction(fm);
        } else {
            return true;
        }
    },

    _getCoordByEvent: function(e, gid) {
        var res = this.mapPicker.getPick_(e.domEvent);
        var z;

        if (gid) {
            z = this.getGroupHeight(gid) + this.options.pickCoordHeight;
        }

        return this.coordScreenToMap(res.x, res.y, z, true);
    },

    /**
     * 模型点击事件
     * @event mapClickNode
     * @return event 事件返回参数，event.target 表示拾取到的地图元素；event.nodeType代表模型拾取的类型；event.EventInfo包括地图坐标(event.eventInfo.coord)、页面点击拾取的事件元素（event.eventInfo.domEvent，即前端mouseClick事件的event参数）。
     * @demo map/模型拾取事件.js
     */
    openMap_: function(sceneId, needCheck) {
        if (this._zopStep_ != 2) {
            return;
        }
        // console.log('openMap_', caller);
        var this_ = this;
        var prev_picker_model_ = null;
        var currentSelect = null;

        // 清空缓存中的POI材质
        fengmap.MapPoi._mats = {};

        if (!this.mapPicker.init_) {

            // 点击POI等
            this.mapPicker.on('pickerObjects_', function(e) {
                this_.selectNull();

                var o = e.intersects[0].object; // distance, ..
                // var meta = o != undefined ? o.meta_ : undefined;

                // if (meta) {
                var fm = o.fm_;

                var coord = fm['mapCoord'];

                // 向前兼容
                fm.target = fm;

                /////////////////
                // pick filter //
                /////////////////
                if (!fm || !this_._canPicked(fm)) {
                    return;
                }

                // 并装原始的dom事件体,回传

                var eventData = Object.assign({
                    x: coord.x,
                    y: coord.y,
                    z: coord.z
                }, fm);

                eventData.eventInfo = {
                    domEvent: e.domEvent,
                    coord: this_._getCoordByEvent(e, fm.groupID),
                    eventID: e.eventID
                }

                this_.emit('mapClickNode', eventData);
                // }
            });

            // 点击component
            this.mapPicker.on('pickerComponent_', function(e) {
                this_.selectNull();

                // 并装原始的dom事件体,回传
                var eventData = Object.assign({}, {
                    eventInfo: {
                        domEvent: e.domEvent,
                        coord: this_._getCoordByEvent(e, fm.groupID),
                        eventID: e.eventID
                    },
                    nodeType: e.component.object.nodeType,
                    target: e.component.object
                });

                this_.emit('mapClickNode', eventData);
            });

            // 点击model
            this.mapPicker.on('pickerModels_', function(e) {
                //jiguo add beg
                return;
                //jimguo add end
                var o = e.intersects[0].object;

                // var meta = o != undefined ? o.meta_ : undefined;
                // if (meta) {

                // var _gid = o.fm_.groupID;

                //////////////////
                // get fm first //
                //////////////////
                var fm = null;
                var bros = o.fm_.brothers;
                // 查看是否为合并后的物体 fm_.brothers
                if (bros) {
                    var _faceIndex = e.intersects[0].faceIndex;

                    for (var i = 0; i < bros.length; i++) {
                        if (_faceIndex < bros[i].faceRange[1]) {
                            // if (this_.options.modelSelectedEffect && this_._canPicked(bros[i])) {
                            // 	// 将当前的子物体设置为选择状态
                            // 	this_.storeSelect(bros[i]);
                            // }

                            fm = bros[i];
                            break;
                        }
                    }
                } else {
                    fm = o.fm_;
                }

                /////////////////
                // pick filter //
                /////////////////
                if (!fm || !this_._canPicked(fm)) {
                    return;
                }

                if (prev_picker_model_ != null) {
                    prev_picker_model_.mouseSelected = false;
                }

                prev_picker_model_ = o;

                ////////////////
                // pick flash //
                ////////////////
                if (this_.options.modelSelectedEffect) {

                    switch (fm.nodeType) {
                        case fengmap.FMNodeType.MODEL:
                            this_.storeSelect(fm);
                            break;
                        case fengmap.FMNodeType.FLOOR:
                            this_.selectNull();
                            // return;
                            break;
                        default:
                            break;
                    }

                    if (fm instanceof fengmap.FMElement) {
                        if (this_.options.modelSelectedEffect) {
                            this_.elementSelect(fm);
                        }
                    }
                }
                /////////////////////////////////


                // 得到这个模型对应的Label对象
                var label = fengmap.MapUtil.getModelLabelObject(this_, fm);

                if (label != undefined) {
                    fm.label = label.fm_;

                    // 先调用一下 fm.mapCoord, 要不然直接调用 x,y,z 回出错
                    // 这样算是初始化了一下
                    fm.label.mapCoord;
                }

                var coord = fm.o3d_ ? fm.mapCoord : {
                    x: 0,
                    y: 0,
                    z: 0
                };

                // 向前兼容
                fm.target = fm;

                fm.x = coord.x;
                fm.y = coord.y;
                fm.z = fm.label == undefined ? coord.z : fm.label.z;

                // 并装原始的dom事件体,回传
                var eventData = fm;
                eventData.eventInfo = {
                    domEvent: e.domEvent,
                    coord: this_._getCoordByEvent(e, fm.groupID),
                    eventID: e.eventID
                }

                this_.emit('mapClickNode', eventData);
                // }
            });

            // hover POI等
            this.mapPicker.on('hoverObjects_', function(e) {

                var o = e.intersects[0].object; // distance, ..

                var fm = o.fm_;

                var coord = fm['mapCoord'];

                // 向前兼容
                fm.target = fm;

                /////////////////
                // hover filter //
                /////////////////
                if (!fm || !this_._canHover(fm)) {
                    return;
                }

                // 并装原始的dom事件体,回传
                var eventData = Object.assign(fm, {
                    eventInfo: {
                        domEvent: e.domEvent,
                        coord: this_._getCoordByEvent(e, fm.groupID),
                        eventID: e.eventID
                    },
                    x: coord.x,
                    y: coord.y,
                    z: coord.z
                });

                this_.emit('mapHoverNode', eventData);
            });

            // hover component
            this.mapPicker.on('hoverComponent_', function(e) {

                // 并装原始的dom事件体,回传
                var eventData = Object.assign({}, {
                    eventInfo: {
                        domEvent: e.domEvent,
                        coord: this_._getCoordByEvent(e, fm.groupID),
                        eventID: e.eventID
                    },
                    nodeType: e.component.object.nodeType,
                    target: e.component.object
                });

                this_.emit('mapHoverNode', eventData);
            });

            // hover model
            this.mapPicker.on('hoverModels_', function(e) {

                var o = e.intersects[0].object;

                var fm = null;
                var bros = o.fm_.brothers;
                // 查看是否为合并后的物体 fm_.brothers
                if (bros) {
                    var _faceIndex = e.intersects[0].faceIndex;

                    for (var i = 0; i < bros.length; i++) {
                        if (_faceIndex < bros[i].faceRange[1]) {
                            fm = bros[i];
                            break;
                        }
                    }
                } else {
                    fm = o.fm_;
                }

                /////////////////
                // hover filter //
                /////////////////
                if (!fm || !this_._canHover(fm)) {
                    return;
                }

                ////////////////
                // hover flash //
                ////////////////
                if (this_.options.modelHoverEffect) {

                    if (fm.nodeType == fengmap.FMNodeType.MODEL) {
                        this_.storeFlash(fm);

                    } else if (fm instanceof fengmap.FMElement) {
                        fm.flash();
                    }
                }

                // 得到这个模型对应的Label对象
                var label = fengmap.MapUtil.getModelLabelObject(this_, fm);

                if (label != undefined) {
                    fm.label = label.fm_;

                    // 先调用一下 fm.mapCoord, 要不然直接调用 x,y,z 回出错
                    // 这样算是初始化了一下
                    fm.label.mapCoord;
                }

                var coord = fm.o3d_ ? fm.mapCoord : {
                    x: 0,
                    y: 0,
                    z: 0
                };

                // 向前兼容
                fm.target = fm;

                fm.x = coord.x;
                fm.y = coord.y;
                fm.z = fm.label == undefined ? coord.z : fm.label.z;

                // 并装原始的dom事件体,回传
                var eventData = Object.assign(fm, {
                    eventInfo: {
                        domEvent: e.domEvent,
                        coord: this_._getCoordByEvent(e, fm.groupID),
                        eventID: e.eventID
                    }
                });

                this_.emit('mapHoverNode', eventData);
            });

            // 空白点击
            this.mapPicker.on('pickerNone_', function(e) {
                this_.selectNull();

                this_.emit('mapClickNode', {
                    target: null,
                    mouse: e.mouse,
                    eventInfo: {
                        domEvent: e.domEvent, // 并装原始的dom事件体,回传
                        coord: this_._getCoordByEvent(e),
                        eventID: e.eventID
                    },
                    nodeType: fengmap.FMNodeType.NONE
                });
            });

            // 空白悬停
            this.mapPicker.on('hoverNone_', function(e) {

                this_.emit('mapHoverNode', {
                    target: null,
                    mouse: e.mouse,
                    eventInfo: {
                        domEvent: e.domEvent, // 并装原始的dom事件体,回传
                        coord: this_._getCoordByEvent(e),
                        eventID: e.eventID
                    },
                    nodeType: fengmap.FMNodeType.NONE
                });
            });
        }
        this.mapPicker.start(this, this.mapView.canvas_);

        // controls scale level changed event
        if (!this._bindScaleLevelChanged) {
            this._bindScaleLevelChanged = true;

            this.controls.constraint.on('scaleLevelChanged', function(l) {
                this_.emit('scaleLevelChanged', {
                    level: l,
                    scale: this_.scaleLevels_[l] /*, mapScale: this_.mapScale, mapScaleLevel: this_.mapScaleLevel*/
                });
            });


            // 比例尺级别改变事件
            this.controls.constraint.on('mapScaleLevelChanged', function(scale) {

                // 处理级别显示
                // fengmap.MapUtil.handleLevelShow(this_);

                this_.emit('mapScaleLevelChanged', {
                    mapScale: scale.mapScale,
                    lastMapScale: scale.lastMapScale
                });
            });
        }

        /**
         * 开始读取 Scene
         */
        console.time('queryScene');
        this.mapService.queryScene(sceneId, function(d) {

            console.timeEnd('queryScene');

            // 如果已经dispose了
            if (this_._stop_) {
                return;
            }

            this_.emit('preBuild', d);

            /////////////
            // certify 只有在数据里有Key 的时候才会去验证//
            /////////////
            if (needCheck && this_.mapService.staticScene_.scene.key) {
                // console.log('data key is', this_.mapService.staticScene_.scene.key);
                // 需要本地验证的情况
                var boo = fengmap.checkOffLine(this_);

                if (!boo) {
                    fm.warn(fm.gs(fm.ss.warn_offline));

                    if (this_._failedCallback) {
                        this_._failedCallback({
                            message: '本地验证失败!'
                        });
                    }

                    return;
                }
            }
            /*var usridmd5 = this_.mapService.staticScene_.scene.key;

            if (fengmap.key == '' || fengmap.appName == '') {
            	console.warn('please set key and appName by fengmap.setKeyAndAppName function.');
            	return;
            } else {
            	var appInfo = fengmap.FMMD5.encryption('fengmap.localhost:' + fengmap.appName);
            	var md5 = fengmap.FMAES.decryption(fengmap.key, appInfo);

            	if (md5 != usridmd5) {
            		console.warn('KEY NOT CERTIFY');
            		return;
            	}
            }*/
            ///////////////////////////////////


            // 在这里先得到一个 热力图的 大小,
            // 这个值用在创建模型时模型的Geometry的时候
            // 需要创建热力图的纹理坐标
            // this_.heatMapSize = fengmap.FMHeatMap.getDeviceWH();


            this_.scaleLevels_ = JSON.parse('[' + d['scene_data']['scaleLevel'] + ']');
            this_.scaleLevel_ = Math.floor(this_.scaleLevels_.length / 2);

            this_.mapScene.setScene(d);
            var o3dScene = this_.mapScene.getO3dScene();
            this_.mapView.scene.add(o3dScene);

            var load_count = this_.mapScene.groupLength_();

            this_.groupIDs = [];
            this_.focusGroupId_ = -1;

            // set original camera position
            var needSetAutoScale = this_.setOriginCameraPosition((this_.__isNewScene || this_.focusGroupId_ == -1) ? 1 : this_.focusGroupId_);

            if (!this_.__isChangeTheme) {

                this_.minScaleLevel_ = this_.options.minScaleLevel;
                this_.maxScaleLevel_ = Math.min(this_.scaleLevels_.length - 1, this_.options.maxScaleLevel);

                var dis = this_.controls.initScaleLevel(this_.scaleLevels_[this_.minScaleLevel_],
                    this_.scaleLevels_[this_.maxScaleLevel_], true);

                if (!needSetAutoScale) {
                    this_.scaleLevel = Math.max(this_.options.defaultScaleLevel, this_.minScaleLevel_);
                }

                if (this_.height) {

                    // mapScale & mapScaleLevel
                    if (this_.options.mapScaleRange) {
                        this_.setMapScaleRange(this_.options.mapScaleRange[0], this_.options.mapScaleRange[1]);
                    } else if (this_.options.mapScaleLevelRange) {
                        this_.setMapScaleLevelRange(this_.options.mapScaleLevelRange[0], this_.options.mapScaleLevelRange[1]);
                    }

                    if (this_.options.defaultMapScale) {
                        this_.mapScale = {
                            scale: this_.options.defaultMapScale,
                            duration: 0
                        };
                    } else if (this_.options.defaultMapScaleLevel) {
                        this_.mapScaleLevel = {
                            level: this_.options.defaultMapScaleLevel,
                            duration: 0
                        };
                    }
                }
            }


            // sort layerGroups
            this_.listGroups.sort(function(ng0, ng1) {
                return parseInt(ng0.gid) - parseInt(ng1.gid);
            });

            ////////////////////////////////////
            ///  如果为分层加载 || 分层解析     ///
            ////////////////////////////////////
            if (this_.options.isSeparate || this_.options.isDecodeByVisible) {

                fengmap.Map.IsMapLoading = false;

                // 第一次加载完成后才会调用 用户的 LoadComplete方法
                // 因为目前的换主题也需要重新加载, 所以要避免再次调用
                if (this_.__isNewScene || this_.focusGroupId_ == -1) {
                    this_._start_(true);
                    this_.loadComplete_(true);
                }

            } else {

                //////////////////////////////
                ///  从单文件中加载所有层    ///
                /////////////////////////////

                // 得到所有层的 gid 数组
                var gids = this_.listGroups.map(function(itm) {
                    return itm.gid;
                });
                var gidCount = this_.mapScene.groupLength_();
                var cnt = 0;

                // 如果 defaultVisibleGroups == 'all', 将其转化
                if (this_.options.defaultVisibleGroups == 'all') {
                    this_.options.defaultVisibleGroups = gids.slice();
                }

                // if (!map.options.lazyCreateMode) {
                // 	this_.loadGroups(gids, function(gid) {

                // 		cnt += 1;
                // 		if (cnt == gidCount) {
                // 			fengmap.Map.IsMapLoading = false;
                // 			if (this_.__isNewScene || this_.focusGroupId_ == -1) {
                // 				this_.loadComplete_();
                // 			}
                // 		}

                // 	});
                // }

                var _gids = gids.slice();

                // 将默认Focus层放到最前面, 使其创建的过程可见
                var _defaultFG = this_.options.defaultFocusGroup;
                if (_defaultFG != 1 && gids.indexOf(_defaultFG) > -1) {
                    _gids[0] = _gids.splice(_defaultFG - 1, 1, _gids[0])[0];
                }

                this_._start_(null, function() {
                    if (this_.options.lazyCreateMode) {
                        setTimeout(function() {
                            this_.loadComplete_();
                        }, 0)
                    }
                });

                // this_.focusGroupId_ = this_.options.defaultFocusGroup;

                if (this_.options.lazyCreateMode) {
                    return;
                }

                console.time('load all groups');
                this_.asyncLoadGroups(_gids, function() {
                    fengmap.Map.IsMapLoading = false;
                    if (this_.__isNewScene || this_.focusGroupId_ == -1) {
                        console.timeEnd('load all groups');
                        // this_._start_();
                        this_.loadComplete_();
                    }
                });

            }
        }, function(errorText) {
            if (this_._failedCallback) {
                this_._failedCallback(errorText);
            }
            if (errorText && typeof errorText === 'object' && errorText.error_code) {
                fm.warn(errorText.error_code, errorText.error_message);
            }
            console.log('queryScene:', errorText);
            fengmap.Map.IsMapLoading = false;
        });
    },

    /**
     * 从分离的文件中加载多个层
     * @param  {Array}   gidArray 加载的层的gid数组
     * @param  {Function} callback 每层载入完成后的回调,反加此层的gid
     * @return {null}
     */
    // loadGroups: function(gidArray, callback) {
    loadGroups: function(gidArray, callback) {
        var this_ = this;

        // console.time('loadGroups');
        console.time('loadGroups');

        for (var i = 0; i < gidArray.length; i++) {
            var gid = gidArray[i];

            // 判断此层是否已经被加载了
            if (this_.groupIDs.indexOf(gid) < 0) {
                this_.loadGroup(gid, callback);
            }
        }

        // console.timeEnd('loadGroups');
        console.timeEnd('loadGroups');
    },

    asyncLoadGroups: (function() {
        var index = 0;

        return function(gidArray, callback) {
            var s = this;

            if (index == gidArray.length) {
                console.log('index == gidArray.length');
                index = 0;
                s.groupIDs.sort(function(a, b) {
                    return a - b
                });
                if (callback) {
                    callback();
                }
                return;
            }

            console.log('index is ', index);

            // if (s.groupIDs.indexOf(gidArray[index]) > -1) {
            if (s.getFMGroup(gidArray[index])) {
                index++;
                s.asyncLoadGroups(gidArray, callback);
            } else {
                setTimeout(function() {
                    s.loadGroup(gidArray[index], function() {

                        index++;

                        s.asyncLoadGroups(gidArray, callback);

                    });
                }, 0);
            }
        }

    })(),

    _storeApplyWorks: function(gid) {

        if (!this.options.useStoreApply) {
            return;
        }

        var s = this;
        var mds = s.getDatasByAlias(gid, 'model');

        mds.forEach(function(itm) {

            delete itm.defaultColor;

            var sad = s.mapScene.modelDatas[itm.FID];

            var sa = itm.data_.storeApply = sad.storeApply;

            if (sa && itm.data_ && itm.data_.theme_) {
                if (sa.id != itm.data_.theme_.id) {
                    if (sa.color) {
                        itm.defaultColor = fengmap.MapUtil.toColor(sa.color);

                        itm.defaultAlpha = sa.alpha == "" ? itm.data_.theme_.alpha : sa.alpha;

                        itm.setColor(itm.defaultColor, itm.defaultAlpha);
                    }
                }
            } else if (s.options.mergeModels) {
                itm.setColorToDefault();
            }
        });
    },

    /**
     * 从分离的文件中加载单个层
     * @param  {int}   gid      层的 gid
     * @param  {Function} callback 此层载入完成后的回调,返回此层gid
     * @return {null}
     */
    loadGroup: function(gid, callback) {
        var this_ = this;

        // record to mapScene groups_
        this_.mapScene.groups_[gid] = this_.mapScene.scene_.scene_data.layerGroups[gid - 1];

        this_.mapService.queryGroup(this_.sceneId_, gid, function(dg) {
            this_.groupIDs.push(gid);

            this_.mapScene.putGroup(gid, dg); // generte group

            // 在这里去设置初始的聚焦层
            if (gid == this_.options.defaultFocusGroup) {
                this_.focusGroupID = {
                    gid: this_.options.defaultFocusGroup,
                    time: 0
                };
            }

            this_.mapScene.forEachGroupModel(gid, function(mesh) {
                //jimguo delete beg
                // if (mesh.fm_.nodeType == fengmap['FMNodeType']['MODEL']) {
                //     mesh.material = this_.createMaterial_(mesh.meta_.theme_);
                //     mesh.userData = {
                //         sid: this_.sceneId_,
                //         gid: gid
                //     };
                //     this_.mapPicker.addModel(mesh);
                // }
                //jimguo delete end
                // });
            }, groupWorks.bind(this_));

            function groupWorks() {
                /////////////////////////////////
                // 合并工作
                /////////////////////////////////

                //jimguo delete beg
                // // 默认将 ModelLine 进行合并来提高效率
                // if (this_.options.mergeModelLines) {
                //     fengmap.MapUtil.mergeModels(this_, gid, 'modelLine');
                // }
                //
                // // 是否将模型合并
                // if (this_.options.mergeModels) {
                //     fengmap.MapUtil.mergeModels(this_, gid);
                // }
                //
                // // 合并Polygon
                // fengmap.MapUtil.mergeModels(this_, gid, 'polygon');
                //jimguo delete end
                /////////////////////////////////

                /////////////////////////////////
                // storeapply color assign
                /////////////////////////////////
                this_._storeApplyWorks(gid);

                // handle level show
                fengmap.MapUtil.handleLevelShow(this_);

                // 得到 o3dGroup
                var o3dGroup = this_.mapScene.getO3dGroup(gid);

                // 加载完需要先看看是否可见
                o3dGroup.visible = this_.visibleGroupIDs_.indexOf(gid) > -1;
                // o3dGroup.visible = this_.options.defaultVisibleGroups.indexOf(gid) > -1;

                // 设置层的Alpha
                if (o3dGroup.visible && this_.options.focusAlphaMode) {
                    if (gid == this_.focusGroupId_) {
                        fengmap.MapUtil.restoreGroupAlpha(this_, gid);
                    } else {
                        fengmap.MapUtil.setGroupAlpha(this_, gid, this_.options.focusAlpha);
                    }
                }

                // 触发楼层加载完成事件
                this_.emit('groupLoaded', gid);

                // 触发用户自己定义的层加载完成的回调
                if (this_.options.groupLoadedCallback) {
                    this_.options.groupLoadedCallback(gid);
                }

                // 触发内部回调
                if (callback) {
                    callback(gid);
                }

            } // group wroks end

        });
    },

    /////////////////////////////////
    // Shadow properties
    /////////////////////////////////
    get shadowEnabled() {
        return this.mapView.shadowLight.castShadow;
    },

    set shadowEnabled(val) {
        this.mapView.shadowLight.castShadow = val;
    },

    get lightAngleX() {
        return this.mapView.shadowAngleX;
    },

    set lightAngleX(val) {
        this.mapView.shadowAngleX = val;
    },

    get lightAngleY() {
        return this.mapView.shadowAngleY;
    },

    set lightAngleY(val) {
        this.mapView.shadowAngleY = val;
    },

    _groupSpace: -1,

    /**
     * 获取/设置 当前地图的楼层间距.
     * @property groupSpace
     * @type {number}
     */
    get groupSpace() {
        return this._groupSpace == -1 ? this.options.defaultGroupSpace : this._groupSpace;
    },

    set groupSpace(val) {
        this._groupSpace = val;
        var this_ = this;
        this.groupIDs.forEach(function(index) {
            this_.getFMGroup(index).o3d_.position.y = val * (index - 1);
        });
    },

    // 整体的亮度
    get brightness() {
        // return this.mapView.ambientLight.intensity;
        return this.mapView.renderer.toneMappingExposure
    },

    set brightness(val) {
        this.mapView.renderer.toneMappingExposure = val;
    },

    /**
     * 地图数据加载完成事件
     *
     * *注意*：目前的“懒创建”版本与之前的版本存在着本质的不同，
     * 之前的loadComplete事件是在，载入fmap数据之后，并且完成了所有楼层的实体创建之后才调用的。
     * 而目前的“懒创建”版本，是在载入完fmap数据之后，就直接调用了。此时场景中并没有创建任何的FMNode实体
     * 实体的创建现在是根据当前的显示级别，以及当前的视口范围来按需创建的。以些来有效的提高“大地图”的创建及显示效率
     *
     * 只是需要开发者了解一下此方法与之前的本质不同。但在实际的使用中，你同样可以在此事件中去初始化导航类（FMNavigation）,
     * 及搜索（map.search）地图数据。只是之前搜索出来的直接是 FMNode对象，而目前搜索出来的是原始的地图数据Object.
     * 如果当前数据的实体已经被创建了，那么就会存在一个 entity 对象，如实体尚未创建，则entity为undefined
     *
     * @event loadComplete
     * @demo map/模型加载完成事件.js
     */

    /**
     * 地图级别变化事件.比如pc端鼠标滚动放大\缩小事件等.
     * @event scaleLevelChanged
     */

    _start_: function(isSeparate, cb) {
        this.requireUpdateCollide_ = true;
        this.__isChangeTheme = false;

        this._stop_ = false;

        this.updateCountDown_ = 0;

        // set pan range
        this.panRange = Math.sqrt(Math.pow((this.maxX - this.minX) / 2, 2) + Math.pow((this.maxY - this.minY) / 2, 2));
        this.controls.setValidRange_(this.validRange_.bind(this));

        this.viewMode = {
            mode: this.options.defaultViewMode,
            time: 0
        };

        // plane_ for pick
        this.plane_ = new fm.Mesh(new fm.PlaneGeometry(10000, 10000, 4, 4), new fm.MeshBasicMaterial({
            color: 0x6699cc,
            visible: false
        }));

        this.mapScene.o3dScene_.add(this.plane_);
        this.plane_.rotation.x = -Math.PI / 2;

        // 如果不是分层加载, 那么在开始时Focus 第一层
        // if (!this.options.isSeparate) {
        // 	this.focusGroupID = (this.__isNewScene || this.focusGroupId_ == -1) ? 1 : this.focusGroupId_;
        // }

        // 如果不是正常加载,而是分层加载.
        if (!isSeparate) { // 不知道为什么.要做这个判断... : 因为分层是, 每一层都是调用这个, 所以某一层会加入多次
            this.visibleGroupIDs = this.options.defaultVisibleGroups;
            // this.focusGroupID    = { gid: this.options.defaultFocusGroup, time: 0};
        }

        this._started_ = true;
        var scope = this;
        this.focusGroupID = {
            groupID: this.options.defaultFocusGroup,
            time: 0,
            callback: function() {
                fengmap.MapUtil.handleLevelShow(scope);

                scope.emit('start');

                if (cb) {
                    cb();
                }
            }
        };

        // 这个 haveUpdate 主要是为了避免,切换地图等操作
        // 会重复调用update的问题,这样就只调用一次提升效率
        if (!this._haveUpdate) {
            this._haveUpdate = true;
            this.update_();
        }
    },

    loadComplete_: function(isSeparate) {

        this.emit('loadComplete', {});

    },

    controlsChange_: function() {
        var s = this;
        var addAngle = 0;
        if (s.viewMode_ == '3d') {
            addAngle = Math.PI;
        }

        s.emit('controlchange');

        s.compass_.updateDirection(-s.controls.getAzimuthalAngle() - addAngle);
        s.requireUpdateCollide_ = true;

        clearTimeout(s._controlsChangeID);

        if (s.forceViewChange) {
            fengmap.MapUtil.handleLevelShow(s);
        } else {
            s._controlsChangeID = setTimeout(function() {
                fengmap.MapUtil.handleLevelShow(s);
            }, 100);
        }
    },

    updateCountDown_: 0, // #20160225,Samuel,E
    __time: 0,
    __cnt: 0,
    __allTime: 0,
    deltaTime: .01,
    immediateDeltaTime: .01,
    renderStep: 10,

    get frameRate() {
        return 60 / this.renderStep;
    },

    set frameRate(value) {
        value = fm.Math.clamp(value, 1, 60);
        this.renderStep = 60 / value;
        this.updateCountDown_ = 0;
        this.timer.getDelta();
    },

    // 被动渲染方式
    get passiveMode() {
        return this.renderStep > 1000;
    },

    set passiveMode(boo) {
        this.renderStep = boo ? Number.MAX_VALUE : 60 / this.options.frameRate;
        this.forceUpdate(true);
    },

    dispose: function() {

        this.controls.removeEventListener('change', this.handleControlsChange);

        // 释放控制器事件绑定
        this.controls.dispose();

        // 释放拾取器的事件绑定
        this.mapPicker.dispose();

        // mapView dispose
        this.mapView.dispose();

        // 删除Scene根节点
        var scene = this.mapScene.getO3dScene();
        if (scene) {
            var rootNode = scene.parent

            while (rootNode.children.length > 0) {
                rootNode.remove(rootNode.children[0]);
            }
        }

        // stop All request
        fm.stopAllRequest();
        fm.requestPool.length = 0;

        this.mapScene = null;
        this.mapView = null;
        this.mapPicker = null;
        this.compass_ = null;
        this.controls = null;

        // 停止渲染循环
        this._stop_ = true;

    },

    update_: function(once) {
        if (!once) {
            // 停止
            if (this._stop_ || !this.mapView || !this.mapView.camera || !(this.mapView.camera instanceof fm.Camera)) {
                if (!this._stop_) {
                    this.dispose();
                }
                return;
            }

            requestAnimationFrame(this.update_.bind(this, once));
        } else {
            this.updateCountDown_ = 0;
        }

        if (this.centerHelper_) {
            this.centerHelper_.position.copy(this.controls.target);
        }

        if (this.updateCountDown_ == 0) {
            this.updateCountDown_ = this.renderStep;
            this.requireUpdateCollide_ = true;
        }

        this.immediateDeltaTime = this.timerImmediate.getDelta();
        this.emit('immediateUpdate', this.immediateDeltaTime);

        this.updateCountDown_--;

        //this.requireUpdateCollide_
        if (true) {// || this.stopLimitFrame
            this.requireUpdateCollide_ = false;
            this.updateSize(null, null, false);
            // this.mapView.scene.updateMatrixWorld();

            this.__time = new Date().getTime();

            this.mapView.frustumUpdate();
            this.mapScene.updateCollide(this.mapView);

            this.__time = new Date().getTime() - this.__time;

            this.__allTime += this.__time;
            this.__cnt += 1;

            if (this.__cnt == 5) {
                this.__cnt = 0;
                // console.log('update Collide use Time(ms)', this.__allTime / 5);
                this.__allTime = 0;
            }

            this.deltaTime = this.timer.getDelta();

            // 组件事件调用
            if (this.componentsManager) {
                this.componentsManager.invokeUpdate(this.deltaTime);
            }

            this.emit('update', this.deltaTime);

            this.mapView.render(this.viewMode_);
        }
    },

    /**
     * 强制刷新
     */
    forceUpdate: function(soft) {
        if (soft) {
            this.updateCountDown_ = 0;
        } else {
            this.update_(true);
        }
    },

    /**
     * 更新宽高的类
     *  force: 是否强制得到当前Container的宽高
     *         因为,如当前的宽高没有变化,tryResize_会返回null
     *         使用这个参数,可以不管是否宽高有变化都会返回值
     */
    updateSize: function(w, h, force) {
        if (force == undefined) {
            force = true;
        }
        if (w == undefined) {
            var size = this.mapView.tryResize_(force);
            if (!size) {
                return;
            }
            w = size.w;
            h = size.h;
        }
        this.mapView.resize(w, h);
        this.zonTempObj.updateHUD(w, h);
        this.compass_.updateHUD(w, h, this.options.compassOffset, this.options.compassSize);

        force && (this.requireUpdateCollide_ = true);
    },


    // not used!!!
    // 20170105 ztc added
    validRange_: function(pt, target) {
        // 开启移动范围限制
        if (this.options.enabledPanRange) {
            var v = new fm.Vector3().copy(target);
            v.y = 0;
            var dis = v.length();

            var range = this.panRange || 1000;

            return dis < range;
        } else {
            return true;
        }
    },

    /**
     * 设置相机的默认位置
     */
    setOriginCameraPosition: function(gid, position) {
        // 使用 focusGrouId_ == -1 来确定是否是首次打开
        // if (!this.__isNewScene || this.focusGroupId_ != -1) {
        // 	return;
        // }

        var s = this.mapScene.box3_.size();
        // var h = this.mapScene.scene_.scene_data.layerGroups[gid - 1].height;
        var h = this.options.defaultGroupSpace * (gid - 1);
        var vec = new fm.Vector3(0, h, 0);
        var y = s.x * .75 + h;

        var to;
        if (!position) {
            to = new fm.Vector3(s.x, y, -s.x);
        } else {
            to.copy(position).y = y;
        }

        this.mapView.camera.position.copy(to);
        this.groupCenter_ = vec;
        this.controls.target.copy(vec);

        // 2d 3d 默认的旋转角度
        if (this.options.defaultControlsPose == null) {
            if (this.options.defaultViewMode == '3d') {
                this.options.defaultControlsPose = -15;
            } else {
                this.options.defaultControlsPose = 0
            }
        }

        // 设置相机  defaultViewCenter
        if (this.options.defaultViewCenter != undefined) {
            var center = this.options.defaultViewCenter;
            if (typeof center != 'object') {
                return;
            }
            var v = this.toSceneCoord(center);

            this.controls.target.copy(v);
        }

        // 通过相机与目标点的位置设置初始状态
        if (this.options.defaultControlsPose != undefined) {
            var _pose = this.options.defaultControlsPose;
            var val = 0;

            switch (typeof _pose) {
                case 'string':
                    switch (_pose) {
                        case 'n':
                            val = Math.PI;
                            break;
                        case 's':
                            val = 0;
                            break;
                        case 'w':
                            val = -Math.PI / 2;
                            break;
                        case 'e':
                            val = Math.PI / 2;
                            break;
                        case 'ne':
                            val = Math.PI * .75;
                            break;
                        case 'nw':
                            val = Math.PI * 1.25;
                            break;
                        case 'se':
                            val = Math.PI / 4;
                            break;
                        case 'sw':
                            val = -Math.PI / 4;
                            break;
                        default:
                            val = 0;
                            break;
                    }
                    this.controls.update({
                        forceTheta: val
                    });
                    break;
                case 'number':
                    // this.controls.update({forceTheta: _pose * fm.Math.DEG2RAD});
                    this.rotateAngle = _pose;
                    break;
                case 'object':

                    var t = this.options.defaultControlsPose.target.split(',');
                    var p = this.options.defaultControlsPose.position.split(',');

                    var tv = new fm.Vector3(parseFloat(t[0]), parseFloat(t[1]), parseFloat(t[2]));
                    var pv = new fm.Vector3(parseFloat(p[0]), parseFloat(p[1]), parseFloat(p[2]));

                    this.controls.target.copy(tv);
                    this.controls.object.position.copy(pv);
                    this.controls.update();

                    return true;
                    break;
            }
        }

        // 设置默认的最大倾斜角度
        if (this.options.defaultMaxTiltAngle != undefined) {
            this.maxTiltAngle = this.options.defaultMaxTiltAngle;
        }

        if (this.options.defaultMinTiltAngle != undefined) {
            this.minTiltAngle = this.options.defaultMinTiltAngle;
        }

        // 设置默认倾斜角度
        if (this.options.defaultTiltAngle != undefined) {
            this.tiltAngle = this.options.defaultTiltAngle;
        }

        return false;
    },

    __moveToId: -1,

    /**
     * 将指定层的label,poi,markers等,不被上层的透明层所遮挡
     * @param  {int} gid 层的 gid
     * @param  {bool} boo 是否被遮挡
     */
    _alwaysShowLabelAndPOI: function(gid, boo) {
        fengmap.MapUtil.getObjectsByAlias(this, gid, [
            'label',
            'facility',
            'textMarker',
            'imageMarker'
        ]).forEach(function(itm) {
            if (itm && itm.alwaysShow) {
                itm.alwaysShow(boo);
            }
        });
    },

    focusGroup_: function(gid, params) {
        // return;
        var scope = this;
        scope.focusGroupId_ = gid;

        params = params || {};

        var listGroups = this.mapScene.scene_.scene_data.layerGroups;

        for (var i in listGroups) {
            var layer = listGroups[i];
            var o3d = this.mapScene.o3dGroups_[layer.gid];

            if (layer.gid == gid) {
                var pt = new fm.Vector3();
                // pt.y = layer.height;
                pt.y = this.getGroupHeight(gid);

                // 恢复焦点层的alpha
                fengmap.MapUtil.restoreGroupAlpha(scope, gid);

                var lastPos = this.mapView.camera.position.clone();
                var lastOffset = this.controls.target.clone();
                var _y = lastPos.y - lastOffset.y;

                pt.x = lastOffset.x;
                pt.z = lastOffset.z;

                var delta = pt.clone().sub(lastOffset);
                var __y = pt.y + _y - lastPos.y;

                // 将 Label 与 POI 设置为 "不被遮挡"
                if (scope.options.focusAlphaMode) {
                    scope._alwaysShowLabelAndPOI(layer.gid, false);
                }

                // get duration
                var _duration = fmg(params, 'time', 'duration', scope.options.focusAnimateTime);

                // 查看参数中是否需要动画过去
                // 此参数主要是为了避免与 moveTo 方法冲突
                if (!params.notMove) {
                    clearInterval(this.__moveToId);

                    this.__moveToId = fm.Tween.fadeTo(
                        this.options.focusAnimateMode ? _duration : 0,
                        function(f) {
                            scope.mapView.camera.position.y = lastPos.y + __y * f;
                            scope.controls.target.y = lastOffset.y + delta.y * f;
                            scope.controls.update();
                        }, null,
                        function() {
                            // 更新阴影的位置
                            scope.mapView.updateShadowPostion();

                            // 调用回调
                            if (params.callback) {
                                params.callback(gid);
                            }
                        }
                    );

                    this.groupCenter_ = pt;
                }
            } else {
                if (o3d && o3d.visible && this.options.focusAlphaMode) {
                    fengmap.MapUtil.setGroupAlpha(scope, layer.gid, this.options.focusAlpha);
                }

                // 不管是否为focusAlphaMode都还原Label 与 POI的无遮挡
                scope._alwaysShowLabelAndPOI(layer.gid, false);
            }
        }

        return this.__moveToId;
    },
    createMaterial_: function(theme) {
        var mat = new fm.MeshLambertMaterial({
            color: theme.color_
        }); // vertexColors
        mat.transparent = true;
        mat.opacity = theme.alpha_;
        return mat;
    },

    /**
     * 添加定位标注物
     * @method addLocationMarker
     * @param {fengmap.FMLocationMarker} lm FMLocationMarker对象
     */
    addLocationMarker: function(lm) {
        this.mapView.scene.add(lm.o3d_);

        if (lm._init_) {
            lm._init_();
        }
    },

    /**
     * 移除定位标注物
     * @method removeLocationMarker
     * @param {fengmap.FMLocationMarker} lm FMLocationMarker对象
     */
    removeLocationMarker: function(lm) {
        if (lm) {
            lm.dispose();
        }
    },

    getModelByName: function(name) {
        return this.mapScene.getO3dScene().getObjectByName(name);
    },

    //
    dumpScene_: function(o3d, indent) {
        if (o3d === undefined) {
            this.dumpScene_(this.mapView.scene, '');
        } else {
            console.log(indent, o3d.position);
            for (var i = 0; i < o3d.children.length; i++) {
                this.dumpScene_(o3d.children[i], '  ' + indent);
            }
        }
    },

    getGroupHeight: function(gid) {
        // console.warn('Deprecated, use .getFMGroup(gid).groupHeight instead!');
        // console.log(gid, this.mapScene.getO3dGroup(gid));
        var g = this.mapScene.getO3dGroup(gid);
        return g ? g.position.y : null;
    },

    // #20160429,Samuel,E
    /**
     * 屏幕坐标转地图坐标
     * @method coordScreenToMap
     * @param  {float} x 屏幕坐标点x值.
     * @param  {float} y 屏幕坐标点y值.
     * @param  {float} z 为当前楼层高度值和模型高度值之和.
     * @return  {fengmap.FMScreenCoord} 返回fengmap.FMScreenCoord 地图坐标对象
     * @demo map/坐标转换.js
     */
    coordScreenToMap: function(x, y, z, isFloat, giveMeRaw) {
        var cam = this.currentCamera_ || this.mapView.camera;

        // z 值的默认值,当前层的高度
        var gh = this.getGroupHeight(this.focusGroupId_);
        // 如果此层尚示加入
        if (gh == undefined) {
            return;
        }

        z = z === undefined ? gh + this.options.pickCoordHeight : z;

        var p = null;
        if (isFloat) { // 小数 比例值 -1 ~ 1
            p = new fm.Vector3(x, y, z);
        } else { // 鼠标的x,y坐标
            p = new fm.Vector3((x / this.mapView.w_) * 2 - 1, 1 - (y / this.mapView.h_) * 2, .5);
        }

        var ray = new fm.Raycaster();
        ray.setFromCamera(p, cam);

        // use mesh
        this.plane_.position.y = z;

        // 因为会移动, 所以在计算前需要更新下plane的MatrixWorld
        this.plane_.updateMatrixWorld();
        this.forceUpdate();

        var inters = ray.intersectObject(this.plane_);

        if (inters.length > 0) {
            var pt = inters[0].point;
            if (giveMeRaw) {
                return {
                    x: pt.x,
                    y: z,
                    z: pt.z
                };
            } else {
                return {
                    x: -pt.x - this.mapScene.sceneX_,
                    y: pt.z + this.mapScene.sceneZ_,
                    z: z
                };
            }
        }
        return null;
    },

    /**
     * 地图坐标转屏幕坐标
     * @method coordMapToScreen
     * @param  {float} x 地图坐标点x值
     * @param  {float} y 地图坐标点y值
     * @param  {float} z 地图坐标点z值
     * @return  {fengmap.FMMapCoord} 返回fengmap.FMMapCoord 地图坐标对象
     */
    coordMapToScreen: function(_x, _y, _z) {
        var x, y, z;
        if (typeof _x == 'object') {
            x = _x.x;
            y = _x.y;
            z = _x.z;
        } else {
            x = _x;
            y = _y;
            z = _z;
        }

        if (z == undefined) {
            z == 0;
        }
        var cam = this.currentCamera_;
        var pos = new fm.Vector3(-x - this.mapScene.sceneX_, z, y - this.mapScene.sceneZ_);
        pos.project(cam);
        var w2 = this.mapView.w_2_;
        var h2 = this.mapView.h_2_;
        return {
            x: pos.x * w2 + w2,
            y: h2 - pos.y * h2,
            z: z
        };
    },

    project_: function(o3d) {
        var p = new fm.Vector3();
        p.setFromMatrixPosition(o3d.matrixWorld);
        p.project(this.currentCamera_); // (-1,1)
        var x = p.x * this.mapView.w_2_;
        var y = p.y * this.mapView.h_2_;
        return {
            x: x + this.mapView.w_2_,
            y: -y + this.mapView.h_2_
        }; // screen coord
    },

    // #20160520,Samuel,new APIs
    /**
     * 获取当前模型的所有楼层ID集合
     * @property groupIDs
     * @type {array}
     */
    get groupIDs() {
        // return this.groupIDs_;
        var ss = this.mapService.staticScene_;

        if (!ss) {
            return [];
        } else {
            return ss.scene.layerGroups.map(function(l) {
                return l.gid;
            });
        }

    },

    // readonly
    // set groupIDs(value) {
    // 	this.groupIDs_ = value;
    // },

    /**
     * 倾斜度，取值范围 0 - 60
     * @property tiltAngle
     * @type {float}
     */
    get tiltAngle() {
        return (Math.PI / 2 - this.controls.constraint.getPolarAngle()) * fm.Math.RAD2DEG;
    },

    set tiltAngle(v) {
        v = (90 - v) * fm.Math.DEG2RAD;
        if (v < this.controls.minPolarAngle) v = this.controls.minPolarAngle;
        if (v > this.controls.maxPolarAngle) v = this.controls.maxPolarAngle;

        this.controls.update({
            forcePhi: v
        });
        this.updateCountDown_ = 0;
        // this.update_();
    },

    /**
     * 旋转度，取值范围 -360 ~ 360,正为顺时针，负为逆时针
     * @property rotateAngle
     * @type {float}
     */
    get rotateAngle() {
        var v = this.controls.constraint.getAzimuthalAngle();
        return (this.viewMode == '3d' ? Math.PI - v : -v) * fm.Math.RAD2DEG;
    },

    set rotateAngle(v) {
        v = -v * fm.Math.DEG2RAD;
        this.controls.update({
            forceTheta: v + (this.viewMode == '3d' ? Math.PI : 0)
        });
        this.updateCountDown_ = 0;
    },

    /**
     * 将地图的倾斜角度缓动至
     * @method tiltTo
     * @param  {Json} params {to: 45, duration: 1, callback: function() {}}
     */
    tiltTo: function(ps) {
        var s = this;
        if (typeof ps == 'number') {
            ps = {
                to: ps
            };
        }

        // tilt angle limit
        ps.to = fm.Math.clamp(ps.to, this.minTiltAngle, this.maxTiltAngle);

        var _time = fmg(ps, 'time', 'duration', .3);

        var from = this.tiltAngle;
        var _angle = ps.to - from;
        clearInterval(s._tiltToID);
        s._tiltToID = fm.Tween.work(_time, function(f) {
            s.tiltAngle = from + _angle * f;
        }, function() {
            if (ps.callback) {
                ps.callback();
            }
        });

        return s._tiltToID;
    },

    /**
     * 将地图水平旋转至
     * @method rotateTo
     * @param {Json} params {to: 45, duration: 1, callback: function() {}}
     */
    rotateTo: function() {
        // 在角度的运算中,得到给定的两个角度值之间最少的角度值
        function getAngle(from, to) {
            var _t = to - from;
            if (Math.abs(_t) > 180) {
                _t = -1 * Math.sign(_t) * 360 + _t;
            }
            return _t;
        }

        return function(ps) {
            var s = this;
            if (typeof ps == 'number') {
                ps = {
                    to: ps
                };
            }

            var _time = fmg(ps, 'time', 'duration', .3);

            var from = s.rotateAngle;
            var _angle = getAngle(from, ps.to);

            var val;
            clearInterval(s._rotateToID);
            s._rotateToID = fm.Tween.work(_time, function(f) {
                val = from + _angle * f;
                if (val <= 0) {
                    val = 360 + val;
                } else if (val >= 360) {
                    val = val - 360;
                }

                s.rotateAngle = val;
            }, function() {
                if (ps.callback) {
                    ps.callback();
                }
            });

            return s._rotateToID;
        }
    }(),
};

//load map state
fengmap.Map.IsMapLoading = false;
fengmap.Map.IsThemeLoading = false;


// #20160122,Enhance in the future!
/**
 *	FMLineMarker为线图层，可包含很多条折线类FMSegment
 * 	@class FMLineMarker
 *	@constructor
 * 	@module FMMap
 *   @namespace fengmap
 *   @demo layer/添加线图层.js
 */
fengmap.FMLineMarker = function() {
    this.segments = [];
};
fengmap.FMLineMarker.prototype = {
    /**
     * 添加折线对象
     * @method addSegment
     * @param  {fengmap.FMSegment} seg 折线对象
     */
    addSegment: function(seg) {
        this.segments.push(seg);
    }
};

/**
 *	FMSegment点集，一个点集代表一条折线
 * 	@class FMSegment
 *	@constructor
 * 	@module FMMap
 *   @namespace fengmap
 */
fengmap.FMSegment = function() {

    /**
     * groupID,
     * points, // FMMapCoord Array
     */

};

fengmap.FMSegment.prototype = {
    /**
     * 设置该折线所在的楼层id
     * @property groupId
     * @type {string|number}
     */
    get groupId() {
        return this.groupid;
    },
    set groupId(v) {
        this.groupid = v;
    },
    get groupID() {
        return this.groupid;
    },
    set groupID(v) {
        this.groupid = v;
    },

    /**
     * 设置该折线的所有坐标点
     * @property points
     * @type {array} fengmap.FMMapCoord地图坐标点集合
     */
    get points() {
        return this.points_;
    },
    set points(v) {
        this.points_ = v;
    }
};
/**
 * 
 */

fengmap.MapConfiguration = {
	
	// EXTENT_EPSILON_Y: -0.5,
	EXTENT_EPSILON_Y: -0.5,
	SCENE_AXIS: false
		
};
/**
 *	MapOptions 是设置加载地图地址，主题数据地址，是否使用静态数据等参数的类
 * 	@class MapOptions
 * 	@module FMMap
 * 	@constructor
 *   @namespace fengmap
 *   @param {object} options 地图参数配置
 *             @param {object} options.container  加载地图html容器,必须的设置。
 *			  @param {string} options.appName 必须的设置,可通过蜂鸟云平台-》我的应用-》创建应用
 *			  @param {string} options.key 必须的设置,key可通过蜂鸟云平台-》我的应用-》创建应用-》添加key添加	
 *			  @param {boolean} options.lazyCreateMode “懒创建” 模式，此模型针对大地图做了“按需创建”的优化，此模式开启后，部分接口在使用上会有变化，如loadComplete事件，map.search方法等，祥情请参见版本的更新说明及开发指南。
 *             @param {string} options.mapServerURL 设置地图路径，跟useStatic设置有关,默认是从蜂鸟视图服务器上获取地图
 *             @param {string}  options.mapThemeURL 设置主题路径
 *             @param {string}  options.defaultThemeName 设置默认主题名称，默认为‘2001’，设置后主题对应文件夹路径为：options.mapThemeURL+options.defaultThemeName。
 *             @param {boolean} options.useStoreApply 开启支持主题中模型的自定义样式
 *             @param {array}  options.defaultVisibleGroups 初始显示楼层ID数组。
 *             @param {int}  options.defaultFocusGroup 初始聚焦楼层ID。
 *             @param {boolean}  options.modelSelectedEffect 支持单击模型高亮，false为单击时模型不高亮
 *             @param {boolean}  options.modelHoverEffect 支持悬停模型高亮，false为悬停时模型不高亮
 *             @param {boolean}  options.modelHoverTime 悬停时间触发时间，默认1000,参数数值表示毫秒时长。
 *             @param {boolean} options.focusAlphaMode 是否对不聚焦图层启用透明设置 默认为true
 *             @param {float} options.focusAlpha 对不聚焦图层启用透明设置 默认为0.1。值范围为 0-1。此属性只有当options.focusAlphaMode = ture是有效
 *             @param {boolean} options.focusAnimateMode 是否开启聚焦图层切换的动画显示。默认true 
 *             @param {fengmap.FMViewMode} options.defaultViewMode 初始二维还是三维状态，fengmap.FMViewMode.MODE_2D|fengmap.FMViewMode.MODE_3D ,默认3维显示。
 *             @param {fengmap.FMViewMode} options.viewModeAnimateMode 是否启用2D，3D模式切换时的动画效果。默认true
 *             @param {boolean} options.moveToAnimateMode  是否启用拾取地图物体时相机的移动动画效果。 默认true。
 *             @param {JSON} options.defaultControlsPose  设置地图默认状态。值可为方向枚举、角度值、或特定角度的Json对象的任意一种
 *             @param {number} options.defaultMapScaleLevel  设置地图初始显示比例尺级别。范围为1-29之间的整数值。如29级的比例尺为1:1厘米。
 *             @param {array} options.mapScaleLevelRange  设置比例尺级别可缩放范围， 通常室内地图使用到的范围为16级到23级。即：[16,23]。
 *             @param {number} options.defaultMapScale  设置地图初始显示自定义比例尺级别。如设置1000，为1:1000（厘米）的显示状态。defaultMapScale的优先级比defaultMapScaleLevel的优先级高。
 *             @param {array} options.mapScaleRange  设置自定义比例尺范围，单位（厘米），如[200,4000]。
 *             @param {array} options.compassOffset  设置初始指南针的偏移量，默认为[10,20],左：10px,上：20px。
 *             @param {numbumer} options.compassSize  设置指南针大小,默认64px。
 *             @param {number} options.defaultGroupSpace  设置初始地图的楼层间距,默认从数据中读取楼层高度.
 *             @param {boolean} options.enabledPanRange 是否开启平移地图范围限制,默认为true
 *             @param {boolean} options.defaultBackgroundColor 默认背景颜色: 0xff00ff, '#00ff00'
 *             @param {boolean} options.defaultBackgroundAlpha 默认背景透明度: 0 ~ 1
 *             @param {boolean} options.noSideFaces 只用于纯2D视图，在创建store时，不会生成侧面，提高渲染效率
 *             @param {fengmap.FMLanguageType} options.defaultLabelLanguage 默认label的语言类型，显示英文或者中文         
 *   @demo map/参数设置.js
 */
fengmap.MapOptions = function(options) {

	var protocol = window.location.protocol === 'https:' ? 'https://' : 'http://';

	var DEFAULT_MAPSERVERURL = protocol + 'source.fengmap.com/newmap'; // fengmap的服务器地址!
	// var DEFAULT_MAPSERVERURL = 'http://192.168.1.222:18081/FMCloud/sdk/auth/downMaps';   // fengmap的服务器地址!
	var DEFAULT_MAPTHEMEURL = protocol + 'source.fengmap.com/webtheme'; // fengmap的服务器地址!

	// 懒创建 模式
	this._lazyCreateMode = false;

	Object.defineProperties(this, {
		lazyCreateMode: {
			get: function() {
				return this._lazyCreateMode;
			},
			set: function(value) {
				this._lazyCreateMode = value;
				this.mergeModels = !value;
			}
		}
	})

	// key & appName
	this.key = null;
	this.appName = null;

	// 全局设置
	this.mapServerURL = 'fengmap';
	this.mapThemeURL = DEFAULT_MAPTHEMEURL;

	// this.useStatic    = true;
	this.useProtoBuf = true;
	this.container = document.body;

	//指南针位置偏移量,左 + 上
	this.compassOffset = [28, 20];
	this.compassSize = 50;
	// 指南针的自定义背景/前景图
	this.compass_fg = null;
	this.compass_bg = null;

	// 是否分层加载, 分层文件放入如: ./data/90114/separate/  目录下
	this.isSeparate = false;

	// 是否是 "读取了整体fmap" 的情况下分层解析
	this.isDecodeByVisible = false;

	// 每层加载完成后的回调: function(gid) {...}
	this.groupLoadedCallback = null;

	// theme
	this.defaultThemeName = '2001';

	// 焦点层相关设置
	this.focusAnimateMode = true;
	this.focusAnimateTime = .3;
	this.focusAlphaMode = true;
	this.focusAlpha = .1;

	// 2D / 3D 视图切换相关设置
	this.viewModeAnimateMode = true;
	this.viewModeAnimateTime = .3;

	// Move To 相关设置
	this.moveToAnimateMode = true;
	this.moveToAnimateTime = .3;

	// 合并每一层的"模型线", 20180309 ztc 这个先默认为false吧。 因为合并了，就不支持storeApply的自定义颜色了
	this.mergeModelLines = false;

	// 合并每一层的Model,提升效率
	this.mergeModels = true;

	// 模型选择时的反馈(颜色与闪烁)
	this.modelSelectedEffect = true;

	// 模型悬停时的反馈(颜色与闪烁)
	this.modelHoverEffect = false;
	this.modelHoverTime = 1000;

	// 缩放级别 0 ~ 6
	this.minScaleLevel = 0;
	this.maxScaleLevel = 6;
	this.defaultScaleLevel = 3;

	// 比例尺缩放级别 1 ~ 29
	this.mapScaleLevelRange = [16, 23]; // [16, 23];
	this.mapScaleRange = null; // [200, 4000];
	this.defaultMapScaleLevel = null;
	this.defaultMapScale = null;

	// 相机的最小距离(米), 此方法可以突破ScaleLevel的限制,因为他的最小0.2,
	// 在某些大场景的情况下,最小的相机距离还是很远,不够合适
	this.minViewDistance = 2000; // 20161117 在没有mapScale之前使用的值是 20

	// 默认可见层及聚焦层
	this.defaultVisibleGroups = [1];
	this.defaultFocusGroup = 1;

	// 默认显示模式
	this.defaultViewMode = '3d';

	// 阴影
	this.shadowEnabled = false;
	this.lightAngleX = 45;
	this.lightAngleY = 45;
	this.shadowSize = 2048;
	this.shadowAlpha = .6;

	// Store Image Angle DEG
	this.storeImageAngle = 0;

	// 导航线动画开关
	this.naviLineAnimation = true;

	// 控制器灵敏度相关
	this.controlsRotateThreshold = .03; // 越小越灵敏
	this.controlsScaleThreshold = .03; // 越小越灵敏

	// 默认的层间距,设置为null从数据中读取.
	this.defaultGroupSpace = 50;

	// 被动渲染模式
	this.passiveMode = false;

	// 主题版本(在Label POI)等的大小计算上有不同.
	this.themeVersion = null;

	// 主题中图片文件的类型: image | base64
	this.themeFileType = null;

	this.cornerRoundLimit = 1;

	/**
	 * 楼梯的配置参数:
	 * 		steps: 15,			// 台阶的级数
	 * 		stepHeight: .2,		// 台阶高度
	 * 		stepDepth: .3,		// 台阶深度
	 * 		width: 1.5,			// 楼梯宽度
	 * 		color: 0x4EE996,	// 颜色
	 * 		inverse: true,		// 反向
	 * 		halfSpace: 2,		// 休息平台宽度
	 * 	 	depth: true 		// shader 深度
	 */
	this.stairsConfig = {};

	/**
	 * 设置默认的相机控制器的位置及目标点的位置
	 * 此值,可以能过 fengmap.MapUtil.getControlInfo() 得到
	 * 3种方式:
	 *  1. fengmap.FMDirection
	 *  2. 角度值 number
	 *  3. object 如下:
	 * 
	 *  	defaultControlsPose: {
	 *	 		target:"-9.213,300.000,-1.258",
	 *	 	 	postion:"-48.963,333.084,24.005"
	 *  	}
	 *
	 *  默认地图旋转-15度
	 */
	this.defaultControlsPose = null;

	// 默认的倾斜角度
	this.defaultTiltAngle = 30;

	// 默认的最大的倾斜角度
	this.defaultMaxTiltAngle = 89.9;

	this.defaultMinTiltAngle = 30;

	// 可以设置 extent 高度, 默认为 -.5 : MapConfiguration
	// this.extentHeight = undefined;
	this.extentHeight = 0;

	// label POI 渐隐渐现
	this.poiLabelFadeMode = false;
	this.poiLabelFadeSpeed = 5;

	this.defaultBackgroundColor = null;
	this.defaultBackgroundAlpha = null;

	this.storeImageDistanceEnabled = false;
	this.storeImageDistance = 500;

	this.useStoreApply = false;

	// frame rate 无操作时,每秒钟渲染的帧数 FPS 1 ~ 60
	this.frameRate = 12;

	// 默认的中心点
	this.defaultViewCenter = null;

	// 点击事件,自动得到当前的地图坐标, 所用到的height属性
	this.pickCoordHeight = 1;

	// 模型文件后缀
	this.modelFileSuffix = 'js';

	// 开启 FXAA 抗锯齿
	this.enabledFXAA = false;

	// 开启 平移地图范围限制
	this.enabledPanRange = true;

	// level show 
	this.levelShowOffset = 0;

	this.defaultLabelLanguage = fengmap.FMLanguageType.CHN;

	// 在最后, 使用自定义的设置覆盖默认设置
	Object.assign(this, options);
	if (this.modelHoverTime < 0) {
		this.modelHoverTime = 1000;
	}

};
/**
 * 
 */

fengmap.MapPicker = function() {
	this.map_ = null;
	this.raycaster_ = new fm.Raycaster();
	this.compassRaycaster_ = new fm.Raycaster();

	this.clickMouse_ = null;
	this.hoverMouse_ = null;
	this.hoverTimeout_ = null;

	this.models_ = [];
	this.objects_ = [];
	this.componentObjs_ = [];

	this.isIntersectedObject_ = false;
	this.isIntersectedModel_ = false;
	this.isintersectedComponent_ = false;

	this.intersectedObjects_ = [];
	this.intersectedModels_ = [];
	this.intersectedComponent_ = null;

	this.container = null;
	
	this.init_ = false;
	this.enableClick_ = true;
	this.enableHover_ = false;

	fm.Evento.convert(this);
};

fengmap.MapPicker.prototype = {
	eventID: 0,

	start:function(map, dom) {

		//this.camera_ = camera;
		this.map_ = map;
		this.container = map.mapView.container_;

		this.dom_ = dom;

		this.mouseoutfun = this.mouseout_.bind(this);
		this.mousedownfun = this.mousedown_.bind(this);
		this.mousemovefun = this.mousemove_.bind(this);
		this.mouseupfun = this.mouseup_.bind(this);

		if (!this.init_) {
			this.init_ = true;
			dom.addEventListener('mouseout',  this.mouseoutfun);
			dom.addEventListener('mousedown',  this.mousedownfun);
			dom.addEventListener('mousemove',  this.mousemovefun);
			dom.addEventListener('mouseup',    this.mouseupfun);
			dom.addEventListener('touchstart', this.mousedownfun);
			dom.addEventListener('touchmove',  this.mousemovefun);
			dom.addEventListener('touchend',   this.mouseupfun);
		}
		this.models_ = [];
		this.objects_ = [];
		this.componentObjs_ = [];
	},

	dispose: function() {
		if (this.dom_) {
			this.dom_.removeEventListener('mouseout',  this.mouseoutfun);
			this.dom_.removeEventListener('mousedown',  this.mousedownfun);
			this.dom_.removeEventListener('mousemove',  this.mousemovefun);
			this.dom_.removeEventListener('mouseup',    this.mouseupfun);
			this.dom_.removeEventListener('touchstart', this.mousedownfun);
			this.dom_.removeEventListener('touchmove',  this.mousemovefun);
			this.dom_.removeEventListener('touchend',   this.mouseupfun);
		}
		
		this.models_ = [];
		this.objects_ = [];
		this.componentObjs_ = [];

		this.intersectedObjects_ = [];
		this.intersectedModels_ = [];
		this.intersectedComponent_ = null;
	},

	addModel:function(mesh) {
		if (!mesh.meta_) {
			mesh.meta_ = {}
		}

		mesh.meta_.type_ = 'Model';
		this.models_.push(mesh);
	},

	///////////////
	// component //
	///////////////
	addComponent: function (obj) {
		this.componentObjs_.push(obj);
	},

	removeComponent: function (comObj) {
		this.removeObject(comObj, null, this.componentObjs_);
	},
	/////////////////////////////////	

	removeModels: function(obj, isModel) {
		this.removeObject(obj, isModel);
	},

	removeObject: function(obj, isModel, arr) {
		obj = [].concat(obj);

		if (isModel == undefined) {
			isModel = true;
		}

		arr = arr || (isModel ? this.models_ : this.objects_);

		for (var i = 0; i < arr.length; i++) {
			var m = arr[i];

			if (obj.indexOf(m) > -1) {
				// var removed = arr[i];
				arr.splice(i, 1);
				i --;
			}
		}
	},

	addUserPOI:function(obj) {	
		obj.meta_ = {type_:'UserPOI', }
		this.objects_.push(obj);
	},

	addUserLabel:function(obj) {
		obj.meta_ = {type_:'UserLabel', }
		this.objects_.push(obj);
	},
	
	addPOI:function(obj) {
		obj.meta_ = {type_:'POI'};
		this.objects_.push(obj);
	},

	addLabel:function(obj) {
		obj.meta_ = {type_:'Label'};
		this.objects_.push(obj);
	},
	
	get enableClick() {
		return this.enableClick_;
	},
	
	set enableClick(value) {
		this.enableClick_ = value;
	},

	get enableHover() {
		return this.enableHover_;
	},
	
	set enableHover(value) {
		this.enableHover_ = value;
	},


	/**
	 * 得到物体是否处理可见状态
	 */
	isVisible: function(obj) {
		if (!obj.visible) {return false;}

		/// -----------------------------------------
		/// 如果map中设置了拾取排除数组
		/// {
		/// 	nodeType: []
		/// 	typeID: []
		/// }
		/// ------------------START------------------

		var excludes = this.map_.pickExclude;
		
		if (obj.fm_ && excludes) {

			var keys = Object.keys(excludes);

			for (var i = 0, il = keys.length; i < il; i ++) {
				var itm = keys[i];
				
				if (excludes[itm].indexOf(obj.fm_[itm]) > -1) {
					return false;
				}
			}

		}
		
		/// -------------------END-------------------

		// fadeVisible Label | POI 的渐隐渐现
		if (obj.fm_ && obj.fm_.constAlpha != undefined && obj.fm_.constAlpha > 0) { return true; }
		if (obj.fadeVisible === false) {return false;}

		var res = true;
		obj.traverseAncestors(function(itm) {
			if (!itm.visible || itm.fadeVisible === false) {
				res = false;
			}
		});
		return res;
	},

	clickCompass: function() {
		if (this.clickMouse_) {
			this.compassRaycaster_.setFromCamera(this.clickMouse_, this.map_.mapView.cameraOrtho);

			if (!this.map_.compass_.spriteBg_) {
				return;
			}

			var res = this.compassRaycaster_.intersectObject(this.map_.compass_.spriteBg_);
			if (res.length > 0) {
				this.map_.emit('mapClickCompass');
			}
		}
	},

	update:function() {
		if ((this.enableClick_||this.enableHover_) && (this.clickMouse_||this.hoverMouse_) ){

			if (this.enableClick_&&this.clickMouse_) {
				this.raycaster_.setFromCamera(this.clickMouse_, this.map_.currentCamera_);
			}else if (this.enableHover_&&this.hoverMouse_) {
				this.raycaster_.setFromCamera(this.hoverMouse_, this.map_.currentCamera_);
			}
			
			this.isIntersectedObject_    = false;
			this.intersectedObjects_ = [];
			this.intersectedModels_  = [];

			var visibleObjects = [];
			for (var i = 0; i< this.objects_.length; i++) {
				var obj = this.objects_[i];
				
				//TODO obj 一定会有parent，需要增加remove list in the future!
				// if (obj.parent && obj.parent.visible) {
				if (this.isVisible(obj)) {
					visibleObjects.push(obj);
				}
			}
			
			//var intersects = this.raycaster_.intersectObjects(this.objects_);
			var intersects = this.raycaster_.intersectObjects(visibleObjects);
			
			if (intersects.length>0) {
				this.intersectedObjects_ = intersects;
				this.isIntersectedObject_ = true;
			}
	

			// if (!this.isIntersectedObject_) { 	// 这一行会使 POI 阻挡模型, 先去掉吧
			if (true) {
				this.isIntersectedModel_ = false;

				var visibleModels = [];
				for (var i = 0; i< this.models_.length; i++) {
					var obj = this.models_[i];
					
					// if (obj.parent.parent.visible) {
					if (this.isVisible(obj)) {
						visibleModels.push(obj);
					}
				}
				
				intersects = this.raycaster_.intersectObjects(visibleModels);
				if (intersects.length>0) {
					this.intersectedModels_ = intersects;
					this.isIntersectedModel_ = true;
				}
			}

			/////////////////////
			// pick components //
			/////////////////////
			var comPickeds = this.raycaster_.intersectObjects(this.componentObjs_);

			this.isintersectedComponent_ = false;

			if (comPickeds.length > 0) {
				for (var i = 0; i < comPickeds.length; i++) {
					var obj = comPickeds[i].object
					if (!this.isVisible(obj) || !obj.enabled) {continue;}
					if (!obj.component) {continue;}
					if (!obj.component.picked) {continue;}
					// obj.component.picked();
					this.isintersectedComponent_ = true;
					this.intersectedComponent_ = obj.component;
					return;
				}
			}
			/////////////////////////////////
		}
	},

	//private
	mouseout_: function(event)	{
		if (!this.enableHover_) {
			return;				
		}

		this.resetHoverTimeout_();
	},

	mousedown_: function(event) {
		if (!this.enableClick_) {
			return;				
		}

		this.resetHoverTimeout_();

		this.clickMouse_ = this.getPick_(event);
		this.curMouse = this.clickMouse_.clone();

		// get picked objects or models
		this.update();

		event.preventDefault();
	},

	mousemove_: function(event) {

		if (event.touches || event.changedTouches) { return;}

		if (!this.enableHover_ || this.clickMouse_) {return;}

		this.resetHoverTimeout_();

		var self = this;
		this.hoverTimeout_ = setTimeout(function(){

			self.hoverMouse_ = self.getPick_(event);

			self.eventID ++;

			self.curMouse = self.hoverMouse_.clone();

			// get picked objects or models
			self.update();

			if (self.isIntersectedObject_ || self.isIntersectedModel_ || self.isintersectedComponent_) {
				if (self.isIntersectedObject_) {
					self.emit('hoverObjects_', {intersects:self.intersectedObjects_, mouse: self.curMouse, domEvent: event, eventID: self.eventID});
				}
				if (self.isIntersectedModel_) {
					self.emit('hoverModels_', {intersects:self.intersectedModels_, mouse: self.curMouse, domEvent: event, eventID: self.eventID});
				}
				if (self.isintersectedComponent_) {
					self.emit('hoverComponent_', {component: self.intersectedComponent_, mouse: self.curMouse, domEvent: event, eventID: self.eventID});
					if (self.intersectedComponent_) {
						self.intersectedComponent_.picked({component: self.intersectedComponent_, mouse: self.curMouse, domEvent: event, eventID: self.eventID});
					}
				}
			}else {
				// 空白点击
				self.emit('hoverNone_', {mouse: self.curMouse, domEvent: event, eventID: self.eventID});
			}

			self.resetHoverTimeout_();

		},this.map_.options.modelHoverTime);

		event.preventDefault();
	},

	mouseup_: function(event) {
		if (!this.enableClick_ || !this.clickMouse_) {return;}

		this.eventID ++;
		this.curMouse = this.getPick_(event);

		// 触发点击事件
		if ((event.button==0 || event.button==2 || event.touches || event.changedTouches) &&  this.curMouse.distanceTo(this.clickMouse_) < .01) {

			// compass click
			this.clickCompass();

			// 判断输入模式
			if (this.map_.inputMode != fengmap.FMInputMode.SELECT) {
				return;
			}

			if (this.isIntersectedObject_ || this.isIntersectedModel_ || this.isintersectedComponent_) {
				if (this.isIntersectedObject_) {
					this.emit('pickerObjects_', {intersects:this.intersectedObjects_, mouse: this.curMouse, domEvent: event, eventID: this.eventID});
				}
				if (this.isIntersectedModel_) {
					this.emit('pickerModels_', {intersects:this.intersectedModels_, mouse: this.curMouse, domEvent: event, eventID: this.eventID});
				}
				if (this.isintersectedComponent_) {
					this.emit('pickerComponent_', {component: this.intersectedComponent_, mouse: this.curMouse, domEvent: event, eventID: this.eventID});
					if (this.intersectedComponent_) {
						this.intersectedComponent_.picked({component: this.intersectedComponent_, mouse: this.curMouse, domEvent: event, eventID: this.eventID});
					}
				}
			} else {
				// 空白点击
				this.emit('pickerNone_', {mouse: this.curMouse, domEvent: event, eventID: this.eventID});
			}
		}

		this.clickMouse_ = null;

		event.preventDefault();
	},

	getPick_: function(e) {
		var clientRect = this.container.getBoundingClientRect();
		var res = new fm.Vector2(), touch = null;

		if (e.touches && e.touches.length > 0) {
			touch = e.touches;
		} else if (e.changedTouches && e.changedTouches.length > 0) {
			touch = e.changedTouches;
		}

		res.x = (((touch ? touch[0].clientX : e.clientX) - clientRect.left) / clientRect.width) * 2 - 1;
		res.y = -(((touch ? touch[0].clientY : e.clientY) - clientRect.top) / clientRect.height) * 2 + 1;

		return res;
	},

	resetHoverTimeout_:function()	{

		if (this.hoverTimeout_ != null) {
			clearTimeout(this.hoverTimeout_);
		}
		this.hoverTimeout_ = null;
	}
};



/**
 *
 */

fengmap.MapService = function(map) {
	this.map_ = map;
	this.options_ = map.options;

	this.useStatic = true;
};

fengmap.MapService.prototype = {
	queryScene:function(sceneId, success, fail) {
		var this_ = this;

		// ajax 请求从自定义路径(本地/服务器上请求)
		function _ajax(url, isSeparate) {
			var scene = null;
			new fm.Ajax(url, function(d) {
				if (isSeparate) {
					scene = this_.convertSite1_(d);		// 解析scene
				} else {
					scene = this_.convertStatic1_(d);	// 解析map
				}

				if (scene) {
					if (fengmap.Map.tempFlipX_) {
						this_.tempFlipX_(scene);
					}
					if (success) {success(scene);}
				} else {
					fm.warn(fm.gs(fm.ss.warn_openerror));
					// if (fail) {fail({msg:'文件解析失败'});}
				}
			},true,fail);
		}

		// ajax 从蜂鸟云上请求地图文件, 判定: mapServerURL = 'fengmap'
		function _ajaxSer(isSeparate) {
			if (!navigator.onLine) {
				fm.warn(fm.gs(fm.ss.connecterror));
				// if (fail) {fail('not on Line!');}
				return;
			}

			var data = fengmap.getCerityData(this_.map_, sceneId);

			var _data = {
				mapId: data.mapId,
				keyValue: data.appKey,
				appName: data.appName,
				webUrl: data.webURL,
				keyType: 3,  // web platform flag
				isSeparate: (isSeparate == undefined ? false : isSeparate)
			};

			var scene = null;

			new fm.Ajax(fengmap.urls.fmFileServer, function(result) {
				if (isSeparate) {
					scene = this_.convertSite1_(result);
				} else {
					scene = this_.convertStatic1_(result);
				}

				if (scene) {
					if (fengmap.Map.tempFlipX_) {
						this_.tempFlipX_(scene);
					}
					if (success) {success(scene);}
				} else {
					if (fail) {fail(result);}
				}
			}, true, function(result) {
				fm.warn(fm.gs(fm.ss.warn_downloaderror));
				// if (typeof result === 'object' && result.error_code) {
				// 	fm.warn(result.error_code, result.error_message);
				// }
				if (fail) {fail(result);}
			}, JSON.stringify(_data));
		}

		if (this.options_.useProtoBuf) {
			if (this.useStatic && !this.options_.isSeparate) {	//使用一个.fmap文件
				// var url = this.options_.mapServerURL + '/' + sceneId + '.fmap';
				/*fm.Ajax(url, function(d) {
					var scene = this_.convertStatic1_(d);
					if (fengmap.Map.tempFlipX_) {
						this_.tempFlipX_(scene);
					}
					success(scene);
				},true,fail);*/

				if (this.options_.mapServerURL != 'fengmap') {
					var url = this.options_.mapServerURL + '/' + sceneId + '.fmap';
					_ajax(url);
				} else {
					_ajaxSer();
				}
			} else {			//访问多个 .fmap文件,从id.scene.fmap开始
				if (this.options_.mapServerURL != 'fengmap') {
					var url = ''
					if (this.options_.isSeparate) {
						url = this.options_.mapServerURL + '/separate/' + sceneId + '.scene.fmap';
					} else {
						url = this.options_.mapServerURL + '/' + sceneId;
					}

					/*fm.Ajax(url, function(d) {
						var scene = this_.convertSite1_(d);
						if (fengmap.Map.tempFlipX_) {
							this_.tempFlipX_(scene);
						}
						success(scene);
					},true,fail);*/

					_ajax(url, true);
				} else {

					/**
					 * 20161227 目前服务端应该还不支持 "分离" 的数据
					 * 我会在请求的数据中增加一个 isSeparate 字段,来让
					 * 服务区分请求的是否为"分离" 数据
					 */
					_ajaxSer(true);
				}
			}
		} else {
			console.warn("Don't set useProtoBuf = false, it's deprected from v0.3!");
			if (this.useStatic) {
				var url = this.options_.mapServerURL + '/' + sceneId + '/SC_0.json';

				new fm.Ajax(url, function(d) {
					var scene =  JSON.parse(d);
					if (fengmap.Map.tempFlipX_) {
						this_.tempFlipX_(scene);
					}
					success(scene);
				},true,fail);
			} else {
				new fm.Ajax(this.options_.mapServerURL + '/' + sceneId, function(d) {
					var scene =  JSON.parse(d);
					if (fengmap.Map.tempFlipX_) {
						this_.tempFlipX_(scene);
					}

					success(scene);
				},true,fail);
			}
		}
	},

	/**
	 * fromSeparate: 是否从分享的文件中读取Group的信息
	 */
	queryGroup:function(sceneId, groupId, success, fail) {
		var this_ = this;
		if (this.options_.useProtoBuf) {
			if (this.useStatic && !this_.options_.isSeparate) {
				var group = this_.convertStatic2_(groupId);
				if (fengmap.Map.tempFlipX_) {
					this_.tempFlipX_(group);
				}
				success(group);
			} else {

				var url;
				if (this_.options_.isSeparate) {
					url = this.options_.mapServerURL + '/separate/';
				} else {
					url = this_.options_.mapServerURL + '/group_v2/' + sceneId + '/' + groupId + '/';
				}

				var _g = {
					geo: null,
					biz: null,
					navi: null
				};

				// 创建 Ajax 请求
				// type: geo, biz, navi
				function _makeAjax(type) {
					var str = '';

					if (this_.options_.isSeparate) {
						function getGName(gid) {
							var _gs = this_.map_.mapScene.scene_.scene_data.layerGroups;
							for (var i = 0; i < _gs.length; i++) {
								if (_gs[i].gid == groupId) {
									return _gs[i].gname;
								}
							}
						}

						//////////////
						// 这个会少去第一层 //
						//////////////
						// var gname = this_.map_.mapScene.scene_.scene_data.layerGroups[groupId].gname;
						var gname = getGName(groupId);
						str = url + sceneId + '.floor.' + gname + '.' + type + '.fmap';
					} else {
						str = url + type;
					}

					new fm.Ajax(str, function(d) {
						_g[type] = d;
						if (_g.geo != null && _g.biz != null && _g.navi != null) {
							var group = this_.convertSite2_(groupId, _g.geo, _g.biz, _g.navi)
							if (fengmap.Map.tempFlipX_) {
								this_.tempFlipX_(group);
							}
							success(group);
						}
					},true,fail);
				}

				_makeAjax('geo');
				_makeAjax('biz');
				_makeAjax('navi');
			}
		} else {
			console.warn("Don't set useProtoBuf = false, it's deprected from v0.3!");
			if (this.useStatic) {
				new fm.Ajax(this.options_.mapServerURL + '/scene/' + sceneId + '/LG_0_' + groupId + '.json', function(d) {
					var group =  JSON.parse(d);
					if (fengmap.Map.tempFlipX_) {
						this_.tempFlipX_(group);
					}
					success(group);
				});
			} else {
				new fm.Ajax(this.options_.mapServerURL + '/group/' + sceneId + '/' + groupId, function(d) {
					var group =  JSON.parse(d);
					//console.log(group);
					if (fengmap.Map.tempFlipX_) {
						this_.tempFlipX_(group);
					}
					success(group);
				});
			}
		}

	},
	/*
	queryTheme:function(themeName, success, fail) {
		if (this.useStatic) {
			new fm.Ajax(this.options_.mapServerURL + '/theme/' + themeName + '/' + themeName + '.json', function(d) {
				var theme =  JSON.parse(d);
				success(theme);
			});
		} else {
			new fm.Ajax(this.options_.mapServerURL + '/theme/' + themeName + '/' + themeName + '.json', function(d) {
				var theme =  JSON.parse(d);
				success(theme);
			});
		}
	},
	*/
	queryThemeV2:function(themeName, success, fail) {
		// if (this.useStatic) {
			new fm.Ajax(this.options_.mapThemeURL + '/' + themeName + '/' + themeName + '.theme', function(d) {

				var theme =  JSON.parse(d);
				success(theme);
			});
		// } else {
		// 	new fm.Ajax(this.options_.mapThemeURL + '/' + themeName + '/' + themeName + '.theme', function(d) {
		// 		var theme =  JSON.parse(d);//console.log(theme);
		// 		success(theme);
		// 	});
		// }
	},

	/**
	 * 载入资源打包成的 rtheme (JSON) 文件
	 * 此文件的目的是减少 fmi 文件量大的所引起的 http请求数量
	 */
	loadResourcesJson: function(themeName, success, fail) {
		var url = this.options_.mapThemeURL + '/' + themeName + '/' + themeName + '.rtheme';
		new fm.Ajax(url, function(d) {
			var data = JSON.parse(d);
			success(data);
		},false,fail);
	},

	getLabel:function(o) {
		var gd = new geo.GData();
		return {oid:o.eid,vertex:gd.parse(o.geo).toStrip()};
	},
	queryNavigation:function(loc1, loc2, success, fail) {
		new fm.Ajax(this.options_.mapServerURL + '/query/navigation', function(d) {
			var info =  JSON.parse(d);
			success(info);
		}, this.toParams_({
			sceneId1:loc1.sceneId, groupId1:loc1.groupId, x1:loc1.x, y1:loc1.y,
			sceneId2:loc2.sceneId, groupId2:loc2.groupId, x2:loc2.x, y2:loc2.y,
		}));
	},
	// -------------------------------------------------------------------------
	toParams_:function(d) {
		var s = '';
		for (var k in d) {
			if (s.length > 0) {
				s += '&';
			}
			s+= k + '=' + d[k];
		}
		return s;
	},
	//
	staticScene_:null,
	convertStatic1_:function(d) {
		// console.log(d);
		if (!d) {return;}

		this.staticScene_ = fmMapDecode(d);
		// console.log(this.staticScene_);
		var d = {
			//sid:0,
			'scene_data':this.staticScene_.scene,
		};

		var layerGroups = d['scene_data']['layerGroups'];
		for (var i=0; i<layerGroups.length; i++) {
			var lg = layerGroups[i];
			lg['elevation'] = lg['height'];
		}

		// console.log(d);
		return d;
	},

	convertToGroup__:function(groupId,geo_s,biz_s,nav_s) {

		var gd = new geo.GData();//namespace conflict!

		//biz, geo, navi

		//hash biz eid => obj
		var hash_extents
		var hash_labels        = {};
		var hash_models        = {};
		var hash_pois          = {};
		var hash_polygon       = {};
		var hash_polygonLabel  = {};
		var hash_externalModel = {};
		var hash_stairModel = {};
		for (var j=0;j<biz_s.length;j++) {
			var biz_0 = biz_s[j];

			var bll = biz_0['labelLayer'];
			for (var k = 0; k < bll.length; k++) {
				var label = bll[k];
				hash_labels[label['eid']] = label;
			}

			var bml = biz_0['modelLayer'];
			for (var k = 0; k < bml.length; k++) {
				var model = bml[k];
				//console.log(model.eid, model);// eid, fid, type, name, ename
				hash_models[model['eid']] = model;
			}

			var bpl = biz_0['poiLayer'];
			for (var k = 0; k < bpl.length; k++) {
				var poi = bpl[k];
				//console.log(poi.eid, poi);
				hash_pois[poi['eid']] = poi;
			}

			bpl = biz_0['polygonLayer'];
			for (var k = 0; k < bpl.length; k++) {
				var polygon = bpl[k];
				hash_polygon[polygon['eid']] = polygon;
			}

			bpl = biz_0['polygonLabelLayer'];
			for (var k = 0; k < bpl.length; k++) {
				var polygon = bpl[k];
				hash_polygonLabel[polygon['eid']] = polygon;
			}

			bpl = biz_0['externalModelLayer'];
			bpl.forEach(function(itm) {
				hash_externalModel[itm.eid] = itm;
			});

			bpl = biz_0['stairLayer']; //步行梯model
			bpl.forEach(function(itm) {
				hash_stairModel[itm.eid] = itm;
			})
		}

		//
		var extents = [];
		var models = [];
		var labels = [];
		var pois = [];
		var stairs = [];

		for (var j=0;j<geo_s.length;j++) {
			var geo_0 = geo_s[j];

			var gel = geo_0['extentLayer'];
			for (var k = 0; k < gel.length; k++) {
				var o = gel[k];
				//console.log('ext.geo',o.geo);
				var geometry = this.convertGeo2Geometry_(o['geo']);
				geometry.fid = o['eid'];//maybe,  TODO	可能错误！
				// console.log(o);
				geometry.height = o['height'];
				extents.push(geometry);
			}

			var gml = geo_0['modelLayer'];
			for (k = 0; k < gml.length; k++) {
				var o = gml[k];
				//console.log(o);
				//{area,eid,geo,height} => {fid,type,oid,vertices,indices}
				var geometry    = this.convertGeo2Geometry_(o['geo']);
				geometry.oid    = o['eid'];//maybe
				var model       = hash_models[o['eid']];
				geometry.type   = model['type'];
				geometry.height = o['height'];
				geometry.fid    = model['fid'];
				geometry.minLevel = model.minlevel;
				geometry.maxLevel = model.maxlevel;

				geometry.ename = model.ename || '';

				// console.log(model);
				geometry.name = model.name;
				geometry.gid = groupId;
				models.push(geometry);
			}

			//stairLayer
			var star = geo_0['stairLayer'];
			for(k = 0; k < star.length;k++) {
				var s = star[k];

				var stair = hash_stairModel[s['eid']];
				stair.vertex = gd.parse(s['geo']).toStrip();
				stairs.push(stair);
			}

			//label
			var gll = geo_0['labelLayer'];
			for (k = 0; k < gll.length; k++) {
				var o = gll[k];

				// console.log(o);//{ eid: 45, geo: "POINT(12961648.4030467 4861838.1049…", height: -1, area: null }
				var label = hash_labels[o['eid']];

				labels.push({
					oid:o['eid'],
					type: label.type,
					height: o['height'],
					minLevel: label.minlevel,
					maxLevel: label.maxlevel,
					vertex:gd.parse(o['geo']).toStrip(),
					ename:(label!=null && label['ename']!=null)?label['ename']:'',
					name:(label!=null && label['name']!=null)?label['name']:''
				});
			}

			//poi
			var gpl = geo_0['poiLayer'];
			for (k = 0; k < gpl.length; k++) {
				var o = gpl[k];
				if (o.height && o.height == -1) {
					o.height = null;
				}
				// console.log(o);//{ eid: 54, geo: "POINT(12961648.4030467 4861838.1049…", height: null, area: null }
				var poi = hash_pois[o['eid']];
				pois.push({fid:o['eid'], height: o.height,vertex:gd.parse(o['geo']).toStrip(),name:(poi!=null && poi['name']!=null)?poi['name']:'',
					type:poi!=null?poi['type']:150001, minLevel: poi.minlevel, maxLevel: poi.maxlevel});
			}

			// polygon
			var polygons = [];
			var ply = geo_0['polygonLayer'];
			for (k = 0; k < ply.length; k++) {
				var o = ply[k];
				var vsData = this.convertGeo2Geometry_(o.geo);

				polygons.push({eid: o.eid, vertices: vsData.vertices, height: o.height,
				 typeID:hash_polygon[o.eid].type, minLevel: o.minlevel, maxLevel: o.maxlevel});
			}

			// polygonLabel
			var plabel = [];
			var plbl = geo_0['polygonLabelLayer'];
			for (k = 0; k < plbl.length; k++) {
				o = plbl[k];
				var _o = hash_polygonLabel[o.eid];
				if (_o.name) {
					plabel.push({eid: o.eid, vertex: gd.parse(o.geo).toStrip(), name:_o.name, type: _o.type,
					 width: _o.width, angle: _o.angle, minLevel: o.minlevel, maxLevel: o.maxlevel});
				}
			}

			// external models
			var externalModels = [];
			var eml = geo_0['externalModelLayer'];
			eml.forEach(function(itm) {
				var o = hash_externalModel[itm.eid];
				var res = Object.assign({}, o);
				res.vertex = gd.parse(itm.geo).toStrip();
				res.height = itm.height;
				externalModels.push(res);
			});

			//liftLayer
		}

		var d = {
			'lgid':groupId,
			'geo_extentlayers':[{'lid':2,'extents':extents}],
			'geo_modellayers':[{'lid':7,'models':models}],
			'geo_labellayers':[{'lid':8,'labels':labels}],
			'geo_poilayers':[{'lid':5,'pois':pois}],
			'geo_polygonlayer':[{'lid': 9, 'polygons': polygons}],
			'geo_polygonlabellayer':[{'lid': 90, 'plabels': plabel}],
			'geo_externalmodellayer':[{'lid': 91, 'externals': externalModels}],
			'geo_stairlayers':[{'lid':100,'stairs':stairs}]
		};

		return d;
	},

	convertStatic2_:function(groupId) {

		var floors = this.staticScene_.floors;
		for (var i = 0; i< floors.length; i++) {
			var floor = floors[i];
			if (floor.gid == groupId) {
				return this.convertToGroup__(groupId,floor.geo,floor.biz,floor.navi);
			}
		}
		return null;
	},
	//
	convertSite1_:function(d) {
		var scene = fmSceneDecode(d);

		var d = {
			//sid:0,
			'scene_data':scene,
		};

		if(!this.staticScene_) {
			this.staticScene_ = {};
			this.staticScene_.floors = [];
		}
		this.staticScene_.scene = scene;

		var layerGroups = scene['layerGroups'];
		for (var i=0; i<layerGroups.length; i++) {
			var lg = layerGroups[i];
			lg['elevation'] = lg['height'];
		}
		return d;
	},
	convertSite2_:function(groupId, r_geo, r_biz, r_nav) {
		var geo = fmFloorGeoDecode(r_geo);
        var biz = fmFloorBizDecode(r_biz);
        // var nav = fmFloorNaviDecode(r_nav); // have some bug!

        var nav;
        try {
        	nav = fmFloorNaviDecode(r_nav);
        } catch (e) {
        	nav = null;
        }

        if(!this.staticScene_) {
        	this.staticScene_ = {};
        	this.staticScene_.floors = [];
        }
        this.staticScene_.floors[groupId-1] = {gid:groupId,geo:[geo],navi:[nav],biz:[biz]};

		return this.convertToGroup__(groupId,[geo],[biz],[nav]);
	},
	//
	convertGeo2Geometry_:function(data) {
		var gd = new geo.GData().parse(data);
		var d = {vertices:gd.toStrip(true)/*, indices:[]*/};//holes:[[],..]
		if (gd.hasHoles()) {
			d.holes = this.tempFlipX_holes_(gd.toStripHoles(true));
		}
		return d;
	},
	//#20160406,Samuel,Copy from v0.2
	tempFlipX_:function(data) {
		if (data && typeof(data) != 'string') {
			for (var k in data) {
				var d = data[k];
				if (typeof d != 'object') {continue;}
				if (k == 'vertices' || k == 'vertex') {
					for (var i = 0; i < d.length; i++) {
						if (i % 2 == 0) {
							d[i] = -d[i];
						}
					}
					/*for (var i in d) {
						if (i % 2 == 0) {
							d[i] = -d[i];
						}
					}*/
				} else if (k == 'scene_data') {
					d.x = -d.x;
					d.defCenX = -d.defCenX;
				} else {
					this.tempFlipX_(d);
				}
			}
		}
	},
	tempFlipX_holes_:function(d) {
		for (var i=0;i<d.length;i++) {
			var h = d[i];
			for (var j = 0;j<h.length;j+= 2) {
				h[j] = -h[j];
			}
		}
		return d;
	},
};


/**
 * 
 */

fengmap.MapTheme = function(map, options) {
	this.options_ = options;
	this.map = map;

	// http://developers.fengmap.com/theme.html
	this.themeName_ = this.options_.defaultThemeName;

	this.data_ = null;

	this.type2theme_   = null;
	//this.poitype2theme_    = null;
	this.defaultTheme_ = {color_:0xffffff, alpha:1, strokeColor_: 0xffffff, strokeWidth: 2};
	this.clearColor_   = 0xffffff;
	
	this.modelOpacity_  = 0.875;
	this.floorColor_    = 0xffff00;
	this.floorOpacity_  = 0.875;
	this.selectedColor_ = 0xff9966;

	//"fillcolor": "0,0,0",    "strokecolor": "255,255,255",     "alpha": "1.0",     "fontsize": "12.0" 
	this.labelStyle_;
	this.labelSelectedStyle_;
	
	this.facilitySize_;

	this.poiMatClones = {};
	
	// 路径线样式
	this.navigateStyle_ = {
		color: 0xff0000,
		lineWidth: 8,
		alpha: 0.8,
		dash: {
			size: 1,
			gap: 1,
		}
	};
};

fengmap.MapTheme.prototype = {
	get themeName() {
		return this.themeName_;
	},
	set data (data) {
		this.data_ = data;
		var scope = this;

		// select null first
		scope.map.selectNull();

		this.poiMatClones = {};

		//viewtheme {clearcolor,clearalpha}
		this.clearColor_ =  this.map.options.defaultBackgroundColor || fengmap.MapUtil.toColor(this.data_['viewtheme']['clearcolor']);
		this.clearAlpha_  = this.map.options.defaultBackgroundAlpha || parseFloat(this.data_.viewtheme.clearalpha);

		// version
		this.version = this.options_.themeVersion || data.version || 1;

		this.fileType = scope.options_.themeFileType || fmg(data, 'filetype', 'fileType', 'image');

		// 线的宽度, 版本的区别
		this.navigateStyle_.lineWidth = this.version == 1 ? 14 : 7;
		
		this.type2theme_ = {};
		//this.poitype2theme_ = {};
		var storethemes = {};

		// set default store theme
		this.defaultTheme_ = data.storetheme[0];

		this.storeThemes = storethemes;

		// for (var i in this.data_.storetheme) {
		for (var i = 0; i < this.data_.storetheme.length; i++) {
			var st = this.data_.storetheme[i];

			st.color_ = fengmap.MapUtil.toColor(st['color']);
			st.strokeColor_ = fengmap.MapUtil.toColor(st['strokecolor']);
			st.strokeWidth = st['strokewidth'];
			st.alpha_ = st['alpha'];

			// image
			// if (st.image && st.image != '') {
			// 	if (this.fileType == 'image') {
			// 		var url = this.options_.mapThemeURL + '/' + this.themeName_ + '/' + st.image;
			// 		st.image = fengmap.MapUtil.loadTexture(url, function() {
			// 			st.imageLoaded = true;
			// 		});
			// 	} else if (scope.fileType == 'rtheme') {
			// 		st.image = scope.getRThemeTexture(st.image);
			// 	}
			// }

			storethemes[st['id']] = st;
		}

		/////////////////////////////////
		// externalModel
		/////////////////////////////////
		var mtDic = {};

		// 将之后载入进来的模型,注册到这个上面
		this.models = {};
		
		var mt = this.data_.externalmodeltheme;

		/////////////////////////////////////////////////////////
		// use externalModel .fmap and NO externalModel theme  //
		/////////////////////////////////////////////////////////
		scope.externalModel = {};

		if (mt) {
			mt.forEach(function(itm, index) {
				mtDic[itm.id] = itm;
			});

			var ma = scope.data_.externalmodelapply;
			if (ma) {
				ma.forEach(function(itm, index) {
					var fidArr = itm.fids.split(',');
					itm.theme_ = mtDic[itm.normalid];

					fidArr.forEach(function(fid) {
						scope.externalModel[fid] = itm;
					});
				});
			}
		}
		/////////////////////////////////
		

		/////////////////////////////////
		// store image
		/////////////////////////////////
		var storeapply = this.data_.storeapply;
		this.storeImages = {};
		if (storeapply) {
			for (var i = 0; i < storeapply.length; i++) {
				var itm = storeapply[i];

				if (itm.fids != undefined && storethemes[itm.normalid]) {
					// fid
					var fids = itm.fids.split(',');
					// 坐标
					var coord = itm.coords.split(',');
					// size
					var size = itm.sizes.split(',');


					var _st = storethemes[itm.normalid];
					if (_st.image) {
						// if (scope.fileType == 'image') {
						// 	var url = scope.options_.mapThemeURL + '/' + scope.themeName_ + '/' + _st.image;
						// 	_st.image = fengmap.MapUtil.loadTexture(url, function() {
						// 		_st.imageLoaded = true;
						// 	});
						// } else if (scope.fileType == 'rtheme') {
						// 	_st.image = scope.getRThemeTexture(_st.image);
						// }

						// scope.loadImage(_st, function (img) {
						// 	_st.image = img;
						// });
					}

					for (var j = 0; j < fids.length; j++) {
						(function () {

							var fid = fids[j];
							var res = {};
							res.coord = new fm.Vector2(parseFloat(coord[j * 2]), parseFloat(coord[j * 2 + 1]));
							res.size  = new fm.Vector2(parseFloat(size[j * 2]), parseFloat(size[j * 2 + 1]));
							res.fid = fid;
							
							// scope.loadImage(storethemes[itm.normalid], function (img) {
							// 	res.image = img;
							// });

							res.image = _st.image;

							// 自定义的颜色信息
							res.theme = storethemes[itm.normalid];

							// 一个store可以有多个image
							if (!scope.storeImages[fid]) {
								scope.storeImages[fid] = [];
							}
							scope.storeImages[fid].push(res);

						})();
					}
				}
			}
		}

		// 在创建之后,更改主题的时候,如果是含有storeImage, 需要重新创建
		var md = this.map.mapScene.modelDatas
		if (md && md.count) {
			// clear previous storeApply
			var mdkeys = Object.keys(md);

			mdkeys.forEach(function (itm) {
				delete md[itm].storeApply;
			});

			var keys = Object.keys(this.storeImages);
			keys.forEach(function (key) {
				var sidatas = scope.storeImages[key];
				scope.map.mapScene._createStoreImages(sidatas);
			});

			// update color & alpha
			this.map.groupIDs.forEach(function (gid) {
				this.map._storeApplyWorks(gid);
			})
		}

		//////////////////////////////////////////////

		/////////////////////////////////
		// polygon
		/////////////////////////////////
		this.polygonMap = {};
		var polygonThemes = {};
		var pts = this.data_.polygontheme;
		if (pts) {
			for (var i = 0; i < pts.length; i++) {
				var mat = new fm.MeshLambertMaterial({
					color: new fm.Color(fengmap.MapUtil.toColor(pts[i].color)),
					opacity: parseFloat(pts[i].alpha),
					transparent: true,
					side: fm.BackSide
				});
				polygonThemes[pts[i]['id']] = mat;
			}

			var fs = this.data_.floorpolygonapply;
			
			for (var i = 0; i < fs.length; i++) {
				var pa = fs[i].typeapply;
				for (var j = 0; j < pa.length; j++) {
					// 支持多个type使用同一个材质
					var _arr = pa[j].type.split(',');
					_arr.forEach(function(_i) {
						scope.polygonMap[_i] = polygonThemes[pa[j].normalid];
					});
				}
			}
		}
		/////////////////////////////////
		

		var floorapply = data['floorapply'];

		for (var i in floorapply) {
			var fa = floorapply[i];
			if (!fa.typeapply) {continue;}
			for (var j in fa['typeapply']) {
				var ta = fa['typeapply'][j];
				if (!ta.normalid) {continue;}

				// store theme
				var st = storethemes[ta['normalid']];

				//selectedid
				var std = storethemes[ta['selectedid']];
				if(std)
					this.selectedColor_ = fengmap.MapUtil.toColor(std['color']);
				
				var types = ta['type'].split(',');
				for (var k in types) {
					this.type2theme_[types[k]] = st;
				}
			}
		}

		if (floorapply.length>0 && floorapply[0].floorid !== undefined) {
			var dextt = data['extenttheme'];
			for (var i = 0; i<dextt.length; i++) {
				var v = dextt[i];
				if (v.id == floorapply[0]['floorid']) {
					this.floorColor_ = fengmap.MapUtil.toColor(dextt[v.id]['color']);
					this.floorOpacity_ = dextt[v.id]['alpha'];
					break;
				}
			}
		}

		// store label
		var dslt = data['storelabeltheme'];
		this.storeLabelThemeDic = {};
		this.storeLabelTypeDic = {};

		if (dslt) {
			if (dslt.length>0) {
				this.labelStyle_ = dslt[0];
				if (dslt.length>1) {
					this.labelSelectedStyle_ = dslt[1];
				}
			}

			var url = this.options_.mapThemeURL + '/' + this.themeName_ + '/';

			// store label load image
			for (var i = 0; i < dslt.length; i++) {
				this.storeLabelThemeDic[dslt[i]['id']] = dslt[i];
				// if (dslt[i].image != undefined && dslt[i].image != '') {
				// 	if (scope.fileType == 'image') {
				// 		dslt[i].texture = fengmap.MapUtil.loadTexture(url + dslt[i].image);
				// 	} else if (scope.fileType == 'rtheme') {
				// 		dslt[i].texture = scope.getRThemeTexture(dslt[i].image);
				// 	}
				// }
			}

			var fa = data['floorstorelabelapply'];
			if (fa) {
				for (var i = 0; i < fa.length; i++) {
					var ta = fa[i].typeapply;
					// 就用全部
					if (fa[i].floorid == '0') {
						for (var j = 0; j < ta.length; j++) {
							var t = ta[j];
							var ts = t.type.split(',');

							for (var k = 0; k < ts.length; k++) {
								this.storeLabelTypeDic[ts[k]] = t;
							}
						}
					}
				}
			}
		}
		///////////////////poiimage////////////////////////		

		this.data_.poiimagetheme_ = {};
		var dpit = this.data_['poiimagetheme'];
		
		var storePoiThemes = {};
		this.storePoiThemes = storePoiThemes;

		for (var i in dpit) {
			(function() {
				var d = dpit[i];
				if (!d.imagename) {return;}			

				// url = scope.options_.mapThemeURL + '/' + scope.themeName_ + '/' + d['imagename'];
				
				// d.material_ = new fm.SpriteMaterial({visible: false});

				// function works(tex) {
				// 	//不是2的幂
				// 	tex.minFilter = fm.LinearFilter;
				// 	tex.magFilter = fm.NearestFilter;
				// 	d.material_.map = tex;
				// 	d.material_.map.needsUpdate = true;
				// 	d.material_.visible = true;

				// 	if (scope.poiMatClones[d['id']]) {
				// 		scope.poiMatClones[d['id']].forEach(function(m) {
				// 			m.map = tex;
				// 			m.map.needsUpdate = true;
				// 		});
				// 	}
				// }

				// if (scope.fileType == 'image') {
				// 	fengmap.MapUtil.loadTexture(url, function(tex) {
				// 		works(tex);
				// 	});
				// } else if (scope.fileType == 'rtheme') {
				// 	var tex = scope.getRThemeTexture(d['imagename']);
				// 	works(tex);
				// }
				
				//set size from theme file config
				// d.material_.size = d.height;

				storePoiThemes[d['id']] = d;
			})();
		}

		var floorpoiapply = data['floorpoiimageapply'];

		for (var i in floorpoiapply) {
			var fa = floorpoiapply[i];
			if (!fa.typeapply) {continue;}
			for (var j in fa['typeapply']) {
				var ta = fa['typeapply'][j];
				if (!ta.normalid) {continue;}
				// store theme
				var st = storePoiThemes[ta['normalid']];

				var types = ta['type'].split(',');
				for (var k in types) {
					this.data_.poiimagetheme_[types[k]] = st;
				}
			}
		}

		// 模型拾取的材质
		if (!this.selectModelMat) {
			this.selectModelMat = new fm.MeshLambertMaterial({
				color: this.selectedColor_,
				emissive: this.selectedColor_,
				transparent: true
			});
		}

		this.selectModelMat.color = new fm.Color(this.selectedColor_);
	},
	get data() {
		return this.data_;
	},

	/**
	 * 按名称得到rtheme中的base64数据
	 */
	getRThemeTexture: function(name) {
		if (this.rtheme) {
			var d;
			for (var i = 0; i < this.rtheme.fmis.length; i++) {
				d = this.rtheme.fmis[i];
				if (d.name == name) {
					var img = new Image();
					img.src = d.content;
					return new fm.Texture(img);
				}
			}
		}
		return null;
	},

	getModelTheme:function(meta) {
		if (!meta) {
			return this.defaultTheme_;
		}

		var theme = this.type2theme_[meta.type];

		if (theme) {
			return theme;
		} else {
			return this.defaultTheme_;
		}
	},

	pushToClones: function(type, mat) {
		if (!this.poiMatClones[type]) {
			this.poiMatClones[type] = [];
		}
		this.poiMatClones[type].push(mat);
	},

	loadImage: function (data, cb, imgProp) {
		var s = this;

		imgProp = imgProp || 'image';

		if (!data[imgProp]) {return;}

		if (s.fileType == 'image') {
			var url = s.options_.mapThemeURL + '/' + s.themeName_ + '/' + data[imgProp];
			fengmap.MapUtil.loadTexture(url, function(tex) {
				if (cb) {cb(tex);}
			});
		} else if (s.fileType == 'rtheme') {
			var tex = s.getRThemeTexture(data.image);
			if (cb) {cb(tex);}
		}
	},

	getPoiMaterialByType:function(type) {
		var s = this;
		var d = this.data_.poiimagetheme_[type];

		var createMat = function (d) {
			url = s.options_.mapThemeURL + '/' + s.themeName_ + '/' + d.imagename;

			mat = new fm.SpriteMaterial({visible: false});
			d.material_ = mat;

			var works = function (tex) {
				//不是2的幂
				tex.minFilter = fm.LinearFilter;
				tex.magFilter = fm.NearestFilter;
				mat.map = tex;
				mat.map.needsUpdate = true;
				mat.visible = true;

				if (s.poiMatClones[d['id']]) {
					s.poiMatClones[d['id']].forEach(function(m) {
						m.map = tex;
						m.map.needsUpdate = true;
					});
				}

				if (mat.loadedCallback) {
					mat.loadedCallback();
					mat.loadedCallback = null;
				}
			}

			s.loadImage(d, works, 'imagename');

			return mat;
		}

		if (d) {
			var mat;
			if (d.material_) {
				mat = d.material_.clone();
			} else {

				mat = createMat(d);

				// url = s.options_.mapThemeURL + '/' + s.themeName_ + '/' + d.imagename;

				// mat = new fm.SpriteMaterial({visible: false});
				// d.material_ = mat;

				// var works = function (tex) {
				// 	//不是2的幂
				// 	tex.minFilter = fm.LinearFilter;
				// 	tex.magFilter = fm.NearestFilter;
				// 	mat.map = tex;
				// 	mat.map.needsUpdate = true;
				// 	mat.visible = true;

				// 	if (s.poiMatClones[d['id']]) {
				// 		s.poiMatClones[d['id']].forEach(function(m) {
				// 			m.map = tex;
				// 			m.map.needsUpdate = true;
				// 		});
				// 	}

				// 	if (mat.loadedCallback) {
				// 		mat.loadedCallback();
				// 		mat.loadedCallback = null;
				// 	}
				// }

				// s.loadImage(d, works, 'imagename');

				// if (s.fileType == 'image') {
				// 	fengmap.MapUtil.loadTexture(url, function(tex) {
				// 		works(tex);
				// 	});
				// } else if (s.fileType == 'rtheme') {
				// 	var tex = s.getRThemeTexture(d['imagename']);
				// 	works(tex);
				// }

			}

			// 因为图片的载入是异步的. 所有有可以在
			// 复制这相材质的时候,图片还没有加载进来.
			// 所以需要先把他们记录下来.等图片加载完成后
			// 再去更新所有记录下来复制过的材质
			this.pushToClones(d.id, mat);	// 之前是 type 现在使用 d.id

			mat.size = d.height;  // 这个size属性, 浪费了我一下午, 没有他渲染不出来!!!! FUCK
			
			return mat;
		} else {
			d = this.data_.poiimagetheme_[0];//default POI
			if (d) {

				if (!d.material_) {
					d.material_ = createMat(d);
				}

				var mat = d.material_.clone();
				mat.size = d.height;
				this.pushToClones(0, mat);
				return mat;
			} else {
				return new fm.SpriteMaterial({color:0xff0000});
			}
		}
	}
	
};

/**
 * fengmap 主要的工具类
 */

/**
 *	MapUtil 主要的工具类
 * 	__class MapUtil
 * 	__module FMTools
 * 	__namespace fengmap
 */
fengmap.MapUtil = {
	REVISION: "10",
	MatMap:undefined
};

//	"255,255,255" to number
fengmap.MapUtil.toColor = function(c) {
	var cs = c.split(',');
	if (cs.length >= 3) {
		return (parseInt(cs[0]) << 16) | (parseInt(cs[1]) << 8) | parseInt(cs[2]);
	} else {
		console.log('color format error', c);
		return 0;
	}
};

//	"255,255,255" to rgba(255,255,255,1)
fengmap.MapUtil.toRgba = function(c) {
	var cs = c.split(',');
	if (cs.length >= 3) {
		return 'rgba(' + (parseInt(cs[0])) + ',' + (parseInt(cs[1])) + ',' + parseInt(cs[2]) + ',1)';
	} else {
		console.log('color format error', c);
		return 0;
	}
};

fengmap.MapUtil.convertToVector3 = function(str) {
	var arr = str.split(',');
	return new fm.Vector3(parseFloat(arr[0]), parseFloat(arr[2]), parseFloat(arr[1]));
}

fengmap.MapUtil.getMapScene = function(fmData) {
	if (fmData && fmData instanceof fengmap.FMGroup) {
		return fmData.scene_;
	} else {
		if (fmData.o3d_ && fmData.o3d_.parent) {
			return fengmap.MapUtil.getMapScene(fmData.o3d_.parent.fm_);
		}
		return null;
	}
};

fengmap.MapUtil.setModelMaterialToDefault = function(map, faceData) {
	if (!faceData || !faceData.faceRange) {
		return;
	}

	var matIndexs = {};

	for (var i = faceData.faceRange[0]; i < faceData.faceRange[1]; i++) {
		var face = faceData.o3d_.geometry.faces[i];
		if (!matIndexs[face.materialIndex]) {
			matIndexs[face.materialIndex] = [face];
		} else {
			matIndexs[face.materialIndex].push(face);
		}
	}

	var keys = Object.keys(matIndexs);

	// 20180301 noSideFaces Mode
	if (keys.length === 1) {
		matIndexs[keys[0]].forEach(function(f) {
			f.materialIndex = 0;
		});
	} else if (keys.length == 2) {
		var boo = keys[0] < keys[1];

		matIndexs[keys[0]].forEach(function(f) {
			f.materialIndex = boo ? 0 : 1;
		});

		matIndexs[keys[1]].forEach(function(f) {
			f.materialIndex = boo ? 1 : 0;
		});
	}

	faceData.o3d_.geometry.groupsNeedUpdate = true;
};

fengmap.MapUtil.getNearestAngle = function(from, to) {
	var _t = to - from;
	if (Math.abs(_t) > 180) {
		_t = -1 * Math.sign(_t) * 360 + _t;
	}
	return _t;
}

fengmap.MapUtil.setModelMaterial = function(map, faceData, mat, matIndex) {
	if (!faceData || !faceData.faceRange) {
		return;
	}

	if (!(mat instanceof fengmap.FMMaterial)) {
		return;
	}

	// 先去掉选择的部分
	if (map) {
		map.selectNull();
	}

	var mats = faceData.o3d_.material.materials;
	var index = matIndex == undefined ? -1 : matIndex;

	if (index == -1) {
		for (var i = 0; i < mats.length; i++) {
			if (mats[i] == mat) {
				index = i;
				break;
			}
		}
	}

	if (index == -1) {
		// 看看这个材质是否已经有他的兄弟了.
		if (!mat.brother) {
			mat.brother = mat.clone();
		}

		mats.push(mat, mat.brother);
		index = mats.length - 2;
	}

	var matIndexs = {};
	for (var i = faceData.faceRange[0]; i < faceData.faceRange[1]; i++) {
		var face = faceData.o3d_.geometry.faces[i];
		var mi = face._materialIndex == undefined ? face.materialIndex : face._materialIndex;
		if (!matIndexs[mi]) {
			matIndexs[mi] = [face];
		} else {
			matIndexs[mi].push(face);
		}
	}

	var keys = Object.keys(matIndexs);

	// 20180301 noSideFaces Mode
	if (keys.length === 1) {
		matIndexs[keys[0]].forEach(function(f) {
			f.materialIndex = index;
			if (f._materialIndex != undefined) {
				f._materialIndex = f.materialIndex;
			}
		});
	} else if (keys.length == 2) {
		var boo = keys[0] < keys[1];

		matIndexs[keys[0]].forEach(function(f) {
			f.materialIndex = boo ? index : index + 1;
			if (f._materialIndex != undefined) {
				f._materialIndex = f.materialIndex;
			}
		});
		matIndexs[keys[1]].forEach(function(f) {
			f.materialIndex = boo ? index + 1 : index;
			if (f._materialIndex != undefined) {
				f._materialIndex = f.materialIndex;
			}
		});

	}

	faceData.o3d_.geometry.groupsNeedUpdate = true;

	return index;
};

/**
 * 得到 FM 数据的别名
 */
fengmap.MapUtil.getAlias = function(fm) {
	if (!fm) {
		return null;
	}

	if (fm._type_) {
		return fm._type_;
	} else {
		if (fm instanceof fengmap.FMLabel) {
			return 'label';
		}
		if (fm instanceof fengmap.FMFacility) {
			return 'facility';
		}
		if (fm instanceof fengmap.FMTextMarker) {
			return 'textMarker';
		}
		if (fm instanceof fengmap.FMImageMarker) {
			return 'imageMarker';
		}
		if (fm instanceof fengmap.FMLocationMarker) {
			return 'locationMarker';
		}
		if (fm instanceof fengmap.FMPolygonMarker) {
			return 'polygonMarker';
		}
	}
	return null;
};


/**
 * 打印出当前 控制器 的角度信息,用于用户设置默认角度
 */
fengmap.MapUtil.getControlsInfo = function(map) {
	var _map = map || fengmap.Map.instance;
	var control = _map.controls;
	var str = 'defaultControlsPose: {\n\ttarget:' + '"' + control.target.x.toFixed(3) + ',' +
		control.target.y.toFixed(3) + ',' + control.target.z.toFixed(3) + '",\n' +
		'\tposition:' + '"' + control.object.position.x.toFixed(3) + ',' +
		control.object.position.y.toFixed(3) + ',' + control.object.position.z.toFixed(3) + '"\n}';
	return str;
};

/**
 * get current platform
 * __return object {isPC:(bool), isWX:(bool), platfrom:(string)}
 */
fengmap.MapUtil.getPlatform = function() {
	var userAgentInfo = navigator.userAgent;
	var Agents = new Array("Android", "iPhone", "SymbianOS", "Windows Phone", "iPad", "iPod");
	var isPC = true;
	var platform = 'PC';
	var isWX = false;
	for (var v = 0; v < Agents.length; v++) {
		if (userAgentInfo.indexOf(Agents[v]) > 0) {
			isPC = false;
			platform = Agents[v];

			if (userAgentInfo.indexOf('MicroMessenger') > 0) {
				isWX = true;
			};
			break;
		}
	}

	return {
		isPC: isPC,
		isWX: isWX,
		platform: platform,
	};
};

/**
 * 通过Layer的别名得到layer的fm_
 * layerAlias: 层的别名, 或数组
 * 		如果是结果是一个值返回的单个值
 * 		如果结果是多个值则返回的是数组
 *
 * calback(layer, alias): 得到相应的层后,调用一个回调方法,对此层相应的处理
 * 		如果在循环中要删除层的话, 需要 return true; 来避免在循环中删除所产生的问题
 */

/**
 * 根据类型别名获取指定楼层上面的某图层
 * __method getLayerByAlias
 * __param {fengmap.FMMap} map  当前地图对象。
 * __param {int} gid  待设置的楼层ID
 * __param {string} layerAlias  别名，extent, model, label, facility,textMarker,imageMarker
 * __param  {function} callback 查找到后的回调函数
 * __return {array} 包含该类型的图层数组
 * __since v1.2.0
 */
fengmap.MapUtil.getLayerByAlias = function(map, gid, layerAlias, callback) {
	var group = map.getFMGroup(gid);
	if (!group || !group.layers) return;
	layerAlias = [].concat(layerAlias);
	var res = [];

	for (var i = 0; i < group.layers.length; i++) {
		var layer = group.layers[i];
		if (layer._type_) {
			if (layerAlias.indexOf(layer._type_) > -1) {
				if (callback) {
					if (callback(layer, layer._type_)) {
						i--;
					}
				}
				res.push(layer);
			}
		} else {
			for (var j = 0; j < layerAlias.length; j++) {
				var alias = layerAlias[j];
				if (fengmap.Map.layerAlias[alias] && layer instanceof fengmap.Map.layerAlias[alias]) {
					if (callback) {
						if (callback(layer, alias)) {
							i--;
						}
					}
					res.push(layer);
				}
			}
		}
	}

	return res.length == 0 ? null : res.length == 1 ? res[0] : res;
};

fengmap.MapUtil.getOrCreateLambertMaterial = function(c, t, o){
	if(undefined == fengmap.MapUtil.MatMap){
		fengmap.MapUtil.MatMap = new ComTool.Map();
	}
	var name = "ml_"+c+"_"+t+"_"+o;
	var mat = fengmap.MapUtil.MatMap.findEx(name);
	if(undefined == mat){
		mat = new fm.MeshLambertMaterial({//
			color: c,
			transparent:t,
			opacity:o
		});
		fengmap.MapUtil.MatMap.insert(name, mat);
	}
	return mat;
};
fengmap.MapUtil.getOrCreateLineBasicMaterial = function(c, t, o, w){
	if(undefined == fengmap.MapUtil.MatMap){
		fengmap.MapUtil.MatMap = new ComTool.Map();
	}
	var name = "lb_"+c+"_"+t+"_"+o;
	var mat = fengmap.MapUtil.MatMap.findEx(name);
	if(undefined == mat){
		mat = new fm.LineBasicMaterial({//
			color: c,
			transparent:t,
			opacity:o,
			linewidth:w
		});
		fengmap.MapUtil.MatMap.insert(name, mat);
	}
	return mat;
};
fengmap.MapUtil.getOrCreateLayer = function(map, gid, layerAlias, callback) {
	var g = map.getFMGroup(gid);
	var layer = g.getOrCreateLayer(layerAlias);

	if (callback) {
		callback(layer);
	}

	return layer;
};

/**
 * 按类型合并Models
 * layerAlias: model | modelLine
 */
fengmap.MapUtil.mergeModels = function(map, gid, layerAlias) {
	layerAlias = layerAlias || 'model';
	var needBrothers = false;

	if (layerAlias == 'model' || layerAlias == 'polygon') {
		needBrothers = true;
	}

	// 得到Model层
	var modelsLayer = fengmap.MapUtil.getLayerByAlias(map, gid, layerAlias);

	if (modelsLayer && !modelsLayer._merged) {
		// 得到 Layer 物体
		var layerObj = modelsLayer.o3d_;

		// 清空之前的 LastAlpha
		layerObj.lastAlpha = {};

		// 得到所有的Model fm_
		models = layerObj.children;

		// 用于记录不同的typeID的信息
		types = {};

		// merge
		models.forEach(function(itm) {
			var typeID = itm.fm_.typeID;

			/////////////////////////////////
			// 支持 minLevel maxLevel
			// typeID = typeID + minLevel + maxLevel
			/////////////////////////////////
			typeID = '' + typeID + itm.fm_.data_.minLevel + itm.fm_.data_.maxLevel;

			// 如果还没有此类型,将其放入types
			if (!types[typeID]) {
				types[typeID] = {};
				types[typeID].fm_ = itm.fm_;
				if (itm.meta_) {
					types[typeID].meta_ = itm.meta_;
				}
				types[typeID].material = itm.material;
				types[typeID].geometry = new fm.Geometry();
				if (needBrothers) {
					types[typeID].brothers = []; // 合并中的所有对象
				}
				types[typeID].faceIndex = 0;

				types[typeID].minLevel = itm.fm_.data_.minLevel;
				types[typeID].maxLevel = itm.fm_.data_.maxLevel;
			}

			if (needBrothers) {
				var _lastIndex = types[typeID].faceIndex;
				types[typeID].faceIndex += itm.geometry.faces.length;


				/*var data = Object.assign({}, itm.fm_);

				// properties on prototype
				data.FID           = itm.fm_.FID;
				data.ID            = itm.fm_.ID;
				data.groupID       = itm.fm_.groupID;
				data.name          = itm.fm_.name;
				data.typeID        = itm.fm_.typeID;
				data.mapCoord      = itm.fm_.mapCoord;
				data.selectedColor = itm.fm_.selectedColor;
				data.minLevel      = itm.fm_.data_.minLevel;
				data.maxLevel 	   = itm.fm_.data_.maxLevel;

				data.faceRange = [_lastIndex, types[typeID].faceIndex];*/

				var data = new fengmap.FMStoreModel(itm.fm_);
				data.faceRange = [_lastIndex, types[typeID].faceIndex];

				// 注册进 brothers
				types[typeID].brothers.push(data);

				// 去掉自身对Mesh的引用,使内存得以释放
				delete itm.fm_.o3d_;
			}

			itm.updateMatrix();
			types[typeID].geometry.merge(itm.geometry, itm.matrix);
		});

		// clean from picker
		map.mapPicker.removeObject(layerObj.children);

		// clean
		while (layerObj.children.length > 0) {
			layerObj.children[0].visible = false;
			layerObj.children[0].geometry.dispose();
			layerObj.remove(layerObj.children[0]);
		}

		// build new Big mesh
		for (var t in types) {
			var _t = types[t];
			_t.geometry.computeBoundingSphere();

			var m;
			switch (layerAlias) {
				case 'model':
					var visibleMaterial = _t.material.clone();
					visibleMaterial.color = new fm.Color(0x000000);
					visibleMaterial.opacity = 0.0;
					m = new fm.Mesh(_t.geometry, new fm.MultiMaterial([_t.material, _t.material.clone(), map.mapTheme.selectModelMat,visibleMaterial]));
					m.castShadow = true;
					m.renderOrder = fengmap.FMRenderOrder.model;
					break;
				case 'polygon':
					m = new fm.Mesh(_t.geometry, _t.material);
					m.material.side = fm.DoubleSide;
					m.receiveShadow = true;
					m.renderOrder = fengmap.FMRenderOrder.polygon;
					break;
				case 'modelLine':
					m = new fm.LineSegments(_t.geometry, _t.material);
					m.renderOrder = fengmap.FMRenderOrder.modelLine;
					break;
			}

			// add minLevel and maxLevel to the combine Mesh object
			m.minLevel = _t.minLevel;
			m.maxLevel = _t.maxLevel;

			////////////////////////////////////////////
			// change merged geoemtry pivot to center //
			////////////////////////////////////////////
			/*if (layerAlias != 'modelLine') {
				var center = _t.geometry.boundingSphere.center.clone();
				var _delta = m.position.clone().sub(center);
				_t.geometry.applyMatrix(new fm.Matrix4().makeTranslation(-_delta.x, -_delta.y, -_delta.z));
				m.position.add(_delta);
			}*/

			_t.fm_.o3d_ = m; // o3d_ 这个 '_', 搞了我4个小时!! FUCK!!
			m.fm_ = _t.fm_;
			if (needBrothers) {
				m.fm_.brothers = _t.brothers;
				m.fm_.brothers.forEach(function(itm) {
					itm.o3d_ = m;
				});
			}

			if (_t.meta_) {
				m.meta_ = _t.meta_ || {};
				m.meta_.fm_ = m.fm_;
			}

			layerObj.add(m);

			if (layerAlias == 'model') {
				map.mapPicker.addModel(m);
			}
		}

		modelsLayer._merged = true;
	}
};

/**
 * get Ortho Camera Size By Perspective Camera
 * distance: 可选参数, 如果不传入此参数,将使用Controls与CameraP来计算相机与目标点之前的距离
 */
fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera = function(cameraP, controls, distance) {
	if (cameraP instanceof fengmap.FMMap) {
		distance = controls;
		controls = cameraP.controls;
		cameraP = cameraP.mapView.camera;
	}

	var fov = cameraP.fov;
	var aspect = cameraP.aspect;

	var hyperfocus = distance != undefined ? distance : controls.target.distanceTo(cameraP.position);

	var halfHeight = Math.tan(fov * fm.Math.DEG2RAD / 2) * hyperfocus;
	var planeHeight = 2 * halfHeight;
	var planeWidth = planeHeight * aspect;
	var halfWidth = planeWidth / 2;

	return {
		top: halfHeight || 1,
		right: halfWidth
	};
}

/**
 * 此方法是针对不受场景缩放影响,一直保持固定大小的 sprite 的方法
 * 用来得到当前需要进近的缩放的比率
 */
fengmap.MapUtil.getSpriteScale = function(map, object) {
	var res = null;
	var dis = 100;

	if (map.viewMode == '3d') {
		if (typeof object === 'number') {
			dis = object;
		} else {
			var pos = object != undefined ? object.getWorldPosition() : map.controls.target;
			dis = map.mapView.camera.position.distanceTo(pos);
		}

		var v = fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera(map.mapView.camera, map.controls, dis);

		res = v.top * 2 / map.height;
	} else if (map.viewMode == 'top' || map.viewMode === '2d') {
		res = map.controls.object.top * 2 / map.controls.object.zoom / map.height;
	}

	return res;
};

/**
 * 对所有Group中的指定Layer (别名), 运行callback
 */

/**
 * 根据类型别名获取所有楼层上面的该类型图层。
 * __method callAllLayerByAlias
 * __param {fengmap.FMMap} map  当前地图对象。
 * __param {string} layerAlias  别名，extent, model, label, facility,textMarker,imageMarker
 * __param {function} callback 依次返回某一楼层的图层回调
 *			__param {object} callback.layer 查询到的某一楼层的图层
 * __since v1.2.0
 */
fengmap.MapUtil.callAllLayersByAlias = function(map, layerAlias, callback) {
	map.groupIDs.forEach(function(gid) {
		fengmap.MapUtil.getLayerByAlias(map, gid, layerAlias, callback);
	});
};

/**
 * 快捷的按类型的别名得到所有的Object
 * 如果采用的是合并这后的Mesh, 得会得到其合并之后的Model
 * 并不会返回子物体, 如果想得到合并之后的子物体的数据
 * 请使用 getDatasByAlias 方法
 * layerAlias: extent, model, label, facility
 * __return {array} object array
 */


fengmap.MapUtil.getObjectsByAlias = function(map, gid, layerAlias, filter) {
	var res = [];
	fengmap.MapUtil.getLayerByAlias(map, gid, layerAlias, function(layer) {
		if (filter != undefined) {
			var len = layer.o3d_.children;
			for (var i = 0; i < len; i++) {
				if (filter(layer.o3d_.children[i])) {
					res.push(layer.o3d_.children[i]);
				}
			}
		} else {
			res.push.apply(res, layer.o3d_.children);
		}
	});
	return res;
};

/**
 * 按别名得到 fm_ 数据 / 支持得到合并之后的子物体的fm数据
 */

/**
 * 根据类型别名获取指定楼层上面的某类地图对象
 * __method getDatasByAlias
 * __param {fengmap.FMMap} map  当前地图对象。
 * __param {int} gid  待设置的楼层ID
 * __param {string} layerAlias  别名，extent, model, label, facility,textMarker,imageMarker
 * __return {array} 包含该类型的地图对象数组
 * __since v1.2.0
 */
fengmap.MapUtil.getDatasByAlias = function(map, gid, layerAlias, filter) {
	var res = [];

	layerAlias = [].concat(layerAlias);

	function append(fm) {
		if (filter) {
			if (filter(fm)) {
				res.push(fm);
			}
		} else {
			res.push(fm);
		}
	};

	if (layerAlias === 'facility') {
		layerAlias = 'poi';
	}

	if (map.options.lazyCreateMode) {
		if (!map.groupDatas[gid]) {
			map.getGroupData(gid);
		}

		var gd = map.groupDatas[gid];

		layerAlias.forEach(function(alias) {
			if (alias === 'facility') {
				alias === 'poi';
			}

			var ll = gd[alias + 's'];

			if (ll) {
				map.groupDatas[gid][alias + 's'].forEach(function(itm) {

					// 如果已经有了实体就直接返回实体，没有就返回数据
					append(itm.entity || itm);

				});
			}

		})
	} else {
		fengmap.MapUtil.getLayerByAlias(map, gid, layerAlias, function(layer) {
			if (filter != undefined) {

				if (layer._type_ && layer._type_==fengmap.FMLayerType.EXTERANL_MODEL) {

					var len = layer._elements.length;
					for (var i = 0; i < len; i++) {
						append(layer._elements[i]);
					}

				}else{
					var len = layer.o3d_.children.length;
					for (var i = 0; i < len; i++) {
						var _fm = layer.o3d_.children[i].fm_;
						var bros = _fm.brothers;
						if (bros) {
							bros.forEach(function(itm) {
								append(itm);
							});
						} else {
							append(_fm);
						}
					}
				}
			} else {
				res = layer.o3d_.children.reduce(function(p, c) {
					p.push.apply(p, c.fm_.brothers != undefined ? c.fm_.brothers : [c.fm_]);
					return p;
				}, []);
			}
		});
	}

	return res;
};

/**
 * 设置指定层的 alpha, 并会将原始的记录在 group 上
 * __param {bool} restoreFirst 是否先还原Alpha, 默认为true
 */
/**
 * 设置指定层的 透明度, 并会将原始的记录在 group 上
 * __method setGroupAlpha
 * __param {fengmap.FMMap} map  当前地图对象。
 * __param {int} gid  待设置的楼层ID
 * __param {int} alpha  透明度值
 * __param  {bool} restoreFirst 是否先还原Alpha,默认为true
 * __since v1.2.0
 */
fengmap.MapUtil.setGroupAlpha = function(map, gid, alpha, restoreFirst) {
	if (restoreFirst == undefined) {
		restoreFirst = true;
	}

	// 是否先还原Alpha
	if (restoreFirst) {
		fengmap.MapUtil.restoreGroupAlpha(map, gid);
	}

	var group = map.mapScene.o3dGroups_[gid];
	if (!group) {
		return;
	}
	group.lastAlpha = {};

	group.traverse(function(itm) {
		if (itm.material) {
			var mat = null;
			// 是否是多维
			if (itm.material.materials) {
				// mat = [
				// 	itm.material.materials[0],
				// 	itm.material.materials[1]
				// ];
				mat = itm.material.materials;
			} else {
				mat = [itm.material];
			}

			// record
			mat.forEach(function(m, index) {
				// 跳过第3个材质(拾取材质)
				if (index == 2) {
					return;
				}

				if (!group.lastAlpha[m.uuid]) {
					group.lastAlpha[m.uuid] = m.opacity;
				}
				m.opacity = alpha;
				m.transparent = true;
			});
		}
	});
};

/**
 * 还原指定层的 Alpha
 */
fengmap.MapUtil.restoreGroupAlpha = function(map, gid) {
	var group = map.mapScene.o3dGroups_[gid];

	if (group && group.lastAlpha) {
		group.traverse(function(itm) {
			if (itm.material) {
				var mat = null;
				if (itm.material.materials) {
					// mat = [
					// 	itm.material.materials[0],
					// 	itm.material.materials[1]
					// ];
					mat = itm.material.materials;
				} else {
					mat = [itm.material];
				}

				mat.forEach(function(m, index) {
					if (index == 2) {
						return;
					}
					if (group.lastAlpha[m.uuid]) {
						m.opacity = group.lastAlpha[m.uuid];
					}
				});
			}
		});
	}
};

/**
 * 通过给定的模型Mesh(或模型fm数据), 得到对应的 Label 数据体
 * modelMeshOrData: mesh | fm 如果是数字的话则代表 gid, 要配合 oid使用
 */
fengmap.MapUtil.getModelLabelObject = function(map, modelMeshOrData, oid) {
	var isNum = typeof modelMeshOrData == 'number';
	var fm = (!isNum && modelMeshOrData.fm_ == undefined) ? modelMeshOrData : modelMeshOrData.fm_;
	var oid = isNum ? oid : (fm.data_ && fm.data_.oid) || null;
	var gid = isNum ? modelMeshOrData : fm.groupID;

	var labelDatas = fengmap.MapUtil.getObjectsByAlias(map, gid, 'label');

	var len = labelDatas.length;
	for (var i = 0; i < len; i++) {
		if (labelDatas[i].data_ && labelDatas[i].data_.oid == oid) {
			return labelDatas[i];
		}
	}

	return null;
}

/**
 * 计算两个地图坐标点之间的距离
 * @param  {fengmap.FMMap} map    FMMap对象
 * @param  {fengmap.MapCoord} coord1 地图坐标点
 * @param  {fengmap.MapCoord} coord2 地图坐标点
 * @return {float}        两坐标点之间的距离
 */
fengmap.MapUtil.getMapCoordDistance = function(map, coord1, coord2) {
	var c1 = map.toSceneCoord(coord1);
	var c2 = map.toSceneCoord(coord2);

	return c1.distanceTo(c2);
};

/**
 * 简单易用的全新搜索接口
 * gids: ('all' / 0) | 3 | [2,5,6]
 * query: {
 * 		nodeType, name, keyword, FID, ID, typeID,
 * 		types: 'model' | ['model', 'facility',...]
 * }
 */

/**
 * 搜索地图元素
 * __method search
 * __param {fengmap.FMMap} map  当前地图对象。
 * __param {int|array} gids  待查询的楼层ID数组或某一楼层的楼层ID
 * __param {function} opts.callback  完成查询后的回调，返回查询结果
 * __param  {JSON} query
 *         __param {fengmap.FMNodeType} query.nodeType  某一种查询类型。
 *         __param {string} query.name  地图元素名称，英文字母区分大小写。
 *         __param {string} query.keyword  地图元素关键字，英文字母区分大小写。
 *         __param {string} query.FID  地图元素模型的FID属性
 *         __param {string} query.ID  地图元素ID，针对所有地图元素
 *         __param {string} query.typeID  地图元素的typeID属性，针对'model'和'facility'类型
 *         __param {array}  query.types  查询类型，包括['model', 'label', 'facility', 'imageMarker', 'textMarker', 'locationMarker']，默认是所有。
 * __since v1.2.0
 * __demo search/查询第一层的所有地图元素.js
 * __demo search/根据ID查询模型.js
 */
fengmap.MapUtil.search = function(map, gids, query, callback) {
	var res = [],distances = [];
	var gs = null;
	var dis = null,
		_dis = null;

	// 记录有距离的数据 {node: , distance: }, 用于按距离排序
	var disNodes = [];
	var types = query.types || ['model', 'externalModel','label', 'facility', 'imageMarker', 'textMarker', 'locationMarker'];

	if (typeof gids == 'number') {
		gs = gids == 0 ? map.groupIDs : [gids];
	} else if (gids == 'all') {
		gs = map.groupIDs;
	} else if (gids instanceof Array) {
		gs = gids;
	}

	for (var i = 0; i < gs.length; i++) {

		var g = gs[i];

		//
		// 因为并不是一开始就会所所有的groupData加载进来的
		// 所以在要此层搜索进，判断一下
		//
		if (map.options.lazyCreateMode && !map.groupDatas[g]) {
			map.getGroupData(g)
		}

		res.push.apply(res,
			fengmap.MapUtil.getDatasByAlias(map, g,
				types, // layers need to find
				function(itm) { // filter function
					var lowerKeyword = query.keyword?query.keyword.toLowerCase():null,
					    lowerName = itm.name?itm.name.toLowerCase():null,
					    lowerEName = itm.eName?itm.eName.toLowerCase():null,
					    keywordLanguageType = fengmap.FMLanguageType.CHN;
					if(lowerKeyword != null && query.keywordLanguageTypes && query.keywordLanguageTypes instanceof Array) {
						if(query.keywordLanguageTypes.indexOf(fengmap.FMLanguageType.EN) >= 0) {
							if(query.keywordLanguageTypes.indexOf(fengmap.FMLanguageType.CHN) >= 0) {
								keywordLanguageType = 'all';	
							} else {
								keywordLanguageType = fengmap.FMLanguageType.EN;
							}							
						}
					}
					
					if (query.nodeType && query.nodeType != fengmap.FMNodeType.ALL && query.nodeType != itm.nodeType) return false;
					if (query.name && (!itm.name || query.name != itm.name)) return false;
					if (query.eName && (!itm.eName || query.eName != itm.eName)) return false;
					if(keywordLanguageType == fengmap.FMLanguageType.CHN) {
						if (lowerKeyword && (!lowerName || lowerName.indexOf(lowerKeyword) < 0)) return false;
					} else if(keywordLanguageType == fengmap.FMLanguageType.EN) {
						if (lowerKeyword && (!lowerEName || lowerEName.indexOf(lowerKeyword) < 0)) return false;
					} else {
						if (lowerKeyword && (!lowerName || lowerName.indexOf(lowerKeyword) < 0) && (!lowerEName || lowerEName.indexOf(lowerKeyword) < 0)) return false;
					}

					if (query.ID && query.ID != itm.ID) return false;
					if (query.FID && query.FID != itm.FID) return false;
					if (query.typeID && query.typeID != itm.typeID) return false;

					// distance check
					if (query.mapCoord && query.radius) {
						if (query.nodeType == fengmap.FMNodeType.MODEL) {
							var vs = itm.data_?itm.data_.vertices:itm.vertices;
							if(!vs) return;
							
							var mvs = [];

							// 重置 dis
							dis = null;

							var height = map.getGroupHeight(g);

							for (var j = 0; j < vs.length; j += 2) {
								mvs.push(new fengmap.FMMapCoord(-vs[j], vs[j + 1], height));
							}

							if (mvs.length < 2) {
								dis = DistanceofTwoPts(query.mapCoord, mvs[0]);
							} else {
								var tmp = new fengmap.FMMapCoord();

								for (var j = 0; j < mvs.length - 1; j++) {
									_dis = pt_distance_to_line(query.mapCoord, mvs[j], mvs[j + 1], tmp);
									if (!dis || _dis < dis) {
										dis = _dis;
									}
								}
							}

							if (dis > query.radius) {
								return;
							} else {
								disNodes.push({
									node: itm,
									distance: dis
								})
							}
						}

						if (query.nodeType == fengmap.FMNodeType.FACILITY) {
							dis = fengmap.MapUtil.getMapCoordDistance(map, query.mapCoord, itm.mapCoord);
							if (dis > query.radius) {
								return;
							} else {
								disNodes.push({
									node: itm,
									distance: dis
								});
							}
						}

						if (query.nodeType == fengmap.FMNodeType.ELEMENT && query.elementType == fengmap.EXTERANL_MODEL) {
							dis = fengmap.MapUtil.getMapCoordDistance(map, query.mapCoord, itm.mapCoord);
							if (dis > query.radius) {
								return;
							} else {
								disNodes.push({
									node: itm,
									distance: dis
								});
							}
						}
					}

					return true;
				}));
	}

	// 如果使用了范围搜索,需要使用距离排序
	if (disNodes.length > 0) {
		disNodes.sort(function(a, b) {
			return a.distance - b.distance;
		});

		res = disNodes.map(function(itm) {
			distances.push(itm.distance);
			return itm.node;
		});
	}

	if (callback) {
		callback(res,distances);
	}

	return res;
};


/**
 * 载入贴图的封装方法
 */
fengmap.MapUtil.loadTexture = function() {
	var loader = new fm.TextureLoader();
	loader.crossOrigin = 'anonymous';

	return function(url, onLoad, onProgress, onError) {
		return loader.load(url, onLoad, onProgress, onError);
	};
}();

/**
 * 创建粒子的Geometry方法
 * params: positions, indexes
 */
fengmap.MapUtil.createPointsGeometry = function(params) {
	var geo = new fm.BufferGeometry();

	// 顶点
	if (params.positions) {
		geo.addAttribute('position', new fm.BufferAttribute(parmas.positions, 3));
	}

	// 索引
	if (params.indexes) {
		geo.setIndex(new fm.BufferAttribute(params.indexes, 1));
	}

	return geo;
};

/**
 * label, poi, 设置位置的标准接口
 */
fengmap.MapUtil._setGeneralProperties = function(obj, posProp, heightProp, heightDes) {
	posProp = posProp || 'position';
	heightProp = heightProp || 'initY_';

	Object.defineProperties(obj, {
		x: {
			get: function() {
				var _x = fengmap.Map.instance.center.x;
				return _x - this[posProp].x;
			},
			set: function(val) {
				var _x = fengmap.Map.instance.center.x;
				this[posProp].x = _x - val;
			}
		},
		y: {
			get: function() {
				var _y = fengmap.Map.instance.center.y;
				return this[posProp].z + _y;
			},
			set: function(val) {
				var _y = fengmap.Map.instance.center.y;
				this[posProp].z = val - _y;
			}
		},
		height: (heightDes || {
			get: function() {
				return this[heightProp];
			},
			set: function(val) {
				this[heightProp] = val;
			}
		})
	});
};

fengmap.MapUtil.showAllStairs = function(map, boo) {
	map.groupIDs.forEach(function(i) {
		map.getFMGroup(i).showStairs(boo);
	});
};

fengmap.MapUtil.stairsConnect = function(map, groupID, boo) {
	var g = map.getFMGroup(groupID);
	boo = boo == undefined ? true : boo;
	if (g.stairsLayer) {
		var s = g.stairsLayer.children[0];
		if (s) {
			g.stairsLayer.scale.y = boo ? (map.groupSpace / s.fm.height) : 1;
		}
	}
};

fengmap.MapUtil.stairsConnectAll = function(map, boo) {
	map.groupIDs.forEach(function(i) {
		fengmap.MapUtil.stairsConnect(map, i, boo);
	});
}

fengmap.MapUtil.getScalelevelValueByVectics = function(map, v1, v2) {
	var sp1 = map.coordMapToScreen(v1);
	var sp2 = map.coordMapToScreen(v2);

	var h = Math.abs(sp2.y - sp1.y);
	var w = Math.abs(sp2.x - sp1.x);

	// console.log(sp1, sp2, h, w, map.height, map.width);

	if (h > w) {
		return h / map.height;
	} else {
		return w / map.width;
	}
}

fengmap.MapUtil.handleLevelShow = function(map) {

	if (!map.options.lazyCreateMode) {
		// current mapScaleLevel
		var curMapScaleLevel = map.mapScaleLevel;

		map.visibleGroupIDs.forEach(function(gid) {

			// handle Model and storeImages
			map.getObjectsByAlias(gid, ['model']).forEach(function(model) {

				if (!model || model.minLevel === undefined || model.minLevel == -1) {
					return;
				}

				var isVisible = curMapScaleLevel >= (model.minLevel + map.options.levelShowOffset) &&
					curMapScaleLevel < (model.maxLevel + map.options.levelShowOffset);
				model.fm_.show = isVisible;
			});

			// handle POI and labels
			([].concat(map.getLayerByAlias(gid, ['facility', 'label']))).forEach(function(lay) {
				if (!lay || lay.minLevel === undefined || lay.minLevel == -1) {
					return;
				}

				var isVisible = curMapScaleLevel >= (lay.minLevel + map.options.levelShowOffset) &&
					curMapScaleLevel < (lay.maxLevel + map.options.levelShowOffset);
				lay.show = isVisible;
			});
		});

		return;
	}

	if (!map._started_) {
		return;
	}

	var gs = map.visibleGroupIDs;

	var curMapScaleLevel = map.mapScaleLevel;

	// update frustum
	map.mapView.frustumUpdate();

	gs.forEach(function(gid) {

		// 针对模型合并之后的场景
		if (map.options.mergeModels) {
			// handle Model and storeImages
			map.getObjectsByAlias(gid, ['model']).forEach(function(model) {

				if (!model || model.minLevel === undefined || model.minLevel == -1) {
					return;
				}

				var boo = curMapScaleLevel > (model.minLevel + map.options.levelShowOffset) &&
					curMapScaleLevel < (model.maxLevel + map.options.levelShowOffset);

				//
				// 视锥剔除
				//
				boo = boo && map.mapView.inView(model, 'sphere');

				// visible to show
				model.show = boo;

			});

			// handle POI and labels
			([].concat(map.getLayerByAlias(gid, ['facility', 'label']))).forEach(function(lay) {
				if (!lay || lay.minLevel === undefined || lay.minLevel == -1) {
					return;
				}

				var isTrue = curMapScaleLevel >= (lay.minLevel + map.options.levelShowOffset) &&
					curMapScaleLevel < (lay.maxLevel + map.options.levelShowOffset)
				lay.show = isTrue;
			});
		} else {

			// 针对分级与视锥
			map.getGroupData(gid, function(gd) {

				var group = map.getFMGroup(gid);

				// extents
				map.visibleOrCreateByFrustum(group, gd, 'extent');

				// models
				map.visibleOrCreateByFrustum(group, gd, 'model');

				// pois
				map.visibleOrCreateByFrustum(group, gd, 'poi');

				// labels
				map.visibleOrCreateByFrustum(group, gd, 'label');

				// externalModel
				map.visibleOrCreateByFrustum(group, gd, 'externalModel');

				//
				// emit groupLoaded event
				//
				if (!group._init_) {
					group._init_ = true;
					map.emit('groupLoaded', gid);
				}

			});
		}

	});

}

//////////////////
// fengmap.Math //
//////////////////
/*fengmap.Math = {
	pointLineProj: function (map, pA, pB, pC) {
		var pa = map.toSceneCoord(pA);
		var pb = map.toSceneCoord(pB);
		var pc = map.toSceneCoord(pC);

		var vab = pb.clone().sub(pa);
		var vac = pc.clone().sub(pa);

		var d = vab.clone().normalize().dot(vac.clone().normalize());
		var res = pa.clone().add(vab.multiplyScalar(d * (vac.length() / vab.length())));

		return map.toMapCoord(res);
	},


};
*/
/**
 * 
 */
fengmap.MapView = function(map) {
	this.map_ = map;
	
	this.scene = null;
	this.camera = null;
	
	this.sceneOrtho = null;
	this.cameraOrtho = null;
	
	this.renderer = null;

	// 视锥
	this.frustum = new fm.Frustum();
	this._frustumUpdate = this.frustumUpdate.bind(this);

	// this.w_;
	// this.h_;
	this.w_2_;
	this.h_2_;

	this.container_ = this.map_.options.container;

	this.w_ = this.container_.clientWidth;
	this.h_ = this.container_.clientHeight;

	this.isPC = fengmap.MapUtil.getPlatform().isPC;
	
	// ztc 2016/06/21 singleton
	if (!fengmap.MapView.instance) {
		fengmap.MapView.instance = this;
	}

	//this.init_();
	
};
fengmap.MapView.prototype = {

	frustumUpdate: function () {

		var c = this.map_.viewMode === '3d' ? this.camera : this.cameraTop;

		// 更新Frustum
		this.frustum.setFromMatrix((new fm.Matrix4).multiplyMatrices(c.projectionMatrix, c.matrixWorldInverse));

	},

	inView: function (obj, type) {
		switch (type || obj.frustumType) {
			case 'object':
				return this.frustum.intersectsObject(obj);
				break;
			case 'sphere':
				return this.frustum.intersectsSphere(obj);
				break;
			case 'box':
				return this.frustum.intersectsBox(obj || obj.geometry.boundingBox);
				break;
			case 'sprite':
				return this.frustum.intersectsSprite(obj);
				break;
			default:
				return this.frustum.containsPoint(obj);
				break;
		}
	},
		
	init:function() {
		var scope = this;
		//renderer

		try {
			this.renderer = new fm.WebGLRenderer({antialias:true, alpha: true});
		} catch (ex) {
			console.log('WebGLRenderer ERROR: ', ex);
			new fengmap.MapError().noWebGL(this.container_);
			return false;
		}
		
		this.renderer.setClearColor(0xffffff);
		this.renderer.setPixelRatio(window.devicePixelRatio);
		this.renderer.autoClear = false;

		this.renderer.shadowMap.enabled = true;
		this.renderer.shadowMap.type = fm.PCFSoftShadowMap;

		this.canvas_ = this.renderer.domElement;
		this.container_.appendChild(this.canvas_);

		//jimguo debug beg
		this.stats_ = new Stats();
		this.container_.appendChild( this.stats_.dom );
		//jimguo debug end

		//camera
		var w = this.container_.clientWidth;
		var h = this.container_.clientHeight;
		this.camera = new fm.PerspectiveCamera(35, w / h, 2, 20000);

		//scene
		this.scene = new fm.Scene();

		//cameraTop
		this.cameraTop = new fm.OrthographicCamera(-w/2, w/2, -h/2, h/2, 1, 100000);
		this.cameraTop.rotation.set(-Math.PI/2,0,0,'XYZ');
		// this.cameraTop.rotation.set(0,0,0,'XYZ');
		this.cameraTop.rotationAutoUpdate = false;
		this.cameraTop.position.set(0,100000,0);

		// composer
		this.composer = new fengmap.ComposerRender(this.map_);

		//cameraOrtho
		this.cameraOrtho = new fm.OrthographicCamera(-w / 2, w / 2, h / 2, -h / 2, 1, 10);
		this.cameraOrtho.position.setZ(10);
			
		//sceneOrtho
		this.sceneOrtho = new fm.Scene();

		//scene.lights
		this.ambientLight = new fm.AmbientLight(0x747474);
		this.scene.add(this.ambientLight);

		this.mainLight = new fm.DirectionalLight(0x888888, 1.2);
		this.mainLight.position.set(1, 1, 1).normalize();
		this.mainLight.target.position.copy(new fm.Vector3());
		this.scene.add(this.mainLight);

		/////////////////////////////////
		// shadow stuff
		/////////////////////////////////
		var sl = new fm.DirectionalLight(0x0, 0.1);
		this.scene.add(sl);
		sl.castShadow = this.map_.options.shadowEnabled;

		sl.shadow.camera.near = .1;
		sl.shadow.camera.far = 2000;
		sl.shadow.mapSize.set(this.map_.options.shadowSize, this.map_.options.shadowSize);
		sl.shadow.bias = .0001;
		
		this.shadowLight = sl;
		this._shadowAngleX = this.map_.options.lightAngleX;
		this._shadowAngleY = this.map_.options.lightAngleY;

		Object.defineProperties(this, {
			shadowAngleX: {
				get: function() {
					return this._shadowAngleX;
				},
				set: function(val) {
					this._shadowAngleX = val;
					this.updateShadowPostion();
				}
			},
			shadowAngleY: {
				get: function() {
					return this._shadowAngleY;
				},
				set: function(val) {
					this._shadowAngleY = val;
					this.updateShadowPostion();
				}
			}
		});

		scope.map_.on('loadComplete', function() {
			var max = Math.max(scope.map_.maxX - scope.map_.minX, scope.map_.maxY - scope.map_.minY) / 2;
			sl.shadow.camera.top = max;
			sl.shadow.camera.bottom = -max;
			sl.shadow.camera.right = max;
			sl.shadow.camera.left = -max;

			sl.shadow.camera.updateProjectionMatrix();

			scope.updateShadowPostion();
		});

		this.secondLight = new fm.DirectionalLight(0x333333);
		this.secondLight.position.set(-1,.5,-1).normalize();
		this.scene.add(this.secondLight);
		
		return true;
	},

	dispose: function () {
		if (this.canvas_.parentNode || this.canvas_.parentElement) {
			this.container_.removeChild(this.canvas_);
		}

		this.renderer.dispose();
	},

	updateShadowPostion: function(val) {
		val || (val = this.shadowLight.shadow.camera.top / 1.5);
		this.shadowDirection = new fm.Vector3(1, 0, 0);
		this.shadowDirection.applyEuler(new fm.Euler(0, this._shadowAngleY * fm.Math.DEG2RAD, this._shadowAngleX * fm.Math.DEG2RAD,'YZX'));

		this.mainLight.position.copy(this.shadowDirection);

		this.shadowLight.position.copy( this.map_.controls.target.clone().add(this.shadowDirection.multiplyScalar(val)));
		this.shadowLight.target.position.copy(this.map_.controls.target);
		this.shadowLight.lookAt(this.shadowLight.target);
	},

	tryResize_: function(force) {
		var w = this.container_.clientWidth;
		var h = this.container_.clientHeight;

		if (force || (w != this.w_ || h != this.h_)) {
			return {w:w, h:h};
		} else {
			return null;		
		}
	},
	
	//public 
	resize:function(w, h) {
		var scope = this;
		var lastSize = {
			w: this.w_,
			h: this.h_
		};
		
		this.w_2_ = w/2;
		this.h_2_ = h/2;

		// 更新Composer的大小
		this.composer.reSize(w, h);
		
		console.log('resize w h: ', w, h);
		
		// perspective camera
		this.renderer.setSize(w, h);
		this.camera.aspect = w / h;
		this.camera.updateProjectionMatrix();

		// top camera
		var orthoSize = fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera(scope.camera, scope.map_.controls);

		// scope.cameraTop.zoom   = 1; 
		scope.cameraTop.left   = - orthoSize.right;
		scope.cameraTop.right  = orthoSize.right;
		scope.cameraTop.top    = orthoSize.top;
		scope.cameraTop.bottom = - orthoSize.top;

		this.cameraTop.updateProjectionMatrix();
		
		// ortho camera
		this.cameraOrtho.left   = - this.w_2_;
		this.cameraOrtho.right  = this.w_2_;
		this.cameraOrtho.top    = this.h_2_;
		this.cameraOrtho.bottom = - this.h_2_;
		this.cameraOrtho.updateProjectionMatrix();

		// 重新计算
		this.w_ = this.container_.clientWidth;
		this.h_ = this.container_.clientHeight;
		
	},
	
	render:function(viewMode) {
		this.renderer.clear();
		if (viewMode == '3d') {
			// use this.composer.enabled = false; to raw renderer
			this.composer.render();
		} else {
			this.composer.renderOrtho();
		}
		
		this.renderer.clearDepth();
		this.renderer.render( this.sceneOrtho, this.cameraOrtho );

		//jimguo debug beg
		this.stats_.update();
		//jimguo debug end
	}
};
/**
 * 
 */

fengmap.MapCompass = function(visible, sceneOrtho, options) {
    this.options_ = options;
    this.spriteBg_ = null;
    this.spritePt_ = null;
    this.materialPt_ = null;
    this.materialBg_ = null;
    this.visible_ = visible;
    this.sceneOrtho_ = sceneOrtho;
    this.w_ = Math.min(options.compassSize,128);
    this.h_ = Math.min(options.compassSize,128);
    //this.margin_ = options.compassOffset;
};

fengmap.MapCompass.prototype = {
    set visible(b) {
        if (b != this.visible_) {
            this.visible_ = b;
            if (b) {
                this._tryInit();
                this.spriteBg_.visible = this.spritePt_.visible = true;

                // 需要更新下场景
            } else {
                if (this.spriteBg_ != null && this.spritePt_ != null) {
                    this.spriteBg_.visible = this.spritePt_.visible = false;
                }
            }
        }
    },
    get visible() {
        return this.visible_;
    },
    updateHUD: function(w, h,offset,size) {
        if (this.spriteBg_ != null && this.spritePt_ != null) {
            //Left Up
            var w_2 = w / 2;
            var h_2 = h / 2;

            var margin_ = !offset?this.options_.compassOffset:offset;

            var w_p = !size? this.w_: Math.min(size,128);
            //w_p = fm.Math.nextPowerOfTwo(w_p);
           
            this.spriteBg_.scale.set(w_p, w_p, 1);
            this.spritePt_.scale.set(w_p, w_p, 1);
            
            this.spriteBg_.position.set(-w_2 + this.w_ / 2 + margin_[0], h_2 - this.h_ / 2 - margin_[1], .5);
            this.spritePt_.position.set(-w_2 + this.w_ / 2 + margin_[0], h_2 - this.h_ / 2 - margin_[1], 1);
        }
    },
    updateDirection: function(a) {
        if (this.materialBg_ != null) {
            //console.log('updateDirection', a);
            //this.materialBg_.rotation = Math.PI - a;
            this.materialPt_.rotation = Math.PI + a;
        }
    },
    //private
    _tryInit: function() {
        if (this.spriteBg_ == null && this.spritePt_ == null) {
            var imageBg = document.createElement('img');

            var bg = this.options_.compass_bg ||'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAGhUlEQVR4nOWbzW/cRBjGn7HHY7u7m8RLojIF8SFUUQECFQqnimsF/wAgEIiWKEqgH+LjAJxRDwjU0kIEpZWASvQvAM6IEy1IILUqogiEaKZVluxu1tv1ztgeDvHSELLJfno3yU/KIfaM93kfjz2ej5fMzc2hEzjnLZUTQowCeBzAgwDuBbALAAfgAcgkxaoASgDmAFwG8AuAnwF8yzkvdySwRUg/DBBC3APgOQBPEEIeZYzVKKV1SqmklErTNEPDMGJCSAwAWmsjjmMjiiIahiFL/mwppau1Pg/gawBnOee/dSR2DXpmgBDCBPA0gGnTNB9zHGfRcZwqYyzoRqCU0gmCIBMEwUgURd8DmAVwjnMedXPdBl0bkAR+GMB7juNUtm3bVrJtu9YLcSup1+vujRs3xoIgyAF4DcDxbo3oygAhxEsATrmuW85mswuUUtWNmFYJw9DyfT9fq9VGAUxyzj/t9FqdGnAfgBnLsg6MjIxcZ4zVOxXQDVJKe3FxcbtS6jSAjzjnl9q9RicGzBBCTmaz2flsNltqt3I/8H1/zPf9Ca31K5zzj9qp264BR03TfNXzPGFZ1kDuejOUUnaxWORRFL3HOX+r1XpGG79xjDF2aHx8/M9hCx4ALMuqj4+P/8kYOyyEONZqvVYNOGHb9v58Pn/VMIy4Q419xzCMOJ/PX7Vte78Q4kRLdVooc8y27Rfy+bwghOguNfYdQojO5/PCtu0XWmkJ6xlwlDE26XnetR7pSw3P864xxiaFEEfXKreWATPJC29uI9z5lRBCtOd5c6ZpviqEmGlWrpkBDxBCTnqeJ4b5mV8PwzBiz/MEIeSkEOL+Vcs0qTudy+Xmh/Ft3y6WZdVzudw8gOnVzq9mwIxlWS9mMpmh+MjpBZlMpmRZ1gEhxOTKcys/hCgAOax9fTcopexCoXAnALp8ALWyBRx2XXdxswUPLD0KruuWsTRy/ZflLYACkBMTE3+kNapLmzAMrfn5+bsAMM55CPy3BTzrOE5lswYPAJRS5TiOD+DZxrHlBkxvphdfMzKZTBHLeoSGAfdRSnd3O321EWCMBZTS3Y3vgoYBTzuOUxmgrlRJYn0KuGnAPtu2q4OTlC5JrPuAJQPGCCF7tkLzb8AYCwghe4QQYwaAvYyxvsziDjNJzHsNAA9RSjfdh896JDE/ZADYRSmVgxaUNknMuwwAO7ewATsNALebphkOWlDaJDHfbgAY2ciTHp2SxDxqAMg1Vmm3EknM2XbWBTYVWmsCQBoAKlrrLWdEEnPFALAYx/GWMyCJuWIA+CuKIjpoQWkTx7EJ4LoB4NcwDNmgBaVNEvOvBoDLW9iAywaAn8IwtActKG2SmH8yAHwnpXQHLShtkpi/MwCUtNYXpJTOoEWlhZTS0Vpf4JyXGt3f1/V6PbNmrU1EEus3wM0psbO1Wm1kcJLSJYn1C+CmAVeiKDq/Fd4FUko3iqLznPMrwH/XBWar1erogHSlRhLjbOP/5QacC4IgF4ahlb6sdAjD0Ep2mZ5rHFtuQAjgDd/386krS4kkttcb64LA/1eHj9VqtVGl1Kb7MFJK2cnW2uPLj680IAIwVS6Xt6emLCWSmKZWbq5ebRj8iVLqdLVaHUtHWv/xfX9MKXWac/7JynPN5gFmK5XKhFJqww+SlFK27/sTAFbdQ9zMgIta60PFYnHHRp4siePYKBaLO7TWU812kq8V3Mkoit5PLkD6pLFvaK1JsVjckWyePtWs3Hp3900p5alSqXRrj/X1nVKpdKuU8hTn/M21yrXSvI8EQfBZsVjkG6ElJHeeB0HwGef8yHrlW32+DwZBcGZhYeG2YX4nxHFsLCws3BYEwRnO+cFW6rQTzBEp5QeFQuGOYewdlFKsUCjcIaX8oJU736CTlJmXCSEncrnc/LBsqqpWq2OVSmVCa32Qc/5hO3U7TZq6H8C0ZVkHRkdHrw9qY6VSyi6Xy42kqVnO+cV2r9Ft2twkgI9d113M5XJ/p7XKHEURrVQqtyQTG1NrdXPr0YvESQrgDQDvOI5TyWQypX7tN5JSOtVqtZE4+TaAd5eP7Dqhl6mzDMAzAKZM09zjuu6ibds9SZ2t1+uZWq02EkXRBQAfA/iSc96TTR39TJ5+HsCThJCHGWM3LMuqJ4nTaq3k6SiKrDAMmVLKllJu01r/COArAJ8PdfJ0M4QQY1hKn38ESxmndwPYjtXT568B+B3AJQA/YCl9vq89zT/uIvNLxH1bgwAAAABJRU5ErkJggg==';
            imageBg.src = bg;
            var textureBg = new fm.Texture(imageBg);

            var imagePt = document.createElement('img'); //image can't shared, texture draw image maybe async!!!
            var fg = this.options_.compass_fg || 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTExIDc5LjE1ODMyNSwgMjAxNS8wOS8xMC0wMToxMDoyMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ODc3NkExOTBBM0QwMTFFNkI4Rjk5RTE2MjhCMzFCODAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ODc3NkExOTFBM0QwMTFFNkI4Rjk5RTE2MjhCMzFCODAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozRkM2NUZGNUEzQ0MxMUU2QjhGOTlFMTYyOEIzMUI4MCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozRkM2NUZGNkEzQ0MxMUU2QjhGOTlFMTYyOEIzMUI4MCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PvSIOBAAAAKaSURBVHja7JvLTuMwFECddNQPQEhVNMCkCJHhESqxa5o9YofEewV7EJ3Zt0gzHzDzPbPvY1vmBwZaEOqCRXeoPIqdelBTQpu0tYPta+lKIdjXV+ceG1SB1ul0kMpDR4oPAAAAAAAAAAAAAAAAAACg6vjEKnGtVhs25TOOP6lUijxv4LgZNNkwDOkM+IVjhcZv1Y6AjWOn5+tt+k4ZAIW+vXX6TgkAK33d/z/Iu1UVABTf2TcWC/QYur874Pu7dI60AApD9uRuAU8ASzj2Qswjc5ZlBFAMuR9XC3SO3d+PMH+frpEGQCHiXtws4AHgK46DEdaRNZYMAIoj7kPWnIsOwIp49oPuAktkAKT7iTHWJ1jfBTrj7h9MIM8hjkURARyN2f1eC45FBLD5QXNxA2B+0Fy+obH6+4BHy3rQm82hnzk2cbypoNXyFzk19Wzc3SVY1MnsQ1GkaW291ZpM/unpe+GOwOP8/N+JJVtYuBAOwFM6/QPpE0hPcpjmT+HuAHwEUNt1/yVLpYEX2G3QHdA7XPdSK5XSBqM6mf4m+LC2djKWBWQtycFwMDWADGzBJbbgy0gG4LUId59kEtIAzwLbHs0Cssa2T1nXx9wAasEVtmAukgGuW0fUHKENoBacRrKAU/e5GeBZkMtdJcvluVAG5HJ1VC6/3hvCG0B/IpyFsqB785/xqoubAZ4FjlNPViqzAw1wnAaqVHymSGFAKAu63f/GsyauBlALGtiCmUADHOca9RkilQHUgnygBd3u53nXw90Az4JstpGsVmd8BmSz16hanQ1MJZMBngWZTN4HiDxnMt/jqCUWA3rvAs+Ad86+tAZ4ANbXt55Ms41I4Oe46tDgf4YUHwAAAAAAAAAAAAAAAAAAQNXxIsAAkfC85URYZVgAAAAASUVORK5CYII=';
            imagePt.src = fg;
            var texturePt = new fm.Texture(imagePt);

            textureBg.needsUpdate = true;
            texturePt.needsUpdate = true;

            this.materialBg_ = new fm.SpriteMaterial({ map: textureBg });
            this.spriteBg_ = new fm.Sprite(this.materialBg_);
            this.spriteBg_.scale.set(this.w_, this.h_, 1);

            this.materialPt_ = new fm.SpriteMaterial({ map: texturePt });
            this.spritePt_ = new fm.Sprite(this.materialPt_);
            this.spritePt_.scale.set(this.lw_, this.lh_, 1);

            //
            this.sceneOrtho_.add(this.spriteBg_);
            this.sceneOrtho_.add(this.spritePt_);

            var container = this.options_.container;

            var w = container.clientWidth;
            var h = container.clientHeight;

            this.updateHUD(w, h);
        }
    },

    setBgVisible: function (boo) {
        this.spriteBg_.visible = boo;
    },

    setFgVisible: function (boo) {
        this.spritePt_.visible = boo;
    },

    setBgImage: function (url) {
        var s = this;
        fengmap.MapUtil.loadTexture(url, function (tex) {
            s.spriteBg_.material.map = tex;
            s.spriteBg_.material.needsUpdate = true;
        });
    },

    setFgImage: function (url) {
        var s = this;
        fengmap.MapUtil.loadTexture(url, function (tex) {
            s.spritePt_.material.map = tex;
            s.spritePt_.material.needsUpdate = true;
        });
    }



};

(function () {
	var _$=["\x4d\x61\x70\x53\x65\x72\x76\x69\x63\x65","\x66\x6d\x62\x61\x6e\x61\x6e\x61","\x6f\x70\x74\x69\x6f\x6e\x73\x5f","\x73\x70\x72\x69\x74\x65\x5f","\x76\x69\x73\x69\x62\x6c\x65\x5f","\x73\x63\x65\x6e\x65\x4f\x72\x74\x68\x6f\x5f","\x77\x5f","\x68\x5f","\x6d\x61\x72\x67\x69\x6e\x5f","\x5f\x74\x72\x79\x49\x6e\x69\x74","\x70\x72\x6f\x74\x6f\x74\x79\x70\x65","\x76\x69\x73\x69\x62\x6c\x65","\x70\x6f\x73\x69\x74\x69\x6f\x6e","\x73\x65\x74","\x64\x6f\x63\x75\x6d\x65\x6e\x74","\x63\x72\x65\x61\x74\x65\x45\x6c\x65\x6d\x65\x6e\x74",'\x69\x6d\x67',"\x73\x72\x63",'\x64\x61\x74\x61\x3a\x69\x6d\x61\x67\x65\x2f\x70\x6e\x67\x3b\x62\x61\x73\x65\x36\x34\x2c\x69\x56\x42\x4f\x52\x77\x30\x4b\x47\x67\x6f\x41\x41\x41\x41\x4e\x53\x55\x68\x45\x55\x67\x41\x41\x41\x51\x41\x41\x41\x41\x41\x7a\x43\x41\x4d\x41\x41\x41\x42\x50\x4e\x53\x62\x6a\x41\x41\x41\x43\x2b\x6c\x42\x4d\x56\x45\x55\x41\x41\x41\x41\x6b\x4a\x43\x52\x59\x57\x46\x68\x51\x55\x46\x42\x53\x55\x6c\x49\x6a\x49\x79\x4d\x34\x4f\x44\x69\x74\x33\x41\x78\x4a\x53\x55\x6d\x49\x79\x51\x4d\x38\x50\x44\x79\x50\x7a\x41\x56\x54\x55\x31\x4d\x71\x4b\x69\x70\x41\x51\x45\x42\x59\x57\x46\x67\x6b\x4a\x43\x51\x6f\x4b\x43\x67\x2f\x50\x7a\x2b\x4d\x79\x67\x57\x52\x7a\x51\x59\x32\x4e\x6a\x59\x33\x4e\x7a\x65\x51\x7a\x51\x56\x55\x56\x46\x53\x4f\x7a\x41\x55\x39\x50\x54\x31\x59\x57\x46\x67\x77\x4d\x44\x43\x52\x7a\x51\x57\x49\x79\x51\x53\x4d\x79\x77\x56\x43\x51\x6b\x4a\x34\x77\x41\x43\x4c\x79\x67\x52\x2b\x77\x77\x47\x62\x30\x77\x67\x33\x4e\x7a\x65\x57\x30\x41\x65\x6e\x32\x51\x71\x4c\x79\x67\x53\x59\x30\x51\x63\x73\x4c\x43\x79\x45\x78\x77\x4f\x6a\x31\x77\x6d\x42\x78\x51\x4a\x4f\x54\x6b\x36\x55\x7a\x77\x61\x6f\x32\x51\x75\x51\x7a\x51\x56\x49\x53\x45\x69\x68\x31\x67\x6d\x66\x31\x41\x69\x45\x78\x77\x4e\x4f\x54\x6b\x35\x4e\x54\x55\x30\x74\x4c\x53\x32\x54\x7a\x77\x59\x78\x4d\x54\x47\x4a\x79\x51\x52\x4f\x54\x6b\x36\x6b\x31\x77\x70\x43\x51\x6b\x4b\x74\x33\x41\x73\x36\x4f\x6a\x6f\x38\x50\x44\x79\x5a\x30\x51\x64\x39\x77\x77\x45\x75\x4c\x69\x36\x65\x31\x41\x69\x65\x31\x41\x69\x54\x7a\x77\x61\x6e\x32\x51\x70\x4b\x53\x6b\x70\x50\x54\x30\x39\x4c\x53\x30\x74\x50\x54\x30\x38\x76\x4c\x79\x39\x42\x51\x55\x47\x53\x7a\x67\x5a\x42\x51\x55\x47\x42\x78\x51\x4a\x38\x77\x67\x46\x41\x51\x45\x43\x54\x7a\x67\x61\x70\x32\x67\x74\x2f\x78\x41\x46\x44\x51\x30\x4f\x59\x30\x51\x65\x6d\x32\x41\x71\x68\x31\x67\x6d\x46\x78\x77\x4e\x49\x53\x45\x69\x53\x7a\x67\x61\x6c\x32\x41\x71\x68\x31\x67\x6b\x78\x4d\x54\x47\x6f\x32\x67\x73\x78\x4d\x54\x46\x4e\x54\x55\x31\x39\x77\x67\x45\x31\x4e\x54\x57\x42\x78\x41\x4b\x49\x79\x41\x4d\x37\x4f\x7a\x75\x62\x30\x67\x68\x59\x57\x46\x69\x46\x78\x77\x4f\x55\x7a\x77\x5a\x42\x51\x55\x46\x56\x56\x56\x55\x2f\x50\x7a\x2b\x44\x78\x67\x4a\x52\x55\x56\x47\x67\x31\x51\x6b\x31\x4e\x54\x57\x59\x30\x51\x64\x4d\x54\x45\x78\x52\x55\x56\x46\x4b\x53\x6b\x71\x50\x7a\x41\x57\x42\x78\x51\x4b\x6a\x31\x77\x6d\x6a\x31\x77\x6d\x67\x31\x51\x6d\x71\x32\x67\x74\x2b\x77\x77\x4b\x41\x78\x41\x49\x36\x4f\x6a\x71\x63\x30\x77\x67\x6d\x4a\x69\x5a\x54\x55\x31\x4d\x35\x4f\x54\x6d\x61\x30\x67\x65\x50\x7a\x51\x56\x46\x52\x55\x56\x53\x55\x6c\x4b\x41\x78\x41\x4a\x58\x56\x31\x63\x73\x4c\x43\x77\x7a\x4d\x7a\x4d\x76\x4c\x79\x39\x53\x55\x6c\x49\x79\x4d\x6a\x4a\x4b\x53\x6b\x71\x5a\x30\x67\x64\x49\x53\x45\x69\x49\x79\x51\x4e\x34\x77\x51\x43\x71\x32\x77\x75\x6a\x31\x77\x6b\x2f\x50\x7a\x38\x34\x4f\x44\x69\x65\x31\x41\x69\x51\x7a\x51\x55\x6d\x4a\x69\x61\x56\x7a\x77\x65\x46\x78\x77\x4f\x64\x31\x41\x69\x6d\x32\x41\x70\x43\x51\x6b\x49\x31\x4e\x54\x55\x6f\x4b\x43\x68\x45\x52\x45\x53\x6e\x32\x51\x71\x46\x78\x77\x4e\x2f\x78\x41\x4a\x47\x52\x6b\x59\x34\x4f\x44\x67\x70\x4b\x53\x6c\x41\x51\x45\x42\x36\x77\x51\x43\x52\x7a\x51\x57\x4c\x79\x67\x52\x53\x55\x6c\x4a\x53\x55\x6c\x49\x7a\x4d\x7a\x4f\x53\x7a\x67\x59\x70\x4b\x53\x6d\x6f\x32\x67\x75\x66\x31\x51\x6d\x47\x79\x41\x4f\x4c\x79\x77\x53\x70\x32\x77\x73\x70\x4b\x53\x6c\x44\x51\x30\x4d\x76\x4c\x79\x2b\x42\x78\x51\x4b\x44\x78\x51\x49\x6b\x4a\x43\x53\x74\x33\x41\x79\x58\x30\x51\x65\x4e\x79\x67\x55\x70\x4b\x53\x6d\x4f\x79\x77\x51\x75\x4c\x69\x35\x37\x77\x51\x47\x49\x79\x41\x4d\x79\x4d\x6a\x4a\x48\x52\x30\x64\x54\x55\x31\x4d\x2b\x50\x6a\x35\x57\x56\x6c\x61\x72\x32\x77\x75\x50\x7a\x41\x55\x6e\x4a\x79\x63\x30\x4e\x44\x53\x4a\x79\x51\x51\x38\x50\x44\x77\x35\x4f\x54\x6b\x33\x4e\x7a\x65\x4e\x79\x77\x55\x70\x4b\x53\x6b\x79\x4d\x6a\x4a\x48\x52\x30\x63\x2b\x50\x6a\x36\x66\x31\x41\x6d\x61\x30\x67\x68\x53\x55\x6c\x4b\x69\x31\x67\x6d\x4c\x79\x67\x56\x51\x55\x46\x42\x44\x51\x30\x4e\x2f\x78\x41\x4a\x39\x77\x67\x46\x36\x77\x51\x46\x4f\x54\x6b\x36\x52\x7a\x51\x61\x6e\x32\x51\x75\x6d\x32\x41\x71\x70\x32\x51\x75\x53\x7a\x67\x61\x58\x30\x51\x65\x57\x7a\x77\x65\x56\x7a\x77\x65\x54\x7a\x67\x59\x77\x4d\x44\x43\x6c\x32\x41\x71\x6a\x31\x77\x71\x64\x30\x77\x69\x62\x30\x77\x68\x4c\x53\x30\x74\x4b\x53\x6b\x6f\x37\x4f\x7a\x74\x42\x51\x55\x45\x74\x4c\x53\x30\x72\x4b\x79\x75\x48\x79\x41\x53\x47\x78\x77\x4f\x45\x78\x67\x4f\x44\x78\x67\x4f\x43\x78\x51\x4a\x4d\x54\x45\x78\x41\x51\x45\x41\x69\x64\x33\x75\x56\x41\x41\x41\x41\x79\x6e\x52\x53\x54\x6c\x4d\x41\x2f\x6f\x6b\x62\x2b\x69\x45\x61\x34\x41\x5a\x4e\x2b\x67\x61\x79\x59\x35\x79\x4f\x38\x71\x51\x44\x35\x4d\x2b\x41\x61\x67\x6a\x6b\x65\x47\x4c\x79\x56\x51\x77\x62\x45\x41\x7a\x38\x46\x43\x49\x65\x45\x41\x53\x35\x6d\x44\x74\x79\x4b\x53\x55\x58\x5a\x54\x53\x79\x69\x52\x58\x77\x78\x73\x53\x45\x58\x56\x70\x59\x54\x45\x49\x72\x39\x2f\x58\x7a\x75\x61\x2b\x74\x6b\x34\x69\x46\x65\x57\x5a\x6b\x55\x6b\x74\x43\x4d\x79\x6b\x65\x39\x2b\x33\x67\x31\x4d\x7a\x49\x77\x4c\x69\x72\x6f\x70\x57\x4e\x6a\x59\x70\x39\x63\x46\x31\x44\x50\x7a\x30\x35\x4e\x6a\x58\x38\x2b\x50\x58\x31\x37\x65\x72\x68\x33\x64\x7a\x55\x72\x4b\x57\x6a\x6d\x35\x68\x37\x63\x48\x42\x74\x59\x45\x39\x45\x4c\x76\x72\x36\x38\x2b\x76\x71\x36\x4d\x33\x4c\x75\x71\x61\x69\x6d\x59\x4b\x42\x67\x57\x5a\x52\x50\x79\x38\x6c\x2b\x76\x6a\x30\x38\x4f\x72\x70\x34\x64\x37\x65\x32\x74\x58\x56\x31\x64\x48\x4f\x78\x4d\x47\x2b\x75\x71\x71\x6a\x6d\x35\x53\x54\x6b\x48\x70\x77\x53\x76\x76\x33\x38\x2f\x48\x76\x33\x4e\x6a\x56\x79\x37\x75\x6c\x6d\x35\x68\x38\x65\x46\x6e\x34\x37\x2b\x76\x71\x79\x62\x57\x75\x69\x6e\x4c\x34\x36\x62\x78\x64\x35\x6e\x66\x35\x7a\x41\x41\x41\x43\x72\x4e\x4a\x52\x45\x46\x55\x61\x4e\x37\x4d\x6c\x6c\x74\x49\x56\x45\x45\x59\x78\x7a\x38\x79\x79\x69\x34\x55\x62\x42\x65\x37\x73\x43\x6d\x62\x56\x6b\x74\x62\x5a\x69\x36\x4b\x70\x46\x6d\x43\x5a\x5a\x74\x64\x51\x43\x55\x74\x57\x7a\x4d\x4a\x4d\x74\x51\x77\x76\x49\x54\x61\x51\x34\x51\x56\x50\x70\x67\x46\x47\x6b\x6c\x55\x55\x46\x42\x45\x46\x36\x49\x6f\x65\x71\x6e\x6f\x70\x59\x73\x2b\x64\x49\x47\x39\x73\x76\x75\x51\x6c\x61\x6c\x73\x62\x72\x61\x50\x4c\x66\x51\x2f\x4f\x32\x63\x76\x35\x2b\x7a\x4d\x36\x55\x33\x37\x51\x57\x64\x6d\x76\x76\x38\x63\x74\x2f\x6d\x66\x37\x35\x73\x5a\x6b\x74\x6a\x5a\x65\x47\x78\x35\x48\x4d\x63\x6b\x6c\x6a\x65\x6b\x30\x43\x53\x78\x36\x6e\x46\x2b\x66\x76\x34\x4c\x45\x32\x6c\x51\x6c\x67\x2b\x4b\x65\x45\x72\x46\x69\x35\x6d\x39\x5a\x54\x79\x68\x75\x6e\x65\x6d\x6d\x47\x66\x56\x46\x4b\x4c\x72\x76\x51\x61\x54\x5a\x6b\x44\x53\x71\x51\x46\x51\x51\x57\x4c\x61\x42\x69\x52\x34\x42\x70\x68\x43\x53\x6a\x56\x48\x71\x52\x72\x51\x78\x45\x72\x41\x38\x6c\x36\x4c\x52\x4a\x6f\x6b\x6b\x76\x4d\x48\x77\x43\x6b\x39\x43\x5a\x6b\x35\x49\x4e\x48\x47\x55\x57\x36\x46\x6c\x47\x63\x63\x70\x57\x68\x41\x43\x32\x62\x61\x47\x52\x64\x6f\x6d\x4d\x76\x6e\x50\x45\x30\x57\x71\x61\x65\x2b\x53\x31\x68\x4a\x52\x42\x46\x55\x30\x4d\x35\x4a\x41\x4b\x62\x77\x7a\x4c\x4d\x69\x66\x76\x33\x57\x68\x6a\x43\x72\x49\x32\x77\x6f\x43\x2f\x30\x65\x36\x6d\x61\x6a\x43\x37\x54\x51\x6c\x4e\x50\x78\x4e\x63\x52\x6a\x34\x52\x37\x52\x79\x79\x5a\x55\x63\x78\x4c\x67\x4b\x34\x4e\x54\x48\x64\x73\x51\x62\x69\x63\x75\x70\x6a\x4a\x6f\x65\x55\x54\x46\x48\x6f\x39\x6e\x4c\x6b\x30\x39\x78\x6d\x2b\x4d\x64\x6f\x46\x75\x6c\x66\x57\x4f\x2b\x4a\x55\x67\x57\x6c\x61\x46\x78\x33\x57\x4b\x59\x7a\x2f\x43\x31\x61\x4a\x64\x70\x2f\x66\x62\x4e\x78\x68\x51\x41\x77\x50\x2b\x67\x77\x53\x67\x64\x70\x2f\x50\x6c\x34\x6c\x2f\x71\x2f\x6c\x79\x55\x70\x37\x50\x6c\x2f\x63\x59\x75\x6f\x6e\x55\x50\x45\x4f\x30\x69\x50\x72\x77\x6a\x44\x65\x6e\x41\x6c\x47\x6a\x38\x46\x54\x78\x2b\x66\x71\x49\x4c\x46\x2b\x2b\x66\x46\x6c\x50\x55\x30\x2f\x62\x7a\x35\x38\x2f\x43\x36\x2f\x6a\x6b\x63\x71\x56\x43\x36\x46\x55\x34\x4a\x47\x33\x51\x71\x32\x6b\x51\x73\x6d\x63\x51\x2f\x75\x6c\x43\x61\x54\x6d\x42\x4b\x49\x64\x4a\x41\x43\x2f\x39\x6f\x52\x6f\x78\x35\x38\x2f\x66\x37\x4a\x70\x36\x71\x6c\x79\x75\x39\x31\x47\x4b\x78\x37\x37\x65\x61\x6f\x68\x44\x34\x71\x68\x77\x75\x33\x4f\x54\x49\x35\x62\x49\x78\x51\x72\x43\x73\x45\x4e\x4d\x53\x6c\x75\x65\x30\x41\x30\x56\x62\x53\x72\x39\x4c\x6e\x64\x5a\x71\x4c\x31\x4d\x47\x41\x48\x54\x54\x31\x46\x6b\x67\x46\x36\x50\x50\x41\x31\x34\x36\x6b\x49\x4f\x57\x4e\x32\x75\x2f\x76\x55\x61\x30\x77\x4e\x76\x77\x4c\x52\x58\x55\x55\x71\x56\x72\x76\x64\x65\x51\x61\x30\x49\x6c\x4e\x52\x63\x4b\x32\x2f\x66\x76\x32\x79\x6b\x41\x61\x35\x38\x30\x56\x30\x35\x5a\x4c\x45\x78\x6d\x6b\x69\x75\x72\x70\x4a\x4a\x6e\x46\x39\x6c\x33\x42\x53\x49\x74\x75\x76\x48\x51\x35\x48\x4f\x35\x6e\x78\x4c\x4f\x4b\x63\x6b\x51\x36\x67\x70\x32\x73\x4f\x78\x35\x56\x56\x36\x67\x53\x41\x73\x6f\x31\x41\x46\x54\x70\x6d\x55\x6f\x47\x2f\x6c\x36\x6b\x6e\x50\x69\x61\x38\x55\x45\x44\x55\x50\x44\x45\x78\x30\x55\x30\x61\x72\x48\x38\x76\x70\x6f\x56\x41\x6a\x63\x59\x45\x2b\x52\x37\x52\x33\x66\x44\x50\x75\x31\x59\x68\x2f\x6a\x76\x56\x31\x49\x62\x6e\x45\x34\x77\x34\x71\x30\x52\x70\x58\x48\x45\x34\x72\x6e\x47\x73\x59\x5a\x6d\x66\x6c\x49\x6d\x75\x53\x53\x55\x7a\x79\x2f\x67\x59\x4d\x66\x38\x45\x55\x61\x58\x4e\x5a\x69\x76\x57\x4e\x6b\x41\x44\x69\x37\x51\x36\x74\x4e\x6f\x4f\x35\x47\x72\x4e\x4f\x43\x4d\x66\x57\x4f\x50\x6a\x34\x2b\x6c\x45\x70\x39\x45\x59\x53\x59\x55\x4a\x77\x56\x6f\x39\x4a\x55\x45\x30\x71\x36\x32\x42\x74\x49\x31\x31\x6d\x39\x41\x74\x56\x4b\x71\x36\x4b\x2b\x50\x6a\x54\x34\x54\x62\x4c\x75\x62\x44\x31\x64\x73\x77\x49\x4a\x63\x30\x61\x48\x47\x42\x68\x39\x4e\x56\x50\x48\x6a\x67\x6b\x6d\x6a\x51\x45\x56\x6b\x34\x45\x77\x41\x6d\x53\x45\x6a\x6d\x7a\x6e\x57\x42\x36\x55\x73\x61\x47\x70\x61\x6f\x6d\x65\x35\x79\x79\x51\x59\x30\x2b\x66\x31\x2b\x45\x79\x6f\x42\x54\x51\x47\x70\x36\x45\x51\x51\x71\x39\x54\x58\x2b\x76\x32\x64\x71\x67\x53\x41\x55\x69\x74\x76\x43\x78\x33\x6f\x6e\x31\x61\x6f\x73\x4d\x7a\x76\x4e\x77\x75\x33\x58\x63\x79\x48\x59\x65\x65\x38\x58\x74\x74\x75\x30\x71\x41\x5a\x46\x34\x58\x73\x6c\x41\x51\x31\x47\x79\x31\x6e\x50\x4b\x43\x48\x4b\x42\x74\x4e\x46\x6d\x64\x43\x63\x61\x4e\x48\x55\x6f\x68\x53\x73\x45\x78\x58\x59\x34\x4b\x4f\x64\x49\x6b\x71\x55\x70\x61\x34\x58\x47\x38\x70\x52\x4c\x6e\x54\x65\x52\x46\x48\x6e\x4d\x45\x4a\x30\x4d\x61\x53\x6a\x74\x42\x70\x4a\x50\x4b\x4b\x69\x30\x36\x6e\x79\x70\x78\x79\x53\x4e\x73\x69\x2b\x59\x35\x42\x6d\x30\x4a\x4f\x72\x6e\x55\x36\x4f\x30\x6d\x41\x6c\x62\x32\x37\x7a\x2b\x76\x64\x76\x4a\x45\x30\x79\x4d\x49\x71\x75\x44\x57\x69\x57\x77\x4b\x6c\x42\x6a\x55\x69\x4f\x55\x51\x38\x47\x70\x6b\x42\x75\x53\x37\x32\x6e\x54\x6b\x38\x64\x4c\x6e\x6b\x61\x32\x69\x42\x30\x31\x6d\x62\x7a\x46\x71\x6e\x4b\x70\x48\x4e\x43\x47\x31\x48\x61\x30\x4a\x62\x72\x6b\x77\x41\x52\x4a\x41\x41\x4d\x74\x73\x78\x36\x6c\x54\x71\x7a\x44\x49\x2b\x68\x65\x7a\x50\x33\x76\x52\x36\x39\x79\x61\x53\x42\x75\x64\x78\x55\x79\x72\x6d\x57\x38\x4f\x55\x56\x6a\x52\x38\x41\x37\x71\x68\x5a\x4c\x48\x4c\x5a\x6a\x50\x78\x53\x4a\x6a\x75\x38\x54\x54\x4b\x61\x66\x37\x6a\x78\x30\x74\x70\x4b\x65\x6b\x2f\x30\x46\x48\x73\x57\x2b\x32\x49\x31\x4a\x45\x73\x4e\x53\x6b\x54\x41\x4a\x47\x44\x30\x65\x39\x39\x45\x55\x4e\x46\x39\x71\x78\x46\x6f\x4a\x77\x45\x4e\x45\x48\x4d\x49\x62\x6f\x52\x43\x4e\x53\x54\x46\x6f\x30\x34\x4a\x33\x76\x34\x42\x6b\x44\x4a\x52\x59\x32\x67\x34\x64\x38\x6b\x64\x6b\x4a\x70\x52\x67\x4d\x66\x57\x6f\x68\x48\x44\x78\x54\x35\x6f\x43\x67\x64\x47\x61\x6e\x54\x45\x56\x67\x34\x4d\x6a\x4b\x53\x51\x7a\x46\x63\x44\x51\x65\x4d\x36\x47\x51\x6f\x50\x6a\x41\x43\x65\x2f\x51\x78\x66\x6d\x42\x38\x55\x46\x45\x38\x43\x44\x53\x52\x67\x41\x4b\x49\x39\x34\x68\x4b\x67\x73\x48\x4e\x38\x35\x37\x50\x34\x33\x4f\x45\x55\x43\x4d\x54\x45\x35\x63\x53\x69\x45\x63\x6c\x54\x74\x41\x65\x31\x75\x77\x6b\x48\x6a\x75\x67\x74\x4b\x49\x52\x33\x72\x61\x4c\x6f\x56\x54\x4b\x79\x78\x77\x64\x76\x63\x72\x32\x70\x74\x48\x52\x30\x56\x4b\x4b\x6b\x6a\x4d\x61\x56\x75\x36\x68\x70\x31\x68\x66\x75\x53\x70\x67\x78\x4c\x69\x4f\x59\x74\x69\x45\x51\x41\x59\x4a\x4b\x49\x56\x6f\x4a\x4b\x71\x33\x61\x2f\x43\x4f\x55\x43\x4d\x32\x32\x36\x55\x55\x34\x6f\x45\x44\x5a\x47\x49\x33\x4f\x30\x64\x71\x2b\x43\x63\x6f\x46\x4b\x77\x38\x57\x33\x6a\x62\x33\x67\x6b\x6c\x69\x39\x31\x4c\x36\x38\x62\x47\x53\x6c\x6e\x76\x30\x64\x6a\x59\x57\x44\x70\x46\x67\x44\x43\x32\x69\x56\x6d\x42\x33\x6b\x6d\x4b\x73\x67\x4a\x6a\x4a\x45\x41\x4d\x2f\x57\x78\x75\x68\x46\x6b\x59\x4c\x79\x55\x2b\x71\x58\x74\x43\x76\x35\x4f\x34\x39\x34\x4d\x47\x68\x77\x67\x31\x59\x72\x4f\x39\x34\x57\x38\x53\x35\x32\x42\x4e\x41\x68\x72\x68\x51\x64\x6f\x4b\x42\x63\x58\x52\x49\x71\x77\x52\x43\x35\x52\x57\x6b\x74\x41\x2f\x47\x68\x35\x2b\x79\x6f\x49\x5a\x77\x38\x50\x44\x5a\x79\x6e\x4d\x64\x6f\x78\x4b\x6f\x39\x33\x74\x73\x55\x57\x4d\x73\x66\x4c\x37\x4c\x6c\x57\x38\x43\x73\x73\x77\x50\x6b\x6c\x63\x30\x76\x75\x48\x67\x59\x48\x53\x6a\x6d\x4b\x64\x52\x32\x63\x4c\x6b\x45\x71\x67\x78\x4f\x73\x56\x62\x42\x4c\x79\x41\x59\x4c\x47\x79\x7a\x39\x49\x37\x30\x4b\x78\x45\x44\x55\x4c\x61\x79\x51\x62\x43\x69\x73\x4f\x77\x35\x36\x68\x6f\x51\x4c\x35\x30\x77\x77\x42\x41\x35\x47\x63\x44\x78\x6a\x49\x2b\x58\x41\x53\x33\x5a\x79\x59\x42\x4d\x42\x51\x6d\x51\x43\x30\x54\x67\x6f\x6c\x55\x39\x51\x39\x6a\x4f\x74\x4b\x46\x33\x4c\x6f\x48\x35\x4b\x41\x73\x7a\x4e\x6d\x2f\x2f\x36\x39\x4e\x57\x32\x47\x41\x42\x32\x52\x72\x74\x37\x72\x4c\x52\x45\x62\x6b\x49\x59\x61\x45\x52\x36\x6b\x6c\x54\x41\x41\x4b\x38\x2f\x53\x72\x42\x46\x57\x48\x43\x73\x48\x42\x77\x66\x44\x33\x2b\x34\x31\x2b\x75\x48\x45\x58\x59\x72\x2b\x61\x32\x49\x63\x52\x50\x38\x65\x52\x56\x69\x44\x59\x51\x34\x70\x79\x55\x41\x73\x2b\x73\x6e\x78\x74\x6a\x5a\x47\x6f\x6c\x30\x66\x50\x33\x36\x38\x51\x32\x4a\x51\x49\x34\x48\x41\x44\x62\x35\x55\x48\x77\x68\x73\x54\x67\x6d\x64\x49\x33\x73\x46\x6d\x30\x51\x67\x45\x4c\x67\x41\x48\x2f\x35\x56\x49\x36\x44\x6a\x38\x2b\x66\x50\x61\x34\x69\x78\x43\x66\x30\x46\x72\x4b\x76\x66\x67\x2f\x37\x61\x38\x4f\x72\x51\x4e\x30\x59\x54\x59\x42\x42\x6b\x4c\x46\x56\x79\x46\x72\x47\x46\x42\x4b\x4b\x57\x69\x62\x6b\x76\x32\x58\x66\x6b\x30\x36\x64\x50\x6d\x67\x61\x6b\x62\x51\x34\x47\x39\x2f\x45\x54\x50\x42\x67\x4d\x37\x6b\x57\x4f\x48\x41\x38\x47\x4c\x36\x50\x68\x4d\x41\x38\x7a\x65\x6f\x69\x65\x59\x35\x6d\x43\x47\x6f\x48\x43\x69\x73\x4f\x49\x78\x55\x58\x71\x75\x52\x2b\x44\x57\x5a\x45\x31\x52\x34\x70\x36\x44\x51\x62\x70\x46\x42\x32\x4a\x77\x4a\x77\x59\x79\x31\x34\x74\x34\x50\x4a\x71\x34\x59\x47\x51\x73\x59\x64\x68\x77\x43\x4c\x53\x59\x50\x64\x73\x75\x37\x31\x6b\x57\x54\x79\x4c\x74\x33\x37\x41\x4d\x62\x45\x46\x4e\x58\x4c\x5a\x62\x6a\x38\x75\x71\x42\x47\x37\x66\x66\x61\x4d\x30\x47\x33\x37\x55\x70\x71\x77\x52\x76\x36\x57\x57\x2f\x59\x67\x62\x59\x56\x52\x47\x48\x34\x64\x49\x67\x31\x53\x61\x41\x4e\x74\x6f\x4a\x68\x6f\x63\x6d\x74\x70\x45\x37\x49\x55\x41\x69\x45\x75\x46\x6c\x30\x74\x61\x43\x47\x4c\x69\x30\x68\x62\x43\x77\x34\x56\x75\x74\x53\x6c\x69\x72\x69\x49\x69\x6b\x4d\x64\x42\x48\x46\x51\x55\x47\x70\x74\x51\x51\x53\x4c\x72\x58\x59\x6f\x2f\x64\x6b\x53\x6a\x52\x68\x63\x68\x4d\x54\x64\x4c\x5a\x6f\x66\x73\x2f\x53\x39\x33\x4a\x75\x62\x32\x48\x37\x33\x5a\x4f\x6a\x51\x30\x6a\x78\x44\x7a\x76\x66\x64\x63\x79\x4b\x65\x4e\x2b\x66\x6e\x47\x73\x33\x52\x66\x6e\x78\x38\x62\x47\x32\x30\x6c\x37\x79\x45\x51\x66\x7a\x76\x65\x66\x4c\x43\x5a\x49\x55\x58\x7a\x57\x72\x33\x59\x31\x76\x75\x56\x6b\x54\x69\x37\x64\x36\x64\x4a\x68\x56\x75\x47\x45\x51\x70\x51\x41\x41\x43\x33\x56\x6d\x79\x72\x79\x43\x72\x4d\x77\x43\x30\x6a\x6d\x57\x7a\x45\x31\x44\x53\x6b\x63\x30\x2b\x59\x2b\x59\x50\x2b\x4c\x4b\x70\x37\x70\x47\x50\x46\x4d\x42\x6f\x44\x75\x66\x65\x33\x74\x35\x33\x6d\x48\x67\x47\x65\x51\x76\x71\x43\x64\x42\x57\x30\x68\x6e\x65\x32\x78\x73\x4d\x77\x59\x41\x75\x57\x31\x36\x37\x4c\x63\x6c\x34\x30\x79\x44\x53\x6e\x45\x67\x6b\x62\x6b\x4c\x67\x53\x56\x4b\x41\x74\x63\x4d\x39\x6b\x6b\x78\x32\x51\x4d\x6c\x53\x4d\x6a\x6c\x32\x68\x56\x4f\x53\x4c\x35\x73\x75\x39\x53\x49\x39\x4f\x7a\x4d\x58\x79\x41\x6a\x2f\x56\x58\x50\x46\x56\x52\x4c\x58\x61\x41\x59\x72\x51\x2f\x30\x44\x63\x2f\x4f\x55\x43\x30\x42\x33\x37\x62\x35\x7a\x2f\x73\x59\x57\x48\x53\x4e\x56\x6b\x72\x32\x2f\x44\x5a\x48\x70\x56\x43\x6f\x56\x67\x63\x42\x41\x6b\x68\x77\x6f\x6d\x62\x38\x46\x38\x6a\x43\x62\x54\x44\x36\x41\x6b\x6f\x6c\x6b\x63\x70\x37\x6d\x30\x64\x6d\x5a\x54\x59\x38\x38\x34\x42\x68\x74\x4d\x36\x6f\x2b\x6e\x38\x2f\x76\x6f\x6b\x79\x51\x74\x30\x45\x33\x68\x6d\x6b\x6d\x59\x52\x48\x4f\x35\x34\x65\x61\x79\x68\x4c\x52\x31\x51\x63\x46\x54\x6a\x72\x43\x6c\x6d\x54\x35\x2f\x4f\x73\x57\x69\x41\x51\x6f\x77\x41\x77\x45\x39\x42\x37\x70\x6d\x4c\x36\x70\x49\x48\x72\x46\x36\x42\x45\x47\x32\x41\x67\x77\x66\x33\x41\x77\x51\x66\x4f\x63\x55\x38\x53\x6d\x52\x34\x36\x4f\x7a\x4f\x62\x59\x4b\x52\x51\x4b\x7a\x71\x70\x63\x39\x61\x75\x48\x48\x79\x78\x6e\x69\x38\x56\x43\x59\x62\x46\x63\x41\x48\x53\x78\x4e\x68\x53\x34\x68\x75\x67\x4b\x77\x6d\x43\x72\x55\x42\x68\x79\x51\x2b\x54\x54\x36\x65\x6c\x70\x50\x77\x51\x69\x37\x4a\x47\x49\x32\x43\x4d\x4d\x65\x4b\x48\x65\x6f\x47\x4f\x4a\x78\x4a\x49\x78\x4a\x57\x31\x36\x35\x4e\x48\x52\x6b\x62\x6c\x41\x4a\x6f\x76\x46\x59\x6a\x73\x73\x6e\x4c\x79\x47\x59\x2f\x7a\x34\x58\x70\x56\x61\x54\x37\x47\x34\x56\x53\x34\x41\x75\x76\x71\x67\x70\x4b\x2f\x4b\x74\x56\x67\x73\x39\x74\x79\x42\x53\x42\x63\x46\x47\x4b\x6a\x56\x49\x39\x4d\x51\x36\x47\x64\x41\x46\x31\x53\x30\x62\x71\x52\x53\x48\x54\x52\x6a\x2b\x2f\x73\x32\x4a\x66\x4a\x38\x66\x39\x39\x73\x6a\x72\x36\x4c\x69\x34\x76\x48\x71\x4e\x44\x44\x4f\x78\x6c\x43\x68\x61\x61\x68\x69\x34\x75\x77\x57\x51\x42\x30\x50\x62\x57\x70\x37\x61\x44\x2b\x4e\x55\x50\x56\x4f\x2f\x77\x72\x69\x35\x42\x35\x63\x58\x35\x2b\x50\x6c\x75\x72\x52\x35\x72\x46\x48\x6d\x47\x41\x65\x70\x45\x32\x2f\x6b\x69\x6c\x76\x67\x4c\x33\x6e\x32\x57\x7a\x36\x68\x4a\x78\x7a\x56\x73\x4c\x5a\x4c\x56\x55\x4b\x67\x56\x52\x59\x59\x64\x33\x4d\x6f\x49\x4b\x4c\x61\x4f\x6c\x55\x6f\x79\x57\x64\x4e\x4c\x56\x42\x78\x76\x43\x64\x42\x72\x64\x35\x4f\x45\x33\x77\x70\x43\x35\x6e\x73\x75\x64\x4f\x2f\x36\x73\x52\x78\x69\x67\x58\x71\x51\x4f\x65\x72\x61\x4e\x4b\x66\x6c\x47\x58\x53\x4a\x6a\x31\x67\x49\x5a\x54\x71\x65\x66\x61\x74\x58\x5a\x50\x6b\x32\x54\x48\x6c\x54\x68\x35\x61\x4e\x68\x36\x50\x68\x35\x59\x67\x48\x59\x4d\x4d\x49\x76\x78\x6b\x7a\x4a\x39\x4a\x50\x4d\x31\x31\x7a\x75\x39\x4c\x37\x59\x49\x79\x79\x52\x4b\x41\x53\x75\x4d\x75\x41\x71\x56\x4d\x7a\x53\x73\x30\x62\x44\x4e\x54\x49\x42\x42\x64\x79\x67\x31\x67\x4b\x4a\x70\x64\x4f\x76\x2f\x4b\x68\x69\x4a\x55\x32\x63\x6c\x32\x71\x62\x44\x31\x61\x4e\x41\x75\x43\x70\x45\x33\x61\x34\x52\x2b\x6e\x32\x67\x6f\x52\x65\x36\x5a\x4c\x4a\x4c\x42\x38\x65\x6a\x72\x65\x4b\x41\x75\x52\x79\x75\x57\x57\x78\x52\x78\x67\x51\x55\x57\x39\x51\x65\x72\x72\x30\x4e\x55\x48\x65\x51\x67\x58\x33\x71\x39\x6b\x63\x34\x55\x78\x6d\x31\x49\x30\x71\x48\x6d\x63\x79\x6d\x56\x37\x38\x2b\x71\x51\x54\x78\x50\x38\x71\x6b\x36\x46\x61\x74\x71\x77\x79\x63\x42\x4a\x45\x59\x2b\x41\x4b\x5a\x4c\x37\x45\x34\x35\x73\x75\x4d\x62\x39\x44\x38\x69\x56\x77\x56\x55\x30\x6a\x4d\x45\x57\x2f\x65\x70\x46\x47\x36\x5a\x6e\x69\x4d\x74\x67\x34\x49\x45\x73\x33\x66\x75\x66\x4e\x67\x53\x56\x41\x62\x79\x5a\x6a\x7a\x57\x76\x72\x53\x54\x75\x71\x61\x53\x2f\x6e\x31\x57\x6b\x6f\x6f\x63\x4a\x53\x71\x67\x64\x45\x4d\x77\x4a\x46\x46\x75\x4c\x78\x42\x55\x67\x34\x34\x6f\x63\x43\x41\x34\x59\x41\x36\x69\x48\x52\x54\x45\x38\x41\x6a\x45\x67\x49\x64\x4a\x6e\x70\x6e\x70\x7a\x30\x2f\x70\x4c\x47\x74\x33\x56\x63\x77\x6e\x6c\x79\x63\x72\x4a\x44\x36\x2f\x66\x78\x45\x49\x4a\x41\x4c\x77\x4e\x30\x38\x59\x4b\x30\x33\x79\x41\x7a\x4c\x67\x74\x41\x41\x6e\x47\x42\x62\x6d\x43\x4e\x5a\x6b\x41\x39\x48\x65\x67\x4a\x30\x4c\x71\x57\x42\x41\x47\x4d\x42\x64\x49\x30\x70\x77\x73\x67\x4d\x38\x4a\x30\x64\x45\x31\x57\x61\x65\x58\x66\x64\x5a\x30\x52\x4d\x56\x31\x44\x32\x73\x6c\x61\x41\x6a\x51\x30\x4c\x45\x4d\x6d\x73\x76\x43\x35\x77\x59\x62\x50\x62\x49\x45\x75\x32\x6d\x36\x31\x64\x50\x52\x45\x6a\x45\x47\x79\x6b\x62\x4b\x44\x43\x68\x48\x50\x6e\x4d\x38\x58\x71\x79\x57\x41\x7a\x2b\x66\x62\x42\x55\x49\x30\x63\x79\x46\x49\x2b\x4f\x63\x59\x30\x30\x49\x42\x61\x4e\x59\x68\x34\x33\x41\x34\x47\x6c\x47\x4c\x52\x6f\x63\x64\x4c\x71\x37\x35\x62\x74\x32\x6f\x61\x47\x4e\x41\x71\x33\x6e\x73\x6e\x34\x6c\x47\x5a\x35\x6f\x76\x45\x33\x33\x42\x50\x54\x6b\x4e\x48\x5a\x66\x58\x36\x32\x32\x42\x6a\x49\x63\x78\x62\x75\x36\x32\x6f\x4b\x61\x46\x49\x42\x50\x53\x74\x43\x42\x44\x33\x5a\x71\x6d\x65\x66\x41\x50\x30\x30\x77\x42\x49\x71\x68\x6a\x50\x76\x46\x46\x59\x51\x5a\x31\x7a\x42\x51\x46\x36\x45\x63\x64\x73\x38\x59\x33\x70\x53\x65\x6f\x59\x7a\x59\x70\x51\x44\x66\x71\x46\x74\x66\x32\x49\x57\x6e\x44\x66\x38\x2f\x61\x64\x54\x57\x62\x63\x62\x4b\x4d\x2f\x35\x34\x72\x63\x59\x6b\x36\x47\x41\x46\x74\x44\x51\x4c\x31\x38\x42\x62\x51\x4e\x6e\x37\x4e\x68\x76\x48\x74\x57\x66\x78\x74\x66\x67\x4c\x62\x4b\x30\x41\x57\x4c\x38\x69\x6b\x64\x41\x41\x41\x41\x41\x42\x4a\x52\x55\x35\x45\x72\x6b\x4a\x67\x67\x67\x3d\x3d',"\x6f\x6e\x6c\x6f\x61\x64","\x54\x65\x78\x74\x75\x72\x65","\x6d\x69\x6e\x46\x69\x6c\x74\x65\x72","\x4c\x69\x6e\x65\x61\x72\x46\x69\x6c\x74\x65\x72","\x6e\x65\x65\x64\x73\x55\x70\x64\x61\x74\x65","\x53\x70\x72\x69\x74\x65","\x53\x70\x72\x69\x74\x65\x4d\x61\x74\x65\x72\x69\x61\x6c","\x73\x63\x61\x6c\x65","\x61\x64\x64","\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72","\x63\x6c\x69\x65\x6e\x74\x57\x69\x64\x74\x68","\x63\x6c\x69\x65\x6e\x74\x48\x65\x69\x67\x68\x74","\x75\x70\x64\x61\x74\x65\x48\x55\x44"];fengmap[_$[0]][_$[1]]=function(a,b,c){this[_$[2]]=c;this[_$[3]]=null;this[_$[4]]=a;this[_$[5]]=b;this[_$[6]];this[_$[7]];this[_$[8]]=0x14;this[_$[9]]()};fengmap[_$[0]][_$[1]][_$[10]]={set visible(b){if(b!=this[_$[4]]){this[_$[4]]=b;if(b){this[_$[9]]();this[_$[3]][_$[11]]=true}else{if(this[_$[3]]!=null){this[_$[3]][_$[11]]=false}}}},get visible(){return this[_$[4]]},updateHUD:function(a,c){if(this[_$[3]]!=null){var d=a/0x2;var e=c/0x2;this[_$[3]][_$[12]][_$[13]](d-this[_$[6]]/0x2-this[_$[8]],-e+this[_$[7]]/0x2+this[_$[8]],0x1)}},_tryInit:function(){if(this[_$[3]]==null){var a=window[_$[14]][_$[15]](_$[16]);a[_$[17]]=_$[18];var c=this;a[_$[19]]=function(){c[_$[3]][_$[11]]=true};var d=new fm[_$[20]](a);this[_$[6]]=0x60;this[_$[7]]=0x14;d[_$[21]]=fm[_$[22]];d[_$[23]]=true;this[_$[3]]=new fm[_$[24]](new fm[_$[25]]({map:d}));this[_$[3]][_$[26]][_$[13]](this[_$[6]],this[_$[7]],0x1);this[_$[3]][_$[11]]=false;this[_$[5]][_$[27]](this[_$[3]]);var e=this[_$[2]][_$[28]];var f=e[_$[29]];var g=e[_$[30]];this[_$[31]](f,g)}}};
})();
/**
 *   FMHeatMap 热力图对象
 *   @class FMHeatMap
 *   @constructor create
 *   @module FMMap
 *   @namespace fengmap
 */
/**
 * 使用create方法创建热力图对象
 * @method create
 * @param  {fengmap.FMMap} map map对象
 * @param  {json} config 配置项
 *             @param {object} config.radius  热点半径
 *             @param {string} config.opacity 热力图透明度，范围0-1
 *             @param {string} config.max  热力点value的最大值
 *             @param {int} config.maxSize  热力图长宽的最大尺寸
 *             @param {boolean} config.gradient  热力图的渐变颜色。默认为：{ 0.45: "rgb(0,0,255)", 0.55: "rgb(0,255,255)", 0.65: "rgb(0,255,0)", 0.95: "yellow", 1.0: "rgb(255,0,0)" }
 */
(function() {

    fengmap.FMHeatMap = {
        create: function(map, config) {
            return new HeatMap(map, config);
        }
    };

    function HeatMap(map, opts) {
        this.map_ = map;
        this.texture_ = null;

        this.config(opts);
    }

    HeatMap.prototype = {
        //获取屏幕DPI
        getDeviceDPI: function() {
            var arrDPI = new Array();
            if (window.screen.deviceXDPI != undefined) {
                arrDPI[0] = window.screen.deviceXDPI;
                arrDPI[1] = window.screen.deviceYDPI;
            } else {
                var tmpNode = document.createElement("DIV");
                tmpNode.style.cssText = "width:1in;height:1in;position:absolute;left:0px;top:0px;z-index:99;visibility:hidden";
                document.body.appendChild(tmpNode);
                arrDPI[0] = parseInt(tmpNode.offsetWidth);
                arrDPI[1] = parseInt(tmpNode.offsetHeight);
                tmpNode.parentNode.removeChild(tmpNode);
            }
            return arrDPI;
        },
        //获取地图范围的高宽。单位像素
        getDeviceWH: function(opts) {
            opts = opts || {};
            var w = this.map_.maxX - this.map_.minX;
            var h = this.map_.maxY - this.map_.minY;
            var wh = { w: Math.round(w), h: Math.round(h) };

            var dpi = this.getDeviceDPI();

            // wh.w = fm.Math.nextPowerOfTwo(wh.w * dpi[0] / 25.4); //取距离最近的2的幂，否则会输出警告
            // wh.h = fm.Math.nextPowerOfTwo(wh.h * dpi[1] / 25.4);

            // 使用 nearest 不使用上面的 next, 不浪费空间
            // wh.w = fm.Math.nearestPowerOfTwo(wh.w * dpi[0] / 25.4); //取距离最近的2的幂，否则会输出警告
            // wh.h = fm.Math.nearestPowerOfTwo(wh.h * dpi[1] / 25.4);

            // 使用 上面的方法得到的 2的幂的大小, 会使得最后的结果点不"圆"
            wh.w = parseInt(wh.w * dpi[0] / 25.4);
            wh.h = parseInt(wh.h * dpi[1] / 25.4);

            /////////////////////////////////
            // 20161201 clamp size to 2048 //
            /////////////////////////////////
            var rat = 1;
            var maxSize = opts.maxSize || 2048;
            if (wh.w >= maxSize || wh.h >= maxSize) {
                if (wh.w >= wh.h) {
                    rat = wh.h / wh.w;
                    wh.w = maxSize;
                    wh.h = parseInt(maxSize * rat);
                } else {
                    rat = wh.w / wh.h;
                    wh.h = maxSize;
                    wh.w = parseInt(maxSize * rat);
                }
            }

            return wh;
        },

        //转换地图坐标到像素坐标
        getPixXY: function(x, y) {
            var aa = (x - this.map_.minX) / (this.map_.maxX - this.map_.minX);
            var bb = (y - this.map_.minY) / (this.map_.maxY - this.map_.minY);

            var pnt = { x: 1 - aa, y: 1 - bb };

            pnt.x = pnt.x * this.options.width;
            pnt.y = pnt.y * this.options.height;

            return pnt;
        },

        // 初始化参数配置
        config: function(opts) {
            var me = this;  

            var wh = me.getDeviceWH(opts);

            var w = wh.w,
                h = wh.h;            
                      
            me.options = {
                width: w,
                height: h,
                // 热图画布透明度，取值范围 0-1
                opacity: opts.opacity ? opts.opacity * 255 : 100 * 255,
                // 点半径
                radius: opts.radius ? opts.radius : 30,
                // 边界模糊半径
                bshadow: opts.radius ? opts.radius / 20 : 30 / 20,
                maxSize: opts.mapSize || 2048,
                boundVal: 15000,
                shadowBlur: 15,
                // 缓存画布中点数据，并且记录最大值, 当最大值发生变化的时候，热图画布需要重新根据缓存的点得数据绘制
                points: {
                    max: opts.max ? opts.max : 100,
                    data: []
                },
                // 调色板颜色取值范围
                gradient: opts.gradient ? opts.gradient : { 0.45: "rgb(0,0,255)", 0.55: "rgb(0,255,255)", 0.65: "rgb(0,255,0)", 0.95: "yellow", 1.0: "rgb(255,0,0)" }
            };

            // 热图画布
            //var container = document.getElementById(id);
            var canvas = document.createElement("canvas"),
                ctx = canvas.getContext('2d');
            canvas.width = w;
            canvas.height = h;

            me.options.ctx = ctx;
            me.options.canvas = canvas;

            console.log(w,h);
        },

        // 绘制圆阴影：可视区域只绘制了一个圆阴影效果，而圆本身的位置在可视区域之外
        renderShadow: function(x, y, val, cache) {
            var me = this,
                ctx = me.options.ctx,
                radius = me.options.radius,
                bval = me.options.boundVal;

            var opacity = parseFloat(val / me.options.points.max, 10);
            ctx.shadowColor = ('rgba(0, 0, 0, ' + opacity + ')');
            ctx.shadowOffsetX = bval;
            ctx.shadowOffsetY = bval;
            ctx.shadowBlur = me.options.shadowBlur;
            ctx.beginPath();
            ctx.arc(x - bval, y - bval, me.options.radius, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();
            if (!cache) {
                me.cachePoint(x, y, val);
            }
        },

        // 绘制彩色热图根据调色板
        colorize: function() {
            var me = this,
                w = me.options.width,
                h = me.options.height,
                ctx = me.options.ctx;
            var img = ctx.getImageData(0, 0, w, h);
            // if (!me._data) {
            //     me._data = ctx.getImageData(0, 0, w, h);
            // }

            var imgData = img.data,
                len = imgData.length,
                palette = me.getPalette();
            var opacity = me.options.opacity;

            for (var i = 3; i < len; i += 4) {
                // [0] -> r, [1] -> g, [2] -> b, [3] -> alpha
                var alpha = imgData[i],
                    // 是因为要取调色板中的颜色，而调色板数的颜色数据对应的步长是4
                    offset = alpha * 4;

                if (!offset) {
                    continue;
                }

                var finalAlpha = (alpha < opacity) ? alpha : opacity;
                imgData[i - 3] = palette[offset];
                imgData[i - 2] = palette[offset + 1];
                imgData[i - 1] = palette[offset + 2];
                imgData[i] = finalAlpha;
            }

            // img.data = imgData;
            ctx.putImageData(img, 0, 0);
        },

        //地图上显示热力图
        renderToMap: function(groupID) {
            var me = this;
            var canvas = me.options.canvas;

            texture_ = new fm.Texture(canvas);
            this.setTexture(groupID, texture_);

        },

        //从地图上移除热力图
        disposeHeatMap: function(groupID) {
            if(!groupID) return;
            var me = this;

            var floor = fengmap.MapUtil.getObjectsByAlias(this.map_, groupID, 'extent')[0];

            if (!floor._hasHeatMap) {return;}

            // 加一个标签,记录当前的heapMap状态
            floor._hasHeatMap = false;

            //
            // release memory from gl
            //
            if (floor.material.map) {
                floor.material.map.dispose();
            }

            floor.material.map = null;
            floor.material.transparent = true;
            floor.material.needsUpdate = true;

            var ms = fengmap.MapUtil.getObjectsByAlias(this.map_, groupID, 'model');
            ms.forEach(function(itm) {

                if (itm.material.type =="MultiMaterial") {
                    // support multiMaterial index
                    var matsLen = itm.material.materials.length;
                    var matIndex = 0, step = 3;

                    while (matIndex < matsLen) {
                        var _mat = itm.material.materials[matIndex];

                        _mat.map = null;

                        _mat.color.copy(_mat._color);

                        _mat.transparent = true;
                        _mat.needsUpdate = true;

                        step = matIndex == 0 ? 3 : 2;
                        matIndex += step;
                    }

                } else {
                    //lazyCreateModel
                    var _mat = itm.material;
                    _mat.map = null;

                    _mat.color.copy(_mat._color);
                    _mat.transparent = true;
                    _mat.needsUpdate = true;
                }
            });
        },


        // 通过调色板来获取平滑的颜色值
        getPalette: function() {
            // 调色板画布
            var pcanvas = document.createElement("canvas"),
                pctx = pcanvas.getContext('2d');
            pcanvas.width = 1;
            pcanvas.height = 256;

            var me = this,
                gradient = me.options.gradient;

            //缓存调色板数据
            var grad = pctx.createLinearGradient(0, 0, 1, 256);
            for (var x in gradient) {
                grad.addColorStop(x, gradient[x]);
            }
            pctx.fillStyle = grad;
            pctx.fillRect(0, 0, 1, 256);
            // 这个有说明: http://www.w3school.com.cn/tags/canvas_getimagedata.asp
            // 返回的是一个一位数组，每一个像素的的颜色有四个值来表示
            // 前三个值表示 红绿蓝，第四个值表示alpha 通道
            // 也就是这个一位数组的长度是: 1 * 256 * 4;
            return pctx.getImageData(0, 0, 1, 256).data;
        },

    }

    // 缓存点数据
    HeatMap.prototype.cachePoint = function(x, y, val) {
        var me = this,
            points = me.options.points,
            data = points.data;
        if (val > points.max) {
            points.max = val;
        }

        data.push([x, y, val]);
    }

    /**
     * 清除热力图的所有热力点
     * @method clearPoints
     */
    HeatMap.prototype.clearPoints = function() {
        this.options.points.data = [];
        this.clear();
    }

    /**
     * 增加一个热点
     * @method addPoint     
     *         @param {float} x  地图坐标x值。
     *         @param {float} y  地图坐标y值。
     *         @param {float} value 热点所占的比重值
     */
    // 增加一个热点
    HeatMap.prototype.addPoint = function(x, y, val) {
        if (!x || !y || !val) return;
        var newxy = this.getPixXY(x, y);
        if (!newxy) return;        

        var me = this;
        me.clear();

        var data = me.options.points.data,
            len = data.length;
        
        for (var i = 0; i < len; i++) {
            me.renderShadow(data[i][0], data[i][1], data[i][2], true);
        }

        me.renderShadow(newxy.x, newxy.y, val, false);
        me.colorize();
    }

    //
    // 根据给定的点
    //
    HeatMap.prototype.getTexture = function(points) {

        this.clearPoints();
        this.addPoints(points);

        var clone = this.options.canvas.cloneNode();
        clone.getContext('2d').drawImage(this.options.canvas, 0, 0);

        return new fm.CanvasTexture(clone);

    }

    HeatMap.prototype.setTexture = function(groupID, tex) {
        var me = this;

        var floor = fengmap.MapUtil.getObjectsByAlias(this.map_, groupID, 'extent')[0];

        // 如果之前创建了heatMap先将其移除
        if (floor._hasHeatMap) {
            this.disposeHeatMap(groupID);
        }

        floor._hasHeatMap = true;

        floor.material.map = tex;
        floor.material.transparent = false;
        floor.material.map.needsUpdate = true;
        floor.material.needsUpdate = true;

        var ms = fengmap.MapUtil.getObjectsByAlias(this.map_, groupID, 'model');
        ms.forEach(function(itm) {

            if (itm.material.type =="MultiMaterial") {
                // support multiMaterial index
                var matsLen = itm.material.materials.length;
                var matIndex = 0, step = 3;
                while (matIndex < matsLen) {
                    itm.material.materials[matIndex].map = tex;

                    // color to WHITE means DONT tints the map
                    itm.material.materials[matIndex]._color = itm.material.materials[matIndex].color.clone();
                    itm.material.materials[matIndex].color = new fm.Color(0xffffff);

                    itm.material.materials[matIndex].transparent = false;
                    itm.material.materials[matIndex].map.needsUpdate = true;
                    itm.material.materials[matIndex].needsUpdate = true;

                    step = matIndex == 0 ? 3 : 2;
                    matIndex += step;
                }

            }else{

                //lazyCreateModel
                itm.material.map = tex;
                // color to WHITE means DONT tints the map
                itm.material._color = itm.material.color.clone();
                itm.material.color = new fm.Color(0xffffff);

                itm.material.transparent = false;
                itm.material.map.needsUpdate = true;
                itm.material.needsUpdate = true;
            }

        });
    }

    HeatMap.prototype.setModelMeshTexture = function(modelMesh) {
        if (!modelMesh || !texture_) {
            return;
        }

        if (modelMesh.material.type =="MultiMaterial") {
            // support multiMaterial index
            var matsLen = modelMesh.material.materials.length;
            var matIndex = 0, step = 3;
            while (matIndex < matsLen) {
                modelMesh.material.materials[matIndex].map = texture_;

                // color to WHITE means DONT tints the map
                modelMesh.material.materials[matIndex]._color = modelMesh.material.materials[matIndex].color.clone();
                modelMesh.material.materials[matIndex].color = new fm.Color(0xffffff);

                modelMesh.material.materials[matIndex].transparent = false;
                modelMesh.material.materials[matIndex].map.needsUpdate = true;
                modelMesh.material.materials[matIndex].needsUpdate = true;

                step = matIndex == 0 ? 3 : 2;
                matIndex += step;
            }

        }else{

            //lazyCreateModel
            modelMesh.material.map = texture_;
            // color to WHITE means DONT tints the map
            modelMesh.material._color = modelMesh.material.color.clone();
            modelMesh.material.color = new fm.Color(0xffffff);

            modelMesh.material.transparent = false;
            modelMesh.material.map.needsUpdate = true;
            modelMesh.material.needsUpdate = true;
        }
    }

    HeatMap.prototype.clear = function() {
        var ctx = this.options.ctx;
        ctx.clearRect(0, 0, this.options.width, this.options.height);
    };

    /**
     * 批量增加热点
     * @method addPoints
     * @param  {array} data.数组的每一个值是{x,y,value}对象。
     */
    HeatMap.prototype.addPoints = function(points) {
        var me = this;
        // me.options.ctx.clearRect(0, 0, me.options.width, me.options.height);       
        me.clear();

        var data = me.options.points.data;
        var len = data.length;

        for (var i = 0; i < len; i++) {
            me.renderShadow(data[i][0], data[i][1], data[i][2], true);
        }

        var plen = points.length;
        for (var j = 0; j < plen; j++) {
            var newxy = this.getPixXY(points[j].x, points[j].y);
            if (!newxy) return true;
            me.renderShadow(newxy.x, newxy.y, points[j].value, false);
        }

        me.colorize();
    }

    // 随机画热点
    /**
     * 随机增加热点
     * @method randomPoints
     * @param  {int} 要随机生成的热力点的数量
     */
    HeatMap.prototype.randomPoints = function(points) {        
        
        var me = this;
        var w = me.options.width,
            h = me.options.height,
            max = me.options.points.max;     

        me.clear();

        for (var i = 0; i < points; i++) {
            var x = Math.floor(Math.random() * w + 1);
            var y = Math.floor(Math.random() * h + 1);
            var value = Math.floor(Math.random() * max + 1);            
            me.renderShadow(x,y,value);
        }
        me.colorize();        
    }

}());

/**
 * fengmap JavaScript SDK 支持同层和跨层路径规划。支持最短路径、最优路径两种规划策略。
 * 同层路径规划：同一楼层任意位置间路径规划；
 * 跨层路径规划：不同楼层任意位置间路径规划。若路径在模型中应用时，当fengmap.MapOptions中的isSeparate属性为false时，跨层路径分析可用。
 * @module Navigation
 */

/**
 *	FMNaviAnalyser 是可分析最短路径、最快路径并返回分析结果的路径类
 * 	@class FMNaviAnalyser
 *	@constructor FMNaviAnalyser
 * 	@module Navigation
 * 	@namespace fengmap
 *   @param {fengmap.NaviOptions} options naviOptions对象
 *   @demo navi/路径分析类参数配置.js
 *   @demo navi/打开路径数据.js
 *   @demo navi/路径分析.js
 */
fengmap.FMNaviAnalyser = {
    // self: this,
    create: function(opts) {
        //var naviAnalyser = {};
        var self = {};

        self.navi_ = new fengmap.NaviDijkstra_(opts);

        var getFMNaviResults_ = function(result) {
            var resultList = [];
            //			for(var i=0 in result) {
            for (var i in result) {
                if (result[i].groupId == undefined) {
                    continue;
                }
                var fmResult = new fengmap.FMNaviResult(result[i].groupId, result[i].length, result[i].pointVector);
                resultList.push(fmResult);
            }
            return resultList;
        };


        /**
         * 根据已加载的fengmap.FMMap导航分析
         * @method analyzeNavi
         * @param {number} startGroupId 起始楼层id
         * @param {fengmap.FMMapCoord} start 起始坐标点
         * @param {number} endGroupId 结束楼层id
         * @param {fengmap.FMMapCoord} end 结束坐标点
         * @param {fengmap.FMNaviModule} module 代表最优路径/最短路径的枚举类型
         * @return  {fengmap.FMRouteCalcuResult} FMRouteCalcuResult 表示分析结果状态的枚举类型
         */
        var analyzeNavi = function(startGroupId, start, endGroupId, end, module,priority) {
            return self.navi_.FMRC_SpanRouteCalculate(startGroupId, start, endGroupId, end, module,priority);
        };

        /**
         * 根据已加载的fengmap.FMMap初始化导航
         * @method init
         * @param  {fengmap.FMMap} map 地图对象
         */
        var init = function(map) {
            self.map = map;
            self.navi_.initByMap(map);
        };

        /**
         * 根据senceid打开模型
         * @method initById
         * @param  {string|number} sid 场景id
         */
        var initById = function(scenceId) {
            self.navi_.openNavi(scenceId);
        };

        /**
         * 返回路径分析后的所有坐标点集
         * @method getRouteAllPoints
         * @return {Array} points 结果对象.格式为:[{"x":x,"y":y,"groupId":groupId}];
         */
        var getRouteAllPoints = function(res) {
            if (!res && !self.naviResult_) return [];
            var resultList = [];
            var result = !res ? self.naviResult_ : res;
            for (var i in result) {
                if (!result[i].getPointList) {
                    continue;
                }
                resultList = resultList.concat(result[i].getPointList());
            }
            return resultList;
        };


        /**
         * 返回根据路径结果列表得到所要画线的点集
         * @method getRouteLineSegments
         * @return {Array<fengmap.FMSegment>} FMSegment 折线集合;
         */
        var getRouteLineSegments = function(res) {
            if (!res && !self.naviResult_) return [];

            var results = !res ? self.naviResult_ : res;

            var resultList = [];

            for (var i = 0, ilen = results.length; i < ilen; i++) {
                var result = results[i];
                var gid = result.groupId;
                var points = result.pointList;

                var seg = new fengmap.FMSegment();
                seg.groupId = gid;
                seg.points = [];

                for (var j = 0, jlen = points.length; j < jlen; j++) {
                    seg.points.push(points[j]);
                };

                resultList.push(seg);
            }

            return resultList;
        };

        /**
         * 获得路径分析后的路径长度
         * @method getRouteDistance
         * @param {array<FMNaviResult>} routeResPoints 路径分析返回的结果集合 
         * @return {number} length 路径长度
         */
        var getRouteDistance = function() {
            var points = getRouteAllPoints();
            if (points.length == 0) return 0;
            var dis = 0;
            for (var j = 0, jlen = points.length; j < jlen - 1; j++) {
                dis += DistanceofTwoPts(points[j], points[j + 1]);
            }

            return dis;
        };

        /**
         * 获得不同层路径导航时，其所有经过的楼层id数组
         * @method getRouteGroupIds
         * @return {array} groupIds 所有
         */
        var getRouteGroupIds = function() {
            if (!self.naviResult_) return [];
            var groupIds = [];
            for (var i in self.naviResult_) {
                if (!self.naviResult_[i].getGroupId) {
                    continue;
                }
                if (i == 0) groupIds.push(self.naviResult_[i].getGroupId());
                else if (groupIds[groupIds.length - 1] != self.naviResult_[i].getGroupId()) {
                    groupIds.push(self.naviResult_[i].getGroupId());
                }
            }
            return groupIds;
        };

        /**
         * 跨层路径规划时，获取当前在组下地图坐标的集合
         * @method getRouteGroupPoints
         * @param groupId 楼层id
         * @return {array} groupIds 所有
         */
        var getRouteGroupPoints = function(groupId) {
            if (!self.naviResult_) return [];
            else {
                var resultList = [];
                for (var i in self.naviResult_) {
                    if (self.naviResult_[i].getGroupId && self.naviResult_[i].getGroupId() == groupId) {
                        resultList = resultList.concat(self.naviResult_[i].getPointList());
                    }
                }
                return resultList;
            }
        };

        /**
         * 获取路径分析结果对象，可能集合为空
         * @method getNaviResults
         * @return {array<FMNaviResult>} naviResults 所有路线集合
         */
        var getNaviResults = function() {
            var result = self.navi_.FMRC_GetRouteCalculateResult();
            self.naviResult_ = getFMNaviResults_(result);
            return self.naviResult_;
        };

        /**
         * 得到路径规划后的文字描述
         * @method getRouteDescriptions
         * @param {FMNaviResult} navResult FMNaviResult对象
         * @param {JSON} params {
         *       directionAssert: 10,    // 10 度, 正方向的断定阀值, 默认左右10度
         *       combineAsset: 5,        // 5  度, 小于些值的转角将被忽略
         * }
         * @return {JSON} {
         *      naviDescriptions:       // 路径的文字描述数组 [str, str , ...]
         *      naviDescriptionsData:   // 路径的描述数据,用户可以用此数据自己组织描述文字 [json, json, ...]
         *      naviDistance:           // 导航的路径长度, 单位米
         *      naviGroupsDistance:     // 每一层的导航长度
         * }
         */
        var getNaviDescriptions = function(navResult, params) {
            // if (!(navResult instanceof fengmap.FMNaviResult)) {return;}

            params = params || {
                directionAssert: 10, // 10 度
                combineAsset: 5, // 5  度
            };

            params.map = self.map;

            var s = Object.assign({}, params);

            var res = fengmap.FMNavigation.prototype._naviDescriptions.call(s, navResult);

            return {
                naviDescriptions: res[0],
                naviDescriptionsData: res[1],
                naviDistance: res[2],
                naviGroupsDistance: res[3]
            };
        }

        return {
            init: init,
            navi_: self.navi_,
            analyzeNavi: analyzeNavi,
            getNaviResults: getNaviResults,
            initById: initById,
            getRouteAllPoints: getRouteAllPoints,
            getRouteDistance: getRouteDistance,
            getRouteGroupIds: getRouteGroupIds,
            getRouteGroupPoints: getRouteGroupPoints,
            getRouteLineSegments: getRouteLineSegments,
            getRouteDescriptions: getNaviDescriptions
        };
    }
};

/**
 *	FMNaviModule 表示路径分析类型的枚举。此配置需要数据（*.fmap）的支持（与路径数据中每条路径的权值有关）。
 * 	@class FMNaviModule
 * 	@module Navigation
 * 	@namespace fengmap
 */
fengmap.FMNaviModule = {
    /**
     * 最短路径标识
     * @property MODULE_SHORTEST
     * @type {Number}
     * @readOnly
     */
    MODULE_SHORTEST: 1,
    /**
     * 最优路径标识
     * @property MODULE_BEST
     * @type {Number}
     * @readOnly
     */
    MODULE_BEST: 2
};

/**
 *	FMNaviResult 定义路径规划的结果
 * 	@class FMNaviResult
 * 	@module Navigation
 * 	@constructor FMNaviResult
 * 	@namespace fengmap
 *   @param {number} groupId 楼层Id
 *   @param {length} length 路径长度
 *   @param {array<fengmap.FMMapCoord>} pointList 点集合
 */
fengmap.FMNaviResult = function(groupId, length, pointList) {
    this.groupId = groupId;
    this.length = length;
    this.pointList = pointList;
}

fengmap.FMNaviResult.prototype = {

    /**
     * 获得楼层id
     * @property GroupId
     * @type {number}
     */
    getGroupId: function() {
        return this.groupId;
    },

    /**
     * 获得路径长度
     * @property Length
     * @type {number}
     */
    getLength: function() {
        return this.length;
    },
    /**
     * 获得该结果列表中的所有点集合
     * @property PointList
     * @type {array<fengmap.FMMapCoord>}
     */
    getPointList: function() {
        var points = [];
        for (var i = 0, len = this.pointList.length; i < len; i++) {
            points.push({
                x: this.pointList[i].x,
                y: this.pointList[i].y,
                groupId: this.groupId
            });
        }
        return points;
    }
}

/*	需要放到别的文件去
 * fengmap.FMErrorMsg = {
	ERR_CONNECT_SERVICE:0,
	ERR_KEY:1,
	ERR_MAP_CACHE:2,
	ERR_MAP_DOWNLOAD:3,
	ERR_MAP_LOAD:4,
	ERR_MAP_NOTEXIST_LOCAL:5,
	ERR_MAP_NOTEXIST_SERVER:6,
	ERR_NET:7,
	ERR_NO_RIGHT:8,
	ERR_THEME_DOWNLOAD:9,
	ERR_THEME_LOAD:10,
	ERR_THEME_NOTEXIST_LOCAL:11,
	ERR_THEME_NOTEXIST_SERVER:12,
	ERR_UNKNOWN:13,
	MSG_ERR_UNKNOWN:14
}*/

/**
 *	FMRouteCalcuResult 定义路径规划分析状态的枚举
 * 	@class FMRouteCalcuResult
 * 	@module Navigation
 * 	@namespace fengmap
 */
fengmap.FMRouteCalcuResult = {

    /**
     * 表示路线计算成功的标识
     * @property ROUTE_SUCCESS
     * @type {number}
     * @readOnly
     */
    ROUTE_SUCCESS: 1, //路线计算成功

    /**
     * 表示失败，没有传入路径计算数据的标识
     * @property ROUTE_FAILED_NO_FMDBDATA
     * @type {number}
     * @readOnly
     */
    ROUTE_FAILED_NO_FMDBDATA: 2, //失败，没有传入路径计算数据

    /**
     * 表示失败，起点与终点很近(绑定到同一个node上)的标识
     * @property ROUTE_FAILED_TOO_CLOSE
     * @type {number}
     * @readOnly
     */
    ROUTE_FAILED_TOO_CLOSE: 3, //失败，起点与终点很近(绑定到同一个node上)

    /**
     * 表示失败，没有起点所在group的navi数据的标识
     * @property ROUTE_FAILED_NO_DATA_START
     * @type {number}
     * @readOnly
     */
    ROUTE_FAILED_NO_DATA_START: 4, //失败，没有起点所在group的navi数据

    /**
     * 表示失败，没有终点所在group的navi数据的标识
     * @property ROUTE_FAILED_NO_DATA_END
     * @type {number}
     * @readOnly
     */
    ROUTE_FAILED_NO_DATA_END: 5, //失败，没有终点所在group的navi数据

    /**
     * 表示失败，没有电梯(手扶梯)进行跨楼梯路线计算的标识
     * @property ROUTE_FAILED_NO_STAIR
     * @type {number}
     * @readOnly
     */
    ROUTE_FAILED_NO_STAIR: 6, //失败，没有电梯(手扶梯)进行跨楼梯路线计算

    /**
     * 表示失败，不支持跨层路线计算的标识
     * @property ROUTE_FAILED_NOTSUPPORT
     * @type {number}
     * @readOnly
     */
    ROUTE_FAILED_NOTSUPPORT: 7, //失败，不支持跨层路线计算

    /**
     * 表示失败，不能计算的标识
     * @property ROUTE_FAILED_CANNOT_CALCULATE
     * @type {number}
     * @readOnly
     */
    ROUTE_FAILED_CANNOT_CALCULATE: 8, // 失败，不能计算

    /**
     * 表示失败，无法到达的标识
     * @property ROUTE_FAILED_CANNOT_ARRIVE
     * @type {number}
     * @readOnly
     */
    ROUTE_FAILED_CANNOT_ARRIVE: 9 // 失败，无法到达
}
/*
 * 导航相关的控制类
 * params:
 *     map,         	// map object
 *     analyser,    	// FMNaviAnalyser
 *     speed,			// float 5
 *     locationMarker,	// marker
 *     inTime, 			// 1.2
 *     scaleLevel,		// 1
 *     followPosition,	// true
 *     followAngle,		// false
 *     changeTiltAngle,	// 是否改变倾斜角度
 *     tiltAngle,		// 模拟导航时的倾斜角度
 *     isMultiGroups	// false 多层显示
 * 	   pause			// 暂停
 * 	   offsetHeight	    // 线的高度
 *
 *     directionAssert, // 正方向判断 +- 10 度
 *     combineAsset,    // 合并路径点的角度 5 度
 *
 * method:
 * 	   setStartPoint,	// 设置,起/终 点, 并会自动创建 imageMarker, 参数可以直接使用 拾取的 event
 * 	   					// {x: y: groupID: url:(default) size:(64)}
 * 	   setEndPoint,
 * 	   simulate,		// 模拟导航时会自动的画线, 所以不需要手机的调用 drawNaviLine
 * 	   drawNaviLine,
 * 	   stop 			// 停止模拟导航
 *
 * events:
 * 	   walking,			// 模拟导航过程中,返回: remain, walk
 * 	   complete,		// 模拟导航结束
 * 	   crossGroup		// 跨层: groupID


 /**
 *	FMNavigation 导航相关的控制类,封装了自动设置起始点标注，路径分析，模拟导航，导航动画的功能。
 * 	@class FMNavigation
 *	@constructor FMNavigation
 * 	@module Navigation
 * 	@namespace fengmap
 *   @param {fengmap.NaviOptions} options naviOptions对象
 *   @param {fengmap.FMMap} options.map 地图对象，必须的设置
 *   @param {float} options.speed 模拟导航定位图标行进的速度，单位m/s。默认5m/s。
 *   @param {boolean} options.followPosition 模拟导航时是否地图跟随,默认true
 *   @param {boolean} options.followAngle 模拟导航时是否改变地图角度，默认false
 *   @param {boolean} options.changeTiltAngle 是否在导航开始时改变地图的倾斜角度
 *   @param {number} options.scaleLevel 模拟导航开始时地图的显示级别，默认1
 *   @param {number} options.offsetHeight 导航线与楼层之间的高度偏移设置。默认是1。
 *   @param {json} options.lineStyle 路径线线型设置
 *   @demo navi/实例化导航参数配置.js
 */

/**
 * 设置起点
 * @method setStartPoint
 * @param {json} options endPoint参数对象
 * @param {bool} noMarker 不自动生成Marker对象, 默认为false
 * @param {float} options.x 起点坐标点x坐标
 * @param {float} options.y 起点坐标点y坐标
 * @param {number} options.groupID 起点坐标点楼层ID
 * @param {string} options.url 起点坐标点标注图片路径, 如不设置,且使用之前设置的图片,只是设置其位置
 * @param {number} options.size 起点坐标点标注图片大小
 * @param {fuction} options.callback 起点坐标点标注添加成功回调
 * @return  {fengmap.FMImageMarker} FMImageMarker 表示添加成功的imageMarker对象
 */


/**
 * 设置终点
 * @method setEndPoint
 * @param {json} options endPoint参数对象
 * @param {bool} noMarker 不自动生成Marker对象, 默认为false
 * @param {float} options.x 结束坐标点x坐标
 * @param {float} options.y 结束坐标点y坐标
 * @param {number} options.groupID 结束坐标点楼层ID
 * @param {string} options.url 结束坐标点标注图片路径, 如不设置,且使用之前设置的图片,只是设置其位置
 * @param {number} options.size 结束坐标点标注图片大小
 * @param {fuction} options.callback 结束坐标点标注添加成功回调
 * @return  {fengmap.FMImageMarker} FMImageMarker 表示添加成功的imageMarker对象
 */

/**
 * 得到此导航路径的文字描述字符串数组
 * @property {Array} naviDescriptions
 */

/**
 * 路径描述的JSON数组, 用户可以根据里面的数据,自己组织描述语言
 * @property {Array} naviDescriptionsData
 */

/**
 * 得到此导航路径的总距离
 * @property {float} naviDistance
 */

/**
 * 路径所经过层对应在各楼层的距离长度: 如:[{groupID: 1, distance: 103.56}, {groupID: 3, distance: 103.56}, {groupID: 1, distance: 53.56}]
 * @property {JSON} naviGroupsDistance
 */


/**
 * 导航所用到的locationMarker对象
 * @property {fengmap.FMLocationMarker} locationMarker
 */

/**
 * 起始点所使用的imageMarker对象
 * @property {fengmap.FMImageMarker} startMarker
 */

/**
 * 结束点所使用的imageMarker对象
 * @property {fengmap.FMImageMarker} endMarker
 */

/**
 * 聚焦到点击的路段
 * @method focusNaviLineSegment
 * @param {int} index 路段下标
 * @param {json} options 聚焦参数
 * @param {float} options.duration 聚焦时的过渡动画效果设置
 * @param {function} options.callback 聚焦完成后的事件回调
 */

/**
 * 设置完起始点后，调用此方法画出导航线
 * @method drawNaviLine
 * @return {fengmap.FMLineMarker} 返回当前绘制的线对象
 */

/**
 * 设置完起始点后，开始模拟导航，调用此方法会自动画线，不需要在调用drawNaviLine方法
 * @method simulate
 */

/**
 * 停止模拟导航
 * @method stop
 */

/**
 * 导航正在进行中的事件,模拟导航中会持续自动调用，真实导航下，通过方法locate回调。
 * @event walking
 * @return {json} 导航中的数据 {remain:data1,walk:data2}
 * @demo navi/模拟导航实时监听事件.js
 */

/**
 * 模拟导航中跨层事件
 * @event crossGroup
 * @demo navi/模拟导航跨楼层事件.js
 */

/**
 * 模拟导航完成事件
 * @event complete
 * @demo navi/模拟导航完成事件.js
 */

/**
 * 清空导航类中的起始点标注，定位标注及路径线
 * @method clearAll
 */

fengmap.FMNavigation = function(params) {
	var s = this;

	fm.Evento.convert(this);

	// 将属性直接附给类
	// params.landMesh 地面物体, 用于有高差的地型画导航线
	Object.assign(s, params);

	s._setDefaultValues({
		map: fengmap.Map.instance,
		analyser: fengmap.FMNaviAnalyser.create({
			naviServerURL: params.map.options.mapServerURL + '/',
			zone: true
		}),
		changeTiltAngle: true,
		speed: 5,
		followPosition: true,
		followAngle: false,
		isMultiGroups: false,
		inTime: 1.2,
		tiltAngle: 80,
		changeGroupTiltAngle: 30,
		minScale: .2, // 最小的缩放值, 用在模拟导航时,视角过近,或过远的问题
		scaleLevel: 1,

		height: 0, // 生成的线形物体与LocationMarker的高度
		offsetHeight: 1, // 生成的线型物体,与楼层之间的高度偏移

		directionAssert: 10, // 10 度
		combineAsset: 5, // 5  度

		naviModule: fengmap.FMNaviModule.MODULE_SHORTEST, // 路径规划算法, 默认为最短路径标识

		autoClearNaviLine: false, // 在画导航线时, 自动清空之前的线

		lineStyle: {
			lineWidth: 10,
			dash: {
				size: 4,
				gap: 2
			}
		}
	});

	s.lineStyle.lineType = fmg(s.lineStyle, 'type', 'lineType', fengmap.FMLineType.FMARROW);
	// god line no animate default
	if (s.lineStyle.lineType == fengmap.FMLineType.FMARROW) {
		s.lineStyle.noAnimate = s.lineStyle.noAnimate == undefined ? true : s.lineStyle.noAnimate;
	}

	s.lineStyle.height = fmg(s, 'height', .1);
	s.lineStyle.offsetHeight = fmg(s, 'offsetHeight', .1);

	// this.lineStyle.lineWidth = this.map.mapTheme.version == 1 ? 8 : (s.lineStyle.lineWidth || 6);

	s.analyser.init(s.map);

	s.startData = null;
	s.endData = null;

	s.startMarker = null;
	s.endMarker = null;
	s._locMarker = null;

	s.startMarkerLayer = new fengmap.FMImageMarkerLayer();
	s.endMarkerLayer = new fengmap.FMImageMarkerLayer();

	s.naviLines = [];

	s._naviResult = null;
	s.naviDescriptions = [];
	s.naviDescriptionsData = [];

	// timer
	s.timer = new fm.Clock();

	// 是否暂停
	s.pause = false;
}

fengmap.FMNavigation.prototype = {
	constructor: fengmap.FMNavigation,

	get locationMarker() {
		if (!this._locMarker) {
			this._locMarker = new fengmap.FMLocationMarker({
				id: 'location',
				// url: this.locationMarkerUrl || 'image/small/marker/loc.png',
				url: this.locationMarkerUrl || '',
				size: this.locationMarkerSize || 100,
			});

			this.map.addLocationMarker(this._locMarker);
			this.locationMarker.o3d_.up.multiplyScalar(-1);
		}

		return this._locMarker;
	},

	set locationMarker(val) {
		if (!(val instanceof fengmap.FMLocationMarker)) {
			return;
		}

		this._locMarker = val;
		this.map.addLocationMarker(this._locMarker);
	},

	setLineStyle: function(ps) {
		this.naviLines.forEach(function(itm) {
			itm.updateStyle(ps);
		});
	},

	isNaviGroup: function(groupID) {
		if (!this.startData || !this.endData) {
			return;
		}
		return (groupID == this.startData.groupID || groupID == this.endData.groupID)
	},

	_setDefaultValues: function(json) {
		var s = this;
		var keys = Object.keys(json);
		keys.forEach(function(key) {
			if (s[key] == undefined) {
				s[key] = json[key];
			}
		});
	},

	_createMarker: function(data, isStart) {
		var url = null;
		var layer = null;

		if (!data.groupID) {
			console.warn('data need groupID parameter!');
			return;
		}

		if (isStart) {
			if (this.startMarker) {
				this.startMarker.dispose();
			}
			layer = this.startMarkerLayer;
			url = data.url || 'image/small/marker/nav_location_start.png';
		} else {
			if (this.endMarker) {
				this.endMarker.dispose();
			}
			layer = this.endMarkerLayer;
			url = data.url || 'image/small/marker/nav_location_end.png';
		}

		var height = data.height == undefined ? 6 : data.height;

		// marker
		var _marker = new fengmap.FMImageMarker({
			x: data.x,
			y: data.y,
			url: url,
			height: height,
			size: data.size || 64,
			callback: function() {
				_marker.alwaysShow();
				if (data.callback) data.callback(_marker);
			}
		});

		layer.addMarker(_marker);

		if (isStart) {
			this.startMarker = _marker;
		} else {
			this.endMarker = _marker;
		}

		var glayer = this.map.getFMGroup(data.groupID);
		glayer.addLayer(layer);
	},

	/*get autoDrawNaviLine() {
		return this._needDrawLines_ == undefined ? true : this._needDrawLines_;
	},

	set autoDrawNaviLine(boo) {
		this._needDrawLines_ = boo;
	},*/

	setStartPoint: function(data, noMarker) {
		// this.startData = data;
		this.startData = Object.assign({}, this.startData, data, {
			x: data.x,
			y: data.y,
			groupID: data.groupID
		});
		if (data.url && !data.noMarker && !noMarker) {
			this._createMarker(data, true);
		}
		this._getNaviResult();
		this._needDrawLines_ = true;
	},

	setEndPoint: function(data, noMarker) {
		// this.endData = data;
		this.endData = Object.assign({}, this.endData, data, {
			x: data.x,
			y: data.y,
			groupID: data.groupID
		});

		if (data.url && !data.noMarker && !noMarker) {
			this._createMarker(data, false);
		}
		this._getNaviResult();
		this._needDrawLines_ = true;
	},

	// 如果是复杂的路径, 不能直接使用analyser的getGroupPoints方法,
	// 需要自己对分析的结果进行分段
	_getGroupsPoints: function() {
		var result = this._naviResult;
		var res = [];

		var _lastGid = null,
			_data = null;

		for (var i = 0; i < result.length; i++) {
			var _res = result[i];

			// 是否是同层
			var isSameGroup = _lastGid == _res.groupId;

			// 如果只有一个点(梯点, 长度为0),跳过
			// * 注意 * 首点与终点的只有一个梯点的情况
			if (_res.length == 0 && !(i == 0 || i == result.length - 1)) {
				continue;
			}

			if (!isSameGroup) {
				_lastGid = _res.groupId;
				// 将上一个 _data 存入结果
				if (_data) {
					res.push(_data);
				}
				// 创建一个新的 _data
				_data = {
					groupId: _res.groupId,
					pointList: []
				};
			}

			Array.prototype.push.apply(_data.pointList, _res.pointList);
		}

		// 加入最后一段
		if (_data) {
			res.push(_data);
		}

		this._groupsPoints = res;

		return res;
	},

	_addZeroResult: function(result) {
		/*var lastGid = null, lastData;
		for (var i = 0; i < result.length - 1; i++) {
			var res = result[i];

			if (lastGid) {
				if (!(res.groupId == lastGid && res.length == 0)) {
					// insert
					result.splice(i, 0, lastData);
				}

				lastGid = null;
				lastData = null;
			}

			if (res.length > 0) {
				lastGid = res.groupId;
				lastData = new fengmap.FMNaviResult(lastGid, 0, [res.pointList[res.pointList.length - 1]]);
			}
		}*/

		for (var i = 0; i < result.length - 1; i++) {
			var res = result[i];

			// 有长度
			if (res.length) {
				var rp = res.pointList[res.pointList.length - 1],
					tp = result[i + 1].pointList[0];

				// 如果两个点之间的距离大于20厘米
				if (DistanceofTwoPts(rp, tp) > .2) {
					res.pointList.push(new fengmap.FMMapCoord(tp.x, tp.y));
				}
			}
		}
	},

	_getNaviResult: function() {
		if (this.startData && this.endData) {
			this._naviResult = this._CaculateLines(this.startData, this.endData, this.startData.groupID, this.endData.groupID);

			// 规格化点, 是这样的, 多层路径, 一般是pointList(多个)后面会跟一个 pointList 只一个点的 "梯" 数据,
			// 但遗憾的是, 有复杂的路径计算中. 就是需要2次或以上的乘梯路径中, 除第一个有这个"梯"数据
			// 其它的就没有了, 所以为了正确的生成路径导航描述及其数据,需要将"梯"数据进行手动的补全
			// 就有了这段代码.
			//
			// 现在梯点都补了, 现在是需要判断,如果路径点的最后一个点与他的梯点不一至的话
			// 将梯点也加入进路径点
			this._addZeroResult(this._naviResult);

			// get groups points, and result in this._groupsPoints
			this._getGroupsPoints();

			// 得到导航的描述及描述数据
			var res = this._naviDescriptions(this._naviResult);
			this.naviDescriptions = res[0];
			this.naviDescriptionsData = res[1];
			this.naviDistance = res[2];
			this.naviGroupsDistance = res[3];
		}
	},

	clearLocationMarker: function() {
		if (this._locMarker) {
			this.map.removeLocationMarker(this._locMarker);
			this._locMarker = null;
		}
	},

	clearMarkers: function() {
		if (this.startMarker) {
			this.startMarker.dispose();
			this.startmarker = null;
			this.startData = null;
		}

		if (this.endMarker) {
			this.endMarker.dispose();
			this.endMarker = null;
			this.endData = null;
		}

		// 清空 navi result
		this._naviResult = null;
	},

	clearNaviLines: function() {
		/*if (this.naviLines.length != 0) {
		    for (var i = 0; i < this.naviLines.length; i++) {
		        if (this.naviLines[i])
		            this.map.clearLineMark(this.naviLines[i]);
		    }
		    this.naviLines = [];
		}*/
		this.map.clearLineMark(this.naviLines);
		this.naviLines = [];
	},


	clearAll: function() {
		this.clearMarkers();
		this.clearNaviLines();
		this.clearLocationMarker();
	},

	_drawLinesByGroup: function(groupId, needClear) {
		var s = this;

		s.lineStyle.up = new fm.Vector3(0, 1, 0);
		s.lineStyle.billboard = false;

		// var groupRouteResult = this.analyser.getRouteGroupPoints(groupId);
		// var groupRouteRes = [new fengmap.FMNaviResult(groupId,groupRouteResult.length,groupRouteResult)];
		// return this._drawlineByResults(groupRouteRes, needClear, groupId);

		s._groupsPoints.forEach(function(itm) {
			if (itm.groupId == groupId) {
				return s._drawlineByResults([itm], needClear, itm.groupId);
			}
		});
	},

	_drawLines: function(res, needClear) {
		var s = this;

		needClear = needClear == undefined ? true : needClear;
		if (needClear) {
			s.clearNaviLines();
		}

		// 先画出第层的线
		/*var gids = s.analyser.getRouteGroupIds();
		gids.forEach(function(gid) {
			s._drawLinesByGroup(gid, false);
		});*/
		s._groupsPoints.forEach(function(itm) {
			s._drawlineByResults([itm], needClear, itm.groupId);
		});

		// 再画中间线
		if (s._groupsPoints.length > 1) {
			s._drawCross(res);
		}
	},

	_drawCross: function(res) {
		var s = this;

		// cross line style
		s.lineStyle.up = new fm.Vector3(0, 0, 1);
		s.lineStyle.billboard = true;

		// 有几条 cross line 跨层线
		var cnt = s._groupsPoints.length - 1;

		for (var i = 0; i < cnt; i++) {
			var lineMarker = new fengmap.FMLineMarker();

			// add segments
			var gps = s._groupsPoints[i],
				gps2 = s._groupsPoints[i + 1];

			var groupIDs = [gps.groupId, gps2.groupId];

			// first segment
			var seg = new fengmap.FMSegment();
			seg.groupID = gps.groupId;
			seg.points = [gps.pointList[gps.pointList.length - 1]];
			lineMarker.addSegment(seg);

			// second segment
			var seg2 = new fengmap.FMSegment();
			seg2.groupID = gps2.groupId;
			seg2.points = [gps2.pointList[0]];
			lineMarker.addSegment(seg2);

			var lineObject = s.map.drawLineMark(lineMarker, s.lineStyle);
			lineObject.groupID = groupIDs;
			s.naviLines.push(lineObject);
		}

		/*var segs = s.analyser.getRouteLineSegments(res);
		var lastgid = -1;
		var groupIDs = [];
		for (var i = 0; i < segs.length; i++) {
			if (lastgid == -1) {
				lastgid = segs[i].groupID;
			} else {
				if (segs[i].groupID != lastgid) {
					lastgid = segs[i].groupID;

					groupIDs.push(segs[i - 1].groupID);
					groupIDs.push(lastgid);

					lineMarker.addSegment(segs[i - 1]);
					lineMarker.addSegment(segs[i]);
				}
			}
		}*/

		//线样式
		// this.map.lineStyle = this.lineStyle;
	},

	_divideSegment: function(segments, maxHeight, segmentLen) {
		var s = this;
		segmentLen = segmentLen || 10;

		segments.forEach(function(seg) {
			if (seg.points.length > 1) {
				var vs = [];
				var newPoints = [];

				for (var i = 1; i < seg.points.length; i++) {
					var p1 = seg.points[i - 1];
					var p2 = seg.points[i];

					var vp1 = s.map.toSceneCoord(p1);
					var vp2 = s.map.toSceneCoord(p2);

					vs.push(vp1);

					var sub = vp2.clone().sub(vp1);

					var dis = sub.length();
					var dir = sub.normalize();

					var div = Math.floor(dis / segmentLen);

					if (div > 0) {
						for (var j = 0; j < div; j++) {
							vs.push(vp1.clone().add(dir.clone().multiplyScalar(dis * (j + 1) / (div + 1))));
						}
					}

					if (i === seg.points.length - 1) {
						vs.push(vp2);
					}
				}

				var downDir = new fm.Vector3(0, -1, 0);
				newPoints = vs.map(function(itm) {
					var _p = itm.clone();
					itm.y = maxHeight;
					var rc = new fm.Raycaster(itm, downDir);

					var res = rc.intersectObject(s.landMesh);

					if (res) {
						var _p = res[0].point;
						_p.y += s.height;
					}

					return s.map.toMapCoord(_p);
				});

				seg.points = newPoints;
			}
		});

		return segments;
	},

	_drawlineByResults: function(results, needClear, groupID) {
		needClear = needClear == undefined ? true : needClear;
		if (needClear) {
			this.clearNaviLines();
		}

		//绘制部分
		var line = new fengmap.FMLineMarker();

		//获取当前路径结果的折线段
		var segments = this.analyser.getRouteLineSegments(results);

		///////////////////////////////
		// 如果设置了landMesh就在这里改变其 z 值. //
		///////////////////////////////
		if (this.landMesh) {

			if (typeof this.landMesh === 'string') {
				this.landMesh = this.map.mapScene.getO3dScene().getObjectByName(this.landMesh);
			}

			if (!this.landMesh) {
				fm.warn('Cannot find land mesh!');
				return;
			}

			if (!this.landMesh.geometry.boundingBox) {
				this.landMesh.geometry.computeBoundingBox();
			}

			var maxHeight = this.landMesh.geometry.boundingBox.max.y + 1;

			segments = this._divideSegment(segments, maxHeight, this.segmentsLength);
		}

		////////////////////////////////////////////////////
		// 20161226 add start and end point to lineObject //
		////////////////////////////////////////////////////
		/*segments[0].points_.unshift({
			x: this.startData.x,
			y: this.startData.y,
			groupId: this.startData.groupID
		});

		segments[segments.length - 1].points_.push({
			x: this.endData.x,
			y: this.endData.y,
			groupId: this.endData.groupID
		});*/

		for (var i = 0, len = segments.length; i < len; i++) {

			// vertex's height
			var segs = segments[i];

			line.addSegment(segs);
		}

		// 如果是起始点与终点只有一个梯点
		if (segments.length == 1 && segments[0].points.length < 2) {
			return;
		}

		if (len > 0) {
			// 如果是箭头类的样式, 使用椭圆线型
			if (this.lineStyle.type == 'arrow' || this.lineStyle.type == 'fmarrow') {
				this.lineStyle.yScale = .3;
			} else {
				this.lineStyle.yScale = 1;
			}

			//线样式
			// this.map.lineStyle = this.lineStyle;

			var lineObject = this.map.drawLineMark(line, this.lineStyle);
			lineObject.groupID = groupID;

			this.naviLines.push(lineObject);

			return lineObject;
		}
	},

	_CaculateLines: function(startpoint, endpoint, startgroupid, endgroupid) {
		if (this.analyser.analyzeNavi(startgroupid, startpoint, endgroupid, endpoint, this.naviModule) == fengmap.FMRouteCalcuResult.ROUTE_SUCCESS) {
			var results = this.analyser.getNaviResults();
			if (results.length == 0)
				return [];
			return results;
		}
		return [];
	},

	drawNaviLine: function(groupID, needClear) {
		if (!this.startData || !this.endData) {
			return;
		}

		this._needDrawLines_ = false;

		this.lineStyle.up = new fm.Vector3(0, 1, 0);
		this.lineStyle.billboard = false;

		// 先清空之前的
		if (!this.autoClearNaviLine && needClear) {
			this.clearNaviLines();
		}

		var line = null;

		// 如不设置 groupID, 则画所有层的线
		if (groupID == undefined || groupID == 'all' || groupID == 0) {
			// return this._drawlineByResults(this._naviResult);

			// 20161114 现在是画出重部的线, 线会自动的根据visibleGroupIDs来判断是
			// 否需要显示或隐藏.
			line = this._drawLines(this._naviResult, this.autoClearNaviLine);
		} else {
			line = this._drawLinesByGroup(groupID, this.autoClearNaviLine);
		}

		this.linesVisible();
		return line;
	},

	_locMarkerToStartPoint: function(offset) {
		if (!this.startData) {
			return;
		}
		offset = offset == undefined ? 3 : offset;
		this.locationMarker.setPosition(this.startData.x, this.startData.y, this.startData.groupID, (offset || this.offsetHeight * 1.01));
	},

	_moveTo: function(data, time, callback) {
		if (time == undefined) {
			time = 0;
		}

		return this.map.moveTo({
			x: data.x,
			y: data.y,
			time: time,
			groupID: data.groupID,
			callback: callback
		});
	},

	/**
	 * 在路径规划完成后,得到当前实际的定位点与路径上的最近点及与这个点之间的距离
	 * @method naviConstraint
	 * @param  {JSON} coord {x: ,y: , groupID: }
	 * @return {JSON}       {coord: , distance:, index:, remain, angle} coord: 垂点的坐标 {x:, y:, groupID}, distance: 指定点与垂点的距离, index: 当前的点所在的线段索引, remain: 导航的剩余距离, angle: 所在路段与正北方向的角度值
	 */
	naviConstraint: function(coord) {
		var navi = this;
		if (!navi.startData || !navi.endData) {
			return;
		}

		// 结果
		var result = {
			coord: {
				groupID: coord.groupID
			},
			distance: null,
			angle: 0 // 路段的角度（与正北方向的夹角）
		};

		// var naviRes = navi.analyser.getNaviResults();
		var naviRes = navi._analyse().map(function(itm) {
			return {
				x: itm.x,
				y: itm.z,
				z: 0,
				groupID: itm.gid,
				index: itm._index
			};
		});

		var _tmpCoord = {};

		for (var i = 1; i < naviRes.length; i++) {
			var p = naviRes[i - 1];
			var p2 = naviRes[i];

			if (p.groupID === coord.groupID && p2.groupID === coord.groupID) {
				var _dis = pt_distance_to_line(coord, p, p2, _tmpCoord);

				if (result.distance == null || _dis < result.distance) {
					result.distance = _dis;
					Object.assign(result.coord, _tmpCoord);

					/// -----------------------------------------
					/// 计算与正北方向的角度值
					/// 可以用于locationMarker
					/// ------------------START------------------

					result.angle = navi.getRouteAngle(p, p2);

					/// -------------------END-------------------

					// + index
					result.index = p.index;

					// 当前约束点到下一个拐角处的距离
					result.distanceToNext = DistanceofTwoPts(_tmpCoord, p2);
				}
			}
		}

		// 计算剩余距离
		if (result.distance != null) {
			var _len = 0;
			for (var i = naviRes.length - 1; i > result.index; i--) {
				if (i - 1 > result.index) {
					var p = naviRes[i];
					var p2 = naviRes[i - 1];

					_len += DistanceofTwoPts(p, p2);
				}
			}

			_len += DistanceofTwoPts(naviRes[result.index + 1], result.coord);

			result.remain = _len;
		}

		return result;
	},

	/**
	 * 全路网路径约束
	 * @method pathConstraint
	 * @param  {JSON} coord {x: ,y: , groupID: }
	 * @return {JSON}       {coord: , distance:, road:, angle} coord: 垂点的坐标 {x:, y:, groupID}, distance: 指定点与垂点的距离, road: 当前的点所在路段, angle: 所在路段与正北方向的角度值
	 */
	pathConstraint: function(coord) {

		if (!this.analyser.navi_) {return;}
		var self = this;

        var rcdb = self.analyser.navi_.naviRcDB.get(coord.groupID);
        if (!rcdb) {return;}

       	var lastRid, rid;
        var rs = rcdb.roadVector;
        var _tmpCoord = {};

        // 结果
        var newRes = {
            distance: 1000,     // 与路的距离
            road: null,         // 路
            coord: {
            	groupID: coord.groupID
            }
        };

        var res = Object.assign({}, newRes, {coord: {}});

        var result = null;

        if (rs.length) {

            rs.forEach(function (r) {

            	if (r.getRoadEntry() != 3) {
            		// 剔除  
	                if (r.m_Id === rid || !self.outRoad(r, coord)) {

	                    // 垂足计算
	                    var _dis = pt_distance_to_line(coord, r.m_StartPoint, r.m_EndPoint, _tmpCoord);

	                    if (rid === r.m_Id) {
	                        res.distance = _dis;
	                        res.road = r;
	                        res.angle = self.getRouteAngle(r.m_StartPoint, r.m_EndPoint);
	                        Object.assign(res.coord, _tmpCoord);
	                    }

	                    if (_dis < newRes.distance) {
	                        newRes.distance = _dis;
	                        newRes.road = r;
	                        newRes.angle = self.getRouteAngle(r.m_StartPoint, r.m_EndPoint);
	                        Object.assign(newRes.coord, _tmpCoord);
	                    }

	                }
            	}
                
            })

            result = newRes;
            var cid = newRes.road.m_Id;

            if (!lastRid || !boo) {
                rid = newRes.road.m_Id;
            } else {
                if (rid !== cid) {
                    if (cid === lastRid) {
                        rid = cid;
                    } else {
                        result = res;
                    }
                }
            }

            lastRid = newRes.road.m_Id;

        }

        return result;
	},

	getRouteAngle: function(p1, p2) {
		var northVec = new fm.Vector3(0, 0, 1);

		var v1 = new fm.Vector3(p1.x, 0, p1.y);
		var v2 = new fm.Vector3(p2.x, 0, p2.y);

		var vec = v2.clone().sub(v1).normalize();
		var angle = vec.angleTo(northVec) * fm.Math.RAD2DEG;

		var bigger = vec.clone().cross(northVec).y > 0;

		return bigger ? 360 - angle : angle;
	},

	outRoad:function(road, coord){

		if(coord.x<road.m_StartPoint.x && coord.x<road.m_EndPoint.x)
			return false;

		if(coord.x>road.m_StartPoint.x && coord.x>road.m_EndPoint.x)
			return false;

		if(coord.y<road.m_StartPoint.y && coord.y<road.m_EndPoint.y)
			return false;

		if(coord.y>road.m_StartPoint.y && coord.y>road.m_EndPoint.y)
			return false;

		return true;
	},

	/**
	 * 用于真实导航，设置定位系统所返回的真实定位坐标，内部自动路径约束，同时触发walking事件，返回如下结果： {remain: 到终点的剩余距离, walk: 已经走过的距离, distanceToNext: 是下一个转角处的距离, angle: 当前路线与正北方向的角度, index: 当前路段的索引, point: 路径约束后的点, groupID, 当前的楼层id}
	 * @method locate
	 * @param {fengmap.MapCoord} coord 定位系统返回并经过坐标转换后的地图坐标点
	 * @param {float} [angle] 角度值，如：45,可选	 
	 */
	locate: function(coord, angle) {
		var s = this;

		// 如果当前是在模拟导航状态
		// 就先停掉模拟导航	
		if (s.isSimulating) {
			s.stop();
		}

		function locateWalking() {
			var cc = s.naviConstraint(coord);

			s.emit('walking', {
				remain: cc.remain,
				walk: s.naviDistance - cc.remain,
				distanceToNext: cc.distanceToNext,
				angle: cc.angle,
				point: cc.coord,
				groupID: coord.gid,
				index: cc.index,
				isReal: true
			});

			if (s._locMarker) {
				s._locMarker.setPosition(cc.coord);
			}
		}

		// 跨楼层	
		if (coord.groupID != s._locateLastGroupID) {
			s._locateLastGroupID = coord.groupID;

		} else {
			// walking
			locateWalking();
		}
	},

	/**
	 * 用于真实导航，设置定位系统所返回的真实定位坐标，内部无路径约束，同时触发walking事件，返回如下结果： {remain: 到终点的剩余距离, walk: 已经走过的距离, distanceToNext: 是下一个转角处的距离, angle: 当前路线与正北方向的角度, index: 当前路段的索引, point: 路径约束后的点, groupID, 当前的楼层id}
	 * 此方法与locate的区别为内部不在内部自动计算约束
	 * @method locateNoConstraint
	 * @param {fengmap.MapCoord} coord 定位系统返回并经过坐标转换后的地图坐标点
	 * @param {json} cc 根据coord坐标，通过约束方法naviConstraint计算的约束后的对象。
	 * @param {float} [angle] 角度值，如：45,可选	 
	 */
	locateNoConstraint: function(coord, cc, angle) {
		var s = this;

		// 如果当前是在模拟导航状态
		// 就先停掉模拟导航	
		if (s.isSimulating) {
			s.stop();
		}

		function locateWalkingNoConstraint() {
			s.emit('walking', {
				remain: cc.remain,
				walk: s.naviDistance - cc.remain,
				distanceToNext: cc.distanceToNext,
				angle: cc.angle,
				point: cc.coord,
				groupID: coord.gid,
				index: cc.index,
				isReal: true
			});

			if (s._locMarker) {
				s._locMarker.setPosition(cc.coord);
			}
		}

		// 跨楼层	
		if (coord.groupID != s._locateLastGroupID) {
			s._locateLastGroupID = coord.groupID;

		} else {
			// walking
			locateWalkingNoConstraint();
		}
	},

	//线上得到点
	_getTransformByLength: function(vs, len) {
		if (len == 0) {
			return vs[0];
		}

		var distance = 0;
		var lastDis = 0;
		var lastV = vs[0];
		var v, vec, dis;

		for (var i = 1; i < vs.length; i++) {
			v = vs[i];
			vec = v.clone().sub(lastV);
			dis = vec.length();
			distance += dis;
			if (distance >= len) {
				vec.normalize();
				var resPnt = lastV.clone().add(vec.clone().multiplyScalar(len - lastDis));
				resPnt.gid = v.gid;
				resPnt.index = v._index;
				return resPnt;
			}

			lastV = v.clone();
			lastV.gid = v.gid;
			lastV.index = v._index;

			lastDis = distance;
		}

		var endPoint = vs[vs.length - 1];
		endPoint.index = endPoint._index;
		return endPoint;
	},

	// 根据坐标点,得到 梯 的类型
	getLadderType: function(coord, groupID) {
		var s = this;

		// coord z value
		coord.z = s.map.getGroupHeight(groupID);

		var res = s.map.search(groupID, {
			mapCoord: coord,
			radius: 15,
			nodeType: fengmap.FMNodeType.FACILITY
		});
		if (res.length > 0) {
			switch (res[0].typeID) {
				case 170001:
					return ' 楼梯';
					break;
				case 170003:
					return ' 扶梯';
					break;
				case 170006:
					return ' 直梯';
					break;
			}
		}
		return '梯';
	},

	_naviDescriptions: function(navResult) {
		var s = this;

		s.combinePoints = [];

		// 最终点距离是否小于3米
		s._boo = false;
		s._tailLen = 0;

		var des = [];
		var desData = [];
		var gid = null,
			res, ps, dis, vec, qianVal = 0,
			allLen = 0;

		var groupLengths = []; // {}

		function createData() {
			var arg = arguments;
			return {
				direction: arg[0],
				distance: arg[1],
				point: arg[2],
				groupID: arg[3]
			}
		}

		var dirArr = ['北', '东北', '东', '东南', '南', '西南', '西', '西北', '北']
		var dirArr2 = ['前', '右前', '右', '右后', '后', '左后', '左', '左前', '前']
		var dirArr3 = ['继续直行', '右前方继续直行', '右转', '右后转', '后退', '左后转', '左转', '左前方继续直行', '继续直行']

		// 得到角度在哪个象限 0 ~ 8 首尾一样 [前...... 前]
		function getField(angle, assetAngle) {
			var ang = Math.PI / 4;
			var val = angle / ang;

			var index = parseInt(val);
			var yu = (val % 1) * ang;

			if (index % 2 == 0) {
				if (yu > assetAngle) {
					index += 1;
				}
			} else {
				if (yu >= ang - assetAngle) {
					index += 1;
				}
			}

			return index;
		}

		// 得到两个向量之间的角度
		function getAngle(v1, v2) {
			var angle = v2.angleTo(v1);
			var cross = v2.clone().cross(v1);

			if (cross.y < 0) {
				angle = 2 * Math.PI - angle;
			}
			return angle;
		}

		// 方向判断
		function getDirection(ps, index) {
			if (index == ps.length - 1) {
				return {
					index: ps[ps.length - 1].index
				};
			}

			var north = new fm.Vector3(0, 0, 1);
			var v1 = index == 0 ? north : ps[index].clone().sub(ps[index - 1]).normalize();

			// console.log(index , ps, ps[index + 1], ps[index]);

			var sub = ps[index + 1].clone().sub(ps[index]);
			var len = sub.length();
			var v2 = sub.normalize();

			var radAsset = s.directionAssert * fm.Math.DEG2RAD;
			var absField = getField(getAngle(north, v2), 22.5 * fm.Math.DEG2RAD);
			var relAngle = getAngle(v1, v2);
			var relField = getField(relAngle, s.directionAssert * fm.Math.DEG2RAD);

			return {
				relField: relField,
				relDesc: dirArr2[relField],
				relAngle: relAngle * fm.Math.RAD2DEG,
				absField: absField,
				absDesc: dirArr[absField],
				distance: len,
				index: ps[index].index
			}
		}

		// 变成场景坐标 再去 重.
		function regularPoints(pps, gid) {
			// 变成场景vector3
			var regularPs = pps.map(function(itm, index) {
				var v = s.map.toSceneCoord(itm);
				v.index = index;
				return v;
			});

			// 得到每个点的方向等信息
			var res = []
			for (var i = 0; i < regularPs.length; i++) {
				var _r = getDirection(regularPs, i);
				_r.point = pps[i];
				_r.groupID = gid;
				res.push(_r);
			}

			// 将 < combineAsset 的点进行合并
			var combineRes = [res[0]];
			for (var i = 1; i < res.length; i++) {
				if (res[i].relAngle <= s.combineAsset || 360 - res[i].relAngle <= s.combineAsset) {
					combineRes[combineRes.length - 1].distance += res[i].distance;
				} else {
					combineRes.push(res[i]);
				}
			}

			return combineRes;
		}

		function getGroupDes(gid){

			if(s.map.getFMGroup(gid) != null){
				return s.map.getFMGroup(gid).groupDesc;
			}

			var layerGroups = s.map.mapService.staticScene_.scene.layerGroups;

			for (var i = 0; i < layerGroups.length; i++) {
				var layerGroup = layerGroups[i];
				if (layerGroup.gid == gid) {
					return layerGroup.desc;
				}
			}

			return '';
		}

		// 得到描述
		function getDesc(combine, index, gid, nextGid) {
			var data = combine[index];

			var end = combine[index + 1];

			var next = dirArr3[end.relField];

			// 如果最终段少于3米, 则将距离加入倒数第二段,并直接结束
			s._boo = (index == combine.length - 3 && end.distance < 3);

			if (!next || s._boo) {
				if (!nextGid) {
					if (s._boo) {
						s._tailLen = end.distance;
					}
					next = '到达目的地';
				} else {
					s._boo = false;
					if (!next) { // 没有下一个点,并且有下一个层,所以为乘梯
						var labber = s.getLadderType(combine[index + 1].point, gid);

						var xing = nextGid > gid ? '上行到达' : '下行到达';
						var ceng = getGroupDes(nextGid);
						next = '乘' + labber + ' ' + xing + ' ' + ceng;
					}
				}
			}

			if (index == 0) {
				if (combine.length == 2) {
					return '向 ' + data.absDesc + ' 直行 ' + Math.ceil(data.distance) + ' 米 ' + next;
				} else {
					return '向 ' + data.absDesc + ' 直行 ' + Math.ceil(data.distance) + ' 米 ' +
						dirArr3[combine[index + 1].relField];
				}
			} else {
				return '直行 ' + Math.ceil(data.distance + (s._boo && !nextGid ? end.distance : 0)) + ' 米 ' + next;
			}
		}

		// 得到描述数据
		function getDescData(combine, index, gid, nextGid) {
			var start = combine[index];
			var end = combine[index + 1];

			// 如果最终段少于3米, 则将距离加入倒数第二段,并直接结束
			// var boo = (index == combine.length - 3 && end.distance < 3);

			var next = dirArr3[combine[index + 1].relField];

			if (!next || s._boo) {
				if (!nextGid) {
					end.relDesc = '终';
				} else {
					var xing = nextGid > gid ? '上' : '下';
					var ceng = getGroupDes(nextGid);
					end.relDesc = xing;
				}
			}

			return {
				startPoint: start.point, //起点
				startGID: start.groupID, //楼层ID
				startIndex: start.index, //对应原始规划点数据索引 待定字段

				endPoint: end.point, //终点
				endGID: end.groupID, //楼层ID
				endIndex: end.index, //对应原始规划点数据索引 待定字段

				startDirection: start.absDesc, //起点绝对方向
				endDirection: end.relDesc, //终点相对方向

				distance: (start.distance + (s._boo && !nextGid ? end.distance : 0)) //距离
			};
		}

		var lonely = false;
		var lastGroupID = null,
			lastDrawed = null;

		for (var i = 0; i < navResult.length; i++) {
			res = navResult[i];
			// if (res.pointList.length < 2) continue;

			// 层数
			gid = res.groupId;

			nextGid = null;
			if (i < navResult.length - 1) {
				// 得到下一层的groupID
				for (var k = i; k < navResult.length; k++) {
					if (navResult[k].groupId != gid) {
						nextGid = navResult[k].groupId;
						break;
					}
				}
			}

			ps = res.pointList;

			// 规格化点 [{}]
			//  absDesc: "北"
			//	absField: 0
			//	distance: 8.942000000737607
			//	groupID: 2
			//	index: 13
			//	point:
			//	relAngle: 270
			//	relDesc: "左"
			//	relField: 6
			var combines = regularPoints(ps, gid);

			if (combines.length > 1) {
				Array.prototype.push.apply(s.combinePoints, combines);
			}

			// console.log('combines', combines, 'nextGid:', nextGid, 'lonely:', lonely);

			// 充添 文字导航 及 文字导航数据
			if (combines.length == 1) {
				if (nextGid || lonely) {
					if (lonely) {
						// 如果desData里面有数据,数组长度不为0
						if (desData.length) {
							if (i == navResult.length - 1) {
								des[des.length - 1] += ' 到达目的地';
								desData[desData.length - 1].endDirection = '终';
							}

							desData[desData.length - 1].endPoint = ps[0];
							desData[desData.length - 1].endGID = gid;
						}
					} else if (lastDrawed == gid || lastDrawed == null) { // lastDrawed == null, 表示无路线直接乘梯
						var xing = nextGid > gid ? '上行到达' : '下行到达';
						var ceng = getGroupDes(nextGid);
						next = '乘梯 ' + xing + ' ' + ceng;

						des.push(next)
						desData.push({
							startPoint: ps[0],
							startDirection: nextGid > gid ? '上' : '下',
							startGID: gid
						});
					}
					lonely = !lonely;
					// lonely = !nextGid;
				}
			} else {
				lastDrawed = gid;
				for (var j = 0; j < combines.length - 1; j++) {

					// 如果最后一段小于3米,就将长度合并到倒数第二段,并视为结束
					if (s._boo) {
						break;
					}

					des.push(getDesc(combines, j, gid, nextGid));
					desData.push(getDescData(combines, j, gid, nextGid));
				}
			}

			// 计算长度
			if (combines.length > 1) {
				// 层的总长度
				// groupLengths[gid] = combines.reduce(function(p, n) {
				// 	return p + (n.distance || 0);
				// }, 0);
				var _len = combines.reduce(function(p, n) {
					return p + (n.distance || 0);
				}, 0);

				groupLengths.push({
					groupID: gid,
					distance: _len
				});

				// 总长
				allLen += _len;
			}

			lastGroupID = gid;
		}

		return [des, desData, allLen, groupLengths];
	},

	focusNaviLineSegment: function(index, ps) {
		var s = this;
		var scale = 1;
		var center = null;
		var sp = null,
			ep = null,
			sgid, egid;
		if (this.naviDescriptionsData) {
			if (index < this.naviDescriptionsData.length) {
				var data = this.naviDescriptionsData[index];

				sp = data.startPoint;
				ep = data.endPoint;
				if (!ep) {
					ep = sp;
				}

				sgid = data.startGID;
				egid = data.endGID;

				sp.z = this.map.getGroupHeight(sgid);
				ep.z = this.map.getGroupHeight(egid);

				center = {
					x: (sp.x + ep.x) / 2,
					y: (sp.y + ep.y) / 2,
					z: ep.z
				};
			}
		}

		if (!center) {
			return;
		}

		ps = ps || {};
		ps.rawLevel = true;

		this.map.moveTo({
			x: center.x,
			y: center.y,
			groupID: egid,
			duration: fmg(ps, 'time', 'duration', .6),
			callback: function() {
				if (sp && ep) {
					scale = s.map.getScalelevelValueByVectics(sp, ep);
				}

				s.map.scaleLevelTo(s.map.scaleLevelValue * scale * (ps.extendScale || 1.3), ps);
			}
		});
	},

	// 分析路径得到路径原始点,及导角差值点
	_analyse: function() {
		if (!this.startData || !this.endData) {
			return;
		}

		/*var resPoints = this.analyser.getRouteAllPoints(); //得到所有点
		var vs = resPoints.map(function(itm, index) {
		    var newpnt = new fm.Vector3(itm.x, 0, itm.y);
		    newpnt.gid = itm.groupId;
		    newpnt._index = index;
		    return newpnt;
		});*/

		var _index = -1;
		var vs = this.naviDescriptionsData.map(function(itm, index) {
			var newpnt = new fm.Vector3(itm.startPoint.x, 0, itm.startPoint.y);
			newpnt.gid = itm.startGID;
			newpnt._index = index;
			_index = index;
			return newpnt;
		});

		// 尾点
		var end = this.naviDescriptionsData[this.naviDescriptionsData.length - 1];

		var endVec = new fm.Vector3(end.endPoint.x, 0, end.endPoint.y);
		endVec.gid = end.endGID;
		endVec._index = _index + 1;

		vs.push(endVec);

		return vs;
	},

	_toPos: null,
	_toRot: null,
	_allLen: 0,

	_preGid: 0,
	_changeGrouping: false,

	_gpsID: null,

	// 模拟 GPS 来定位当前点
	_gps: function() {
		var s = this;
		if (s._gpsID) {
			clearInterval(s._gpsID);
		}

		s._gpsStop = false;

		var ps = s._analyse();

		// record end point of the line
		// use to check if end
		// s._endPoint_ = ps[ps.length -1].clone();
		// s._endPoint_ = s.map.toSceneCoord(s._endPoint_);

		s.timer.start();

		s.isSimulating = true;
		s._isEnd_ = false;

		s._groupPointsIndex = 0;

		var _interval = 1000 / 30;
		var _step_ = 2,
			_cnt_ = 0;

		function ff() {
			if (!s._gpsStop) {
				requestAnimationFrame(ff);
			}

			// 结束了, 不再获得新的位置
			if (s._isEnd_) {
				return;
			}

			_cnt_++;

			if (_cnt_ == _step_) {
				_cnt_ = 0;
			} else {
				return;
			}

			var delta = s.timer.getDelta();

			// 如果是暂停或换层时,不做处理
			if (s._changeGrouping || s.pause) {
				return;
			}

			s._allLen += s.speed * delta;
			if (s._allLen == 0) {
				return;
			}

			// console.log('delta', delta, 'allLen', s._allLen);

			var res = s._getTransformByLength(ps, s._allLen);

			var remainDistance = s.naviDistance - s._allLen;

			// if (res) {
			// y, z 互换, 返回给 walking 的使用
			var _res = Object.assign({}, res);
			var _y = _res.y;
			_res.y = _res.z;
			_res.z = _y;

			s._gpsData = {
				remain: remainDistance,
				walk: s._allLen,
				point: _res,
				groupID: res.gid,
				index: res.index - 1
			};

			res.x = -res.x - s.map.mapScene.sceneX_;
			res.y = s.locationMarker.o3d_.position.y;
			res.z -= s.map.mapScene.sceneZ_;

			// to postion
			s._toPos = res.clone();

			// }

			// 模拟导航结束
			if (!res || remainDistance <= s._tailLen) {
				s._isEnd_ = true;
				return;

				/*s.stop();
				s.emit('complete');
				return;*/
			}

			// res.index是走到了未合并的点集合中的索引
			// 所以需要得到与其对应的是哪个索引
			// res.index = s._findCombineIndex(res.index, res.gid);

			if (!s._preGid) {
				// s._preGid = res.gid;
				s._preGid = ps[0].gid;
			}

			/*s.emit('walking', {
				remain: remainDistance,
				walk: s._allLen,
				point: _res,
				groupID: res.gid,
				index: res.index - 1
			});*/

			// 如果在导航中停止
			if (!s.isSimulating) {
				return;
			}

			// 跨楼层
			if (s._preGid != res.gid) {
				s._preGid = res.gid;

				// 楼层组 + = 1
				s._groupPointsIndex++;

				// locationMarker hide first when change groups
				s.locationMarker.visible = false;

				var desPnt = {
					x: -res.x - s.map.mapScene.sceneX_,
					y: res.z + s.map.mapScene.sceneZ_
				};
				desPnt.groupID = res.gid;

				// 跟随位置时, 需要自动切换楼层
				if (s.followPosition) {
					s._changeGrouping = true;
					if (s.changeTiltAngle) {
						s._viewID = fm.Tween.action(s.map, s.inTime, {
							tiltAngle: s.changeGroupTiltAngle
						});
					}

					s._scaleLevelToID = s.map.scaleLevelTo(s.scaleLevel + 1, {
						time: s.inTime,
						callback: function() {
							// 显示next楼层
							if (!s.isMultiGroups) {
								s.map.visibleGroupIDs = [res.gid];

								// 将locationMarker放到下一层开始的位置
								var _pos = s.locationMarker.getPosition();

								var _nextPoints = s._groupsPoints[s._groupPointsIndex];
								if (_nextPoints && _nextPoints.pointList && _nextPoints.pointList.length > 0) {
									_pos = s._groupsPoints[s._groupPointsIndex].pointList[0];
								}

								_pos.groupID = res.gid;

								s.locationMarker.setPosition(_pos);

								// s.drawNaviLine(res.gid);
							}

							s._moveToID = s._moveTo(desPnt, s.inTime, function() {
								var _minScale = s.map.scaleLevels_[s.scaleLevel] < .2 ? s.minScale : s.map.scaleLevels_[s.scaleLevel];
								s.map.scaleLevelTo(_minScale, {
									time: s.inTime,
									rawLevel: true,
									callback: function() {
										s._changeGrouping = false;
									}
								});

								// locationMarker show again
								s.locationMarker.groupID = res.gid;
								s.locationMarker.visible = true;

								if (s.changeTiltAngle) {
									s._viewID = fm.Tween.action(s.map, s.inTime, {
										tiltAngle: s.tiltAngle
									});
								}
							});
						}
					});
				} else { // 不跟随位置时
					// if (!s.isMultiGroups) {
					// s.drawNaviLine(res.gid);
					// s.map.focusGroupID = {groupID: res.gid, duration: 0};
					// s.map.visibleGroupIDs = s.map.visibleGroupIDs;
					s.linesVisible();

					// }
				}

				// 触发跨层事件
				s.emit('crossGroup', res.gid);
			}

			var matrix = s.locationMarker.o3d_.matrix.clone();
			matrix.lookAt(s.locationMarker.o3d_.position, s._toPos, s.locationMarker.o3d_.up);
			matrix.multiply(new fm.Matrix4().makeRotationFromEuler(new fm.Euler(Math.PI / 2, 0, Math.PI)));

			// to rotation
			s._toRot = new fm.Quaternion().setFromRotationMatrix(matrix);

			// 被动渲染
			if (s.map.passiveMode) {
				s.map.forceUpdate(true);
			}

			// s._gpsID = setTimeout(ff, _interval);
		}

		ff();
		// s._gpsID = setTimeout(ff, _interval);
		// s._gpsID = setInterval(, 1000 / 30);
	},

	_animateFun: null,

	stop: function() {
		// clearInterval(this._gpsID);
		this._gpsStop = true;
		clearInterval(this._viewID);
		clearInterval(this._scaleLevelToID);
		clearInterval(this._moveToID);
		if (this._animateFun) {
			this.map.off('update', this._animateFun);
		}
		this._allLen = 0;
		this._preGid = 0;
		this._groupPointsIndex = 0;
		this._toPos = this._toRot = null;
		this.timer.stop();
		this.isSimulating = false;
	},

	// 将 locationMarker 动画到当前的 GPS 定位点
	_animate: function() {
		var s = this;

		if (s._changeGrouping || s.pause) {
			return;
		}

		if (s._toPos) {
			var pos = s.locationMarker.o3d_.position.clone().lerp(s._toPos, (s.followSpeed || .2));

			// 判断是否到达了终点: 与终点的距离 < 0.5米
			var dis = DistanceofTwoPts(pos, s._toPos);

			// 需要变回 场景坐标
			pos.x = -pos.x - s.map.mapScene.sceneX_;
			pos.y = pos.z + s.map.mapScene.sceneZ_;

			pos.gid = s.locationMarker.gid;
			s.locationMarker.setPosition(pos.x, pos.y, s._preGid, s.offsetHeight * 1.01);

			s.emit('walking', Object.assign({}, s._gpsData, {
				remain: s._gpsData.remain + dis,
			}));

			if (s.followPosition) {
				s._moveToID = s._moveTo(pos);
			} else {
				s.map.updateCountDown_ = 0;
			}

			if (s._isEnd_ && dis < .5) {
				s.stop();
				s.emit('complete');
				return;
			}
		}

		if (s._toRot) {
			s.locationMarker.o3d_.quaternion.slerp(s._toRot, .2); //改变定位图标方向

			// 如不旋转地图
			if (!s.followAngle) {
				return;
			}

			var v = new fm.Vector3(1, 0, 0);
			var vv = v.clone();

			// tranform vector from local to world
			var m = s.locationMarker.o3d_.matrix.clone();
			m.setPosition(new fm.Vector3());
			vv.applyMatrix4(m);

			// 差乘的Y值是否为负,来判断两个向量的方向是否为相反
			var neg = vv.clone().cross(v);
			var neg = neg.y < 0 ? -1 : 1;

			var angle = v.angleTo(vv);

			// 计算转换过的角度
			var realAngle = Math.PI - angle * neg;

			// 如果是3D视图
			if (s.map.controls.object instanceof fm.PerspectiveCamera) {
				realAngle += Math.PI;
			}

			s.map.controls.update({
				forceTheta: realAngle
			});
		}
	},

	linesVisible: function(groupIDs) {
		/*this.naviLines.forEach(function(line) {
			line.visibleGroupIDChanged(this.map.visibleGroupIDs);
		});*/
		this.map.visibleGroupIDs = groupIDs || this.map.visibleGroupIDs;
	},

	/**
	 * ps:
	 * 	inTime: 1
	 * 	scaleLevel: 0
	 * 	speed: 2
	 */
	simulate: function(ps) {
		if (!this.startData || !this.endData) {
			return;
		}

		ps = ps || {};

		var s = this;
		var inTime = ps.inTime || s.inTime || .7;
		ps.scaleLevel = ps.scaleLevel || s.scaleLevel || 0;

		// locationMarker to startPoint
		s._locMarkerToStartPoint(fmg(ps, 'height', 'zOffset', 'offset', s.offsetHeight * 1.01));

		// 画导航线
		/*if (s.isMultiGroups) {
			s.drawNaviLine(null, true);
		} else {
			s.drawNaviLine(null, true);
		}*/

		if (s._needDrawLines_ || fmg(ps, 'autoClear', false)) {
			s.drawNaviLine(null, true);
		}

		if (!s.isMultiGroups) {
			this.linesVisible([s.startData.groupID]);
		}

		// 将视角移动起始点
		s._moveToID = s._moveTo(s.startData, inTime, function() {
			// focus
			s.map.focusGroupID = {
				gid: s.startData.groupID,
				time: 0
			}

			// 倾斜角度
			if (s.changeTiltAngle) {
				s._viewID = fm.Tween.action(s.map, inTime, {
					tiltAngle: s.tiltAngle
				});
			}

			// scale level to 0
			var _minScale = s.map.scaleLevels_[ps.scaleLevel] < .2 ? s.minScale : s.map.scaleLevels_[ps.scaleLevel];
			s._scaleLevelToID = s.map.scaleLevelTo(_minScale, {
				callback: works,
				rawLevel: true,
				time: inTime
			});
		});

		// 模拟导航
		function works() {
			s._gps();

			s._animateFun = s._animate.bind(s);
			s.map.on('update', s._animateFun);
		}
	},
};
//FengMap 路径计算方法 基于Dijkstra

//路径计算结果返回类型
var ROUTE_SUCCESS = 1; //路线计算成功
var ROUTE_FAILED_NO_FMDBDATA = 2; //失败，没有传入路径计算数据
var ROUTE_FAILED_TOO_CLOSE = 3; //失败，起点与终点很近(绑定到同一个node上)
var ROUTE_FAILED_NO_DATA_START = 4; //失败，没有起点所在group的navi数据
var ROUTE_FAILED_NO_DATA_END = 5; //失败，没有终点所在group的navi数据
var ROUTE_FAILED_NO_STAIR = 6; //失败，没有电梯(手扶梯)进行跨楼梯路线计算
var ROUTE_FAILED_NOTSUPPORT = 7; //失败，不支持跨层路线计算
var ROUTE_FAILED_CANNOT_CALCULATE = 8; // 失败，不能计算
var ROUTE_FAILED_CANNOT_ARRIVE = 9; // 失败，无法到达

//路径计算方式
var RC_Module_Cost_Distance = 1; // 最短路径
var RC_Module_Cost_Time = 2; // 最快(利用rank)

var FMRouteSetting = function() {
    this._cgp = FMROUTE_CGP_DEFAULT;
    this._rcm = RC_Module_Cost_Time;
}

//跨层路径计算轮廓
var RouteOutline = function() {
    this.Idfrom = -1; //int
    this.Idto = -1; //int
    this.Nodefrom = new NaviNode; //Node
    this.Nodeto = new NaviNode; //Node
    this.Geofrom = new fengmap.FMMapCoord; //fengmap.FMMapCoord
    this.Geoto = new fengmap.FMMapCoord; //fengmap.FMMapCoord
    this.next = null; // 下一个  RouteOutline

    this.invalide = function() {
        return (this.Idfrom < 0 || this.Idto < 0);
    }

    this.init = function(Idfrom, Idto, Nodefrom, Nodeto, Geofrom, Geoto) {

        this.Idfrom = Idfrom;
        this.Idto = Idto;
        this.Nodefrom = Nodefrom;
        this.Nodeto = Nodeto;
        this.Geofrom = Geofrom;
        this.Geoto = Geoto;
    }
};

// Extent点结构
var tagExtentPt = function(GID, EID, pt) {
    this.m_GID = GID;
    this.m_EID = EID;
    this.m_pt = pt;
    this.m_pre = -1;
    this.m_dist = -Infinity;
    this.m_visited = false;
    this.m_vPre = [];
    this.operator = function(rhs) {
        return (this.m_GID == rhs.m_GID && this.m_EID == rhs.m_EID);
    }
};

// Extent之间通行梯类结构
var tagExtentLift = function() {

    this.m_startGroupID = -1;
    this.m_startExtentID = -1;
    this.m_endGroupID = -1;
    this.m_endExtentID = -1;

    this.m_startLifts = [];
    this.m_endLifts = [];

    this.init = function(startGroupID, startExtentID, endGroupID, endExtentID, startLifts, endLifts) {

        this.m_startGroupID = startGroupID;
        this.m_startExtentID = startExtentID;
        this.m_endGroupID = endGroupID;
        this.m_endExtentID = endExtentID;

        this.m_startLifts = startLifts;
        this.m_endLifts = endLifts;
    }
}

//图
var Graph = function(vertices) {
    this.m_vertices = vertices;
    this.m_matrix = [];

    var size = vertices.length;
    for (var i = 0; i < size; i++) {
        this.m_matrix[i] = [];
        for (var j = 0; j < size; j++) {
            this.m_matrix[i][j] = Infinity;
        }
    }
};

//路径计算结果
var FMRC_Result = function() {
    this.groupId = 0; // 组id（楼层编号） int
    this.length = 0; // 长度 double
    this.nodeVector = []; // Node序列
    this.pointVector = []; // fengmap.FMMapCoord序列
};

//路径计算参数 结构
var FMRC_Para = function() {
    this.m_Node = new NaviNode; //Node
    this.m_GroupId = 0; //路径Node所在groupId(楼层) int
    this.m_Point = new fengmap.FMMapCoord; //点坐标(外部输入的) fengmap.FMMapCoord
    this.m_CrossPt = new fengmap.FMMapCoord; //点与绑定路段的垂点 fengmap.FMMapCoord
    this.m_Road = new NaviRoad; //点绑定的路段 Road
};

function IsInVector(mVector, id) {
    if (mVector.length == 0)
        return false;

    for (var i = 0; i < mVector.length; i++) {
        if (mVector[i] == id)
            return true;
    }
    return false;
}

function isPointInSameExtent(graph, pnt0, pnt1) {
    if (graph == null)
        return 0;

    var oid0 = graph.QueryContainExtentId(pnt0);
    var oid1 = graph.QueryContainExtentId(pnt1);

    if (oid0 == oid1)
        return 1;

    return 0;
}

function isNotAllNodeTreatHead(nodeVector) {
    for (var i = 0; i < nodeVector.length; i++) {
        if (nodeVector[i]._treatHead == false) {
            return 1;
        }
    }

    return 0;
}

function isNotAllPathinvalide(paths) {
    for (var i = 0; i < paths.size(); i++) {
        if (paths.get(paths.keys[i])._weight < ERROR_WEIGHT)
            return 1;
    }

    return 0;
}

// 获取最小值
function extractMin(vertices) {
    var mark = -1,
        size = vertices.length;
    for (var i = 0; i < size; ++i) {
        if (!vertices[i].m_visited && vertices[i].m_dist < Infinity) {
            if (mark == -1) {
                mark = i;
            } else if (vertices[i].m_dist < vertices[mark].m_dist) {
                mark = i;
            }
        }
    }

    return mark;
}

// 计算图中最短路径
function calShortestPath(graph, startIdx, endIdx, shortestPath) {
    var size = graph.m_vertices.length;
    if (startIdx < 0 || startIdx >= size || endIdx < 0 || endIdx >= size) {
        return null;
    }

    graph.m_vertices[startIdx].m_visited = true;

    for (var idx = 0; idx < size; idx++) {
        graph.m_vertices[idx].m_dist = graph.m_matrix[startIdx][idx];
    }

    var count = size;
    while (--count) {
        var tag = extractMin(graph.m_vertices);
        if (-1 == tag) {
            continue;
        }

        graph.m_vertices[tag].m_visited = true;

        for (var idx = 0; idx < size; idx++) {
            if (!graph.m_vertices[idx].m_visited && graph.m_matrix[tag][idx] != Infinity && graph.m_vertices[idx].m_dist >= graph.m_matrix[tag][idx] + graph.m_vertices[tag].m_dist) {
                graph.m_vertices[idx].m_dist = graph.m_matrix[tag][idx] + graph.m_vertices[tag].m_dist;
                graph.m_vertices[idx].m_pre = tag;

                graph.m_vertices[idx].m_vPre.push(tag);
            }
        }
    }

    var vecShortestPath = savePaths(endIdx, graph.m_vertices);
    var pathSize = vecShortestPath.length;
    for (var pathIdx = 0; pathIdx < pathSize; pathIdx++) {
        vecShortestPath[pathIdx].unshift(graph.m_vertices[startIdx]);
    }

    var minSize = Infinity;
    for (var idx = 0; idx < pathSize; idx++) {
        var currSize = vecShortestPath[idx].length;
        if (currSize < minSize) {
            minSize = currSize;
            for (var idj = 0, idjlen = vecShortestPath[idx].length; idj < idjlen; idj++) {
                shortestPath.push(vecShortestPath[idx][idj]);
            }
        }
    }

    return vecShortestPath;
}

function savePaths(endIdx, vertices) {
    var vecShortestPath = [],
        childPaths = [];
    if (-1 != endIdx) {
        var prevSize = vertices[endIdx].m_vPre.length;
        if (0 != prevSize) {
            var vSize = vertices[endIdx].m_vPre.length;
            for (var idx = 0; idx < vSize; idx++) {
                childPaths = savePaths(vertices[endIdx].m_vPre[idx], vertices);

                for (var j = 0, jlen = childPaths.length; j < jlen; j++) {
                    childPaths[j].push(vertices[endIdx]);
                }

                vecShortestPath = vecShortestPath.concat(childPaths);
            }
        } else {
            vecShortestPath.push([vertices[endIdx]]);
        }
    }

    return vecShortestPath;
}

//Dijkstra最短路径Handle
fengmap.NaviDijkstra_ = function(options) {
    this.options = new fengmap.NaviOptions(options);
    this.naviService = new fengmap.NaviService(this.options);

    this.m_Start = new FMRC_Para; //起点参数 FMRC_Para
    this.m_End = new FMRC_Para; //终点参数 FMRC_Para

    this.naviRcDB = new NaviMap(); //路径计算的数据(每一个group对应一份Graph数据) int Graph

    this.path = new NaviMap(); //正向搜索结果(起点 ==》 终点) int NaviInformation

    //  var pathTail = new NvaiMap() ;//反向搜索结果(终点 ==》 起点) int NaviInformation

    this.m_RC_Result = []; // 跨group路线计算结果 FMRC_Result

    this.minDistance = .1;

    this.initByMap = function(map) {
        if (!(map && map.mapService && map.mapService.staticScene_ && map.mapService.staticScene_.floors)) return;

        //清空之前的数据
        this.naviRcDB = new NaviMap();
        this.path = new NaviMap();
        this.m_RC_Result = [];

        var groups = map.mapService.staticScene_.floors;
        //      for(var i=0 in groups) {
        for (var i in groups) {
            var groupId = groups[i].gid;
            if (groupId == undefined) {
                continue;
            }

            var geo = groups[i].geo[0];
            var biz = groups[i].biz[0];
            var nav = groups[i].navi[0];
            var navi = this.naviService.convertToGroup__(groupId, geo, biz, nav);
            var nodes = [];
            for (var j in navi.naviNodes) {
                var node = navi.naviNodes[j];
                if (node.nodeId == undefined) {
                    continue;
                }
                nodes[j] = new NaviNode();
                nodes[j].m_Id = node.nodeId;
                nodes[j].m_Point = node.geoArr;
                nodes[j].setNodeType(node.nodeType);
                nodes[j].setLiftType(node.liftType);
                nodes[j].m_LiftId = node.liftFlag;
                nodes[j].setLiftEntry(node.liftEntry);

                nodes[j].m_SegLinks = node.linkSegArr;
                nodes[j].m_LiftFloors = node.liftFloorArr;
            }

            var roads = [];
            for (var k in navi.naviSegments) {
                var road = navi.naviSegments[k];
                var pnts = road.geoArr;
                if (!pnts) {
                    continue;
                }
                roads[k] = new NaviRoad();

                roads[k].m_Id = road.segmentId;
                roads[k].m_StartId = road.snode;
                roads[k].m_StartPoint = pnts[0];
                roads[k].m_EndId = road.enode;
                roads[k].m_EndPoint = pnts[1];
                roads[k].m_Length = road.length;
                roads[k].setRoadEntry(road.entry);
                roads[k].setRoadRank(road.rank);
            }

            var naviObsModels = [],
                naviObsExtents = [];
            for (var l = 0, len = navi.extentLayer.length; l < len; l++) {
                var extlayer = navi.extentLayer[l];
                var obs = new NaviObstruct();
                obs.o_Id = extlayer.eid;
                obs.o_Points = extlayer.geoArr;
                naviObsExtents.push(obs);
            }

            for (var m = 0, mlen = navi.modelLayer.length; m < mlen; m++) {
                var fmodellayer = navi.modelLayer[m];
                var obs = new NaviObstruct();
                obs.o_Id = fmodellayer.eid;
                obs.o_Fid = fmodellayer.fid;
                //--useless
                //obs.o_CenterPnt = fmodellayer.center;
                obs.o_Points = fmodellayer.geoArr;
                naviObsModels.push(obs);
            }

            var graph = new NaviGraph(nodes, roads, true, 1);
            if (naviObsModels.length > 0 && naviObsExtents.length > 0) {
                graph.obstructExtents = naviObsExtents;
                graph.obstructModels = naviObsModels;
            }
            this.naviRcDB.put(navi.gid, graph);
        }

        //更新扶梯关联楼梯id的代码，解决只走直梯不走扶梯的问题
        this.processFMNaviNode();

        //加入阻挡线数据
        // if (obstruct) {
        //     this.processFMNaviObstruct(obstruct);
        // }
    }

    //只读导航数据和地图数据无关的方法
    this.openNavi = function(sceneId) {

        var _this = this;
        this.naviService.queryScene(sceneId, function(scene) {
            //清空之前的数据
            this.naviRcDB = new NaviMap();
            this.path = new NaviMap();
            this.m_RC_Result = [];

            var groups = [];

            for (var i in scene.layerGroups) {
                var gid = scene.layerGroups[i].gid;
                if (gid == undefined) {
                    continue;
                }
                var gname = scene.layerGroups[i].gname;
                groups[i] = {
                    gid: gid
                };
            }

            for (var i in groups) {
                if (groups[i].gid == undefined) {
                    continue;
                }
                _this.naviService.queryNaviData(sceneId, groups[i].gid, function(navi) {

                    var nodes = [];
                    for (var j in navi.naviNodes) {
                        var node = navi.naviNodes[j];
                        if (node.nodeId == undefined) {
                            continue;
                        }
                        nodes[j] = new NaviNode();
                        nodes[j].m_Id = node.nodeId;
                        nodes[j].m_Point = node.geoArr;
                        nodes[j].setNodeType(node.nodeType);
                        nodes[j].setLiftType(node.liftType);
                        nodes[j].m_LiftId = node.liftFlag;
                        nodes[j].setLiftEntry(node.liftEntry);
                        nodes[j].m_SegLinks = node.linkSegArr;
                        nodes[j].m_LiftFloors = node.liftFloorArr;
                    }

                    var roads = [];
                    for (var k in navi.naviSegments) {
                        var road = navi.naviSegments[k];
                        if (road.snode == undefined) {
                            continue;
                        }
                        var pnts = road.geoArr;
                        roads[k] = new NaviRoad();

                        roads[k].m_Id = navi.m_Id;
                        roads[k].m_StartId = road.snode;
                        roads[k].m_StartPoint = pnts[0];
                        roads[k].m_EndId = road.enode;
                        roads[k].m_EndPoint = pnts[1];
                        roads[k].m_Length = road.length;
                        roads[k].setRoadEntry(road.entry);
                        roads[k].setRoadRank(road.rank);
                    }

                    var naviObsModels = [],
                        naviObsExtents = [];
                    for (var l = 0, len = navi.extentLayer.length; l < len; l++) {
                        var extlayer = navi.extentLayer[l];
                        var obs = new NaviObstruct();
                        obs.o_Id = extlayer.eid;
                        obs.o_Points = extlayer.geoArr;
                        naviObsExtents.push(obs);
                    }

                    for (var m = 0, mlen = navi.modelLayer.length; m < mlen; m++) {
                        var fmodellayer = navi.modelLayer[m];
                        var obs = new NaviObstruct();
                        obs.o_Id = fmodellayer.eid;
                        obs.o_Fid = fmodellayer.fid;
                        //--useless
                        //obs.o_CenterPnt = fmodellayer.center;
                        obs.o_Points = fmodellayer.geoArr;
                        naviObsModels.push(obs);
                    }

                    var graph = new NaviGraph(nodes, roads, true, 1);
                    if (naviObsModels.length > 0 && naviObsExtents.length > 0) {
                        graph.obstructExtents = naviObsExtents;
                        graph.obstructModels = naviObsModels;
                    }
                    _this.naviRcDB.put(navi.gid, graph);

                    //在循环楼层结束的时候调用
                    if (groups[i].gid == groups.length) {
                        //更新扶梯关联楼梯id的代码，解决只走直梯不走扶梯的问题
                        this.processFMNaviNode();
                    }
                });
            }
        });
    }

    this.reset = function() {
        this.path.clear();
        //this.pathTail.clear();
    }

    //重新为扶梯赋值关联楼层
    this.processFMNaviNode = function() {
        if (this.naviRcDB.size() <= 0) return;

        var flagGIDS = {};
        this.naviRcDB.each(function(i, graph) {
            var nodes = [];
            graph.QueryLiftNodesByType(NaviLiftType_Escalator, nodes);

            for (var j in nodes) {
                var node = nodes[j];

                if (!node.getLiftFlagId()) {
                    continue;
                }

                var flag = node.getLiftFlagId() % 100;
                if (!flagGIDS[flag]) {
                    flagGIDS[flag] = node.m_LiftFloors;
                } else {
                    flagGIDS[flag] = flagGIDS[flag].concat(node.m_LiftFloors);
                }
            }
        });

        this.naviRcDB.each(function(i, graph) {

            var nodes = [];
            graph.QueryLiftNodesByType(NaviLiftType_Escalator, nodes);

            for (var m in nodes) {
                var node = nodes[m];
                if (!node.getLiftFlagId) {
                    continue;
                }
                var flag = node.getLiftFlagId() % 100;

                if (flagGIDS[flag]) {
                    node.m_LiftFloors = flagGIDS[flag];
                }
            }
        });
    }

    this.processFMNaviObstruct = function(obstruct){

        var groupObstructIndices = [];
        var groupID = 0;
        var obstructLines = obstruct.obstructlines;

        for (var i = 0; i < obstructLines.length; i++) {
            if(typeof obstructLines[i].groupID != 'number')
                continue;

            groupID = obstructLines[i].groupID;
            if (typeof groupObstructIndices[groupID] == 'undefined') {
                groupObstructIndices[groupID] = [];
            }
            groupObstructIndices[groupID].push(i);
        }

        for (var i = 0; i < this.naviRcDB.keys.length; i++) {

            groupID = this.naviRcDB.keys[i];

            if (typeof groupObstructIndices[groupID] == 'undefined') 
                continue;

            if (groupObstructIndices[groupID].length == 0)
                continue;

            var naviGraph = this.naviRcDB.get(groupID);

            var index = -1;
            for (var j = 0; j < groupObstructIndices[groupID].length; j++) {

                index = groupObstructIndices[groupID][j];
                var naviObstructLine  = new NaviObstructLine();
                naviObstructLine.initByJson(obstructLines[index]);
                naviGraph.obstructLines.push(naviObstructLine);
            }
        }
    }

    // 初始化起点、终点到其他点的最短距离
    this.InitPath = function(graph) {
        var nodes = graph.nodeVector;
        for (var i = 0; i < nodes.length; i++) {
            var v = nodes[i];
            // 正向
            if (!v.equals(this.m_Start.m_Node)) {
                var info = new NaviInformation;
                info._curNode = v;
                info._weight = this.getWeight(graph, this.m_Start.m_Node, v);
                info._list.push(this.m_Start.m_Node);
                this.path.put(v.m_Id, info);
            }

            //          if (!v->equals(m_End.m_Node))
            //          {
            //              NaviInformation info;
            //              info._curNode = v;
            //              info._weight = getWeight(graph, this.m_End.m_Node, v);
            //              info._list.push_back(m_End.m_Node);
            //
            //              std::pair<int, Information> m(v->getId(), info);
            //              this.pathTail.insert(m);
            //          }
        }
        return true;
    }

    this.getMinWeightNodeFromHead = function(graph, start) {
        var weight = ERROR_WEIGHT;

        var node = null;
        for (var i = 0; i < graph.nodeVector.length; i++) {
            if (!graph.nodeVector[i].equals(start) && !graph.nodeVector[i]._treatHead) {
                var info = this.path.get(graph.nodeVector[i].getId());
                if (info._weight < weight) {
                    weight = info._weight;
                    node = graph.nodeVector[i];
                };
            }
        };

        if (node)
            node._treatHead = true;

        return node;
    }

    // 得到任意两点之间的权重
    this.getWeight = function(graph, start, end) {

        if (typeof graph.vertexLen[start.getId()] == 'undefined') {
            return ERROR_WEIGHT;
        }

        if (typeof graph.vertexLen[start.getId()][end.getId()] == 'undefined') {
            return ERROR_WEIGHT;
        }

        return graph.vertexLen[start.getId()][end.getId()];
    }

    //int groupId, int flag, Node **node
    this.getLiftNodeInBuilding = function(groupId, flag, node) {
        if (this.naviRcDB.length == 0) {
            return false;
        }
        var gra = this.naviRcDB.get(groupId);
        if (gra.invalide()) {
            return -1;
        }

        if (gra.QueryLiftNodeByFLAGID(flag, node)) {
            return true;
        }
        return false;
    }

    // 返回同一个梯的另一端的Node点
    //int groupId, int flag, Node **node
    this.getLiftNodeInBuilding = function(groupId, flag, node) {
        if (this.naviRcDB.size() == 0) {
            return false;
        }
        var gra = this.naviRcDB.get(groupId);
        if (gra.invalide()) {
            return -1;
        }

        if (gra.QueryLiftNodeByFLAGID(flag, node)) {
            return true;
        }
        return false;
    }

    //int groupId,int accessGroupId, fengmap.FMMapCoord point, Node** snode,Node** enode
    this.getLiftNearestAccessNodesInBuilding = function(groupId, accessGroupId, point, snode, enode) {
        if (this.naviRcDB.size() == 0)
            return false;

        var gras = this.naviRcDB.get(groupId);
        if (gras.invalide())
            return false;

        var grae = this.naviRcDB.get(accessGroupId);
        if (grae.invalide())
            return false;

        var sNodeVector = [];
        sNodeVector = gras.QuerySameExtentLiftNodesByGeoPoint(point, accessGroupId, sNodeVector);
        if (sNodeVector.length == 0)
            return false;

        var result = false;
        for (var i = 0; i < sNodeVector.length; i++) {
            snode.setNode(sNodeVector[i]);
            result = grae.QueryLiftNodeByFLAGID(snode.getLiftFlagId(), enode);
            if (result)
                break;
        }

        return result;
    }

    this.getLiftAccessNodesInBuilding = function(groupId, accessGroupId, point, snodes, enodes, priority) {
        if (this.naviRcDB.size() == 0)
            return false;
        var graph = this.naviRcDB.get(groupId);
        if (graph.invalide())
            return false;

        var grae = this.naviRcDB.get(accessGroupId);
        if (grae.invalide())
            return false;

        var sNodeVector = new Array(),
            sDistance = new Array();
        graph.QuerySameExtentLiftNodesByGeoPoint(point, accessGroupId, sNodeVector, sDistance);
        if (sNodeVector.length == 0) return false;

        liftNodeSort(sNodeVector, sDistance, priority);

        for (var i = 0; i < sNodeVector.length; i++) {
            var snode = sNodeVector[i];
            var enode = new NaviNode();
            var result = grae.QueryLiftNodeByFLAGID(snode.getLiftFlagId(), enode);
            if (result) {
                snodes.push(snode);
                enodes.push(enode);
            }
        }

        if (snodes.length == 0)
            return false;

        return true;

    }

    this.getLiftAccessNodesInBuilding_End = function(groupId, accessGroupId, point,endPoint, snodes, enodes, priority) {
        if (this.naviRcDB.size() == 0)
            return false;
        var graph = this.naviRcDB.get(groupId);
        if (graph.invalide())
            return false;

        var grae = this.naviRcDB.get(accessGroupId);
        if (grae.invalide())
            return false;

        var sNodeVector = new Array(),
            sDistance = new Array();
        graph.QuerySameExtentLiftNodesByGeoPoint(point, accessGroupId, sNodeVector, sDistance);
        if (sNodeVector.length == 0) return false;

        var vecDistEnd = [];
        for (var i = 0; i < sNodeVector.length; i++) {
            var snode = sNodeVector[i];
            var enode = new NaviNode();
            var result = grae.QueryLiftNodeByFLAGID(snode.getLiftFlagId(), enode);
            if (result) {
                var currDist = DistanceofTwoPts(enode.m_Point,endPoint)
                vecDistEnd.push(currDist);
                snodes.push(snode);
                enodes.push(enode);
            }
        }

        liftNodeSort(snodes, vecDistEnd, priority);

        if (snodes.length == 0)
            return false;

        return true;

    }

    this.getLiftAccessNodesInBuilding_StartEnd = function(groupId, accessGroupId, point,endPoint, snodes, enodes, priority) {
        if (this.naviRcDB.size() == 0)
            return false;
        var graph = this.naviRcDB.get(groupId);
        if (graph.invalide())
            return false;

        var grae = this.naviRcDB.get(accessGroupId);
        if (grae.invalide())
            return false;

        var sNodeVector = new Array(),
            sDistance = new Array();
        graph.QuerySameExtentLiftNodesByGeoPoint(point, accessGroupId, sNodeVector, sDistance);
        if (sNodeVector.length == 0) return false;

        var vecDistTotal = [];        

        for (var i = 0; i < sNodeVector.length; i++) {
            var snode = sNodeVector[i];
            var currDist = sDistance[i];
            var enode = new NaviNode();
            var result = grae.QueryLiftNodeByFLAGID(snode.getLiftFlagId(), enode);
            if (result) {
                currDist += DistanceofTwoPts(enode.m_Point,endPoint);
                vecDistTotal.push(currDist);
                snodes.push(snode);
                enodes.push(enode);
            }
        }

        liftNodeSort(snodes, vecDistTotal, priority);

        if (snodes.length == 0)
            return false;

        return true;

    }

    this.getRealLiftAccessNodesInBuilding = function(groupId, accessGroupId, point, snodes, enodes, priority) {
        if (this.naviRcDB.size() == 0)
            return false;
        var graph = this.naviRcDB.get(groupId);
        if (graph.invalide())
            return false;

        var grae = this.naviRcDB.get(accessGroupId);
        if (grae.invalide())
            return false;

        var sNodeVector = new Array(),
            sDistance = new Array();
        graph.QuerySameExtentLiftNodesByGeoPoint(point, accessGroupId, sNodeVector, sDistance);
        if (sNodeVector.length == 0) return false;

        liftNodeSort(sNodeVector, sDistance, priority);

        for (var i = 0; i < sNodeVector.length; i++) {
            var snode = sNodeVector[i];
            var enode = new NaviNode();
            var result = grae.QueryLiftNodeByFLAGID(snode.getLiftFlagId(), enode);
            if (result) {
                snodes.push(snode);
                enodes.push(enode);
            }
        }

        if (snodes.length == 0)
            return false;

        return true;

    }

    //double &length, std::vector<Node> &nodeVector
    // this.FMRC_GetRouteCalculateNodes = function(length, nodeVector) {
    this.FMRC_GetRouteCalculateNodes = function(result) {
        var info = this.path.get(this.m_End.m_Node.getId());
        result.length = info._weight;
        for (var i = 0; i < info._list.length; i++) {
            result.nodeVector[i] = info._list[i];
        };

        if (this.m_End.m_Node.getId() != result.nodeVector[result.nodeVector.length - 1].getId()) {
            result.nodeVector.push(this.m_EndNode);
        }
        return true;
    }

    //std::vector<fengmap.FMMapCoord> &ptVector, int flag
    this.FMRC_GetRouteCalculateGeoPoints = function(ptVector, flag) {

        var needStart = true;
        var needEnd = true;
        var tmpVector = [];

        var info = this.path.get(this.m_End.m_Node.getId());
        var nodeVector = info._list;
        for (var i = 0; i < nodeVector.length; i++) {
            tmpVector[i] = new fengmap.FMMapCoord();
            tmpVector[i].setGeoPoint(nodeVector[i].getGeoPoint());
        };

        if (this.m_End.m_Node.getId() != nodeVector[nodeVector.length - 1].getId()) {
            tmpVector.push(new fengmap.FMMapCoord());
            tmpVector[tmpVector.length-1].setGeoPoint(this.m_End.m_Node.getGeoPoint());
        }

        if (flag == 0) {
            // 同层路径搜索
            var tmpPt = new fengmap.FMMapCoord();
            pt_distance_to_line(this.m_Start.m_Point, tmpVector[0], tmpVector[1], tmpPt);
            if (is_nearlysame_pt(this.m_Start.m_CrossPt, tmpPt)) {
                needStart = false; // 起点不用添加
            }   
            var tmpPt2 = new fengmap.FMMapCoord();
            pt_distance_to_line(this.m_End.m_Point, tmpVector[tmpVector.length - 1], tmpVector[tmpVector.length - 2], tmpPt2);
            if (is_nearlysame_pt(this.m_End.m_CrossPt, tmpPt2)) {
                needEnd = false; // 终点不用添加
            }

            var index = 0;
            //加入起点
            if (DistanceofTwoPts(this.m_Start.m_CrossPt, this.m_Start.m_Point) > this.minDistance) {
                ptVector[index] = new fengmap.FMMapCoord();
                ptVector[index].setGeoPoint(this.m_Start.m_Point);
                index++;
            }

            //加入起点交点
            ptVector[index] = new fengmap.FMMapCoord();
            ptVector[index].setGeoPoint(this.m_Start.m_CrossPt);
            index++;

            for (var i = 0; i < tmpVector.length; i++) {

                if (i==0) {
                    if (needStart) {
                        ptVector[index] = new fengmap.FMMapCoord();
                        ptVector[index].setGeoPoint(tmpVector[i]);
                        index++;
                    }

                } else if (i==(tmpVector.length-1)) {
                    if (needEnd) { 
                        ptVector[index] = new fengmap.FMMapCoord();
                        ptVector[index].setGeoPoint(tmpVector[i]);
                        index++;
                    }
                } else {
                    ptVector[index] = new fengmap.FMMapCoord();
                    ptVector[index].setGeoPoint(tmpVector[i]);
                    index++;
                }
            }

            //加入交点
            ptVector[index] = new fengmap.FMMapCoord;
            ptVector[index].setGeoPoint(this.m_End.m_CrossPt); // 终点的垂点
            index++;

            //加入终点
            if (DistanceofTwoPts(this.m_End.m_CrossPt, this.m_End.m_Point) > this.minDistance) {
                ptVector[index] = new fengmap.FMMapCoord();
                ptVector[index].setGeoPoint(this.m_End.m_Point);
                index++;
            }

        } else if (flag == 1) {

            var index = 0;
            //加入起点
            if (DistanceofTwoPts(this.m_Start.m_CrossPt, this.m_Start.m_Point) > this.minDistance) {
                ptVector[index] = new fengmap.FMMapCoord();
                ptVector[index].setGeoPoint(this.m_Start.m_Point);
                index++;
            }

            //加入起点交点
            ptVector[index] = new fengmap.FMMapCoord();
            ptVector[index].setGeoPoint(this.m_Start.m_CrossPt);
            index++;

            var tmpPt = new fengmap.FMMapCoord();
            pt_distance_to_line(this.m_Start.m_Point, tmpVector[0], tmpVector[1], tmpPt);
            if (is_nearlysame_pt(this.m_Start.m_CrossPt, tmpPt)) {
                needStart = false; // 起点不用添加
            }  

            for (var i = 0; i < tmpVector.length; i++) {
                if (i == 0) {
                    if (needStart) {
                        ptVector[index] = new fengmap.FMMapCoord();
                        ptVector[index].setGeoPoint(tmpVector[i]);
                        index++;
                    }

                } else {
                    ptVector[index] = new fengmap.FMMapCoord();
                    ptVector[index].setGeoPoint(tmpVector[i]);
                    index++;
                }
            }
        } else if (flag == 2) {

            var tmpPt2 = new fengmap.FMMapCoord();
            pt_distance_to_line(this.m_End.m_Point, tmpVector[tmpVector.length - 1], tmpVector[tmpVector.length - 2], tmpPt2);
            if (is_nearlysame_pt(this.m_End.m_CrossPt, tmpPt2)) {
                needEnd = false; // 终点不用添加
            }

            var index = 0;
            for (var i = 0; i < tmpVector.length; i++) {
                if ((i == tmpVector.length - 1)) {
                    if (needEnd) {
                        ptVector[index] = new fengmap.FMMapCoord();
                        ptVector[index].setGeoPoint(tmpVector[i]);
                        index++;
                    }

                } else {
                    ptVector[index] = new fengmap.FMMapCoord();
                    ptVector[index].setGeoPoint(tmpVector[i]);
                    index++;
                }
            }

            //加入交点
            ptVector[index] = new fengmap.FMMapCoord;
            ptVector[index].setGeoPoint(this.m_End.m_CrossPt);
            index++;

            //加入终点
            if (DistanceofTwoPts(this.m_End.m_CrossPt, this.m_End.m_Point) > this.minDistance) {
                ptVector[index] = new fengmap.FMMapCoord();
                ptVector[index].setGeoPoint(this.m_End.m_Point);
                index++;
            }

        } else if (flag == 3) {
            // 不用处理
            var nodeVector = info._list;
            // 如果最后一个点不是endNode，则添加
            for (var i = 0; i < nodeVector.length; i++) {
                ptVector[i] = new fengmap.FMMapCoord();
                ptVector[i].setGeoPoint(nodeVector[i].getGeoPoint());
            }
        } else {
            return false;
        }

        return true;
    }

    //int groupId, std::vector<fengmap.FMMapCoord> &ptVector
    this.FMRC_GetSpanRouteCalculateGeoPoints = function(groupId, ptVector) {
        if (this.m_RC_Result.length == 0) {
            return false;
        }

        for (var i = 0; i < this.m_RC_Result.length; i++) {
            var res = this.m_RC_Result[i];
            if (res.groupId == groupId) {
                ptVector = res.pointVector;
                return true;
            };
        };

        return false;
    }

    //std::vector<int>& groups
    this.FMRC_GetRouteCalculateGroups = function(groups) {
        if (this.m_RC_Result.length == 0) {
            return false;
        }

        for (var i = 0; i < this.m_RC_Result.length; i++) {
            groups[i] = this.m_RC_Result[i].groupId;
        };
        return true;
    }

    this.FMRC_GetRouteCalculateAllLength = function(length) {
        length = 0;
        if (this.m_RC_Result.length == 0) {
            return false;
        }

        for (var i = 0; i < this.m_RC_Result.length; i++) {
            length += this.m_RC_Result[i].length;
        };
        return true;
    }

    this.FMRC_GetRouteCalculateResult = function() {
        return this.m_RC_Result;
    }

    this.getLiftNodeByFlagInArray = function(nodes, flag) {

        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].getLiftFlagId() % 100 == flag % 100)
                return nodes[i];
        }

        return null;
    }

    this.getElementIndex = function(array, ele) {

        for (var i = 0; i < array.length; i++) {
            if (ele.m_GID == array[i].m_GID && ele.m_EID == array[i].m_EID) {
                return i;
            }
        }

        return -1;
    }

    // 计算Extent之间所有可以通行的梯类集合
    this.calcExtentLifts = function(startGroupID, startPt, endGroupID, endExtentID, setting, startLifts, endLifts) {
        var startGraph = this.naviRcDB.get(startGroupID);
        if (startGraph == null) {
            return false;
        }

        var endGraph = this.naviRcDB.get(endGroupID);
        if (endGraph == null) {
            return false;
        }

        // 计算楼层间可以通行的所有梯类点
        var startNodes = new Array();
        var endNodes = new Array();
        if (!this.getLiftAccessNodesInBuilding(startGroupID, endGroupID, startPt, startNodes, endNodes, setting._cgp)) {
            return false;
        }

        // 依次判断梯类点通行属性和所在Extent
        var startLiftSize = startNodes.length;
        for (var i = 0; i < startLiftSize; ++i) {
            var t_startNode = startNodes[i];

            var startEntryType = t_startNode.getLiftEntry();
            if (3 == startEntryType ||
                (1 == startEntryType && startGroupID > endGroupID) ||
                (2 == startEntryType && startGroupID < endGroupID)) {
                continue;
            }

            var startLiftFlag = t_startNode.getLiftFlagId();

            // 查找同一梯类对应终点层结点
            var t_endNode = this.getLiftNodeByFlagInArray(endNodes, startLiftFlag);
            if (t_endNode == null) {
                continue;
            }

            if (endExtentID != endGraph.QueryContainExtentId(t_endNode.m_Point)) {
                continue;
            }

            startLifts.push(t_startNode);
            endLifts.push(t_endNode);
        }

        return startLifts.length != 0;
    }

    // 按照与指定点的距离对结点排序
    this.sortNodesByDist = function(point, lifts,priority){

        var size = lifts.length;
        var dists = [];
        
        for (var i = 0; i < size; i++){

            dists[i] = DistanceofTwoPts(point, lifts[i].m_Point);
        }
        
        liftNodeSort(lifts, dists ,priority);
    }

    //计算通行轮廓-新增
    this.calRouteLine = function(startGroupID, endGroupID, startExtentID, endExtentID, startPara, endPara, setting) {
        // 重新构图
        // 提取所有Extent
        var startIdx = -1;
        var endIdx = -1;
        var key = -1;
        var allExtentPt = [];

        for (var navikey in this.naviRcDB.keys) {
            var currGID = this.naviRcDB.keys[navikey];
            var currGraph = this.naviRcDB.get(currGID);

            //Extents
            var currExtents = currGraph.obstructExtents;

            for (var extIndex in currExtents) {
                var extent = currExtents[extIndex];
                ++key;
                var currEID = extent.o_Id;

                if (extent.o_Points.length <= 0) {
                    continue;
                }

                var ptExtent = getPolygonInnerPt(extent.o_Points);

                allExtentPt.push(new tagExtentPt(currGID, currEID, ptExtent))
                if (startGroupID == currGID && startExtentID == currEID) {
                    startIdx = key;
                }

                if (endGroupID == currGID && endExtentID == currEID) {
                    endIdx = key;
                }

            }
        }

        // 初始化图
        var newGraph = new Graph(allExtentPt);

        // 计算权值
        var size = allExtentPt.length;
        var vExtentLift = [];
        for (var i = 0; i < size * size; i++) {
            vExtentLift[i] = null;
        }

        for (var currIdx = 0; currIdx < size; currIdx++) {
            /*if(currIdx == 5 || currIdx == 7 ) {
                debugger;
            }*/
            var currExtentPt = allExtentPt[currIdx];
            var currGID = currExtentPt.m_GID;
            var currEID = currExtentPt.m_EID;

            var currPara = new FMRC_Para();
            currPara.m_GroupId = currGID;
            if (currIdx == startIdx) {
                currPara.m_Point = startPara.m_Point;
            } else if (currIdx == endIdx) {
                currPara.m_Point = endPara.m_Point;
            } else {
                var currGraph = this.naviRcDB.get(currGID);
                if (!currGraph) {
                    currPara.m_Point = currExtentPt.m_pt;
                } else {
                    var posCurrExtent = null;
                    for (var index = 0, plen = currGraph.obstructExtents.length; index < plen; index++) {
                        if (currGraph.obstructExtents[index].o_Id == currEID) {
                            posCurrExtent = currGraph.obstructExtents[index];
                            break;
                        }
                    }
                    if (!posCurrExtent) {
                        return null;
                    }

                    // 判断点是否在Extent中
                    if (isInPolygon(startPara.m_Point, posCurrExtent.o_Points)) {
                        currPara.m_Point = startPara.m_Point;
                    } else if (isInPolygon(endPara.m_Point, posCurrExtent.o_Points)) {
                        currPara.m_Point = endPara.m_Point;
                    } else {
                        currPara.m_Point = currExtentPt.m_pt;
                    }
                }
            }

            for (var nextIdx = 0; nextIdx < size; nextIdx++) {
                /*if(nextIdx == 3) {
                    debugger;
                }*/
                var nextExtentPt = allExtentPt[nextIdx];
                var nextGID = nextExtentPt.m_GID;
                var nextEID = nextExtentPt.m_EID;

                if (currGID == nextGID) {
                    if (currEID == nextEID) {
                        newGraph.m_matrix[currIdx][nextIdx] = 0;
                    }

                    continue;
                }

                // 计算邻接矩阵，保存通行梯类
                var startLifts = [];
                var endLifts = [];
                if (this.calcExtentLifts(currGID, currPara.m_Point, nextGID, nextEID, setting,
                        startLifts, endLifts)) {
                    newGraph.m_matrix[currIdx][nextIdx] = Math.abs(currGID - nextGID);

                    var currLift = new tagExtentLift();
                    currLift.init(currGID, currEID, nextGID, nextEID, startLifts, endLifts);
                    vExtentLift[currIdx * size + nextIdx] = currLift;
                }
            }
        }

        // 计算最短路径
        var shortestPath = new Array();
        var vecShortestPath = calShortestPath(newGraph, startIdx, endIdx, shortestPath);
        if (vecShortestPath == null) {
            return null;
        }

        //提取路径数据
        if (shortestPath.length == 0) {
            return null;
        }


        // 提取路径数据，计算引导线
        var minPathLength = 0;
        var shortestPathSize = vecShortestPath.length;
        for (var i = 0; i < shortestPathSize; i++)
        {   
            if (i==0) {
                minPathLength = vecShortestPath[i].length;
                continue;
            }
            
            if (vecShortestPath[i].length < minPathLength)
            {
                minPathLength = vecShortestPath[i].length;
            }
        }
        
        var t_vecShortestPath = [];
        for (var i = 0; i < shortestPathSize; i++)
        {
            var shortPath = vecShortestPath[i];
            if (shortPath.length == minPathLength)
            {
                t_vecShortestPath.push(shortPath);
            }
        }

        var t_vOutLine = [];
        for (var i = 0; i < t_vecShortestPath.length; i++) {
            var ele = t_vecShortestPath[i];
            if (ele.length == 0) {
                continue;
            }

            var tempOutLine = null;

            var ptFrom = ele[0];
            var idxFrom = this.getElementIndex(allExtentPt, ptFrom);
            if (idxFrom == -1) {
                return null;
            }

            var t_startGID = startGroupID;
            var startGraph = this.naviRcDB.get(t_startGID);

            var t_startPt = startPara.m_Point;
            var t_startNode = new NaviNode;
            var t_startRoad = new NaviRoad;
            var t_startCross = new fengmap.FMMapCoord;
            if (!startGraph.QueryNearestSameExtentElementByGeoPoint(t_startPt, t_startRoad, t_startNode, t_startCross)) {
                return null;
            }

            var flag1 = false;
            var sizePath = ele.length;
            // 记录引导线的终点
            var recordingEndPt;

            for (var idx = 1; idx < sizePath; ++idx) {
                var ptTo = ele[idx];
                var idxTo = this.getElementIndex(allExtentPt, ptTo);
                if (-1 == idxTo) {
                    return null;
                }

                var t_endGID = ptTo.m_GID;
                startGraph = this.naviRcDB.get(t_startGID);

                var t_endPt;
                var t_endCross;
                var t_endNode = null;
                var t_endRoad = null;

                var currLifts = vExtentLift[idxFrom * size + idxTo];
                if (currLifts == null) {
                    break;
                }

                var startLifts = currLifts.m_startLifts;
                var endLifts = currLifts.m_endLifts;

                var startLiftSize = startLifts.length;

                var recordingStartPt = null;
                if (1 == idx)
                {
                    recordingStartPt = startPara.m_Point;
                }
                else
                {
                    recordingStartPt = recordingEndPt;
                }
                
                // 按照与引导线起点的距离对梯类排序
                this.sortNodesByDist(recordingStartPt, startLifts,setting._cgp);

                var flag2 = false;
                for (var j = 0; j < startLiftSize; j++) {

                    var startLift = startLifts[j];
                    var endLift = null;

                    for (var k= 0; k < endLifts.length; k++) {
                        if (endLifts[k].m_LiftId == startLift.m_LiftId) {
                            endLift = endLifts[k];
                            break;
                        }
                    }
                    if (endLift == null) {
                        continue;
                    }

                    // 判断同层是否可以通行
                    if (!startGraph.nodesAccess(t_startNode, startLift)) {
                        continue;
                    }


                    flag2 = true;

                    t_endNode = endLift;
                    t_endPt = endLift.m_Point;
                    t_endCross = t_endPt;

                    // 保存引导线
                    var t_outLine = new RouteOutline();
                    t_outLine.init(t_startGID, t_endGID, startLift, endLift, t_startPt, t_endPt);
                    if (tempOutLine == null) {
                        tempOutLine = [];

                    }
                    tempOutLine.push(t_outLine);

                    // 记录引导线的终点
                    recordingEndPt = t_outLine.Nodeto.m_Point;
                    break;
                }

                if (!flag2) {
                    tempOutLine = null;
                    break;
                }

                t_startGID = t_endGID;
                t_startNode = t_endNode;
                t_startRoad = t_endRoad;
                t_startPt = t_endPt;
                t_startCross = t_endCross;

                idxFrom = idxTo;
            }

            // 判断最后一层梯类与终点是否可以通行

            var endGraph = this.naviRcDB.get(endGroupID);
            if (!endGraph.nodesAccess(t_startNode, endPara.m_Node)) {
                tempOutLine = null;
                continue;
            }
            
            if (tempOutLine != null) {
                t_vOutLine.push(tempOutLine);
            }
        }

        var shortIndex = -1;
        var shortLength = 0;
        for (var i = 0; i < t_vOutLine.length; i++) {
            
            var t_outLine = t_vOutLine[i];
            if (t_outLine.length == 0) {
                continue;
            }

            var t_line = t_outLine[0];
            var t_line1 = null;
            var length = DistanceofTwoPts(startPara.m_Point, t_line.Nodefrom.m_Point);

            for (var j = 0; j < t_outLine.length-1; j++) {

                t_line = t_outLine[j];
                t_line1 = t_outLine[j+1];
                length += DistanceofTwoPts(t_line.Nodeto.m_Point, t_line1.Nodefrom.m_Point);
            }
            if (t_line1 != null) {
                length += DistanceofTwoPts(t_line1.Nodeto.m_Point, endPara.m_Point);
            }else{
                length += DistanceofTwoPts(t_line.Nodeto.m_Point, endPara.m_Point);
            }
            
            if (shortIndex == -1) {
                shortIndex = i;
                shortLength = length;
            }else{
                if (length < shortLength) {
                    shortIndex = i;
                    shortLength = length;
                }
            }
        }

        if (shortIndex == -1) {
            return null;
        }

        return t_vOutLine[shortIndex];
    }

    //Graph *graph, Node *start, Node *end)
    this.RouteCalculate = function(graph, start, end) {
        var result = false;
        this.m_Start.m_Node = start;
        this.m_End.m_Node = end;
        this.reset();
        // 初始化从源点到其他点的距离
        this.InitPath(graph);

        var node;
        //var times = 0;
        // 循环查找
        while (isNotAllPathinvalide(this.path)) {
            var info = null;
            //times++;

            // 起点查找
            var node = this.getMinWeightNodeFromHead(graph, start);
            if (node == null)
                break;

            if (!node.equals(end) && !(node._treatTail)) {
                // 没有找到
                info = this.path.get(node.getId());
                var tempWeight = info._weight;

                for (var i = 0; i < graph.nodeVector.length; i++) {
                    var v = graph.nodeVector[i];

                    if (v.equals(start) || v.equals(node) || v._treatHead == true) {
                        continue;
                    } else {
                        info = this.path.get(v.getId());
                        if ((tempWeight + this.getWeight(graph, node, v)) < info._weight) {
                            info._weight = tempWeight + this.getWeight(graph, node, v);
                            info.clearList();
                            var pathData = this.path.get(node.getId())._list;
                            for (var m = 0; m < pathData.length; m++) {
                                info._list.push(pathData[m]);
                            };
                            info._list.push(node);
                            //Map
                            this.path.put(v.getId(), info);
                        }
                    }
                }
            } else {
                result = true;
                break;
            }
        }
        return result;
    }

    // 同group路线计算
    //int groupId, fengmap.FMMapCoord startPoint, fengmap.FMMapCoord endPoint, FMRC_RouteCalcuModule module
    this.FMRC_RouteCalculate = function(groupId, startPoint, endPoint, module) {
        this.m_RC_Result = [];
        this.reset();
        // 设置起点与终点坐标
        this.m_Start.m_Point = startPoint;
        this.m_Start.m_GroupId = groupId;
        this.m_End.m_Point = endPoint;
        this.m_End.m_GroupId = groupId;

        // step1: 检查navi数据的完整性
        if (this.naviRcDB.size() == 0) {
            // 没有初始化FMDBKernel指针
            return ROUTE_FAILED_NO_FMDBDATA;
        }

        var curentGraph = this.naviRcDB.get(groupId);
        if (curentGraph.invalide()) {
            return ROUTE_FAILED_NO_DATA_START;
        } else {
            curentGraph.initVertexLen(module);
        }

        // step2: 绑定起(终)点坐标到对应的路段和节点
        if (false == curentGraph.QueryNearestSameExtentElementByGeoPoint(startPoint, this.m_Start.m_Road, this.m_Start.m_Node, this.m_Start.m_CrossPt)) {
            curentGraph.reset();
            return ROUTE_FAILED_NO_DATA_START;
        }
        if (false == curentGraph.QueryNearestSameExtentElementByGeoPoint(endPoint, this.m_End.m_Road, this.m_End.m_Node, this.m_End.m_CrossPt)) {
            curentGraph.reset();
            return ROUTE_FAILED_NO_DATA_END;
        }
        // 同一个group内路线计算
        if (this.m_Start.m_Node.getId() != this.m_End.m_Node.getId()) {
            if (!this.RouteCalculate(curentGraph, this.m_Start.m_Node, this.m_End.m_Node)) {
                curentGraph.reset();
                return ROUTE_FAILED_CANNOT_ARRIVE;
            }
        } else {

            var result = new FMRC_Result();
            result.groupId = groupId;
            result.nodeVector.push(this.m_Start.m_Node);

            result.pointVector.push(this.m_Start.m_Point);
            if (this.m_Start.m_Road.m_Id == this.m_End.m_Road.m_Id) {
                result.length = DistanceofTwoPts(this.m_Start.m_CrossPt, this.m_End.m_CrossPt);
                result.pointVector.push(this.m_Start.m_CrossPt);
                result.pointVector.push(this.m_End.m_CrossPt);
            } else {
                result.length = DistanceofTwoPts(this.m_Start.m_CrossPt, this.m_Start.m_Node.getGeoPoint());
                result.length += DistanceofTwoPts(this.m_Start.m_Node.getGeoPoint(), this.m_End.m_CrossPt);

                result.pointVector.push(this.m_Start.m_CrossPt);
                result.pointVector.push(this.m_Start.m_Node.getGeoPoint());
                result.pointVector.push(this.m_End.m_CrossPt);
            }
            result.pointVector.push(this.m_End.m_Point);

            this.m_RC_Result.push(result);
            return ROUTE_SUCCESS;
        }

        curentGraph.reset();
        return ROUTE_SUCCESS;
    }

    this.IsSameExtent = function(start, end, snode, enode, spoint, epoint, type) {
        if (type == 1 || type == 3) {
            if (start && (isPointInSameExtent(start, snode.m_Point, spoint) == 0))
                return 0;
        }


        if (type == 2 || type == 3) {
            if (end && (isPointInSameExtent(end, enode.m_Point, epoint) == 0))
                return 0;
        }

        return 1;
    }

    this.CalcSameGraphOutline = function(start, end, outLine, setting) {
        var graph = this.naviRcDB.get(start.m_GroupId);
        if (!graph)
            return false;

        if (isPointInSameExtent(graph, start.m_Point, end.m_Point)) {
            var subOutLine = new RouteOutline();
            subOutLine.Idfrom = start.m_GroupId;
            subOutLine.Idto = end.m_GroupId;
            subOutLine.Nodefrom.setNode(start.m_Node);
            subOutLine.Nodeto.setNode(end.m_Node);
            subOutLine.Geofrom = start.m_Point;
            subOutLine.Geoto = end.m_Point;
            outLine.push(subOutLine);

            return true;
        }

        return false;
    }


    this.CalcDifferentGraphOutline = function(start, end, routeList, setting, isSameExtentType) {
        var snodes = new Array();
        var enodes = new Array();

        var startGraph = this.naviRcDB.get(start.m_GroupId);
        if (!startGraph)
            return false;

        var endGraph = this.naviRcDB.get(end.m_GroupId);
        if (!endGraph)
            return false;

        if (this.getLiftAccessNodesInBuilding(start.m_GroupId, end.m_GroupId, start.m_Point, snodes, enodes, setting._cgp)) {
            for (var i = 0, ilen = snodes.length; i < ilen; i++) {
                var snode = snodes[i];

                /******判断当前梯类是否可以通行********************/
                if (snode.getLiftEntry() == 3 || (snode.getLiftEntry() == 1 && start.m_GroupId > end.m_GroupId) || (snode.getLiftEntry() == 2 && start.m_GroupId < end.m_GroupId)) {
                    continue;
                }

                var startLiftType = snode.getLiftFlagId();
                // 查找同一梯类对应终点层结点
                var enode = null;
                for (var j = 0, jlen = enodes.length; j < jlen; j++) {
                    if (enodes[j].getLiftFlagId() % 100 == startLiftType % 100) {
                        enode = enodes[j];
                        break;
                    }
                }

                if (!enode) continue;

                if (!this.IsSameExtent(startGraph, endGraph, snode, enode, start.m_Point, end.m_Point, isSameExtentType)) {
                    continue;
                }

                if (!startGraph.nodesAccess(start.m_Node, snode)) {
                    continue;
                }

                var subOutLine = new RouteOutline();
                subOutLine.Idfrom = start.m_GroupId;
                subOutLine.Idto = end.m_GroupId;
                subOutLine.Nodefrom.setNode(snode);
                subOutLine.Nodeto.setNode(enode);
                routeList.push(subOutLine);

                return true;
            }
        }

        /*if (this.getLiftNearestAccessNodesInBuilding(start.m_GroupId,end.m_GroupId,end.m_Point,snode,enode))
        {
            if (this.IsSameExtent(startGraph,endGraph,snode,enode,start.m_Point,end.m_Point,isSameExtentType))
            {
                var subOutLine = new RouteOutline();
                subOutLine.Idfrom = start.m_GroupId;
                subOutLine.Idto = end.m_GroupId;
                subOutLine.Nodefrom.setNode(snode);
                subOutLine.Nodeto.setNode(enode);
                routeList.push(subOutLine);

                return true;
            }
        }*/

        return false;
    }

    //----------------------------------------------------------------------------

    // 选取长度最短的引导线
    this.selectMinDistOutLine = function(vecOutLine, startPoint, endPoint)
    {
        if (!vecOutLine || vecOutLine.length==0)
        {
            return -1;
        }
        
        // 选取长度最短的引导线
        var minIdx = -1;
        var minDist = Number.MAX_VALUE;
        var outLineSize = vecOutLine.length;

        for (var outLineIdx = 0; outLineIdx < outLineSize; ++outLineIdx)
        {
            var currOutLine = vecOutLine[outLineIdx];
            if (!currOutLine || currOutLine.length < 2)
            {
                continue;
            }
            
            var currDist = DistanceofTwoPts(startPoint, currOutLine[0].Nodefrom.m_Point);
            currDist += DistanceofTwoPts(currOutLine[0].Nodeto.m_Point, currOutLine[1].Nodefrom.m_Point);
            currDist += DistanceofTwoPts(currOutLine[1].Nodeto.m_Point, endPoint);
            
            if (currDist < minDist)
            {
                minDist = currDist;
                minIdx = outLineIdx;
            }
        }
        
        return minIdx;
    }


    //int startGroupId, fengmap.FMMapCoord &startPoint, int endGroupId, fengmap.FMMapCoord &endPoint
    this.FMRC_RouteCalculateEx = function(startGroupId, startPoint, endGroupId, endPoint, routeList, setting) {
        // var routeList = null;

        this.reset();
        // 设置起点与终点坐标
        this.m_Start.m_Point = startPoint;
        this.m_Start.m_GroupId = startGroupId;
        this.m_End.m_Point = endPoint;
        this.m_End.m_GroupId = endGroupId;


        var startPara = new FMRC_Para; //起点参数 FMRC_Para
        startPara.m_GroupId =  startGroupId;
        var endPara = new FMRC_Para; //终点参数 FMRC_Para
        endPara.m_GroupId =  endGroupId;

        var module = setting._rcm;

        // step1: 检查navi数据的完整性
        if (this.naviRcDB.size() == 0) {
            // 没有初始化FMDBKernel指针
            return ROUTE_FAILED_NO_FMDBDATA;
        }

        var startGraph = this.naviRcDB.get(startGroupId);
        if (startGraph.invalide()) {
            return ROUTE_FAILED_NO_DATA_START;
        }
        startGraph.initVertexLen(module);

        // step2: 绑定起(终)点坐标到对应的路段和节点
        if (false == startGraph.QueryNearestSameExtentElementByGeoPoint(startPoint, startPara.m_Road, startPara.m_Node,  startPara.m_CrossPt)) {
            startGraph.reset();
            return ROUTE_FAILED_NO_DATA_START;
        }
        startGraph.reset();
        startPara.m_Point = startPara.m_CrossPt;

        var endGraph = this.naviRcDB.get(endGroupId);
        if (endGraph.invalide()) {
            return ROUTE_FAILED_NO_DATA_END;
        }

        endGraph.initVertexLen(module);

        if (false == endGraph.QueryNearestSameExtentElementByGeoPoint(endPoint, endPara.m_Road, endPara.m_Node, endPara.m_CrossPt)) {
            endGraph.reset();
            return ROUTE_FAILED_NO_DATA_END;
        }
        endGraph.reset();
        endPara.m_Point = endPara.m_CrossPt;

        //楼层相同但可以通行
        if (startGroupId === endGroupId) {
            var sameGraph_ = this.naviRcDB.get(startGroupId);
            if (sameGraph_.invalide()) {
                return ROUTE_FAILED_NO_DATA_START;
            }

            if (this.CalcSameGraphOutline(startPara, endPara, routeList, setting)) {
                return ROUTE_SUCCESS;
            }
        }

        //楼层ID不同但可通行
        var enode = new NaviNode();
        var snodes = [new NaviNode()];
        startGraph = this.naviRcDB.get(startGroupId);
        if (startGraph.invalide()) {
            return ROUTE_FAILED_NO_DATA_START;
        }
        endGraph = this.naviRcDB.get(endGroupId);
        if (endGraph.invalide()) {
            return ROUTE_FAILED_NO_DATA_END;
        }
        if (this.calcDifferentGraphOutline_Up(2,startPara, endPara, routeList, setting, 3)) {
            return ROUTE_SUCCESS;
        }

        //下楼排在上楼方案之前
        var nearGids = [];
        for (var i = 0,len = this.naviRcDB.size(); i < len; i++) {
            var currGroupId = this.naviRcDB.keys[i];
            var nearGID = {};
            nearGID.offset = Math.abs(currGroupId - startGroupId); //求楼层差绝对值
            if (currGroupId == startGroupId) {
                nearGID.offset = -1;
            }
            if (currGroupId == endGroupId) {
                nearGID.offset = 0;
            }
            nearGID.gid = currGroupId;
            nearGids.push(nearGID);
        }
        nearGids.sort(function(ng0, ng1) {
            return ng0.offset > ng1.offset
        });

        //计算与各层的通行路线
        for (var j = 1,nlen = nearGids.length; j < nlen; j++) {
            var _ngroupId = nearGids[j].gid;

            if (_ngroupId == endGroupId)
                continue;

            var para = new FMRC_Para();
            para.m_GroupId = nearGids[j].gid;
            para.m_Point = this.m_Start.m_Point;

            var t_Graph = this.naviRcDB.get(para.m_GroupId);
            if (!t_Graph)
            {
                return ROUTE_FAILED_NO_DATA_START;
            }
            
            var t_vecOutLine = [];
            for (var i = 0; i < t_Graph.obstructExtents.length; i++) {
                var extent = t_Graph.obstructExtents[i];

                if (!isInPolygon(para.m_Point, extent.o_Points))
                {
                    para.m_Point = getPolygonInnerPt(extent.o_Points);
                }
                
                t_Graph.initVertexLen(setting._rcm);
                var paraTmp = new FMRC_Para();
                if (!t_Graph.QueryNearestSameExtentElementByGeoPoint_processForbid(para.m_Point, paraTmp.m_Road, paraTmp.m_Node, paraTmp.m_CrossPt))
                {
                    t_Graph.reset();
                    continue;
                }
                t_Graph.reset();
                para.m_Node = paraTmp.m_Node;
                para.m_Road = paraTmp.m_Road;
                para.m_CrossPt = paraTmp.m_CrossPt;
                para.m_Point = paraTmp.m_CrossPt;

                routeList.length = 0;

                var tmpRouteList = this.calcDifferentGraphOutline_All(0,startPara, para, setting, 3);
                if (tmpRouteList==null || tmpRouteList.length==0)
                    continue;

                for (var k = 0; k < tmpRouteList.length; k++) {
                    
                    var tmpRouteLists = [];
                    tmpRouteLists.push(tmpRouteList[k]);

                    para.m_Point = tmpRouteList[k].Nodeto.getGeoPoint();
                    para.m_Node = tmpRouteList[k].Nodeto;
                    if (this.calcDifferentGraphOutline_Up(2,para, endPara, tmpRouteLists, setting, 3) == false)
                        continue;

                    t_vecOutLine.push(tmpRouteLists);
                }
            }
            
            if (t_vecOutLine.length == 0) {
                continue;
            }

            var minIdx = this.selectMinDistOutLine(t_vecOutLine, startPara.m_Point, endPara.m_Point);
            if (-1 != minIdx)
            {
                routeList.push(t_vecOutLine[minIdx][0]);
                routeList.push(t_vecOutLine[minIdx][1]);
                return ROUTE_SUCCESS;
            }
        }

        //************************************************************************************
        // Modify 2017/12
        // 修改与各层的通行路线的处理方式

        // 查询起点坐标、终点坐标所在ExtentID
        var startExtentID = startGraph.QueryContainExtentId(startPara.m_Point);
        var endExtentID = endGraph.QueryContainExtentId(endPara.m_Point); 
        var routeLine = this.calRouteLine(startGroupId, endGroupId, startExtentID, endExtentID,
            startPara, endPara,setting);

        if (routeLine == null) {
            return ROUTE_FAILED_CANNOT_ARRIVE;
        }

        for (var i = 0; i <routeLine.length ; i++) {
            routeList.push(routeLine[i]);
        }

        return ROUTE_SUCCESS;
        //************************************************************************************
    }

    this.FMRC_RouteCalculateGroupList = function(startGroupId, startPoint, endGroupId, endPoint, groupList, setting) {
        if (groupList == null || groupList.length <= 0) return ROUTE_FAILED_CANNOT_ARRIVE;

        //重新计算扶梯类型
        // this.processFMNaviNode();

        //求取起点终点对应的路径节点
        this.m_Start.m_Point = startPoint;
        this.m_End.m_Point = endPoint;
        this.m_Start.m_GroupId = startGroupId;
        this.m_End.m_GroupId = endGroupId;

        var module = setting._rcm;

        var startGraph = this.naviRcDB.get(startGroupId);
        if (startGraph.invalide()) {
            return ROUTE_FAILED_NO_DATA_END;
        }
        startGraph.initVertexLen(module);
        if (false == startGraph.QueryNearestSameExtentElementByGeoPoint(this.m_Start.m_Point, this.m_Start.m_Road, this.m_Start.m_Node, this.m_Start.m_CrossPt)) {
            startGraph.reset();
            return ROUTE_FAILED_NO_DATA_START;
        }

        var endGraph = this.naviRcDB.get(endGroupId);
        if (endGraph.invalide()) {
            return ROUTE_FAILED_NO_DATA_END;
        }
        endGraph.initVertexLen(module);
        if (false == endGraph.QueryNearestSameExtentElementByGeoPoint(this.m_End.m_Point, this.m_End.m_Road, this.m_End.m_Node, this.m_End.m_CrossPt)) {
            endGraph.reset();
            return ROUTE_FAILED_NO_DATA_START;
        }

        //同层
        if (groupList.length == 1 && groupList[0].Idfrom == groupList[0].Idto) {
            var subline = groupList[0];
            if (subline.Nodefrom.getGeoPoint().x == subline.Nodeto.getGeoPoint().x && subline.Nodefrom.getGeoPoint().y == subline.Nodeto.getGeoPoint().y) {
                var result = new FMRC_Result();
                result.groupId = subline.Idfrom;
                result.nodeVector.push(subline.Nodefrom);

                result.pointVector.push(this.m_Start.m_Point);
                if (this.m_Start.m_Road.m_Id == this.m_End.m_Road.m_Id) {
                    result.length = DistanceofTwoPts(this.m_Start.m_CrossPt, this.m_End.m_CrossPt);
                    result.pointVector.push(this.m_Start.m_CrossPt);
                    result.pointVector.push(this.m_End.m_CrossPt);
                } else {
                    result.length = DistanceofTwoPts(this.m_Start.m_CrossPt, subline.Nodefrom.getGeoPoint());
                    result.length += DistanceofTwoPts(subline.Nodefrom.getGeoPoint(), this.m_End.m_CrossPt);

                    result.pointVector.push(this.m_Start.m_CrossPt);
                    result.pointVector.push(subline.Nodefrom.getGeoPoint());
                    result.pointVector.push(this.m_End.m_CrossPt);
                }
                result.pointVector.push(this.m_End.m_Point);

                this.m_RC_Result.push(result);
                return ROUTE_SUCCESS;
            }
            var graph = this.naviRcDB.get(subline.Idfrom);
            if (graph.invalide()) {
                return ROUTE_FAILED_NO_DATA_END;
            }
            graph.initVertexLen(module);

            if (!this.RouteCalculate(graph, subline.Nodefrom, subline.Nodeto)) {
                graph.reset();
                return ROUTE_FAILED_CANNOT_CALCULATE;
            }
            graph.reset();
            // 计算成功,添加到m_RC_Result
            var result = new FMRC_Result();
            result.groupId = subline.Idfrom;
            // this.FMRC_GetRouteCalculateNodes(result.length, result.nodeVector);
            this.FMRC_GetRouteCalculateNodes(result);
            this.FMRC_GetRouteCalculateGeoPoints(result.pointVector, 0);

            this.m_RC_Result.push(result);
            return ROUTE_SUCCESS;
        }

        //跨层计算
        var nodes = new Array();
        var gids = new Array();
        this.getNodesGidsFromGroupList(groupList, nodes, gids);

        var startNode = this.m_Start.m_Node;
        var endNode = this.m_End.m_Node;
        //起点
        if (!nodes[0].equals(startNode)) {
            var graph = this.naviRcDB.get(gids[0]);
            graph.initVertexLen(module);

            if (!this.RouteCalculate(graph, startNode, nodes[0])) {
                graph.reset();
                return ROUTE_FAILED_CANNOT_CALCULATE;
            }
            graph.reset();
            // 计算成功,添加到m_RC_Result
            var result = new FMRC_Result();
            result.groupId = gids[0];
            this.FMRC_GetRouteCalculateNodes(result);
            this.FMRC_GetRouteCalculateGeoPoints(result.pointVector, 1);
            this.m_RC_Result.push(result);
        }

        //中间段
        for (var j = 0, size = nodes.length; j < size - 1; j++) {
            if (gids[j] == gids[j + 1]) {
                var curgraph = this.naviRcDB.get(gids[j]);
                curgraph.initVertexLen(module);

                if (!this.RouteCalculate(curgraph, nodes[j], nodes[j + 1])) {
                    curgraph.reset();
                    return ROUTE_FAILED_CANNOT_CALCULATE;
                }
                curgraph.reset();
                // 计算成功,添加到m_RC_Result
                var result = new FMRC_Result();
                result.groupId = gids[j];
                this.FMRC_GetRouteCalculateNodes(result);
                this.FMRC_GetRouteCalculateGeoPoints(result.pointVector, 3);
                this.m_RC_Result.push(result);
            } else {
                if (this.isSameFlag(nodes[j], nodes[j + 1]) == 1) {
                    var result = new FMRC_Result();
                    result.groupId = gids[j];
                    result.nodeVector.push(nodes[j]);
                    result.pointVector.push(nodes[j].getGeoPoint());
                    this.m_RC_Result.push(result);
                } else {
                    var gra = this.naviRcDB.get(gids[j]);
                    gra.initVertexLen(module);

                    var flagNode = new NaviNode;
                    gra.QueryLiftNodeByFLAGID(nodes[j + 1].getLiftFlagId(), flagNode);

                    if (!this.RouteCalculate(gra, nodes[j], flagNode)) {
                        gra.reset();
                        return ROUTE_FAILED_CANNOT_CALCULATE;
                    }
                    gra.reset();
                    // 计算成功,添加到m_RC_Result
                    var result = new FMRC_Result();
                    result.groupId = gids[j];
                    this.FMRC_GetRouteCalculateNodes(result);
                    this.FMRC_GetRouteCalculateGeoPoints(result.pointVector, 3);
                    this.m_RC_Result.push(result);
                }

                var result1 = new FMRC_Result();
                result1.groupId = gids[j + 1];
                result1.nodeVector.push(nodes[j + 1]);
                result1.pointVector.push(nodes[j + 1].getGeoPoint());
                result1.length = 0;
                this.m_RC_Result.push(result1);
            }
        }

        //终点段
        var endIndex = nodes.length - 1;
        if (!nodes[endIndex].equals(endNode)) {
            var grap = this.naviRcDB.get(gids[endIndex]);
            grap.initVertexLen(module);

            if (!this.RouteCalculate(grap, nodes[endIndex], endNode)) {
                grap.reset();
                return ROUTE_FAILED_CANNOT_CALCULATE;
            }
            grap.reset();

            var result = new FMRC_Result();
            result.groupId = gids[endIndex];
            this.FMRC_GetRouteCalculateNodes(result);
            this.FMRC_GetRouteCalculateGeoPoints(result.pointVector, 2);
            this.m_RC_Result.push(result);
        }

        return ROUTE_SUCCESS;
    }

    /*
     * 老数据格式时用此方法。不同层的相同楼梯id不同，只是后两位相同
     */
    this.isSameFlag = function(node0, node1) {
        var flag0 = node0.getLiftFlagId();
        var flag1 = node1.getLiftFlagId();

        if (flag0 % 100 == flag1 % 100) return 1;

        return 0;
    }

    /*
     *当用新数据格式时用此方法。比如新的华为数据
     *
     this.isSameFlag = function (node0,node1) {
        var flag0 = node0.getLiftFlagId();
        var flag1 = node1.getLiftFlagId();

        var tlog0 = parseInt(Math.log(flag0)/Math.log(10))+1;
        var tlog1 = parseInt(Math.log(flag1)/Math.log(10))+1;
        var tlog = parseInt(tlog0 - 4);
        if(tlog0 != tlog1) return 0;

        var tpow = parseInt(Math.pow(10,tlog));
        if((flag0 % tpow) == (flag1 % tpow))
            return 1;

        return 0;
    }*/

    this.getNodesGidsFromGroupList = function(groupList, nodes, gids) {

        if (!groupList || groupList.length <= 0) return;

        for (var i in groupList) {
            var subline = groupList[i];

            if (!subline.Nodefrom) {
                continue;
            }

            if ((nodes.length == 0) || subline.Nodefrom.getId() != nodes[nodes.length - 1].getId() || subline.Idfrom != gids[gids.length - 1]) {
                nodes.push(subline.Nodefrom);
                gids.push(subline.Idfrom);
            }

            if (subline.Nodeto.getId() != nodes[nodes.length - 1].getId() || subline.Idto != gids[gids.length - 1]) {
                nodes.push(subline.Nodeto);
                gids.push(subline.Idto);
            }
        }
    };

    // 跨group(多楼层)路线计算
    //int startGroupId, fengmap.FMMapCoord startPoint, int endGroupId, fengmap.FMMapCoord endPoint, FMRC_RouteCalcuModule module
    this.FMRC_SpanRouteCalculate = function(startGroupId, startPoint, endGroupId, endPoint, module, priority) {
        this.m_RC_Result = [];
        this.reset();
        // step1: 检查navi数据的完整性
        if (this.naviRcDB.size() == 0) {
            return ROUTE_FAILED_NO_FMDBDATA;
        }
        ///new Ex///////////////////////////////////////////////////////////////////////////////////////////////
        var setting = new FMRouteSetting();
        setting._rcm = module;
        setting._cgp = priority || 0;
        var groupList = new Array();
        if (!this.FMRC_RouteCalculateEx(startGroupId, startPoint, endGroupId, endPoint, groupList, setting)) {
            return ROUTE_FAILED_NOTSUPPORT;
        }
        ///end////////////////////////////////////////////////////////////////////////////////////////////////////

        return this.FMRC_RouteCalculateGroupList(startGroupId, startPoint, endGroupId, endPoint, groupList, setting);
    };

    // 通行梯类选取方法
    // liftSelectType 0--以到起点的长度排序 1--以到终点的长度排序 2--以到起终点的长度之和排序
    // isSameExtent 0--不判断 1--只起点判断 2--只终点判断 3--全部判断
    this.calcDifferentGraphOutline_Up = function(LiftSelectType, start, end, routeList, setting, isSameExtentType) {
        var snodes = new Array();
        var enodes = new Array();

        var startGraph = this.naviRcDB.get(start.m_GroupId);
        if (!startGraph)
            return false;

        var endGraph = this.naviRcDB.get(end.m_GroupId);
        if (!endGraph)
            return false;

        switch (LiftSelectType) {
            case 0:
                if (!this.getLiftAccessNodesInBuilding(start.m_GroupId, end.m_GroupId, start.m_Point, snodes, enodes, setting._cgp)) {
                    return false;
                }
                break;
            case 1:
                if (!this.getLiftAccessNodesInBuilding_End(start.m_GroupId, end.m_GroupId, start.m_Point, end.m_Point, snodes, enodes, setting._cgp)) {
                    return false;
                }
                break;
            case 2:
                if (!this.getLiftAccessNodesInBuilding_StartEnd(start.m_GroupId, end.m_GroupId, start.m_Point, end.m_Point, snodes, enodes, setting._cgp)) {
                    return false;
                }
                break;
            default:
                return false;
        }

        for (var i = 0, ilen = snodes.length; i < ilen; i++) {
            var snode = snodes[i];

            /******判断当前梯类是否可以通行********************/
            if (snode.getLiftEntry() == 3 || (snode.getLiftEntry() == 1 && start.m_GroupId > end.m_GroupId) || (snode.getLiftEntry() == 2 && start.m_GroupId < end.m_GroupId)) {
                continue;
            }

            var startLiftType = snode.getLiftFlagId();
            // 查找同一梯类对应终点层结点
            var enode = null;
            for (var j = 0, jlen = enodes.length; j < jlen; j++) {
                if (enodes[j].getLiftFlagId() % 100 == startLiftType % 100) {
                    enode = enodes[j];
                    break;
                }
            }

            if (!enode) continue;

            if (!this.IsSameExtent(startGraph, endGraph, snode, enode, start.m_Point, end.m_Point, isSameExtentType)) {
                continue;
            }

            if (isSameExtentType == 1 || isSameExtentType == 3 ) {
                if(!startGraph.nodesAccess(start.m_Node, snode))
                    continue;
            }

            if (isSameExtentType == 2 || isSameExtentType == 3 ) {
                if(!endGraph.nodesAccess(enode,end.m_Node))
                    continue;
            }

            var subOutLine = new RouteOutline();
            subOutLine.Idfrom = start.m_GroupId;
            subOutLine.Idto = end.m_GroupId;
            subOutLine.Nodefrom.setNode(snode);
            subOutLine.Nodeto.setNode(enode);
            routeList.push(subOutLine);

            return true;
        }
        return false;
    };

    // 通行梯类选取方法
    // liftSelectType 0--以到起点的长度排序 1--以到终点的长度排序 2--以到起终点的长度之和排序
    // isSameExtent 0--不判断 1--只起点判断 2--只终点判断 3--全部判断
    this.calcDifferentGraphOutline_All = function(LiftSelectType, start, end, setting, isSameExtentType) {
        var snodes = new Array();
        var enodes = new Array();

        var routeList = [];

        var startGraph = this.naviRcDB.get(start.m_GroupId);
        if (!startGraph)
            return null;

        var endGraph = this.naviRcDB.get(end.m_GroupId);
        if (!endGraph)
            return null;

        switch (LiftSelectType) {
            case 0:
                if (!this.getLiftAccessNodesInBuilding(start.m_GroupId, end.m_GroupId, start.m_Point, snodes, enodes, setting._cgp)) {
                    return null;
                }
                break;
            case 1:
                if (!this.getLiftAccessNodesInBuilding_End(start.m_GroupId, end.m_GroupId, start.m_Point, end.m_Point, snodes, enodes, setting._cgp)) {
                    return null;
                }
                break;
            case 2:
                if (!this.getLiftAccessNodesInBuilding_StartEnd(start.m_GroupId, end.m_GroupId, start.m_Point, end.m_Point, snodes, enodes, setting._cgp)) {
                    return null;
                }
                break;
            default:
                return null;
        }

        for (var i = 0, ilen = snodes.length; i < ilen; i++) {
            var snode = snodes[i];

            /******判断当前梯类是否可以通行********************/
            if (snode.getLiftEntry() == 3 || (snode.getLiftEntry() == 1 && start.m_GroupId > end.m_GroupId) || (snode.getLiftEntry() == 2 && start.m_GroupId < end.m_GroupId)) {
                continue;
            }

            var startLiftType = snode.getLiftFlagId();
            // 查找同一梯类对应终点层结点
            var enode = null;
            for (var j = 0, jlen = enodes.length; j < jlen; j++) {
                if (enodes[j].getLiftFlagId() % 100 == startLiftType % 100) {
                    enode = enodes[j];
                    break;
                }
            }

            if (!enode) continue;

            if (!this.IsSameExtent(startGraph, endGraph, snode, enode, start.m_Point, end.m_Point, isSameExtentType)) {
                continue;
            }

            if (isSameExtentType == 1 || isSameExtentType == 3 ) {
                if(!startGraph.nodesAccess(start.m_Node, snode))
                    continue;
            }

            if (isSameExtentType == 2 || isSameExtentType == 3 ) {
                if(!endGraph.nodesAccess(end.m_Node, enode))
                    continue;
            }

            var subOutLine = new RouteOutline();
            subOutLine.Idfrom = start.m_GroupId;
            subOutLine.Idto = end.m_GroupId;
            subOutLine.Nodefrom.setNode(snode);
            subOutLine.Nodeto.setNode(enode);
            routeList.push(subOutLine);
        }

        if (routeList.length != 0) {
            return routeList;
        }
        return null;
    }
}

var NaviInformation = function()
{
	this._curNode = new NaviNode(); // Node
	this._weight; // double
	this._list = []; //array Node 
	
	this.clearList = function()
	{
		this._list.splice(0,this._list.length);
	}
};

/**
*	NaviOptions 是设置加载地图路径数据参数的类
* 	@class NaviOptions
* 	@module Navigation
* 	@constructor
*   @namespace fengmap
*   @param {object} options 路径分析对象加载参数配置项
*             @param {string} [options.naviServerURL] 设置获取地图的服务器路径,默认是从蜂鸟视图服务器上获取地图
*             
*   @demo navi/路径分析类参数配置.js
*/
fengmap.NaviOptions = function(options) {
	this.options_ = options;
	if (!this.options_.hasOwnProperty('naviServerURL') || this.options_.naviServerURL == null) {		
		this.options_.naviServerURL = '.http://source.fengmap.com/newmap';//正式发布，可改为正式的服务器地址!		
	}
	
	if (this.options_.useStatic === undefined) {
		this.options_.useStatic = false;
	}
};
fengmap.NaviOptions.prototype = {
	get naviServerURL () {
		return this.options_.naviServerURL;
	},
	get useStatic () {
		return this.options_.useStatic;
	}
};

fengmap.NaviService = function(options) {
//	this.map_ = map;
	this.options_ = options;
};
fengmap.NaviService.prototype = {
		
		staticNaviScene_:null,
		
		queryScene:function(sceneId,success,fail) {
			var url;
			var this_ = this;
			if(this.options_.useStatic) {
				url = this.options_.naviServerURL + '/' + sceneId + '.fmap';
				new fm.Ajax(url, function(d) {
					var scene = this_.convertStatic1_(d);
					success(scene.scene_data);
				},true);
			} else {
				url = this.options_.naviServerURL +  '/' + sceneId;
				//访问多个 .fmap文件,从id.scene.fmap开始
				new fm.Ajax(url, function(d) {
					var scene = this_.convertSite1_(d);					
//					console.log(scene);
					success(scene.scene_data);
				},true);
			}
		},
		queryNaviData:function(sceneId, groupId, success, fail) {
			var this_ = this;
			if(this.options_.useStatic) {
				var group = this_.convertStatic2_(groupId);
				//console.log(group);			
				success(group);
			} else {
				var geo = null;
				var biz = null;
				var nav = null;
				var this_ = this;				
				new fm.Ajax(this.options_.naviServerURL + '/group_v2/' + sceneId + '/' + groupId + '/geo', function(d) {
					geo = d;
					if (geo != null && biz != null && nav != null) {
						var group = this_.convertSite2_(groupId, geo, biz, nav);						
						success(group);
					}
				},true);
				new fm.Ajax(this.options_.naviServerURL + '/group_v2/' + sceneId + '/' + groupId + '/biz', function(d) {
					biz = d;
					if (geo != null && biz != null && nav != null) {
						var group = this_.convertSite2_(groupId, geo, biz, nav);				
						success(group);
					}
				},true);
				new fm.Ajax(this.options_.naviServerURL + '/group_v2/' + sceneId + '/' + groupId + '/navi', function(d) {
					nav = d;
					if (geo != null && biz != null && nav != null) {
						var group = this_.convertSite2_(groupId, geo, biz, nav);				
						success(group);
					}
				},true);
				
			}
			
		},
		
		/*queryScene:function(sceneId, success, fail) {
			//console.log(this.options_.useStatic);
			if (this.options_.useStatic) {				
				var url = this.options_.naviServerURL + '/scene/' + sceneId + '/'+sceneId + '.scene.fmap';
				//console.log(url);
				new fm.Ajax(url, function(d) {
					//console.log(d);
					//var scene =  JSON.parse(d);				
					var scene = fmSceneDecode(d);
					//console.log(scene);
					
					success(scene);
				},true);
			} else {
				new fm.Ajax(this.options_.naviServerURL + '/scene/' + sceneId, function(d) {
					//console.log(d);
					//var scene =  JSON.parse(d);			
					var scene = fmSceneDecode(d);
					//console.log(scene);				
					success(scene);
				},true);
			}
		},*/
		
		convertSite1_:function(d) {
			var scene = fmSceneDecode(d);
			var d = {
				//sid:0,
				scene_data:scene,
			};
			
			/*var layerGroups = scene.layerGroups; 
			for (var i=0; i<layerGroups.length; i++) {
				var lg = layerGroups[i];
				lg.elevation = lg.height;
			}*/
			return d;
		},
		
		convertSite2_:function(groupId, r_geo, r_biz, r_nav) {
//			console.log(r_geo, r_biz, r_nav);
			var geo = fmFloorGeoDecode(r_geo);
	        var biz = fmFloorBizDecode(r_biz);
	        var nav = fmFloorNaviDecode(r_nav); 
	        //
	        //console.log(geo,biz,nav);

			return this.convertToGroup__(groupId,geo,biz,nav);
		},
		
		convertGeo2Geometry_:function(data,extent) {
			var gd = new navigeo.GData().parse(data);
			return gd.points_;
		},
		
		
		//#20160406,Samuel,Copy from v0.2
		tempFlipX_:function(data) {
			if (data && typeof(data) != 'string') {
				//console.log(data, typeof(data)); 
				for (var k in data) {
					var d = data[k];
					if (k == 'vertices' || k == 'vertex') {
						for (var i in d) {
							if (i % 2 == 0) {
								d[i] = -d[i];
							}
						}
					} else if (k == 'scene_data') {
						d.x = -d.x;
						d.defCenX = -d.defCenX;
					} else {
						this.tempFlipX_(d);
					}
				}
			} 
		},	
		
		//根据返回的结点关联楼层对象解析成数组。有中间有|分割的数组
		ConvertStringToArray:function(str) {
			if(str == "" || !str) return [];
			var res = [];
		    var tmp = str;
	        var tmpArr = [];
	        //tmp = tmp.replace(new RegExp(/(,)/g),'');
	        if (tmp.indexOf('|') >= 0 || tmp.indexOf('-') >= 0 || tmp.indexOf(',') >= 0) {
	            tmpArr = tmp.split(/[|,-]/);            
	            res.push.apply(res,tmpArr);
	        }
	        else res.push(tmp);
		    return res;
		},
		
		convertStatic1_:function(d) {
			this.staticNaviScene_ = fmMapDecode(d);
			//console.log(this.staticScene_);
			var d = {
				//sid:0,
				scene_data:this.staticNaviScene_.scene,
			};
			
			/*var layerGroups = d.scene_data.layerGroups; 
			for (var i=0; i<layerGroups.length; i++) {
				var lg = layerGroups[i];
				lg.elevation = lg.height;
			}*/
			
			//console.log(d);
			return d;
		},
		
		convertStatic2_:function(groupId) {
//			console.log('convertStatic2_', groupId);
			var floors = this.staticNaviScene_.floors;
			for (var i = 0; i< floors.length; i++) {
				var floor = floors[i];
				if (floor.gid == groupId) {
					return this.convertToGroup__(groupId,floor.geo[0],floor.biz[0],floor.navi[0]);
				}
			}
			return null;
		},
		
		convertToGroup__:function(groupId,geo_s,biz_s,nav_s) {
			
			//biz, geo, navi
			
			var hash_labels = {};
			var models = [];
			var extents = [];
			var nodes = [];
			var roads = [];
			var zones = [];
			
			for (var j=0, jlen = geo_s.extentLayer.length;j<jlen;j++) {
				var extlayer = geo_s.extentLayer[j];
				extlayer.geoArr = this.convertGeo2Geometry_(extlayer.geo,true);
				extents.push(extlayer);
			}
			
			for(var i = 0, ilen = geo_s.labelLayer.length; i<ilen;i++) {
				hash_labels[geo_s.labelLayer[i].eid] = geo_s.labelLayer[i];
			}
			
			for(var k = 0,klen=geo_s.modelLayer.length;k<klen;k++) {
				var geoModel = geo_s.modelLayer[k];
				var bizModel = biz_s.modelLayer[k];
				var model = {};
				model.fid = bizModel.fid;
				model.eid = geoModel.eid;
				//--useless 
				//model.center = this.convertGeo2Geometry_(hash_labels[geoModel.eid].geo)[0];
				model.geoArr = this.convertGeo2Geometry_(geoModel.geo);
				//model.points = this.convertGeo2Geometry_(geoModel.geo);
				models.push(model);
			}
			
			for(var m=0,mlen = nav_s.naviNodes.length; m< mlen;m++) {
				var node = nav_s.naviNodes[m];
				node.geoArr = this.convertGeo2Geometry_(node.geo)[0];
				node.linkSegArr = this.ConvertStringToArray(node.linkSeg);
				node.liftFloorArr = this.ConvertStringToArray(node.liftFloor);
				nodes.push(node);
			}
			
			for(var n=0,nlen = nav_s.naviSegments.length; n< nlen;n++) {
				var road = nav_s.naviSegments[n];
				road.geoArr =  this.convertGeo2Geometry_(road.geo);
				road.m_Id = nav_s.mid;
				roads.push(road);
			}
			
			if (nav_s.zones) {
				for(var o=0,nlen = nav_s.zones.length; o< nlen;o++) {
					var zone = nav_s.zones[o];
					zone.geoArr =  this.convertGeo2Geometry_(zone.geo);
					zone.m_Id = nav_s.mid;
					zones.push(zone);
				}	
			}
	
			var d = {
				gid:groupId,
				extentLayer:extents,
				modelLayer:models,
				naviSegments:roads,
				naviNodes:nodes,
				zones: zones
			};
			//console.log(d);
			return d;			
		},
};


// FengMap Navi中路线计算模块的数据结构定义部分


var ERROR_WEIGHT = 999999999.0; // 路段错误的权重
var NAVI_NODE_MAXNUM = 1000;

var NaviLiftType_NULL = 0; // 无梯类
var NaviLiftType_Lift = 1; // 垂直电梯
var NaviLiftType_Stair = 2; // 步行梯
var NaviLiftType_Escalator = 3; // 手扶电梯

var NaviNodeType_NULL = -1;
var NaviNodeType_COMMON = 0; // 普通节点
var NaviNodeType_SIDE = 1; // 端点
var NaviNodeType_FLOOR = 2; // 跨层节点(电梯类)
var NaviNodeType_EXTENT = 3; // 外部节点(连接室外路段或其它建筑路段)

var FMROUTE_CGP_DEFAULT = 0; //LIFT > ESCALATOR > STAIR
var FMROUTE_CGP_LIFTFIRST = 1;
var FMROUTE_CGP_ESCALATORFIRST = 2;
var FMROUTE_CGP_STAIRFIRST = 3;
var FMROUTE_CGP_LIFTONLY = 4;
var FMROUTE_CGP_ESCALATORONLY = 5;
var FMROUTE_CGP_STAIRONLY = 6;

/**
 * Node结点的类定义
 */
var NaviNode = function() {

    /**
     * 标识nodeId(int)
     */
    this.m_Id = -1;
    /**
     * 坐标(geopoiont)
     */
    this.m_Point = new fengmap.FMMapCoord();
    /**
     * 类型(nodeType 和 liftType) 使用一BYTE存储
     * bit0-1:nodeType	bit2-3:lifttye	bit4-5:liftentry通行规则类型 bit6-7:两位保留
     */
    this.m_Type = 0;
    /**
     * 梯类点所能到达的group(楼层)编号vector (int[])
     */
    this.m_LiftFloors = [];
    /**
     * 关联路段的segIdvector(int[])
     */
    this.m_SegLinks = [];
    /**
     * 如果是梯类，则为当前梯的FLAG id (int)
     */
    this.m_LiftId = 0;
    /**
     * 如果当前是梯类点，则与其属于同一个梯的其他楼层的Node点 (vector<Node>)
     */
    this.m_RelatedLiftNodes = [];

    /**
     * 标识：从起点到Node是否求出最短路径(bool)
     */
    this._treatHead = false;
    /**
     * 标识：从终点到Node是否求出最短路径(bool)
     */
    this._treatTail = false;

    //===================================================

    //Node(int mId);
    //Node(int mId, double mLongitude, double mLatitude);
    //Node(int mId, GeoPoint pt);
    //Node(const NaviNode& naviNode);
    //
    //TODO:需实现对象的深拷贝
    //Node& operator=(const Node& tmp);


    this.initNode = function(mId) {
        this.m_Id = mId;
        this.m_Point.x = 0.0;
        this.m_Point.y = 0.0;
        this.m_Type = 0;
        this.m_LiftId = 0;
        this._treatHead = false;
        this._treatTail = false;
    }

    /**
     * [equals 比较两个对象的值是否相同]
     * @param  {[type]} other [description]
     * @return {[type]}       [description]
     */
    this.equals = function(other) {
        return this.m_Id == other.m_Id;
    };

    this.setNode = function(otherNode) {
        this.m_Id = otherNode.m_Id;
        this.m_Point = otherNode.m_Point;
        this.m_Type = otherNode.m_Type;
        this.m_LiftFloors = [];
        for (var i = 0; i < otherNode.m_LiftFloors.length; i++) {
            this.m_LiftFloors[i] = otherNode.m_LiftFloors[i]
        };
        this.m_SegLinks = [];
        for (var i = 0; i < otherNode.m_SegLinks.length; i++) {
            this.m_SegLinks[i] = otherNode.m_SegLinks[i]
        };
        this.m_LiftId = otherNode.m_LiftId;

        this.m_RelatedLiftNodes = [];
        for (var i = 0; i < otherNode.m_RelatedLiftNodes.length; i++) {
            this.m_RelatedLiftNodes[i] = otherNode.m_RelatedLiftNodes[i];
        };

        this._treatHead = otherNode._treatHead;
        this._treatTail = otherNode._treatTail;
    }
    /**
     * // 设置节点类型【0】普通节点 【1】端点  【2】跨层节点	 【3】外部节点
     * m_Type: bit0-1; 00：普通节点	01：端点	10：跨层节点	11：外部节点
     * @param {[type]} value [description]
     */
    this.setNodeType = function(value) {
        if (value != -1) {
            this.m_Type |= value;
        }
    }

    this.getNodeType = function() {
        return this.m_Type & 0x3;
    }

    // 设置梯类类型【0】非梯类   【1】垂直电梯 【2】步行梯【3】手扶电梯
    // m_Type: bit2-3；00：非梯类	01：垂直电梯	10：步行梯	11：手扶电梯
    this.setLiftType = function(value) {

        this.m_Type |= (value << 2);
    }

    this.getLiftType = function() {
        return (this.m_Type >> 2) & 0x3;
    }
    // 梯类的通行规则	【0】上下通行	【1】仅上行	 【2】仅下行  【3】上下均不通行
    // m_Type: bit4-5
    this.setLiftEntry = function(value) {
        return this.m_Type |= (value << 4);
    }

    this.getLiftEntry = function() {
        return (this.m_Type >> 4) & 0x3;
    }

    this.getLiftFlagId = function() {
        return this.m_LiftId;
    }

    this.getId = function() {
        return this.m_Id;
    }

    this.getGeoPoint = function() {
        return this.m_Point;
    }

    this.setGeoPoint = function(point) {
        this.m_Id = -1;
        this.m_Point = point;
    }

    this.getx = function() {
        return this.m_Point.x;
    }

    this.gety = function() {
        return this.m_Point.y;
    }

    this.getNumLiftFloors = function() {
        return this.m_LiftFloors.length;
    }

    this.getNumSegLinks = function() {
        return this.m_SegLinks.length;
    }

    this.getLiftFloors = function() {
        return this.m_LiftFloors;
    }

    this.getSegLinks = function() {
        return this.m_SegLinks;
    }

    //NaviLiftType_Lift 1 NaviLiftType_Stair 2 NaviLiftType_Escalator 3
    this.contansFloor = function(floorId) {

        if (this.getLiftType() == NaviLiftType_Stair) {
            return true;
        }

        for (var i = this.m_LiftFloors.length - 1; i >= 0; i--) {

            if (this.m_LiftFloors[i] == floorId) {
                return true;
            };
        };
        return false;
    }
};

//==========Node Class End============


/**
 * Road路段的类的定义
 */
var NaviRoad = function() {
    /**
     * 标识ID(int)
     */
    this.m_Id = -1;
    /**
     * 起点Node ID(int)
     */
    this.m_StartId = -1;
    /**
     * 起点Node 坐标(fengmap.FMMapCoord)
     */
    this.m_StartPoint = new fengmap.FMMapCoord();
    /**
     * 终点Node ID(int)
     */
    this.m_EndId = -1;
    /**
     * 终点Node 坐标(fengmap.FMMapCoord)
     */
    this.m_EndPoint = new fengmap.FMMapCoord();
    /**
     * 路段长度(double)
     */
    this.m_Length = 0;
    /**
     * 权重
     */
    /*double m_Weight;*/
    /**
     *  rank 与 entry  (BYTE)
     *	bit0-1:rank	   bit2-3:entry 	bit4-7:四位保留
     */
    this.m_Type = 0;
    /**
     * 形状点序列(std::vector<fengmap.FMMapCoord> )
     * 按照起点到终点的方向
     */
    this.m_PointVector = [];

    this.setRoad = function(otherRoad) {
        this.m_Id = otherRoad.m_Id;
        this.m_StartId = otherRoad.m_StartId;
        this.m_StartPoint = otherRoad.m_StartPoint;
        this.m_EndId = otherRoad.m_EndId;
        this.m_EndPoint = otherRoad.m_EndPoint;
        this.m_Length = otherRoad.m_Length;
        this.m_Type = otherRoad.m_Type;
        this.m_PointVector = [];
        for (var i = 0; i < otherRoad.m_PointVector.length; i++) {
            this.m_PointVector[i] = otherRoad.m_PointVector[i];
        }
    }

    this.getStartId = function() {
        return this.m_StartId;
    }

    this.getEndId = function() {
        return this.m_EndId;
    }

    this.getStartPoint = function() {
        return this.m_StartPoint;
    }

    this.getEndPoint = function() {
        return this.m_EndPoint;
    }

    // void Road::setWeight(double mWeight)
    // {
    // 	m_Weight = mWeight;
    // }

    this.getLength = function() {
        return this.m_Length;
    }

    // double Road::getWeight() const
    // {
    // 	return this.m_Weight;
    // }

    this.getGeoPointList = function() {
        return this.m_PointVector;
    }

    // 道路等级	m_Type bit0-1:
    this.setRoadRank = function(value) {
        //assert(value <= 3);
        this.m_Type |= value;
    }

    this.getRoadRank = function() {
        return this.m_Type & 0x3;
    }

    // 路段通行属性 m_Type bit2-3
    this.setRoadEntry = function(value) {
        this.m_Type |= (value << 2);
    }

    this.getRoadEntry = function() {
        return (this.m_Type >> 2) & 0x3;
    }
};

//==========Road Class End============

//==========Obstruct Class start============
/**
 * 阻挡类
 */
var NaviObstruct = function() {
    /**
     * ID(int)
     */
    this.o_Id;

    this.o_Fid;

    /**
     * 中心点
     * --useless
     */
    //this.o_CenterPnt = new fengmap.FMMapCoord();

    /**
     *
     */
    this.o_Fid;

    /**
     * 点数组
     */
    this.o_Points = [];

    // 判断点在多边形内
    this.contain = function(pnt) {
        var oddNodes = 0;
        var p1 = new fengmap.FMMapCoord();
        var p2 = new fengmap.FMMapCoord();
        var len = this.o_Points.length;
        for (var i = 0; i < len; i++) {
            p1 = this.o_Points[i];
            p2 = this.o_Points[(i + 1) % len];
            if ((p1.y < pnt.y && p2.y >= pnt.y) || (p2.y < pnt.y && p1.y >= pnt.y) &&
                (p1.x <= pnt.x || p2.x <= pnt.x)) {

                if (p1.x + (pnt.y - p1.y) / (p2.y - p1.y) * (p2.x - p1.x) < pnt.x) {
                    oddNodes = !oddNodes;
                }
            }
        }
        return oddNodes;
    }
};


var NaviObstructLine = function() {
    /**
     * ID(int)
     */
    this.id_;

    /**
     * 楼层ID(int)
     */
    this.groupID_;

    /**
     * 包围盒[minX,minY,maxX,maxY]
     */
    this.bb_ = [Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE];

    /**
     * 点数组
     */
    this.points_ = [];

    var self = this;

    /**
     * 求叉积
     */
    this.cross_ = function(lhs,rhs){
        return lhs.x * rhs.y - lhs.y * rhs.x;
    }

    /**
     * 跨立
     */
    this.intersect_ = function(lhsS, lhsE, rhsS, rhsE)
    {
        var r1 = self.cross_({'x':lhsS.x-rhsS.x,'y':lhsS.y-rhsS.y}, {'x':rhsE.x-rhsS.x,'y':rhsE.y-rhsS.y}) * self.cross_({'x':lhsE.x-rhsS.x,'y':lhsE.y-rhsS.y}, {'x':rhsE.x-rhsS.x,'y':rhsE.y-rhsS.y}) < 0;
        var r2 = self.cross_({'x':rhsS.x-lhsS.x,'y':rhsS.y-lhsS.y}, {'x':lhsE.x-lhsS.x,'y':lhsE.y-lhsS.y}) * self.cross_({'x':rhsE.x-lhsS.x,'y':rhsE.y-lhsS.y}, {'x':lhsE.x-lhsS.x,'y':lhsE.y-lhsS.y}) < 0;
        
        return r1 && r2;
    }

    this.initByJson = function(data){

        if (data && data.id && data.groupID && data.points && data.points.length>=2) {
            self.id_ = data.id;
            self.groupID_ = data.groupID;
            self.points_ = data.points;

            var point = null;
            for (var i = 0; i < self.points_.length; i++) {
                
                point = self.points_[i];

                if (point.x < self.bb_[0])
                    self.bb_[0] = point.x;

                if (point.y < self.bb_[1])
                    self.bb_[1] = point.y;

                if (point.x > self.bb_[2])
                    self.bb_[2] = point.x;

                if (point.y > self.bb_[3])
                    self.bb_[3] = point.y;
            }
        }
    }

    // 判断线段是否与阻挡线相交
    this.isCross = function(pt0,pt1) {

        if (self.points_.length == 0) {
            return false;
        }

        if (!pt0 || !pt1) {
            return false;
        }

        if (pt0.x < self.bb_[0] && pt1.x < self.bb_[0]) 
            return false;

        if (pt0.y < self.bb_[1] && pt1.y < self.bb_[1]) 
            return false;

        if (pt0.x > self.bb_[2] && pt1.x > self.bb_[2]) 
            return false;

        if (pt0.y > self.bb_[3] && pt1.y > self.bb_[3]) 
            return false;

        var length = self.points_.length-1;
        var pts0 = null;
        var pts1 = null;
        for (var i = 0; i < length; i++) {
            
            pts0 = self.points_[i];
            pts1 = self.points_[i+1];

            if(self.intersect_(pt0,pt1,pts0,pts1))
                return true;
        }

        return false;
    }
};

//==========Obstruct Class End============
var NodeDistance = function() {
    this._distance = ERROR_WEIGHT;
    var _node;
};

function NodeDistanceFunc(nd0, nd1) {
    return parseFloat(nd0._distance) > parseFloat(nd1._distance) ? 1 : -1;
}
/**
 * 路网类
 * 包含结点与路段
 */
var NaviGraph = function(nodes, roads, flag, type) {
    type = 1;

    this.nodeVector = nodes; // 结点容器
    this.roadVector = roads; // 路段容器
    this.obstructModels = []; //模型阻挡
    this.obstructExtents = []; //区域阻挡 不可跨区域进行路径规划
    this.obstructLines = []; //阻挡线 不可跨越进行路径规划
    this.needVertex = flag;

    var maxNodeNum = this.nodeVector.length + 1;
    //double       **vertexLen;
    this.vertexLen = new Array();
    // 是否需要增加距离向量,如果不需要，则不申请内存
    if (this.needVertex == true) {
        var road = null;
        for (var i = 0; i < this.roadVector.length; i++) {
            road = this.roadVector[i];

            if (typeof this.vertexLen[road.m_StartId] == 'undefined') {
                this.vertexLen[road.m_StartId] = new Array();
            }
            this.vertexLen[road.m_StartId][road.m_EndId] = ERROR_WEIGHT;

            if (typeof this.vertexLen[road.m_EndId] == 'undefined') {
                this.vertexLen[road.m_EndId] = new Array();
            }
            this.vertexLen[road.m_EndId][road.m_StartId] = ERROR_WEIGHT;
        }
    }

    this.roadDiffusion = [];
    for (var i = 0; i < this.roadVector.length; i++) {
        this.roadDiffusion[i] = false;
    }

    this.setObstructModels = function(value) {
        this.obstructModels = value;
    }

    this.setobstructExtents = function(value) {
        this.obstructExtents = value;
    }

    this.setObstructLines= function(value) {
        this.obstructLines = value;
    }

    this.invalide = function() {

        return ((this.nodeVector.length == 0) || (this.roadVector.length == 0));
    }

    this.reset = function() {
        for (var i = 0; i < this.nodeVector.length; i++) {
            this.nodeVector[i]._treatHead = false;
        }

        if (this.needVertex == true) {
            var maxNodeNum = this.nodeVector.length + 1;
            for (var i = 0; i < maxNodeNum; i++) {
                for (var j = 0; j < maxNodeNum; j++) {
                    if (typeof this.vertexLen[i] == 'undefined') {
                        continue;
                    }

                    if (typeof this.vertexLen[i][j] == 'undefined') {
                        continue;
                    }

                    this.vertexLen[i][j] = ERROR_WEIGHT;
                }
            }
        }
    }

    this.initVertexLen = function(type) {
        var weight = ERROR_WEIGHT;
        for (var i = 0; i < this.roadVector.length; i++) {
            if (this.needVertex == false)
                continue;

            var road = this.roadVector[i];
            if (type == 1) {
                weight = road.getLength();
            } else if (type == 2) {
                weight = road.getLength() * road.getRoadRank();
            }

            var roadEntry = road.getRoadEntry();
            if (roadEntry == 0 || roadEntry == 1) {
                this.vertexLen[road.m_StartId][road.m_EndId] = weight;
            }

            if (roadEntry == 0 || roadEntry == 2) {
                this.vertexLen[road.m_EndId][road.m_StartId] = weight;
            }
        }
    }

    //==============function===========

    // this.QueryNearestElementByGeoPoint=function(pt,road,node,crossPt){
    // 	var dis = 99999999.0;
    // 	var crossPtTmp = new fengmap.FMMapCoord;//fengmap.FMMapCoord
    // 	var nodeTmp = new NaviNode;
    // 	if (this.nodeVector.length <= 0 || this.roadVector.length <= 0)
    // 	{
    // 		return false;
    // 	}

    // 	for (var i = 0; i < this.roadVector.length; i++) {

    // 		var record = this.roadVector[i];

    // 		//endzzz
    // 		var tmp = pt_distance_to_line(pt, record.getStartPoint(), record.getEndPoint(), crossPtTmp);
    // 		if (tmp < dis)
    // 		{
    // 			dis = tmp;
    // 			road.setRoad(record);
    // 			crossPt.x = crossPtTmp.x;
    // 			crossPt.y = crossPtTmp.y;
    // 		}
    // 	};

    // 	var nodeId;
    // 	if (DistanceofTwoPts(road.getStartPoint(), crossPt) <= DistanceofTwoPts(road.getEndPoint(), crossPt))
    // 	{
    // 		nodeId = road.getStartId();
    // 	} else {
    // 		nodeId = road.getEndId();
    // 	}

    // 	for (var i = 0; i < this.nodeVector.length; i++) {

    // 		var indexNode = this.nodeVector[i];
    // 		if (indexNode.getId() == nodeId)
    // 		{
    // 			node.setNode(indexNode);
    // 			break;
    // 		}
    // 	};
    // 	return true;
    // }

    // 返回以距离排序的梯类节点,扶梯优先直梯
    // this.QueryLiftNodesByGeoPoint = function(pt,groupId,nodes)
    // {
    // 	if (this.nodeVector.length <= 0 || this.roadVector.length <= 0){
    // 		return [];
    // 	}
    //     var nodeDistances=[];
    //     for (var i = 0; i < this.nodeVector.length; i++) {
    //     	var node = this.nodeVector[i];

    // 		if (node.contansFloor(groupId))
    // 		{
    // 			var nodeDis = new NodeDistance();
    // 			nodeDis._node = node;
    // 			nodeDis._distance = DistanceofTwoPts(pt,node.getGeoPoint());
    // 			nodeDis._distance = parseFloat(nodeDis._distance).toFixed(4);

    // 			if(node.getLiftType() == NaviLiftType_Lift)
    // 				nodeDis._distance -= 8;
    // 			if(node.getLiftType() == NaviLiftType_Escalator)
    // 				nodeDis._distance -= 15;

    // 			nodeDistances.push(nodeDis);
    // 		}
    //     };

    //     if (!nodeDistances||nodeDistances.length==0){
    //         return [];
    //     }

    //     nodeDistances = nodeDistances.sort(NodeDistanceFunc);

    //     nodes=[nodeDistances.length];
    //     for (var i = 0; i < nodeDistances.length; i++) {
    //     	nodes[i] = new NaviNode;
    //     	nodes[i].setNode(nodeDistances[i]._node);
    //     }
    //     return nodes;
    // }

    //重置路线扩散标记
    this.resetRoadDiffusion = function() {

        for (var i = 0; i < this.roadDiffusion.length; i++) {
            this.roadDiffusion[i] = false;
        }
    }

    //判断节点是否相通
    this.nodesAccess = function(start, end) {

        if (this.nodeVector.length <= 0 || this.roadVector.length <= 0) {
            return false;
        }

        if (start.m_Id == end.m_Id) {
        	return true;
        }

        this.resetRoadDiffusion();

        var access = [];
        access.push(start.m_Id);

        var road = null;
        var entry = null;
        var accessLen = 0;
        var index = accessLen;

        while (accessLen != access.length) {

            index = accessLen;
            accessLen = access.length;

            for (var j = index; j < access.length; j++) {

                for (var i = 0; i < this.roadVector.length; i++) {

                    if (this.roadDiffusion[i] == true) {
                        continue;
                    }

                    road = this.roadVector[i];
                    entry = road.getRoadEntry();

                    if (road.m_StartId == access[j] && (entry == 0 || entry == 1)) {
                        if (road.m_EndId == end.m_Id) {
                            return true;
                        }

                        access.push(road.m_EndId);
                        this.roadDiffusion[i] = true;
                    }

                    if (road.m_EndId == access[j] && (entry == 0 || entry == 2)) {

                        if (road.m_StartId == end.m_Id) {
                            return true;
                        }

                        access.push(road.m_StartId);
                        this.roadDiffusion[i] = true;
                    }
                }
            }
        }

        return false;
    }

    // 返回以距离排序的梯类节点,扶梯优先直梯
    this.QuerySameExtentLiftNodesByGeoPoint = function(pt, groupId, nodes, distance) {
        if (this.nodeVector.length <= 0 || this.roadVector.length <= 0) {
            return [];
        }

        var ptExtentID = this.QueryContainExtentId(pt);

        var nodeDistances = [];
        for (var i = 0; i < this.nodeVector.length; i++) {
            var node = this.nodeVector[i];

            var nodeExtentID = this.QueryContainExtentId(node.getGeoPoint());

            if (node.contansFloor(groupId) && (nodeExtentID == ptExtentID || ptExtentID == 0)) {
                var nodeDis = new NodeDistance();
                nodeDis._node = node;
                nodeDis._distance = DistanceofTwoPts(pt, node.getGeoPoint());
                nodeDis._distance = parseFloat(nodeDis._distance).toFixed(4);

                /*if(node.getLiftType() == NaviLiftType_Lift)
                	nodeDis._distance -= 8;
                if(node.getLiftType() == NaviLiftType_Escalator)
                	nodeDis._distance -= 15;*/

                nodeDistances.push(nodeDis);
            }
        };

        if (!nodeDistances || nodeDistances.length == 0) {
            return [];
        }

        nodeDistances = nodeDistances.sort(NodeDistanceFunc);

        for (var i = 0; i < nodeDistances.length; i++) {
            nodes[i] = new NaviNode;
            nodes[i].setNode(nodeDistances[i]._node);
            distance[i] = parseFloat(nodeDistances[i]._distance);
        }
        return nodes;
    }

    this.QueryLiftNodeByFLAGID = function(flag, node) {
        if (!this.nodeVector || this.nodeVector.length <= 0 || !this.roadVector || this.roadVector.length <= 0) {
            return false;
        }

        //老数据格式时用此方法。不同层的相同楼梯id不同，只是后两位相同
        for (var i = 0; i < this.nodeVector.length; i++) {
            var nodeIndex = this.nodeVector[i];
            // Node是连通点 && 其FLAGID的后两位与flag的后两位一致
            if (nodeIndex.getNodeType() == NaviNodeType_FLOOR) {
                var flagIndex = nodeIndex.getLiftFlagId() % 100;
                if (flagIndex == (flag % 100)) {
                    node.setNode(nodeIndex);
                    return true;
                }
            }
        }

        /**
		 * 当用新数据格式时用此方法。比如新的华为数据
		 *
		var tlog = parseInt(Math.log(flag)/Math.log(10))+1;
	    var tpow =  parseInt(Math.pow(10,tlog-4));
	    var flagId = 0;
	    var flagpow = flag % tpow;

		for (var i = 0; i < this.nodeVector.length; i++) {
			var nodeIndex = this.nodeVector[i];
			// Node是连通点 && 其FLAGID的后两位与flag的后两位一致
			if (nodeIndex.getNodeType() == NaviNodeType_FLOOR )
			{
				flagId = nodeIndex.getLiftFlagId();
				var tmp = parseInt(Math.log(flagId)/Math.log(10))+1;
	            if (tmp != tlog)
	                continue;

	            var flagIndex = flagId % tpow;
	            if (flagIndex == flagpow)
	            {
	            	node.setNode(nodeIndex);
	                return true;
	            }
			}
		}**/
        return false;
    }

    this.QueryLiftNodesByType = function(type, nodes) {

        if (!this.nodeVector || this.nodeVector.length <= 0 || !this.roadVector || this.roadVector.length <= 0) {
            return false;
        }

        for (var i = 0; i < this.nodeVector.length; i++) {
            var nodeIndex = this.nodeVector[i];
            // 电梯类型匹配
            if (nodeIndex.getLiftType() == type) {
                nodes[i] = nodeIndex;
            }
        };

        return (nodes.length != 0);
    }

    this.QueryContainExtentId = function(pt) {
        if (this.obstructExtents.length <= 0 || !pt)
            return 0;

        for (var i = 0, len = this.obstructExtents.length; i < len; i++) {
            var obsExtent = this.obstructExtents[i];
            if (obsExtent.contain(pt))
                return obsExtent.o_Id;
        }

        return 0;
    }

    this.isLineObstruct = function(pt0,pt1){

        if (this.obstructLines.length ==0 || !pt0 || !pt1) {
            return false;
        }

        for (var i = 0; i < this.obstructLines.length; i++) {

            if(this.obstructLines[i].isCross(pt0,pt1))
                return true;
        }

        return false;
    }

    this.QueryNearestSameExtentElementByGeoPoint = function(pt, road, node, crossPt) {
        var dis = 99999999.0;
        var crossPtTmp = new fengmap.FMMapCoord; //fengmap.FMMapCoord
        var nodeTmp = new NaviNode;
        if (this.nodeVector.length <= 0 || this.roadVector.length <= 0) {
            return false;
        }

        var ptExtentId = this.QueryContainExtentId(pt);

        for (var i = 0; i < this.roadVector.length; i++) {

            var record = this.roadVector[i];
            if (ptExtentId != this.QueryContainExtentId(record.getStartPoint()) && ptExtentId != 0)
                continue;

            //endzzz
            var tmp = pt_distance_to_line(pt, record.getStartPoint(), record.getEndPoint(), crossPtTmp);
 
            if(this.isLineObstruct(crossPtTmp,pt))
                continue;

            if (tmp < dis) {
                dis = tmp;
                road.setRoad(record);
                crossPt.x = crossPtTmp.x;
                crossPt.y = crossPtTmp.y;
            }
        }

        if (!road)
            return false;

        var nodeId;
        if (DistanceofTwoPts(road.getStartPoint(), crossPt) <= DistanceofTwoPts(road.getEndPoint(), crossPt)) {
            nodeId = road.getStartId();
        } else {
            nodeId = road.getEndId();
        }

        for (var i = 0; i < this.nodeVector.length; i++) {

            var indexNode = this.nodeVector[i];
            if (indexNode.getId() == nodeId) {
                node.setNode(indexNode);
                break;
            }
        }
        return true;
    }

    // 计算距离pt点最近的Road与Node的记录，用于起终点的路段绑定，处理禁行路段
    this.QueryNearestSameExtentElementByGeoPoint_processForbid = function(pt, road, node, crossPt) {
        var dis = 99999999.0;
        var crossPtTmp = new fengmap.FMMapCoord; //fengmap.FMMapCoord
        var nodeTmp = new NaviNode;
        if (this.nodeVector.length <= 0 || this.roadVector.length <= 0) {
            return false;
        }

        var ptExtentId = this.QueryContainExtentId(pt);

        for (var i = 0; i < this.roadVector.length; i++) {

            var record = this.roadVector[i];

            if (0 != record.getRoadEntry()){
                continue;
            }

            if (ptExtentId != this.QueryContainExtentId(record.getStartPoint()) && ptExtentId != 0)
                continue;

            //endzzz
            var tmp = pt_distance_to_line(pt, record.getStartPoint(), record.getEndPoint(), crossPtTmp);
 
            if(this.isLineObstruct(crossPtTmp,pt))
                continue;

            if (tmp < dis) {
                dis = tmp;
                road.setRoad(record);
                crossPt.x = crossPtTmp.x;
                crossPt.y = crossPtTmp.y;
            }
        }

        if (road.m_Id==-1)
            return false;

        var nodeId;
        if (DistanceofTwoPts(road.getStartPoint(), crossPt) <= DistanceofTwoPts(road.getEndPoint(), crossPt)) {
            nodeId = road.getStartId();
        } else {
            nodeId = road.getEndId();
        }

        for (var i = 0; i < this.nodeVector.length; i++) {

            var indexNode = this.nodeVector[i];
            if (indexNode.getId() == nodeId) {
                node.setNode(indexNode);
                break;
            }
        }

        if (node.m_Id==-1) {
            return false;
        }

        return true;
    }
};

function liftNodeSort(nodes, distances, priority) {
    if (nodes.length <= 0)
        return;

    if (nodes.length != distances.length)
        return;

    modifyDistance(nodes, distances, priority);

    var nodeDistances = [];
    for (var i = 0, ilen = nodes.length; i < ilen; i++) {
        if (!distances[i]) continue;

        var nodeDistance = new NodeDistance();
        nodeDistance._node = nodes[i];
        nodeDistance._distance = distances[i];
        nodeDistances.push(nodeDistance);
    }

    nodeDistances = nodeDistances.sort(NodeDistanceFunc);

    var disLen = nodeDistances.length;
    if (nodes.length > disLen) nodes.splice(0, nodeDistances.length); //不改变原对象的指针
    if (distances.length > disLen) distances.splice(0, nodeDistances.size); //同上

    for (var i = 0; i < disLen; i++) {
        nodes[i] = nodeDistances[i]._node;
        distances[i] = nodeDistances[i]._distance;
    }
}

var kFirstPriorityOffset = 15.0;
var kSecondPriorityOffset = 8.0;

function modifyDistance(nodes, distances, priority) {
    if (priority == FMROUTE_CGP_DEFAULT) //同FMROUTE_CGP_ESCALATORFIRST
    {
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].getLiftType() == NaviLiftType_Escalator) {
                distances[i] -= kFirstPriorityOffset;
            } else if (nodes[i].getLiftType() == NaviLiftType_Lift) {
                distances[i] -= kSecondPriorityOffset;
            }
        }
    } else if (priority == FMROUTE_CGP_STAIRFIRST) {
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].getLiftType() == NaviLiftType_Stair) {
                distances[i] -= kFirstPriorityOffset;
            } else if (nodes[i].getLiftType() == NaviLiftType_Escalator) {
                distances[i] -= kSecondPriorityOffset;
            }
        }
    } else if (priority == FMROUTE_CGP_ESCALATORFIRST) {
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].getLiftType() == NaviLiftType_Escalator) {
                distances[i] -= kFirstPriorityOffset;
            } else if (nodes[i].getLiftType() == NaviLiftType_Lift) {
                distances[i] -= kSecondPriorityOffset;
            }
        }
    } else if (priority == FMROUTE_CGP_LIFTFIRST) {
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].getLiftType() == NaviLiftType_Lift) {
                distances[i] -= kFirstPriorityOffset;
            } else if (nodes[i].getLiftType() == NaviLiftType_Escalator) {
                distances[i] -= kSecondPriorityOffset;
            }
        }
    } else if (priority == FMROUTE_CGP_STAIRONLY) {
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].getLiftType() != NaviLiftType_Stair)
                distances[i] = null;
        }
    } else if (priority == FMROUTE_CGP_ESCALATORONLY) {
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].getLiftType() != NaviLiftType_Escalator)
                distances[i] = null;
        }
    } else if (priority == FMROUTE_CGP_LIFTONLY) {
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].getLiftType() != NaviLiftType_Lift)
                distances[i] = null;
        }
    }
}
// FengMap Navi Engine Tools

/**
* 点的坐标定义
*/
/*var GeoPoint =function(){
	var m_Longitude=0;
	var m_Latitude=0;

	this.setGeoPoint=function(other)
	{
		this.m_Longitude = other.m_Longitude;
		this.m_Latitude = other.m_Latitude;
	}
};*/

var REAL_EPSILON=0.00001;
var SMAE_EPSILON=0.00001;
var NEARLYSMAE_EPSILON=0.01;

//是否接近于0
function is_zero(f) 
{
	if (f<REAL_EPSILON && f>-REAL_EPSILON) {
		return true;
	}
	else {
		return false;
	}
}

//是否大于EPSILON
function gt_zero(f) 
{
	if (f>REAL_EPSILON) {
		return true;
	}
	else {
		return false;
	}
}

//是否小于EPSILON
function lt_zero(f) 
{
	if (f<-REAL_EPSILON) {
		return true;
	}
	else {
		return false;
	}
}

/**
 * 计算点到线段的最短距离和相应的垂点
 * @param mPt 某一点
 * @param startPt 线段的起点
 * @param endPt 线段的终点
 * @return 【fengmap.FMMapCoord】 垂点
 */
function pt_distance_to_line(mPt, startPt, endPt, crossPt) 
{
	var dist;
	var x0 = startPt.x, y0 = startPt.y;
	var x1 = endPt.x, y1 = endPt.y;
	var xx = mPt.x, yy = mPt.y;
	
	var v1x = x1-x0, v1y = y1-y0;
	var lv1 = Math.sqrt(v1x*v1x+v1y*v1y);  //终点到起点的距离
	
	var v2x = xx-x0, v2y = yy-y0;
	var lv2 = Math.sqrt(v2x*v2x+v2y*v2y);  //点pt到起点的距离
	
	// 如果线段非常短
	if (is_zero(lv1)) {
        crossPt.x = startPt.x;
        crossPt.y  = startPt.y;

		if (is_zero(lv2)) {
			dist = 0;
			return dist;
		}
		else {
			dist = lv2;
			return dist;
		}
	}
	
	var nv1x = v1x/lv1, nv1y = v1y/lv1;
	var dotv1v2 = nv1x*v2x+nv1y*v2y;  // 计算点pt在v1v2上的投影
	if (!gt_zero(dotv1v2)) {
		// 投影点在线段外v1前
		crossPt.x = startPt.x;
		crossPt.y  = startPt.y;
		dist = lv2;
		return dist;
	}
	else if (!lt_zero(dotv1v2-lv1)) {
		// 投影点在线段外v2后
		var v3x = xx-x1, v3y = yy-y1;
		var lv3 = Math.sqrt(v3x*v3x+v3y*v3y);
		crossPt.x = endPt.x;
		crossPt.y  = endPt.y;
		dist = lv3;
		return dist;
	}
	//投影点在中间
	var p1x = x0+dotv1v2*nv1x, p1y = y0+dotv1v2*nv1y;
	
	var vx = xx-p1x, vy = yy-p1y;
	var d = Math.sqrt(vx*vx+vy*vy);
	crossPt.x = p1x;
	crossPt.y  = p1y;
	dist = d;
	return dist;
}

/**
* 求 两点之间的平面距离
* @param pt1
* @param pt2
* @return
*/
function DistanceofTwoPts(pt1, pt2) {
	return Math.sqrt((pt1.x-pt2.x) * (pt1.x-pt2.x) +
			(pt1.y-pt2.y) * (pt1.y-pt2.y));
}

/**
* 判断两个point是否为同一个 精确到小数点后五位
* @param p0
* @param p1
* @return 【true】类似同一个点 【false】不是
*/
function is_same_pt(p0, p1) {
	if (Math.abs(p0.x - p1.x) <= SMAE_EPSILON
		&& Math.abs(p0.y - p1.y) <= SMAE_EPSILON) {
			return true;
	}
	else {
		return false;
	}
}

function is_nearlysame_pt(p0, p1) {
    if (Math.abs(p0.x - p1.x) <= NEARLYSMAE_EPSILON
        && Math.abs(p0.y - p1.y) <= NEARLYSMAE_EPSILON) {
            return true;
    }
    else {
        return false;
    }
}

/**
 * [getPolygonInnerPt 随机产生一个位于多边形内部的点]
 * @param  {[array]} polygon [多边形边界点数组]
 * @return {[coord]}         [return：多边形内部的点]
 */
function getPolygonInnerPt(polygon) {    
    if(polygon && polygon.length == 0) return {x:0,y:0};

    var len = polygon.length;

    if(len < 3) {
        return polygon[0];
    }

    var ptPre = polygon[0],ptCurr = polygon[1];

    var ptMid = {
        x:(ptPre.x + ptCurr.x) / 2,
        y:(ptPre.y + ptCurr.y) / 2
    }

    var dAlpha = Math.atan2(ptCurr.y - ptPre.y, ptCurr.x - ptPre.x);
    dAlpha -= Math.PI /2.0;

    var dLength = 3.0;
    while (dLength > 0.5)
    {
        var ptTmp = {x:ptMid.x+ dLength * Math.cos(dAlpha),y:ptMid.y + dLength * Math.sin(dAlpha)};
        
        if (isInPolygon(ptTmp, polygon))
        {
            return ptTmp;
        }
        
        dLength /= 2.0;
    }
    
    dAlpha +=  Math.PI;
    dLength = 3.0;
    while (dLength > 0.5)
    {
        var ptTmp = {x:ptMid.x+ dLength * Math.cos(dAlpha),y:ptMid.y + dLength * Math.sin(dAlpha)};
        
        if (isInPolygon(ptTmp, polygon))
        {
            return ptTmp;
        }
        
        dLength /= 2.0;
    }
    
    return {x:0,y:0};

}

/**
 * [isInPolygon 判断点是否在多边形中]
 * @param  {[coord]}  pt      [点]
 * @param  {[array<coord>]}  polygon [多边形边界数组]
 * @return {Boolean}         [是否在多边形内部]
 */
function isInPolygon(pt,polygon) {
    var bRet = false;

    var size = polygon.length;
    for(var i = 0, j = size - 1; i < size; j = i, ++i)
    {
        var sx = polygon[i].x;
        var sy = polygon[i].y;
        var tx = polygon[j].x;
        var ty = polygon[j].y;
            
        // 点与多边形顶点重合
        if((sx == pt.x && sy == pt.y) || (tx == pt.x && ty == pt.y))
        {
            return true;
        }
            
        // 判断线段两端点是否在射线两侧
        if((sy < pt.y && ty >= pt.y) || (sy >= pt.y && ty < pt.y))
        {
            // 线段上与射线 Y 坐标相同的点的 X 坐标
            var x = sx + (pt.y - sy) * (tx - sx) / (ty - sy);
                
            // 点在多边形的边上
            if(x == pt.x)
            {
                return true;
            }
                
            // 射线穿过多边形的边界
            if(x > pt.x)
            {
                bRet = !bRet;
            }
        }
    }
        
    // 射线穿过多边形边界的次数为奇数时点在多边形内
    return bRet;
}

function NaviMap() 
{   
    /** 存放键的数组(遍历用到) */  
    this.keys = new Array();   
    /** 存放数据 */  
    this.data = new Object();   
       
    
    this.clear = function(){
//    	for (var i = 0; i < this.keys.length; i++)
//    	{
//    		this.remove(this.keys[i]);
//    	};
    	
    	delete this.keys;
    	delete this.data;
    	this.keys = new Array();  
    	this.data = new Object();
    }
    
    /**  
     * 放入一个键值对  
     * @param {String} key  
     * @param {Object} value  
     */  
    this.put = function(key, value) {   
        if(this.data[key] == null){   
            this.keys.push(key);   
        }   
        this.data[key] = value;   
    };   
       
    /**  
     * 获取某键对应的值  
     * @param {String} key  
     * @return {Object} value  
     */  
    this.get = function(key) { 
        return this.data[key];   
    };   
       
    /**  
     * 删除一个键值对  
     * @param {String} key  
     */  
    this.remove = function(key) {   
        this.keys.remove(key);   
        this.data[key] = null;   
    };   
       
    /**  
     * 遍历Map,执行处理函数  
     *   
     * @param {Function} 回调函数 function(key,value,index){..}  
     */  
    this.each = function(fn){   
        if(typeof fn != 'function'){   
            return;   
        }   
        var len = this.keys.length;   
        for(var i=0;i<len;i++){   
            var k = this.keys[i];   
            fn(k,this.data[k],i);
        }   
    };   
       
    /**  
     * 获取键值数组(类似Java的entrySet())  
     * @return 键值对象{key,value}的数组  
     */  
    this.entrys = function() {   
        var len = this.keys.length;   
        var entrys = new Array(len);   
        for (var i = 0; i < len; i++) {   
            entrys[i] = {   
                key : this.keys[i],   
                value : this.data[i]   
            };   
        }   
        return entrys;   
    };   
       
    /**  
     * 判断Map是否为空  
     */  
    this.isEmpty = function() {   
        return this.keys.length == 0;   
    };   
       
    /**  
     * 获取键值对数量  
     */  
    this.size = function(){   
        return this.keys.length;   
    };   
       
    /**  
     * 重写toString   
     */  
    this.toString = function(){   
        var s = "{";   
        for(var i=0;i<this.keys.length;i++,s+=','){   
            var k = this.keys[i];   
            s += k+"="+this.data[k];   
        }   
        s+="}";   
        return s;   
    };   
}   
/**
 * fengmap.FMNaviZoneDijkstra
 */

var FMNaviZoneSubDijkstra = function(options) {
	fengmap.NaviDijkstra_.call(this, options);
}

FMNaviZoneSubDijkstra.prototype = Object.create(fengmap.NaviDijkstra_.prototype);

FMNaviZoneSubDijkstra.prototype = {
	getNearestAccessNodeCoord: function(groupID, point, targetGroupID) {
		if (!this.naviRcDB.get(groupID)) return null;

		var graph = this.naviRcDB.get(groupID);
		var node = new NaviNode();
		node = graph.queryNearestLiftNodeByPoint(targetGroupID, point);
		if (!node) return null;

		var coord = node.getGeoPoint();
		return coord;
	},
	getNearestEntranceCoord: function(groupID, point, type) {
		if (!this.naviRcDB.get(groupID)) return null;
		var graph = this.naviRcDB.get(groupID);
		return graph.queryEntranceCoordByPoint(point, type);
	}
}

fengmap.FMNaviZoneDijkstra = function(options) {

	this.options = new fengmap.NaviOptions(options);
	this.naviService = new fengmap.NaviService(this.options);

	this._results = []; //结果数组

	this.initByMap = function(map) {
		if (!(map && map.mapService && map.mapService.staticScene_ && map.mapService.staticScene_.floors))
			return;

		//清空之前的数据
		this._naviRcDB = new NaviMap();
		this._zoneMap = {};
		this._zoneDijkstrs = {};

		var zones = {},
			this_ = this;

		// this.naviService.queryZone(map.sceneId_, function(zones) {
		// 	var zoneObj = zones.navizones;
		// 	for (var i = 0, ilen = zoneObj.length; i < ilen; i++) {
		// 		var zoneObjGroup_ = zoneObj[i];
		// 		zones[zoneObjGroup_.groupID] = [];

		// 		for (var j = 0, jlen = zoneObjGroup_.zones.length; j < jlen; j++) {
		// 			var groupZone = zoneObjGroup_.zones[j];
		// 			var zonePnts = new navigeo.GData().toPointsArr(groupZone.coords);
		// 			var zone = new NaviZone(groupZone.id, zoneObjGroup_.groupID, groupZone.type, zonePnts);
		// 			zones[zoneObjGroup_.groupID].push(zone);
		// 		}
		// 	}

			var floors = map.mapService.staticScene_.floors;

			floors.forEach(function (floor) {
				var naviArr = floor.navi;

				naviArr.forEach(function (navi) {
					var zs = navi.zones;

					if (!zones[navi.gid]) {
						zones[navi.gid] = [];
					}

					zs.forEach(function (z) {
						var parser = new navigeo.GData();
						var zonePnts = parser.parsePnt(z.geo).points_;

						if (zonePnts.length) {
							zonePnts.length --;
						}

						var zone = new NaviZone(z.id, navi.gid, z.type, zonePnts);
						zones[navi.gid].push(zone);
					})

				})
			})

			this_._zoneMap = zones;

			var groups = map.mapService.staticScene_.floors;
			for (var i in groups) {
				var groupId = groups[i].gid;
				if (groupId == undefined) {
					continue;
				}

				var geo = groups[i].geo[0];
				var biz = groups[i].biz[0];
				var nav = groups[i].navi[0];
				var navi = this_.naviService.convertToGroup__(groupId, geo, biz, nav);
				var nodes = [];
				for (var j in navi.naviNodes) {
					var node = navi.naviNodes[j];
					if (node.nodeId == undefined) {
						continue;
					}
					nodes[j] = new NaviNode();
					nodes[j].m_Id = node.nodeId;
					nodes[j].m_Point = node.geoArr;
					nodes[j].setNodeType(node.nodeType);
					nodes[j].setLiftType(node.liftType);
					nodes[j].m_LiftId = node.liftFlag;

					nodes[j].m_SegLinks = node.linkSegArr;
					nodes[j].m_LiftFloors = node.liftFloorArr;
				}

				var roads = [];
				for (var k in navi.naviSegments) {
					var road = navi.naviSegments[k];
					var pnts = road.geoArr;
					if (!pnts) {
						continue;
					}
					roads[k] = new NaviRoad();

					roads[k].m_Id = road.segmentId;
					roads[k].m_StartId = road.snode;
					roads[k].m_StartPoint = pnts[0];
					roads[k].m_EndId = road.enode;
					roads[k].m_EndPoint = pnts[1];
					roads[k].m_Length = road.length;
					roads[k].setRoadEntry(road.entry);
					roads[k].setRoadRank(road.rank);
				}

				var naviObsModels = [],
					naviObsExtents = [];
				for (var l = 0, len = navi.extentLayer.length; l < len; l++) {
					var extlayer = navi.extentLayer[l];
					var obs = new NaviObstruct();
					obs.o_Id = extlayer.eid;
					obs.o_Points = extlayer.geoArr;
					naviObsExtents.push(obs);
				}

				for (var m = 0, mlen = navi.modelLayer.length; m < mlen; m++) {
					var fmodellayer = navi.modelLayer[m];
					var obs = new NaviObstruct();
					obs.o_Id = fmodellayer.eid;
					obs.o_Fid = fmodellayer.fid;
					//--useless
					//obs.o_CenterPnt = fmodellayer.center;
					obs.o_Points = fmodellayer.geoArr;
					naviObsModels.push(obs);
				}

				var graph = new NaviGraph(nodes, roads, true, 1);
				if (naviObsModels.length > 0 && naviObsExtents.length > 0) {
					graph.obstructExtents = naviObsExtents;
					graph.obstructModels = naviObsModels;
				}
				this_._naviRcDB.put(navi.gid, graph);
			}

			this_.init();
		// });
	}

	this.init = function() {
		for (var i in this._zoneMap) {
			if (!this._naviRcDB.get(i)) continue;
			var originGraph = this._naviRcDB.get(i);
			var zones = this._zoneMap[i];
			if (!this._zoneDijkstrs[i])
				this._zoneDijkstrs[i] = {};

			for (var j = 0, jlen = zones.length; j < jlen; j++) {
				var zone = zones[j];
				var subGraph = this.stripGraph(originGraph, zone);

				if (!subGraph) {
					this._zoneDijkstrs[i][zone.id] = null;
					continue;
				}

				//subGraph.simplify();

				var subNaviRcDB = new NaviMap();
				subNaviRcDB.put(i, subGraph);

				var subDijkstra = new FMNaviZoneSubDijkstra({});
				subDijkstra.initNaviByNaviMap(subNaviRcDB);
				this._zoneDijkstrs[i][zone.id] = subDijkstra;
			}

			originGraph.simplify();
		}

		this._originDijkstra = new fengmap.NaviDijkstra_({});
		this._originDijkstra.initNaviByNaviMap(this._naviRcDB);
	}

	this.stripGraph = stripGraphFunc.bind(this);

	this.isPointInZone = isPointInZone;

	this.calcCorssPoint = calcCorssPoint;

	this.getIndexFormID = getIndexFormID;

	this.getPointContainZone = function(groupID, point) {

		if (!this._zoneMap[groupID]) return null;

		var zone = null;
		var zones = this._zoneMap[groupID];
		//pntArr = [point.x, point.y];

		for (var i = 0, ilen = zones.length; i < ilen; i++) {
			if (this.isPointInZone(zones[i], point) == 1) {
				zone = zones[i];
				break;
			}
		}

		return zone;
	}

	this.getRouteCalculateAllLength = function() {
		var length = 0;

		for (var i = 0, ilen = this._results.length; i < ilen; i++) {
			var res = this._results[i];
			length += res.length;
		}
		return length;
	}

	this.getOriginNaviDataMap = function() {
		return this._naviRcDB;
	}

	this.FMRC_GetRouteCalculateResult = function() {
		return this._results;
	}

	this.FMRC_SpanRouteCalculate = function(startGroupId, start, endGroupId, end, module) {
		return this.RouteCalculate(startGroupId, start, endGroupId, end, module);
	}

	this.RouteCalculate = function(startGroupId, startPoint, endGroupId, endPoint, module) {
		this._results = [];
		var type;
		var szone = this.getPointContainZone(startGroupId, startPoint);
		var ezone = this.getPointContainZone(endGroupId, endPoint);
		var sDijkstra;
		if (szone) sDijkstra = this._zoneDijkstrs[startGroupId][szone.id];

		var eDijkstra;
		if (ezone) eDijkstra = this._zoneDijkstrs[endGroupId][ezone.id];

		if (sDijkstra == eDijkstra) {
			if (!sDijkstra) {
				type = this._originDijkstra.FMRC_SpanRouteCalculate(startGroupId, startPoint, endGroupId, endPoint, module);
				if (type == ROUTE_SUCCESS)
					this._results = this._originDijkstra.FMRC_GetRouteCalculateResult();
			} else {
				type = sDijkstra.FMRC_SpanRouteCalculate(startGroupId, startPoint, endGroupId, endPoint, module);
				if (type == ROUTE_SUCCESS)
					this._results = sDijkstra.FMRC_GetRouteCalculateResult();

			}
		} else {
			if (!sDijkstra) {
				var coord = eDijkstra.getNearestEntranceCoord(endGroupId, endPoint, NaviEntranceType_ENTRANCE, coord);
				if (!coord)
					return ROUTE_FAILED_CANNOT_ARRIVE;

				type = this._originDijkstra.FMRC_SpanRouteCalculate(startGroupId, startPoint, endGroupId, coord, module);
				if (type != ROUTE_SUCCESS) return type;

				this._results = this._originDijkstra.FMRC_GetRouteCalculateResult();
				type = eDijkstra.FMRC_SpanRouteCalculate(endGroupId, coord, endGroupId, endPoint, module);
				if (type != ROUTE_SUCCESS)
					return type;
				var results = [];
				results = eDijkstra.FMRC_GetRouteCalculateResult();
				this._results = this._results.concat(results);
			} else if (!eDijkstra) {
				var coord = sDijkstra.getNearestEntranceCoord(startGroupId, startPoint, NaviEntranceType_ENTRANCE);
				if (!coord)
					return ROUTE_FAILED_CANNOT_ARRIVE;

				type = sDijkstra.FMRC_SpanRouteCalculate(startGroupId, startPoint, startGroupId, coord, module);
				if (type != ROUTE_SUCCESS)
					return type;

				this._results = sDijkstra.FMRC_GetRouteCalculateResult();

				type = this._originDijkstra.FMRC_SpanRouteCalculate(startGroupId, coord, endGroupId, endPoint, module);
				if (type != ROUTE_SUCCESS) return type;

				var results = this._originDijkstra.FMRC_GetRouteCalculateResult();
				this._results = this._results.concat(results);

			} else {
				if (szone.id == ezone.id) {
					var coord = sDijkstra.getNearestAccessNodeCoord(startGroupId, startPoint, endGroupId);
					if (!coord) {
						coord = sDijkstra.getNearestAccessNodeCoord(startGroupId, endPoint, endGroupId);
					}

					if (coord) {
						type = sDijkstra.FMRC_SpanRouteCalculate(startGroupId, startPoint, startGroupId, coord, module);
						if (type == ROUTE_SUCCESS) {
							this._results = sDijkstra.FMRC_GetRouteCalculateResult();
							type = eDijkstra.FMRC_SpanRouteCalculate(endGroupId, coord, endGroupId, endPoint, module);
							if (type == ROUTE_SUCCESS) {
								var eResults = [];
								eResults = eDijkstra.FMRC_GetRouteCalculateResult();
								this._results = this._results.concat(eResults);
							}
						}
					}
				}

				if (type != ROUTE_SUCCESS) this._results = [];

				if (type != ROUTE_SUCCESS) {
					var sCoord = sDijkstra.getNearestEntranceCoord(startGroupId, startPoint, NaviEntranceType_EXIT, sCoord);
					if (!sCoord)
						return ROUTE_FAILED_CANNOT_ARRIVE;

					var eCoord = eDijkstra.getNearestEntranceCoord(endGroupId, endPoint, NaviEntranceType_ENTRANCE, eCoord);
					if (!eCoord)
						return ROUTE_FAILED_CANNOT_ARRIVE;

					type = sDijkstra.FMRC_SpanRouteCalculate(startGroupId, startPoint, startGroupId, sCoord, module);
					if (type != ROUTE_SUCCESS)
						return type;

					this._results = sDijkstra.FMRC_GetRouteCalculateResult();

					type = this._originDijkstra.FMRC_SpanRouteCalculate(startGroupId, sCoord, startGroupId, eCoord, module);
					if (type != ROUTE_SUCCESS)
						return type;

					var mResults = this._originDijkstra.FMRC_GetRouteCalculateResult();
					this._results = this._results.concat(mResults);

					type = eDijkstra.FMRC_SpanRouteCalculate(endGroupId, eCoord, endGroupId, endPoint, module);
					if (type != ROUTE_SUCCESS)
						return type;

					var eResults = eDijkstra.FMRC_GetRouteCalculateResult();
					this._results = this._results.concat(eResults);
				}
			}
		}
		return type;
	}
}

function getIndexFormID (nodes, nodeSize, id) {
	for (var i = 0; i < nodeSize; i++) {
		if (!nodes[i])
			continue;

		if (nodes[i].m_Id == id)
			return i;
	}

	return -1;
}

function isPointInZone (zone, point) {

	if (zone._bb.minX_ > point.x || zone._bb.maxX_ < point.x)
		return 0;

	if (zone._bb.minY_ > point.y || zone._bb.maxY_ < point.y)
		return 0;

	return ptInPolygon2d(zone._pointVector, point, zone._pointNum);
}

function calcCorssPoint (zone, start, end, cross) {
	var cross = new Array();
	for (var i = 0; i < zone._pointNum; i++) {
		var p1 = zone._pointVector[i];
		var p2 = zone._pointVector[(i + 1) % zone._pointNum];

		if (calcCrossPoint(p1, p2, start, end, cross) == 1)
			break;
	}

	return cross;
}


/**
 * 提出来的 stripGraph 方法
 */
function stripGraphFunc(graph, zone) {
	
	if (!graph || !zone) return;

	var startIn = 0,
		endIn = 0,
		roadSize = graph.roadVector.length,
		nodeSize = graph.nodeVector.length,
		roads = graph.roadVector,
		nodes = graph.nodeVector,
		isIn = 0;

	var newRoadMarks = new Int8Array(roadSize); //0-不在范围内 1-起终点都在范围内 2-只起点在范围内 3-只终点在范围内

	for (var i = 0; i < roadSize; i++) {
		if (!roads[i]) continue;

		var road = roads[i];
		startIn = this.isPointInZone(zone, road.getStartPoint());
		endIn = this.isPointInZone(zone, road.getEndPoint());

		if (startIn == 1) {
			if (endIn == 1)
				newRoadMarks[i] = 1;
			else
				newRoadMarks[i] = 2;

			isIn = 1;
			continue;
		}

		if (endIn == 1) {
			if (startIn == 1)
				newRoadMarks[i] = 1;
			else
				newRoadMarks[i] = 3;

			isIn = 1;
			continue;
		}

	}

	if (isIn == 0) return null;

	var newNodes = new Array(nodeSize),
		newRoads = new Array(roadSize),
		nodeIndex = 0,
		stripNodeMarks = new Int8Array(nodeSize);

	//先处理2 3类型
	for (var i = 0, ilen = newRoadMarks.length; i < ilen; i++) {
		if (newRoadMarks[i] == 0 || newRoadMarks[i] == 1)
			continue;

		if (!roads[i])
			continue;

		var road = roads[i],
			cross;

		cross = this.calcCorssPoint(zone, road.getStartPoint(), road.getEndPoint());

		var seglink = [road.m_Id];

		var newNode = new NaviNode();
		newNode.setNodeType(NaviNodeType_COMMON);
		newNode.setLiftType(NaviLiftType_NULL);
		newNode.setEntranceType(NaviEntranceType_ACCESS);
		newNode.setGeoPoint(cross);
		newNode.m_SegLinks = seglink;

		var newRoad = new NaviRoad();
		newRoad.setRoad(road);
		if (newRoadMarks[i] == 2) {
			var copyNode = new NaviNode();
			copyNode.setNode(newNode);

			nodeIndex = this.getIndexFormID(nodes, nodeSize, newRoad.getEndId());
			copyNode.m_Id = nodes[nodeIndex].m_Id;
			newRoad.m_EndPoint = copyNode.getGeoPoint();
			//newRoad.m_PointVector[1] = copyNode.getGeoPoint();
			newRoad.calcLength(); //重新计算距离
			newRoads[i] = newRoad;

			newNodes[nodeIndex] = copyNode;
			nodeIndex = this.getIndexFormID(nodes, nodeSize, newRoad.getStartId());
			newNodes[nodeIndex] = nodes[nodeIndex];

			var copyNode1 = new NaviNode();
			copyNode1.setNode(newNode);
			copyNode1.m_Id = nodes[nodeIndex].m_Id;
			road.m_StartPoint = copyNode1.getGeoPoint();
			//road.m_PointVector[0] = copyNode1.getGeoPoint();
			road.calcLength(); //need varify
			nodes[nodeIndex] = copyNode1;

			stripNodeMarks[nodeIndex] = 2;
		} else {
			var copyNode = new NaviNode();
			copyNode.setNode(newNode);

			nodeIndex = this.getIndexFormID(nodes, nodeSize, newRoad.getStartId());
			copyNode.m_Id = nodes[nodeIndex].m_Id;
			newRoad.m_StartPoint = copyNode.getGeoPoint();
			//newRoad.m_PointVector[0] = copyNode.getGeoPoint();
			newRoad.calcLength(); //重新计算距离
			newRoads[i] = newRoad;

			newNodes[nodeIndex] = copyNode;
			nodeIndex = this.getIndexFormID(nodes, nodeSize, newRoad.getEndId());
			newNodes[nodeIndex] = nodes[nodeIndex];

			var copyNode1 = new NaviNode();
			copyNode1.setNode(newNode);

			copyNode1.m_Id = nodes[nodeIndex].m_Id;
			road.m_EndPoint = copyNode1.getGeoPoint();
			//road.m_PointVector[1] = copyNode1.getGeoPoint();
			road.calcLength(); //need varify
			nodes[nodeIndex] = copyNode1;

			stripNodeMarks[nodeIndex] = 2;
		}

		// delete newNode;
		// newNode = null;
	}

	//处理 1类型
	for (var i = 0, ilen = newRoadMarks.length; i < ilen; i++) {
		if (newRoadMarks[i] != 1) continue;

		var road = roads[i];
		if (!road)
			continue;

		newRoads[i] = road;
		nodeIndex = this.getIndexFormID(nodes, nodeSize, road.getStartId());

		if (stripNodeMarks[nodeIndex] != 2) {
			newNodes[nodeIndex] = nodes[nodeIndex];
			stripNodeMarks[nodeIndex] = 1;
		}

		nodeIndex = this.getIndexFormID(nodes, nodeSize, road.getEndId());
		if (stripNodeMarks[nodeIndex] != 2) {
			newNodes[nodeIndex] = nodes[nodeIndex];
			stripNodeMarks[nodeIndex] = 1;
		}

		roads[i] = null;
	}

	for (var j = 0; j < nodeSize; j++) {
		if (stripNodeMarks[j] == 1)
			nodes[j] = null;
	}

	var newNaviGraph = new NaviGraph(newNodes, newRoads, true, 1);

	return newNaviGraph;
	
}
/**
 * 
 */

var navigeo = navigeo || {};


navigeo.GData = function() {
	this.points_;// = [];
};

navigeo.GLEN1 = 'MULTIPOLYGON((('.length;
navigeo.GLEN2 = 'POINT('.length;
navigeo.GLEN3 = 'MULTILINESTRING(('.length;

navigeo.GData.prototype = {
	parse:function(txt) {
		this.points_ = [];
		this.holes_ = [];
		//console.log(txt);
		if (txt.indexOf('MULTIPOLYGON(((') == 0) {
			var xys_s = txt.substring(navigeo.GLEN1,txt.length - 3).split(/\),\(/);
			//console.log(xys_s.length);
			for (var j=0;j<xys_s.length; j++) {
				var xys = xys_s[j].split(/,/);
				//console.log(xys);
				if (j == 0) {
					for (var i=0; i<xys.length; i++) {
						var xy = xys[i].split(' ');
						this.points_.push({x:parseFloat(xy[0]), y:parseFloat(xy[1])});
					}
				} else {//> 0
					var hole = [];
					for (var i=0; i<xys.length; i++) {
						var xy = xys[i].split(' ');
						hole.push({x:parseFloat(xy[0]), y:parseFloat(xy[1])});
					}
					this.holes_.push(hole);
				}
			}
		} else if (txt.indexOf('POINT(') == 0) {
			var xy = txt.substring(navigeo.GLEN2,txt.length - 1).split(' ');
			this.points_.push({x:parseFloat(xy[0]), y:parseFloat(xy[1])});
		} else if (txt.indexOf('MULTILINESTRING((') == 0) {
			var xys = txt.substring(navigeo.GLEN3,txt.length - 2).split(',');
			//console.log(xys);
			for (var i=0; i<xys.length; i++) {
				var xy = xys[i].split(' ');
				this.points_.push({x:parseFloat(xy[0]), y:parseFloat(xy[1])});
			}
		}
		return this;
	},
	parsePnt:function(txt) {
		this.points_ = [];
		//console.log(txt);
		if (txt.indexOf('MULTIPOLYGON(((') == 0) {
			var xys = txt.substring(navigeo.GLEN1,txt.length - 3).split(',');
			//console.log(xys);
			for (var i=0; i<xys.length; i++) {
				var xy = xys[i].split(' ');
				this.points_.push({x:parseFloat(xy[0]), y:parseFloat(xy[1])});
			}
		} else if (txt.indexOf('POINT(') == 0) {
			var xy = txt.substring(navigeo.GLEN2,txt.length - 1).split(' ');
			this.points_.push({x:parseFloat(xy[0]), y:parseFloat(xy[1])});
		} else if (txt.indexOf('MULTILINESTRING((') == 0) {
			var xys = txt.substring(navigeo.GLEN3,txt.length - 2).split(',');
			//console.log(xys);
			for (var i=0; i<xys.length; i++) {
				var xy = xys[i].split(' ');
				this.points_.push({x:parseFloat(xy[0]), y:parseFloat(xy[1])});
			}
		}
		return this;
	},
	toPntStrip:function(removeLast) {
		var strip = [];
		var len = this.points_.length;
		if (removeLast === true) {
			if (len >= 1) {
				for (var i=0; i<len - 1; i++) {
					var p = this.points_[i];
					strip.push(p.x, p.y);
				}
			}
		} else {
			for (var i=0; i<len; i++) {
				var p = this.points_[i];
				strip.push(p.x, p.y);
			}
		}
		return strip;
	},
}


/**
 * 
 */
fengmap.MapBoxCollision = function() {
	this.rects_ = [];
};
fengmap.MapBoxCollision.prototype = {
	clear: function() {
		this.rects_.length = 0;
	},
	push: function(label, rect) {
		if (this.rects_.length == 0) {
			this.rects_.push(rect);
			return false;
		} else {
			for (var i in this.rects_) {
				var rect_a = this.rects_[i];
				if (this.collision_(rect_a, rect)) {
					return true;
				}
			}
			this.rects_.push(rect);
			return false;
		}
	},
	// -------------------------------------------------------------------------
	// Private
	collision_: function(rect1, rect2) {
		// return (
		// 	rect1.x < rect2.x + rect2.w &&
		// 	rect1.x + rect1.w > rect2.x &&
		// 	rect1.y < rect2.y + rect2.h &&
		// 	rect1.h + rect1.y > rect2.y
		// );
		return (!(
				rect1.x > rect2.x + rect2.w ||
				rect1.x + rect1.w < rect2.x ||
				rect1.y > rect2.y + rect2.h ||
				rect1.h + rect1.y < rect2.y
			)
		);
	}
	
};

/**
 * Created by CastingJ on 17/5/12.
 */

/**
 * 定位坐标转地图坐标
 * @class MapCoordTransform
 * @constructor MapCoordTransform
 * @namespace fengmap
 * @demo navi/定位坐标转换.js
 */
fengmap.MapCoordTransform = function() {
    var _locOrigion;
    var _locRange;

    var _mapOrigion;
    var _mapAxisX;
    var _mapAxisY;
    var _mapRange;

    this.getVectorLen = function(vector) {
        return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
    }

    /**
     * 转化器的初始配置，定位图上的4个角点与地图的坐标对应关系
     * @method init
     * @param  {JSON} locOrigion {x:, y: } 定位坐标原点， 如： {x: 0, y: 0}
     * @param  {JSON} locRange   {x:, y: } 定位范围 如： {x: 100, y: 100}
     * @param  {Array} mapParas   定位图上的四个角点对应的地图坐标数组,逆时针序列。[0]:定位原点地图坐标，[1]:X轴终点地图坐标，[2]:定位原点对角点地图坐标，[3]:Y轴终点地图坐标，如：[{x: 13502836.48, y: 3658566.56}, {x:, y:}, {x:, y:}, {x:, y:}]
     * @return {null}
     */
    this.init = function(locOrigion, locRange, mapParas) {
        if (mapParas.length != 4)
            return false;

        _locOrigion = locOrigion;
        _locRange = locRange;

        _mapOrigion = mapParas[0];
        _mapAxisX = {
            'x': mapParas[1].x - mapParas[0].x,
            'y': mapParas[1].y - mapParas[0].y
        };
        _mapAxisY = {
            'x': mapParas[3].x - mapParas[0].x,
            'y': mapParas[3].y - mapParas[0].y
        };
        _mapRange = {
            'x': this.getVectorLen(_mapAxisX),
            'y': this.getVectorLen(_mapAxisY)
        };

        //向量单位化
        _mapAxisX.x /= _mapRange.x;
        _mapAxisX.y /= _mapRange.x;
        _mapAxisY.x /= _mapRange.y;
        _mapAxisY.y /= _mapRange.y;

    };

    /**
     * 定位坐标转换方法
     * @method transform
     * @param  {JSON} loc {x:, y:}定位图上的坐标点， 如{x: 45, y: 150}
     * @return {fengmap.MapCoord}     返回对应的地图坐标
     */
    this.transform = function(loc) {
        var offstRatio = {
            'x': (loc.x - _locOrigion.x) / _locRange.x,
            'y': (loc.y - _locOrigion.y) / _locRange.y
        };

        var mapOffset = {
            'x': offstRatio.x * _mapRange.x,
            'y': offstRatio.y * _mapRange.y
        };
        var mapCoord = {
            'x': _mapOrigion.x + _mapAxisX.x * mapOffset.x + _mapAxisY.x * mapOffset.y,
            'y': _mapOrigion.y + _mapAxisX.y * mapOffset.x + _mapAxisY.y * mapOffset.y
        };

        return mapCoord;
    };

}
/**
 * 
 */

fengmap.MapLabel = function(gid, label, style, map,nodeType) {

	this.map = map;
	
	this.data_ = label;
	this.data_.gid = gid;
	
	if (label.vertex) {
		this.data_.x_ = label.vertex[0];
		this.data_.y_ = label.vertex[1];
	}

	this.width_;
	this.height_;
	this.material_ = null;

	this.scaleRatio_ = 2;

	this.enabledUpdateSize = true;

	this.message = label.name;
	
	//如果是label类型
	if(!nodeType) {
		if(this.map.options.defaultLabelLanguage === fengmap.FMLanguageType.EN) {
			this.message = label.ename;
		}		
	}

	style = style || {};

	style.imageAlign = style.imageAlign || 'left';
	style.imageSize = null;
	style.imageSpace = style.imageSpace || 4;
	style.textSpace = style.textSpace || 4;
	style.pivotType = style.pivotType || 'center';
	this.style = style;

	this.originPosition = null;
	this.pivotOffset    = null;
	this.pivot_         = null;
	this.originPivot    = null;
	this.iconPivot      = null;	

	// 制作文字
	this.updateStyle(style);

	fm.Sprite.call(this, this.material_);
};

fengmap.MapLabel.prototype = new fm.Sprite();

Object.defineProperties(fengmap.MapLabel.prototype, {
	// 设置轴心
	pivot: {
		get: function() {
			return this.pivot_;
		},
		set: function(val) {
			if (!(val instanceof fm.Vector3)) {
				return;
			}
			this.pivot_ = val;
			this.pivotOffset = new fm.Vector3(this.width_ / 2 - val.x , 0, val.y - this.height_ / 2);

			// use YXZ order!
			var euler = new fm.Euler( this.map.controls.getPolarAngle(),
										this.map.controls.getAzimuthalAngle(), 0, 'YXZ');
			var rotationMatrix = new fm.Matrix4().makeRotationFromEuler( euler );

			this.position.copy(this.originPosition.clone().add(
					this.pivotOffset.clone().multiplyScalar(this.meterperpixel_).applyMatrix4( rotationMatrix ))
			);
		},
	}
});

/**
 * 闪烁效果(放大缩小)
 * @method flash
 * @param  {json} params [{scale: time: callback:}]
 * @return {null}        [null]
 */

// 设置位置的标准接口
fengmap.MapUtil._setGeneralProperties(fengmap.MapLabel.prototype, 'originPosition');

Object.assign(fengmap.MapLabel.prototype, {
	setname: function(v){
		this.message = v;
		this.updateStyle();
	},
	setText: function(v) {
		this.setname(v);
	},
	setfontsize: function(v){
		this.style.fontsize = v;
		this.updateStyle();
	},
	setfillcolor: function(v){
		this.style.fillcolor = v;
		this.updateStyle();
	},
	setfontstrokecolor: function(v){
		this.style.strokecolor = v;
		this.updateStyle();
	}
});

/**
 * Marker's functions to invoke o3d_
 */
fengmap.MapLabel.parentFunctions = {
	alwaysShow: function(boo, ro) {
		this.o3d_.alwaysShow(boo, ro);
	},
	flash: function(ps) {
		return this.o3d_.flash(ps);
	},
	jump: function(ps) {
		return this.o3d_.jump(ps);
	},
	moveTo: function(ps) {
		this.o3d_.moveTo(ps);
	},
	stopJump: function(ps) {
		this.o3d_.stopJump(ps);
	},
	stopFlash: function (ps) {
		this.o3d_.stopFlash(ps);
	},
	stopMoveTo: function (ps) {
		this.o3d_.stopMoveTo(ps);
	}
};

/**
 * Label, POI 等的共用方法
 */
fengmap.MapLabel.generalFunctions = {
	updateScreenSize: function(mapView) {
		if (this.enabledUpdateSize === undefined) {
			this.enabledUpdateSize = true;
		}

		if (!this.enabledUpdateSize || !this.parent) {
			return;
		}

		mapView = mapView || fengmap.Map.instance.mapView;

		var camera = mapView.map_.currentCamera_;

		if (!this.originPosition) {
			this.originPosition = this.position.clone();
		}

		if (this.initY_ == undefined || isNaN(this.initY_)) {
			if (isNaN(this.position.y)) {
				this.position.y = 0;
			}
			this.initY_ = this.position.y;
		}

		if (mapView.map_.viewMode == '3d') {
			if(mapView.h_ == 0) return;

			this._lastScale = undefined;

			// 设置轴心的偏移  2016/10/31 去掉了这个轴心的设置.
			// 因为现在还不需要这么高级的功能,反而会在创建的时候会跳一下.
			if (this.pivot_) {
				// this.pivot = this.pivot_;
			}
			
			this.position.setY(this.initY_);

			// 得到3D相机中的物体缩放
			var res = fengmap.MapLabel.getPerspectiveScale(this, mapView);

			var h = this.height_ * res.meterperpixel / 2;
			var _h = this.notAddImageHeight ? 0 : h;

			this.position.setY(this.initY_ + _h);

			this.scale.copy(res.scale);
		} else {
			if (mapView.map_.mapTheme.version == 1) {
				this._lastScale = fengmap.MapLabel.getPerspectiveScale(this, mapView).scale;
				this.scale.copy(this._lastScale.clone().multiplyScalar(1 / camera.zoom));
			} else {
				var res = fengmap.MapLabel.getPerspectiveScale(this, mapView);
				this.scale.copy(res.scale);
			}
		}
	},

	alwaysShow: function(boo, renderOrder) {
		var alias = fengmap.MapUtil.getAlias(this.fm_);
		var _ro = fengmap.FMRenderOrder[alias];

		renderOrder = renderOrder == undefined ? (_ro == undefined ? 25 : _ro) : renderOrder;

		boo = boo == undefined ? true : boo;
		// 20161201  四川人报的问题. 有时是没有material的, 会报错
		if (!this.material) {return;}
		// this.material.depthWrite = !boo;
		this.material.depthTest = !boo;
		this.renderOrder = boo ? renderOrder : 0;
	},

	stopFlash: function(params) {
		clearInterval(this._flashID);
		this.width_ = this.originSize.width;
		this.height_ = this.originSize.height;
		this._isAnimating = false;
	},

	stopJump: function(params) {
		if (!params) {
			return;
		}
		clearInterval(this._jumpID);
		this.initY_ = params._initY;
		this._isAnimating = false;
	},

	stopMoveTo: function(params) {
		clearInterval(this._moveToID);
		this._isAnimating = false;
	},

	flash: function(params) {
		var s = this;

		if (this._isAnimating && !params.force) {
			return;
		}

		s._isAnimating = true;

		params = params || {};
		// 次数
		params.times    = fmg(params, 'times', 1);
		if (params.times == 0) {
			params.times = Number.MAX_VALUE;
		}

		// 次数间隔
		params.delay    = fmg(params, 'delay', 0);
		params.scale    = fmg(params, 'scale', 1.5);
		params.duration = fmg(params, 'time', 'duration', .6);

		if (!this.originSize) {
			this.originSize = {
				width: this.width_,
				height: this.height_
			};
		}

		this.width_ = this.originSize.width;
		this.height_ = this.originSize.height;

		clearInterval(this._flashID);
		this._flashID = fm.Tween.action(this, params.duration, {
			width_: this.width_ * params.scale,
			height_: this.height_ * params.scale
		}, fm.Tween.pingPongSin, function() {
			params.times --;

			if (params.times > 0) {
				s._flashID = setTimeout(function() {
					params.force = true;
					s.flash(params);
				}, params.delay * 1000);
			} else {
				s._isAnimating = false;

				if (params.callback) {
					params.callback();
				}
			}
		});

		return params;
	},

	jump: function(params) {
		var s = this;

		if (this._isAnimating && !params.force) {
			return;
		}

		s._isAnimating = true;

		params = params || {};

		if (params._initY == undefined) {
			params._initY = s.initY_;
		}

		// 次数
		params.times    = fmg(params, 'times', 1);
		if (params.times == 0) {
			params.times = Number.MAX_VALUE;
		}

		// 次数间隔
		params.delay    = fmg(params, 'delay', 0);
		params.height   = fmg(params, 'height', 8);
		params.duration = fmg(params, 'time', 'duration', 1);
		
		clearInterval(this._jumpID);
		this._jumpID = fm.Tween.action(this, params.duration * .2, {
			initY_: params._initY + params.height
		}, fm.Tween.easeOutQuad, function() {
			s._jumpID = fm.Tween.action(s, params.duration * .8, {
				initY_: params._initY
			}, fm.Tween.bounce, function() {
				params.times --;

				if (params.times > 0) {
					s._jumpID = setTimeout(function() {
						params.force = true;
						s.jump(params);
					}, params.delay * 1000);
				} else {
					s._isAnimating = false;

					if (params.callback) {
						params.callback();
					}
				}
			});
		});

		return params;
	},

	/**
	 * ps: x, y, (time | duration), callback, update
	 */
	moveTo: function(ps) {
		var s = this;

		var time = fmg(ps, 'time', 'duration', 1);

		s._isAnimating = true;

		fm.Tween.kill(s._moveToID);
		s._moveToID = fm.Tween.action(s, time, {
			x: ps.x,
			y: ps.y
		}, (ps.ease || fm.Tween.linear), function() {
			s._isAnimating = false;
			if (ps.callback) {
				ps.callback();
			}
		}, function(f) {
			if (ps.update) {
				ps.update({x: s.x, y: s.y});
			}
		});

		return ps;
	},

	fade: function (ps) {
		var s = this;

		if (!s.material || s._isFading) {return;}
		s._isFading = true;

		ps = ps || {};

		// 如果是 in,需要先显示出来,才能渐显
		if (!ps.out) {
			s.visible = true;
		}

		var time = fmg(ps, 'time', 'duration', .2);

		fm.Tween.kill(s._fadeID);
		s._fadeID = fm.Tween.action(s.material, time, {
			opacity: (ps.out ? 0 : 1)
		}, null, function () {
			s._isFading = false;
			// over
			if (ps.out) {
				s.visible = false;
			}
		});
	}
};

Object.assign(fengmap.MapLabel.prototype, fengmap.MapLabel.generalFunctions);

/**
 * 得到sprite在3D相机中的缩放比率
 */
fengmap.MapLabel.getPerspectiveScale = function(scope, mapView) {
	var pos = scope.getWorldPosition();

	var isTop = mapView.map_.viewMode == 'top';

	// 设置y坐标的目的是,在 'top' 视图中计算的scale要与焦点层一至
	isTop && (pos.y = mapView.map_.groupCenter_.y);

	var me = pos;
	var to = mapView.camera.position;
	var target = mapView.map_.controls.target.clone();

	var dist = me.distanceTo(to);
	var v1   = target.clone().sub(to).normalize();
	var v2   = me.clone().sub(to).normalize();

	// 点积一下,是为解决如果物体离中心点的平面距离太远,会放大的问题.
	// 这样做就会只保持相机中心点所处的缩放大小
	var dot = v1.dot(v2);
	dist = dist * dot;

	var meterperpixe = 1;

	// theme version 2.0
	if (mapView.map_.mapTheme.version == 1) {
		meterperpixel = dist / mapView.h_ * .3 * (scope.scaleRatio_ || 1);
	} else {	// theme version 2.0
		meterperpixel = fengmap.MapUtil.getSpriteScale(mapView.map_, scope);
	}

	var scaleRatio =  mapView.map_.mapTheme.version == 1 ? 1 : scope.scaleRatio_ || 1;

	var w = scope.width_ * meterperpixel  ;// / scaleRatio;
	var h = scope.height_ * meterperpixel ;// / scaleRatio;

	scope.meterperpixel_ = meterperpixel;
	
	var res = {
		scale: new fm.Vector3(w, h, 1),
		meterperpixel: meterperpixel
	}

	return res;
};

// -----------------------------------------------------------------------------
// Private
fengmap.MapLabel.prototype.makeTextSprite_ = function( message, parameters ) {
	var scope = this;
	if ( parameters === undefined ) parameters = {};

	// if (scope.map.mapTheme.version > 1) {
	// 	message.fontsize *= scope.scaleRatio_;
	// }

	var color           = null;
	var borderThickness = null;
	var borderColor     = null;

	var labelType = (scope.data_ && scope.data_.type && scope.map.mapTheme.storeLabelTypeDic) ? 
					scope.map.mapTheme.storeLabelTypeDic[scope.data_.type] : undefined;

	// label type from theme
	if (labelType) {
		var labelTheme = scope.map.mapTheme.storeLabelThemeDic[labelType.normalid];

		var t = labelTheme;

		if (t) {

			var url = scope.map.options.mapThemeURL + '/' + scope.map.themeName + '/';

			if (t.image && !t.texture) {
				// if (scope.map.mapTheme.fileType == 'image') {
				// 	t.texture = fengmap.MapUtil.loadTexture(url + t.image);
				// } else if (scope.map.mapTheme.fileType == 'rtheme') {
				// 	t.texture = scope.map.mapTheme.getRThemeTexture(t.image);
				// }
				scope.map.mapTheme.loadImage(t, function (tex) {
					t.texture = tex;
				});
			}

			if (t.fillcolor) {
				color = fengmap.MapUtil.toRgba(t.fillcolor);
			}

			if (t.strokecolor) {
				borderColor = fengmap.MapUtil.toRgba(t.strokecolor);
			}

			var _fontsize_ = getValue('fontsize', 'number') * scope.scaleRatio_;
			var _imagesize_ = getValue('imagesize', 'number') * scope.scaleRatio_;

			// 如果是旧版的主题, 向前兼容, 最小字体大小 36
			if (scope.map.mapTheme.version == 1) {
				if (_fontsize_ && _fontsize_ < 36) {
					_fontsize_ = 36;
				}
			}

		} else {
			labelType = null;
		}

	}

	var fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : '"Microsoft Yahei","微软雅黑",Tahoma,Arial';
	var fontsize = _fontsize_ ? _fontsize_ : parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 36;
	// fontsize = Math.ceil(fontsize * (this.scaleRatio_ || 1));

	if (!color) {
		color           = parameters.hasOwnProperty("color") ? parameters["color"] : 'rgba(0,0,0,1)';
	}

	if (!borderColor) {
		borderColor     = parameters.hasOwnProperty("borderColor") ? parameters["borderColor"] : 'rgba(150,150,150,1)';
	}
	
	borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 2;

	var isPC        = fengmap.MapUtil.getPlatform().isPC;
	borderThickness = borderThickness * (isPC ? 2 : 1);
	// var _fontSize   = Math.ceil(fontsize * (isPC && fontsize <= 36 ? 1.1 : 1));
	
	var _fontSize   = Math.ceil(fontsize);

	_font           = _fontSize + "px " + fontface;

	// message = message + '\n' + message + 'aklsjdflajsdf' + '\n' + message;

	// message = 'wqlaksjdf,,你好, asdfasdf , 这是什么东西 , 这是什么东西, 这是什么东西';
	var canvas, context;
	if (!this.canvas) {
		this.canvas = document.createElement('canvas');
	}
	
	if (!this.context) {
		this.context = this.canvas.getContext('2d');
	}

	canvas  = this.canvas;
	context = this.context;

	context.font = _font;

	var halfBor = borderThickness / 2;

	//////////
	// 多行文字 //
	//////////
	var fs = message.split('\n');
	var textLines = [];

	var textMaxW = 0;
	var textMaxH = 0;
	for (var i = 0; i < fs.length; i++) {
		if (fs[i] == '') {
			fs.splice(i, 1);
			i--;
		} else {
			var _width = context.measureText(fs[i]).width;
			textMaxW = Math.max(textMaxW, _width);
			textMaxH += _fontSize; //  + borderThickness;    //+ borderThickness;
			textLines.push({
				text: fs[i],
				width: _width
			});
		}
	}

	parameters.textSpace = parameters.textSpace || 4;

	// textMaxH += (parameters.textSpace * (fs.length - 1));

	// get size data (height depends only on font size)
	// var metrics = context.measureText( message );

	/////////////////////
	// draw icon stuff //
	/////////////////////
	var poiImg = null;
	var hasImg = false;
	var textOffset = {x: halfBor, y: -borderThickness};
	var imageOffset = {x: 0, y: 0};

	var _w = textMaxW + borderThickness;

	// 先得到高度, 这样在含有Image的时候,可以先对文字进行偏移
	// var _h = (message == undefined || message == '') ? 0 : _fontSize + borderThickness / 2;
	var _h = (message == undefined || message == '') ? 0 : textMaxH;
	var imageSize = _imagesize_ || parameters.imageSize || _fontSize;
	var imageSpace = parameters.imageSpace || 4;
	var maxW = textMaxW;
	var maxH = _h;

	var allCnt = 50;
	var tryCnt = 0;

	function getValue(param, type) {
		if (labelTheme[param] && labelTheme[param] != '') {
			if (type == 'color') {
				return fengmap.MapUtil.toRgba(labelTheme[param]);
			} else if (type == 'number') {
				return parseFloat(labelTheme[param]);
			}
		}
		return 0;
	}

	// label type from theme
	if (labelType) {
		// var labelTheme = scope.map.mapTheme.storeLabelThemeDic[labelType.normalid];
		// var _fontsize_ 		= getValue('fontsize', 'number');
		var platesize       = getValue('platesize', 'number');
		var platecolor      = getValue('platecolor', 'color');
		var platestorkcolor = getValue('platestorkcolor', 'color');

		if (platesize) {
			if (platesize < _fontSize) {
				platesize = _fontSize + 4;
			}

			var _delta = (platesize - _fontSize) * 2;  // * 4

			textMaxW += _delta * 2;
			textMaxH += _delta * 2;

			_w = textMaxW + borderThickness;
			_h = textMaxH;
			imageSize = parameters.imageSize || (imageSize + _delta);
		} 
	} else {
		_h += borderThickness;
	}

	if (labelType && labelTheme.image && labelTheme.image != '') {
		hasImg = true;

		// get text and image offset
		switch (parameters.imageAlign) {
			case 'left':
			case 'right':
				if (imageSize > textMaxH) {
					textOffset.y = (imageSize - textMaxH) / 2 - halfBor;
					_h = imageSize;
				} else {
					textOffset.y = -borderThickness;
					imageOffset.y = (textMaxH - imageSize) / 2;
				}

				if (parameters.imageAlign == 'left') {
					textOffset.x = imageSize + imageSpace;
					_w = textMaxW + textOffset.x;
				} else {
					imageOffset.x = textMaxW != 0 ? textMaxW + imageSpace : 0;
					_w = textMaxW + imageSize + imageSpace;
				}
			break;
			case 'top':
			case 'bottom':
				maxW = Math.max(textMaxW, imageSize) + borderThickness;

				if (textMaxW >= imageSize) {
					imageOffset.x = Math.ceil((textMaxW + halfBor - imageSize) / 2);
				} else {
					textOffset.x = Math.ceil((imageSize - textMaxW + halfBor) / 2);
				}

				if (parameters.imageAlign == 'top') {
					_h = _h + imageSize + imageSpace;
					_w = maxW;
					textOffset.y = imageSize + imageSpace - halfBor;
				} else {
					var textH = _h;
					_h = _h + imageSize + imageSpace;
					_w = maxW;
					imageOffset.y = textH + imageSpace;
				}
			break;
		}
	}

	// nextPowerOf2 is not use , because the result of pivot is NOT CENTER
	// canvas.width  = Math.ceil(_w);
	// canvas.height = Math.ceil(_h);
	canvas.width  = _w;
	canvas.height = _h;

	// pivot
	scope.originPivot = new fm.Vector3(canvas.width / 2, 0, canvas.height / 2);
	scope.pivot_ = scope.originPivot.clone();

	// 画Icon
	if (hasImg) {

		// ugly!!
		halfBor = 0;

		var _intervalId = setInterval(function() {
			if (!labelTheme.texture) {return;}

			// 达到尝试次数
			if (tryCnt == allCnt) {
				clearInterval(_intervalId);
			}

			poiImg = labelTheme.texture.image;
			if (poiImg) {
				context.drawImage(poiImg, imageOffset.x, imageOffset.y, imageSize, imageSize);

				// 记录图标的Pivot
				scope.iconPivot = new fm.Vector3(imageOffset.x + imageSize / 2, 0, imageOffset.y + imageSize / 2);

				if (parameters.pivotType == 'icon') {
					scope.pivot = scope.iconPivot;
				}

				if (texture) {
					texture.needsUpdate = true;
				}

				clearInterval(_intervalId);
			}

			tryCnt ++;
		}, 100);
	}

	if (message != undefined && message || '') {
		//second time
		context.font = _font;
		context.imageSmoothingEnabled = true;

		// 将Canvas背景设置为红色,方便测试
		// context.fillStyle = 'red';
		// context.fillRect(0, 0, canvas.width, canvas.height);

		// draw plate
		if (platesize) {
			context.strokeStyle = platestorkcolor;
			context.lineWidth = 4;

			var _top = 0;
			if (parameters.imageAlign == 'top') {
				_top = imageSize + imageSpace;
			}

			// 框的内缩
			var _val = 2; //textMaxH / 10;

			context.roundRect(textOffset.x + _val, _val + _top, textMaxW - _val * 2, textMaxH - _val * 2, textMaxH / 6).stroke();
			context.fillStyle = platecolor;
			context.roundRect(textOffset.x + _val, _val + _top, textMaxW - _val * 2, textMaxH - _val * 2, textMaxH / 6).fill();
		}
		
		var y_kao = 0;
		for (var i = 0; i < textLines.length; i++) {
			var ox = (textMaxW - textLines[i].width) / 2 + textOffset.x;
			// var oy = (i + 1) * (_fontSize + parameters.textSpace + halfBor) + textOffset.y - parameters.textSpace;
			var oy = (i + 1) * (_fontSize); // - parameters.textSpace;


			// text
			if (!platesize) {
				y_kao = 0;
				context.strokeStyle = borderColor;
				context.lineWidth = borderThickness;
				// context.textAlign = 'bottom';
				context.strokeText(textLines[i].text, ox, oy + y_kao + textOffset.y + halfBor);
			} else {
				// oy -= textOffset.y / 2;
				y_kao = _delta / 2;
			}

			context.fillStyle = color;
			if (!platesize) {
				// context.textAlign = 'bottom';
				context.fillText(textLines[i].text, ox , oy + y_kao + textOffset.y + halfBor);
			} else {
				context.fillText(textLines[i].text, ox , oy + y_kao);
			}
		}
	}

	this.width_  = canvas.width ;
	this.height_ = canvas.height;

	// 之前是把这个去掉的, 但是会在 遮挡剔除 时, 计算有误.
	// 所以还是需要将 缩放放在这里
	this.width_ /= this.scaleRatio_;
	this.height_ /= this.scaleRatio_;

	this.originSize = {
		width: this.width_,
		height: this.height_
	};

	var texture;
	// canvas contents will be used for a texture
	if (!this.texture || parameters.external) {
		texture = new fm.Texture(canvas);
		texture.minFilter = fm.LinearFilter;
		
		// texture.anisotropy = 8;
		texture.anisotropy = fengmap.MapView.instance.renderer.getMaxAnisotropy();
		
		texture.generateMipmaps = false;
		this.texture = texture;
	}
	texture = this.texture;
	texture.needsUpdate = true;
	//*/

	/*
	// 加入图集
	var atlas = this.map.mapAtlas.appendText({
		text: message,
		font: _font,
		fontSize: _fontSize,
		strokeStyle: borderColor,
		fillStyle: color,
		lineWidth: borderThickness,
	});

	var texture = new fm.Texture(this.map.mapAtlas.atlases[atlas.index].ctx.canvas);

	texture.repeat.x = atlas.width / this.map.mapAtlas.atlasWidth;
	texture.repeat.y = atlas.height / this.map.mapAtlas.atlasHeight;

	texture.offset.x = atlas.offsetX;
	texture.offset.y = atlas.offsetY;

	texture.wrapS = fm.ClampToEdgeWrapping;
	texture.wrapT = fm.ClampToEdgeWrapping;

	texture.minFilter       = fm.LinearFilter;
	texture.generateMipmaps = false;
	texture.anisotropy      = this.map.mapView.renderer.getMaxAnisotropy();

	texture.needsUpdate = true;

	this.width_ = atlas.width;
	this.height_ = atlas.height;
	//*/

	if (!parameters.external) {
		if (!this.material_) {
			this.material_ = new fm.SpriteMaterial({
				map: texture,
				depthWrite: false
			});
		}
	}

	return texture;
};

/**
 * 更新样式, 用在更换主题的时候
 */
fengmap.MapLabel.prototype.updateStyle = function(style) {
	style = style || this.style;

	var map = this.map || fengmap.Map.instance;
	var _size = map.mapTheme.version == 1 ? 2 : (this.scaleRatio_ || 1);

	this.makeTextSprite_( this.message, {
		fontsize:style.fontsize * _size,
		borderThickness:2,
		color:fengmap.MapUtil.toRgba((style.fillcolor || '0,0,0')), 
		borderColor: fengmap.MapUtil.toRgba((style.strokecolor || '255,255,255')),
		// poiId: style.poiId,
		imageAlign: style.imageAlign || 'left',
		imageSize: style.imageSize,
		imageSpace: style.imageSpace,
		textSpace: style.textSpace || 4,
		pivotType: style.pivotType || 'center'  // center | icon
	});
}

// 画圆角矩形
CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
     this.beginPath();
     this.moveTo(x+r, y);
     this.arcTo(x+w, y, x+w, y+h, r);
     this.arcTo(x+w, y+h, x, y+h, r);
     this.arcTo(x, y+h, x, y, r);
     this.arcTo(x, y, x+w, y, r);
     this.closePath();
     return this;
 }


/**
 * line mesh used in navigation
 *
 * ps: up, radius, segments, yScale 
 */
!(function() {
    fengmap.MapNavLineGeometry = function( ps ) {
        // s = self
        var s = this;

        // inherit from Geometry
        fm.Geometry.call(this);

        s.pathVertices = null;
        s.radius       = 1;
        s.segments     = 12;

        // uv map 0 to 1 per length
        s.uvBaseLen = 1;

        // assign custom parameters
        Object.assign(s, ps);

        if (s.lineMode == fengmap.FMLineMode.PLANE) {
            s.yScale = .3;
        } else if (s.lineMode == fengmap.FMLineMode.CIRCLE) {
            s.yScale = 1;
        }

        s.yScale = s.yScale || 1 ;
        s.smooth = fmg(s, 'smooth', true);

        if (!s.up) {
            s.up = new fm.Vector3(0, 1, 0);
        }

        this._uvs   = [];
        this._rings = [];

        // build
        build(s);
    };

    fengmap.MapNavLineGeometry.prototype = Object.create(fm.Geometry.prototype);
    fengmap.MapNavLineGeometry.prototype.constructor = fengmap.MapNavLineGeometry;

    /**
     * change radius
     */
    fengmap.MapNavLineGeometry.prototype.setRadius = function( val ) {
        // return;
        var s = this;
        var k = 0;
        var rings = s._rings;

        var isArr = val instanceof Array;
        var _var = .1, baseVLen, _scale = 1, _sub;

        for (var i = 0; i < rings.length; i++) {
            var ring = rings[i];
            var center = s.pathVertices[i];

            // ! center maybe undefined. don't know why could it happend
            if (!center) {continue;}

            for (var j = 0; j < ring.length; j++) {
                var v = ring[j];

                // 椭圆的支持
                if (j == 0 && s.yScale != 1) {
                    baseVLen = ring[0].clone().sub(center).length();
                }

                // 椭圆
                if (s.yScale != 1) {
                    _sub = v.clone().sub(center);
                    _scale = _sub.length() / baseVLen;
                }

                var res = center.clone().add(v.clone().sub(center).normalize().multiplyScalar(val * _scale));
                s.vertices[k].copy(res);
                k++;
            }
        }

        if (val < .1) {val = .1;}

        s.radius = val;

        s.verticesNeedUpdate = true;
    };

    ///
    ///private fields & functions
    ///

    // build mesh
    var build = function( s ) {
        if (!s.pathVertices || s.pathVertices.length < 2) {
            console.warn('MapNavLineGeometry: The pathVertices parameter is null!');
            return;
        }

        // build Vertices && uv0
        buildVertices(s);

        // build faces
        buildFaces(s);

        // build uv0
        buildUv(s);

        // caculate normal
        s.computeFaceNormals();
    }

    /**
     * build vertices
     */
    function buildVertices ( s ) {
        // vertices template
        var vsTmp = [];
        var deltaRad = Math.PI * 2 / s.segments;
        var firstPoint;
        for (var i = 0; i < s.segments; i++) {
            var _ver = new fm.Vector3(
                0,
                s.radius * s.yScale * Math.sin(deltaRad * i),
                s.radius * Math.cos(deltaRad * i)
            );
            vsTmp.push(_ver);
            if (i == 0) {
                firstPoint = _ver;
            }
        }

        // 将最一个点再次放到最后, 这样做是为了防止首尾相接面儿的uv拉伸问题
        vsTmp.push(firstPoint);

        var pre, me, next, mx;
        var len = s.pathVertices.length;

        // record length & perimeter
        var res = getLengthAndCenter(s.pathVertices);
        s.length = res.length;
        s.center = res.center;

        if (!s.notCenter) {
            doVs(s.pathVertices, s.center);
        }

        s.perimeter = 2 * Math.PI * s.radius;

        var uvX = 0, uvY = 0, ver;
        uvY_delta = s.perimeter / s.segments;
        s._uvs = [];

        _up = s.up.clone();

        s._up_ = null;

        for (var i = 0; i < len; i++) {
            pre = i == 0 ? null : s.pathVertices[i - 1];
            next = i == len - 1 ? null : s.pathVertices[i + 1];
            me = s.pathVertices[i];

            // get matrix by three verts
            mx = getMatrixByVerts(pre, me, next);

            // console.log(mx, new fm.Vector3().setFromMatrixColumn(mx, 0),
            //     new fm.Vector3().setFromMatrixScale(mx));

            if (!s._up_) {
                s._up_ = new fm.Vector3(0, 1, 0).applyMatrix4(mx).normalize();
            }
         
            if (i > 0) {
                uvX += me.distanceTo(pre);
            }
            uvY = 0;

            // record rings used to change radius
            s._rings[i] = [];

            var _me = me.clone();
            _me.y = 0;

            var _len = 0, addedLen = 0;

            for (var j = 0; j < vsTmp.length; j++) {
                ver = vsTmp[j].clone().applyMatrix4( mx );

                // push vertex
                s.vertices.push(ver);

                // push to rings
                s._rings[i].push(ver);

                // calculate uv
                /*if (mx.angle) {
                    var _ver = ver.clone();
                    _ver.y = 0;
                    _len =  _ver.distanceTo(_me);

                    // + -
                    var sign = Math.sign((_ver.clone().sub(_me)).dot(mx.vz));

                    addedLen = _len * sign * Math.sin(mx.angle);
                }*/

                // record uv
                s._uvs.push(new fm.Vector2((uvX + addedLen) / s.length, 1 - uvY / s.perimeter));
                uvY += uvY_delta;
            }
        }
    };

    /**
     * build faces
     */
    function buildFaces( s ) {
        var segLen = s.pathVertices.length;
        var ss = s.segments + 1;
        var tmp;
        for (var i = 0; i < segLen - 1; i++) {
            tmp = i * ss;
            for (var j = 0; j < ss - 1; j++) {
                // if (j < ss - 1) {
                    s.faces.push(new fm.Face3(tmp + j + 1, tmp + j,      tmp + ss + j));
                    s.faces.push(new fm.Face3(tmp + j + 1, tmp + j + ss, tmp + ss + j + 1));
                // } else { // this used to "closed shape: first vert is lastVert but the last face uv is wrong"
                //     s.faces.push(new fm.Face3(tmp, tmp + ss - 1,     tmp + ss * 2 - 1));
                //     s.faces.push(new fm.Face3(tmp, tmp + ss * 2 - 1, tmp + ss));
                // }
            }      
        }
    }

    /**
     * build face uv0
     */
    function buildUv(s) {
        var len = s.faces.length;

        for (var i = 0; i < len; i++) {
            var f = s.faces[i];
            s.faceVertexUvs[0].push([
                s._uvs[f.a], s._uvs[f.b], s._uvs[f.c]
            ]);
        }
        s.uvsNeedUpdate = true;
    }

    /**
     * get path length
     */
    function getLengthAndCenter( vs ) {
        var res = 0;
        var sum = vs[0].clone();
        for (var i = 1; i < vs.length; i++) {
            res += vs[i].distanceTo(vs[i - 1]);
            sum.add(vs[i]);
        }
        return {
            length: res,
            center: sum.divideScalar(vs.length)
        };
    }

    /**
     * very vertice sub center
     */
    function doVs(vs, center) {
        vs.forEach(function(itm) {
            itm.sub(center);
        });
    }

    var _up = null;

    /**
     * get a matrix by three vectices
     */
    function getMatrixByVerts(pre, me, next) {
        var _pre  = pre && pre.clone();
        var _me   = me.clone();
        var _next = next && next.clone();
        var scale = 1, angle = null;

        var vx;
        if (!pre) {
            vx = _next.sub(_me).normalize();
        } else if (!next) {
            vx = _me.sub(_pre).normalize();
        } else {
            var vme = _me.clone().sub(_pre).normalize();
            var vnext = _next.sub(_me).normalize();

            // get scale
            angle = vme.angleTo(vnext) / 2;
            scale = 1 / Math.cos(angle);

            // clamp
            scale = fm.Math.clamp(scale, 1, 2);

            vx = vme.add(vnext).normalize();
        }

        var _vy = _up.clone();
        var vz  = new fm.Vector3().crossVectors(vx, _vy).normalize();
        var vy  = new fm.Vector3().crossVectors(vz, vx).normalize();
        
        // _up = vy.clone();   // 不去改变 up ,一直为 Vector3(0, 1, 0)

        // vz scale
        vz.multiplyScalar(scale);

        var res = new fm.Matrix4().makeBasis(vx, vy, vz).setPosition(me);
        res.angle = angle;
        res.vz = vz;

        return res;
    }
})();

/**
 * 
 */
fengmap.MapPoi = function(gid, poi, theme) {
	this.data_ = poi;//fid, vertex, name, type
	this.data_.gid = gid;
	
	if (poi.vertex) {
		this.data_.x_ = poi.vertex[0];
		this.data_.y_ = poi.vertex[1];
	}
	
	var mat;

	// 每一层的POI都是独立的, 用于设置某层的Alpha
	// 如不这样,所有楼层的POI的材质将会一起变化
	// 
	// 这样是每一层同样式的图标使用同一个材质
	// 但如果在POI Fade的时候,会一起更改透明度.
	// 
	/*fengmap.MapPoi._mats = fengmap.MapPoi._mats || {}
	mat = fengmap.MapPoi._mats[gid + '_' + poi.type];

	if (!mat) {
		mat = theme.getPoiMaterialByType(poi.type);	
		fengmap.MapPoi._mats[gid + '_' + poi.type] = mat;
	}*/

	// 每一个POI使用独立的材质, 这样可以在Fade的时候,
	// 分别的控制其透明度
	mat = theme.getPoiMaterialByType(poi.type);

	// mat.depthTest = false;

	fm.Sprite.call(this, mat);

	// this.visible = mat.visible;
	// if (!this.visible) {
	// 	var s = this;
	// 	mat.loadedCallback = function () {
	// 		s.visible = true;
	// 		s._isloaded = true;
	// 	}
	// }

	this.scale.set(10,10,10);

	// this.scaleRatio_ = window.devicePixelRatio;

	//for collision! 
	//set size from theme file config
	this.width_ = parseFloat(mat.size);
	this.height_ = parseFloat(mat.size);
	
};
fengmap.MapPoi.prototype = new fm.Sprite();

Object.assign(fengmap.MapPoi.prototype, fengmap.MapLabel.generalFunctions);

fengmap.MapUtil._setGeneralProperties(fengmap.MapPoi.prototype);

//for user POI!
fengmap.MapPoi2 = function(gid, poi, url, callback) {
	this.data_ = poi;
	this.data_.gid = gid;

	this.visible = false;
	var mat = null;
	var self = this;
	var texture = fengmap.MapUtil.loadTexture(url, function(tex) {
		mat = new fm.SpriteMaterial({map: tex});
		self.visible = true;

		var scaleFactor = poi.size_ / 32;
		
		fm.Sprite.call(self, mat);
		var _tmp = 10 * scaleFactor;
		self.scale.set(_tmp, _tmp, _tmp);
		
		//for collision!
		self.width_ = 32 * scaleFactor;
		self.height_ = 32 * scaleFactor;

		if (callback) {callback(tex);}
	});
};

fengmap.MapPoi2.prototype = new fm.Sprite();

Object.assign(fengmap.MapPoi2.prototype, fengmap.MapLabel.generalFunctions);
fengmap.MapUtil._setGeneralProperties(fengmap.MapPoi2.prototype);

//for Location Marker
fengmap.MapPoi3 = function(gid, poi, url, callback) {
	this.data_ = poi;//fid, vertex, name, type
	this.data_.gid = gid;

	var mat = new fm.MeshLambertMaterial({transparent: true});

	var geo = new fm.PlaneGeometry(1,1,1,1);
	fm.Mesh.call(this, geo, mat);

	this.visible = false;

	var self = this;
	var texture = fengmap.MapUtil.loadTexture(url, function(tex) {
		
		mat.map = tex;
		mat.doubleSided = true;

		// 2016.10.17 alphaTest = 0, 0.5时有部分的图片内容没有正常的显示出来.
		mat.alphaTest = 0;

		mat.depthWrite = false;
		mat.depthTest = false;
		self.renderOrder = fengmap.FMRenderOrder.locationMarker;

		var scaleFactor = poi.size_ / 32;
		
		//set size 2016-06-07
		self.scale.set(10*scaleFactor,10*scaleFactor,10*scaleFactor);
		
		self.rotation.set(-Math.PI/2,0,Math.PI,'XYZ');
		
		//for collision!
		self.width_ = 32 * scaleFactor;
		self.height_ = 32 * scaleFactor;

		self.visible = true;

		if (callback) {callback(tex);}
	});
};

fengmap.MapPoi3.prototype = Object.create(fm.Mesh.prototype);

fengmap.MapPoi3.prototype.constructor = fengmap.MapPoi3;

Object.assign(fengmap.MapPoi3.prototype, fengmap.MapLabel.generalFunctions);
fengmap.MapUtil._setGeneralProperties(fengmap.MapPoi3.prototype);

fengmap.appendMapPoi__ = {

	/**
	 * 设置图片, url | image
	 */
	setUrl: (function() {

		function setTexture(s, tex) {
			// dispose
			if (s.material.map) {
				s.material.map.image = null;
				s.material.map = null;
			}

			s.material.map = tex;
			s.material.needsUpdate = true;
		}

		return function (url) {
			var s = this;

			if (typeof url === 'string') {

				fengmap.MapUtil.loadTexture(url, function(tex) {
					setTexture(s, tex);
				});
				
			} else if (url instanceof Image && s.material.map) {
				s.material.map.image = url;
				s.material.map.needsUpdate = true;
			}

			// this.material = new fm.SpriteMaterial({map: fengmap.MapUtil.loadTexture(url)});
		}
		
	})(),
};

Object.assign(fengmap.MapPoi2.prototype, fengmap.appendMapPoi__);
Object.assign(fengmap.MapPoi3.prototype, fengmap.appendMapPoi__);




/**
 * 
 */

fengmap.MapScene = function(map, mapTheme) {
	this.map_ = map;

	this.mapTheme_ = mapTheme;
	this.scene_ = null;
	this.sceneX_ = 0;
	this.sceneZ_ = 0;
	this.groups_ = {};

	this.o3dScene_ = null;
	this.o3dGroups_ = {};
	this.o3dGroupsOctree_ = {}; //octree
    this.o3dGroupsBox_ = {};

	this.userGroups_ = {};

	// 记录一些 store 的原始数据,以fid为key
	this.modelDatas = {};
	this.externalModels = {};

	this.o3dNavigation_ = null;

	this.box3_ = null;
	this.minX_ = 0;
	this.minY_ = 0;
	this.maxX_ = 0;
	this.maxY_ = 0;

	this.asyncWaitTime = 0;
};

fengmap.MapScene.prototype = {
	clear: function() {

	},
	setScene: function(d) {
		this.scene_ = d;

		this.sceneX_ = this.scene_['scene_data']['defCenX'];
		this.sceneZ_ = this.scene_['scene_data']['defCenY'];

		this.o3dScene_ = new fm.Object3D();
		this.o3dGroups_ = {};
		this.userGroups_ = {};
		this.o3dGroupsOctree_ = {}; //octree
        this.o3dGroupsBox_ = {};

		this.modelDatas = {};

		this.o3dNavigation_ = new fm.Object3D();
		this.o3dScene_.add(this.o3dNavigation_);

		//calc bound
		this.box3_ = fengmap.MapSceneUtil.calcSceneBox3(this.scene_['scene_data']);

		this.minX_ = this.scene_['scene_data']['minX'];
		this.maxX_ = this.scene_['scene_data']['maxX'];
		this.minY_ = this.scene_['scene_data']['minY'];
		this.maxY_ = this.scene_['scene_data']['maxY'];
	},
	calcInitCamera: function() {
		return fengmap.MapSceneUtil.calcInitCamera(this.box3_);
	},
	getO3dScene: function() {
		return this.o3dScene_;
	},
	forEachGroups: function(cb) {
		var gs = this.scene_['scene_data']['layerGroups'];
		for (var i in gs) {
			var group = gs[i];
			this.groups_[group['gid']] = group;
			cb(group);
		}
	},
	groupLength_: function() {
		return this.scene_['scene_data']['layerGroups'].length;
	},

	putGroup: function(gid, dg) {
		var group = this.groups_[gid];

		if (!group) {
			return;
		}

		group.a_ = dg; //append!
		var fmGroup = new fengmap.FMGroup(this, group);
		var o3d = fmGroup.o3d_;

		// 默认层为不可见, 需要使用 map.visibleGroupIDs 去显示相应的层
		o3d.visible = this.map_.options.defaultVisibleGroups.indexOf(gid) > -1;

		o3d.meta_ = group;

		var groupHeight = this.map_.options.defaultGroupSpace ? this.map_.options.defaultGroupSpace * (gid - 1) : group.elevation;
		o3d.position.set(0, groupHeight, 0);
        o3d.updateMatrixWorld();

		this.o3dGroups_[gid] = o3d;
		if(undefined == this.o3dGroupsOctree_[gid]){
			this.o3dGroupsOctree_[gid] = new fm.Octree({undeferred: false,depthMax: Infinity,objectsThreshold: 8,overlapPct: 0.15});
            this.o3dGroupsBox_[gid] = undefined;
		}
		this.o3dScene_.add(o3d);
	},

	setGroupLabelVisible: function(gid, visible) {
		console.warn("Deprecated!");
	},
	setGroupPoiVisible: function(gid, visible) {
		console.warn("Deprecated!");
	},
	getO3dGroup: function(gid) {
		return this.o3dGroups_[gid];
	},
	getO3dGroupOctree: function(gid) {
		return this.o3dGroupsOctree_[gid];
	},
    getO3dGroupBox: function(gid) {
		return this.o3dGroupsBox_[gid];
	},
	/**
	 * 
	 * 这里主要是创建StoreImage,与自定义的store颜色透明度啥的 
	 *
	 * 技术上讲是处理 storeapply 
	 * 
	 */
	_createStoreImages: function(sidatas, model, layer) {
		if (!sidatas) {
			return;
		}

		model = model || this.modelDatas[sidatas[0].fid];

		// 如果没找到对应的model
		if (!model) {
			return;
		}

		layer = layer || this.map_.getOrCreateLayer(model.gid, 'storeImage');

		var sidata = null;
		model.storeImages = [];
		for (var i = 0; i < sidatas.length; i++) {
			sidata = sidatas[i];
			sidata.height = (model.height || 0) + 0.2;

			// 如果有图片的话, 就创建storeimage
			if (sidata.image) {
				var si = new fengmap.FMStoreImage({
					gid: model.gid,
					fid: model.fid,
					minLevel: model.minLevel,
					maxLevel: model.maxLevel,
					style: sidata,
					map: this.map_
				});

				model.storeImages.push(si);

				layer.addMarker(si);
			}

			// 处理自定义的store颜色与透明度
			model.storeApply = sidata.theme;
		}
	},

	forEachGroupModel: function(gid, cb, groupWorks) {
		var o3dGroup = this.getO3dGroup(gid);

		if (!o3dGroup) {
			return;
		}

		var dg = this.groups_[gid].a_;
		var scope = this;

		//*
		console.time('groupID ' + gid + ' build time');
		scope.asyncBuidExtents(dg, o3dGroup, gid)
			.then(scope.asyncBuidModels.bind(scope, dg, o3dGroup, gid))
			 .then(scope.asyncBuildPOIs.bind(scope, dg, o3dGroup, gid))
			 .then(scope.asyncBuildLabels.bind(scope, dg, o3dGroup, gid))
			.then(scope.asyncBuildPolygons.bind(scope, dg, o3dGroup, gid))
			.then(scope.asyncBuildStairs.bind(scope, dg, o3dGroup, gid))
			.then(scope.asyncBuildExternalModels.bind(scope, dg, o3dGroup, gid))
			.then(function() {
				console.timeEnd('groupID ' + gid + ' build time');
				groupWorks();
			});

		// scope.asyncBuidExtents(dg, o3dGroup, gid)
		// 	.then(scope.asyncBuidModels.bind(scope, dg, o3dGroup, gid, cb))
		// 	.then(scope.asyncBuildPOIs.bind(scope, dg, o3dGroup, gid))
		// 	// .then(scope.asyncBuildLabels.bind(scope, dg, o3dGroup, gid))
		// 	// .then(scope.asyncBuildPolygons.bind(scope, dg, o3dGroup, gid))
		// 	// .then(scope.asyncBuildStairs.bind(scope, dg, o3dGroup, gid))
		// 	// .then(scope.asyncBuildExternalModels.bind(scope, dg, o3dGroup, gid))
		// 	.then(function() {
		// 		console.timeEnd('groupID ' + gid + ' build time');
		// 		groupWorks();
		// 	});
		//*/
	},

	createExtents: function(model, layer) {
		var scope = this;

		if (typeof model != 'object') {
			return undefined;
		}

		var amount = 1;
		if (model.hasOwnProperty('height') && model.height != null && model.height > 0) {
			amount = model.height;
		}

		var gs = scope.createGeometry_(model, amount);
		if(undefined == gs){return undefined;}

		var mesh = new fm.Mesh(gs.geometry);
		mesh.rotation.set(Math.PI / 2, 0, 0, 'XYZ'); //if extrude

		var _height = fengmap.MapConfiguration.EXTENT_EPSILON_Y;;
		if (scope.map_.options.extentHeight != undefined) {
			_height = scope.map_.options.extentHeight;
			// } else {
			// 	_height = fengmap.MapConfiguration.EXTENT_EPSILON_Y;
		}

		mesh.position.setY(_height);

		mesh.fm_ = {
			nodeType: fengmap.FMNodeType.FLOOR,
			groupID: layer.groupID,
			o3d_: mesh,
			mapCoord: {x: 0,y: 0,z: 0}
		};

		layer.o3d_.add(mesh);
        mesh.updateMatrixWorld();

		// 将楼板加入到点击事件中,这样也可以避免多楼层时的穿透问题
		scope.map_.mapPicker.addModel(mesh);

		//jimguo add beg
		mesh.material = fengmap.MapUtil.getOrCreateLambertMaterial(scope.mapTheme_.floorColor_, true, scope.mapTheme_.floorOpacity_);
		//jimguo add end

		//jimguo delete beg
		// mesh.material = new fm.MeshLambertMaterial({
		// 	color: scope.mapTheme_.floorColor_
		// });
		// mesh.material.transparent = true;
		// mesh.material.opacity = scope.mapTheme_.floorOpacity_;
		//jimguo delete end

		mesh.renderOrder = fengmap.FMRenderOrder.extent;

		//jimguo delete beg
		//// shadow
		//mesh.receiveShadow = true;
		//jimguo delete end

		return mesh.fm_;
	},

	// createModels: function(model, layer) {
	// 	var scope = this;
	// 	// var model = models[j]; //fid, type, oid, vertices, indices
	// 	if (!model.fid) {
	// 		return;
	// 	}
    //
	// 	var amount = 2;
	// 	if (model.hasOwnProperty('height') && model.height != null && model.height > 0) {
	// 		amount = model.height;
	// 	}
    //
	// 	model.height = amount;
    //
	// 	// 将model的数据记录下来
	// 	scope.modelDatas[model.fid] = model;
    //
	// 	// count property
	// 	if (!scope.modelDatas.count) {
	// 		scope.modelDatas.count = 1;
	// 	} else {
	// 		scope.modelDatas.count++;
	// 	}
    //
	// 	var gs = scope.createGeometry_(model, amount);
	// 	if (gs) {
    //
	// 		/////////////////////////////////
	// 		// store image
	// 		/////////////////////////////////
	// 		var sidatas = scope.mapTheme_.storeImages[model.fid];
    //
	// 		if (sidatas) {
	// 			scope._createStoreImages(sidatas, model);
	// 		}
    //
	// 		var modeltheme = scope.mapTheme_.getModelTheme(model);
	// 		// console.log(model, modeltheme);
	// 		var mesh = new fengmap.ModelMesh(gs.geometry, model.storeApply || modeltheme);
    //
	// 		//if extrude
	// 		mesh.rotation.set(Math.PI / 2, 0, 0, 'XYZ');
	// 		mesh.position.setY(amount);
    //
	// 		//end if extrude
	// 		mesh.meta_ = model;
	// 		mesh.meta_.theme_ = modeltheme;
	// 		mesh.meta_.type_ = 'Model';
    //
	// 		layer.o3d_.add(mesh);
    //
	// 		var fmModel = new fengmap.FMModel(model, mesh, scope);
    //
	// 		if (model.storeImages) {
	// 			model.storeImages.forEach(function(si) {
	// 				mesh.add(si.o3d_);
	// 			});
    //
	// 		}
    //
	// 		fmModel.storeImages = model.storeImages;
    //
    //
	// 		/**
	// 		 * 画线框
	// 		 */
	// 		var points = gs.shape.createPointsGeometry();
	// 		if (points && points.vertices.length > 0) points.vertices.push(points.vertices[0]);
    //
	// 		////////////////////////////////////////////////////
	// 		/// 将 Line 变为 LineSegments 方便之后的合并工作 ///
	// 		////////////////////////////////////////////////////
	// 		var segVerts = [];
	// 		var len = points.vertices.length;
    //
	// 		for (var j = 0; j < len; j++) {
	// 			if (j == 0 || j == len - 1) {
	// 				segVerts.push(points.vertices[j]);
	// 			} else {
	// 				segVerts.push(points.vertices[j], points.vertices[j]);
	// 			}
	// 		}
	// 		points.vertices = segVerts;
	// 		/////////////////////////////////////////////////////
    //
	// 		var lineStyle = model.storeApply || modeltheme;
    //
	// 		// var lineBasicStyle = { color: 0xf0f0f0, linewidth: 1 };
	// 		var lineBasicStyle = {
	// 			color: lineStyle.strokeColor_,
	// 			linewidth: lineStyle.strokeWidth,
	// 			transparent: true,
	// 			opacity: lineStyle.alpha
	// 		};
    //
	// 		// if (!_lineMat || _lastType != model.type) {
	// 		// 	_lastType = model.type;
	// 		var _lineMat = new fm.LineBasicMaterial(lineBasicStyle);
	// 		// }
    //
	// 		var line = new fm.LineSegments(points, _lineMat);
	// 		line.castShadow = false;
	// 		line.renderOrder = fengmap.FMRenderOrder.modelLine;
    //
	// 		// record oid to the mesh
	// 		line.fm_ = {
	// 			nodeType: fengmap.FMNodeType.LINE,
	// 			typeID: fmModel.typeID,
	// 			data_: {
	// 				minLevel: model.minLevel,
	// 				maxLevel: model.maxLevel
	// 			},
	// 			o3d_: line
	// 		};
    //
	// 		// line.rotation.set(Math.PI/2,0,0,'XYZ');
    //
	// 		// amout 加了一点距离, 是为了解决, 在2D或3D(垂直视角)时
	// 		// 中间的线段会消失的问题
	// 		line.position.setZ(-amount * .005);
    //
	// 		line.geometry.computeBoundingSphere();
    //
	// 		fmModel.frameLine = line;
	// 		mesh.add(line);
    //
	// 		// lineLayer.o3d_.add(line);
    //
	// 		//heatmap
	// 		if (layer.group.heatmap_) {
	// 			layer.group.heatmap_.setModelMeshTexture(mesh);
	// 		}
    //
	// 		scope.map_.mapPicker.addModel(mesh);
    //
	// 		return fmModel;
	// 	}
	// },
	createModels: function(model, layer, storeImageLayer, lineLayer, donotPick, castY, castZ, castRot) {
		var scope = this;
		if (undefined == model.fid) {return undefined;}

		var amount = 2;
		if (model.hasOwnProperty('height') && model.height != null && model.height > 0) {
			amount = model.height;
		}
		model.height = amount;

		// 将model的数据记录下来
		scope.modelDatas[model.fid] = model;

		// count property
		if (!scope.modelDatas.count) {
			scope.modelDatas.count = 1;
		} else {
			scope.modelDatas.count++;
		}

		var gs = scope.createGeometry_(model, amount);
		if(undefined == gs){return undefined;}
		//if (gs) {

			/////////////////////////////////
			// store image
			/////////////////////////////////
			var sidatas = scope.mapTheme_.storeImages[model.fid];
			if (sidatas) {
				scope._createStoreImages(sidatas, model, storeImageLayer);
			}

		var modeltheme = scope.mapTheme_.getModelTheme(model);
		var mesh = new fengmap.ModelMesh(gs.geometry, model.storeApply || modeltheme);

		//if extrude
		mesh.rotation.set(Math.PI / 2, 0, 0, 'XYZ');
		mesh.position.setY(amount);

		//end if extrude
		mesh.meta_ = model;
		mesh.meta_.theme_ = modeltheme;
		mesh.meta_.type_ = 'Model';

		layer.o3d_.add(mesh);

		var fmModel = new fengmap.FMModel(model, mesh, scope);

		if(undefined == storeImageLayer && undefined != model.storeImages){
			model.storeImages.forEach(function(si) {
				mesh.add(si.o3d_);
			});
		}

		fmModel.storeImages = model.storeImages;


		/**
		 * 画线框
		 */
		var points = gs.shape.createPointsGeometry();
		if (points && points.vertices.length > 0) points.vertices.push(points.vertices[0]);

		////////////////////////////////////////////////////
		/// 将 Line 变为 LineSegments 方便之后的合并工作 ///
		////////////////////////////////////////////////////
		var segVerts = [];
		var len = points.vertices.length;

		for (var j = 0; j < len; j++) {
			if (j == 0 || j == len - 1) {
				segVerts.push(points.vertices[j]);
			} else {
				segVerts.push(points.vertices[j], points.vertices[j]);
			}
		}
		points.vertices = segVerts;
		/////////////////////////////////////////////////////

		var lineStyle = model.storeApply || modeltheme;

		// // var lineBasicStyle = { color: 0xf0f0f0, linewidth: 1 };
		// var lineBasicStyle = {
		// 	color: lineStyle.strokeColor_,
		// 	linewidth: lineStyle.strokeWidth,
		// 	transparent: true,
		// 	opacity: lineStyle.alpha
		// };
		//
		//
		// // if (!_lineMat || _lastType != model.type) {
		// // 	_lastType = model.type;
		// var _lineMat = new fm.LineBasicMaterial(lineBasicStyle);
		// // }
		var _lineMat = fengmap.MapUtil.getOrCreateLineBasicMaterial(lineStyle.strokeColor_, false, lineStyle.alpha, lineStyle.strokeWidth);
		var line = new fm.LineSegments(points, _lineMat);
		line.castShadow = false;
		line.renderOrder = fengmap.FMRenderOrder.modelLine;

		// record oid to the mesh
		line.fm_ = {
			nodeType: fengmap.FMNodeType.LINE,
			typeID: fmModel.typeID,
			data_: {
				minLevel: model.minLevel,
				maxLevel: model.maxLevel
			},
			o3d_: line
		};

		if(true == castRot){line.rotation.set(Math.PI/2,0,0,'XYZ');}

		// amout 加了一点距离, 是为了解决, 在2D或3D(垂直视角)时
		// 中间的线段会消失的问题
		if(undefined == castZ || true == castZ){line.position.setZ(-amount * .005);}
		if(true == castY)line.position.setY(amount + amount * .005);
		line.geometry.computeBoundingSphere();
        line.geometry.computeBoundingBox();
        
		fmModel.frameLine = line;
		if(undefined == lineLayer){mesh.add(line);}else{lineLayer.o3d_.add(line);}

        mesh.updateMatrixWorld();
		//heatmap
		if (layer.group.heatmap_) {
			layer.group.heatmap_.setModelMeshTexture(mesh);
		}

		if(undefined == donotPick || false == donotPick){
			scope.map_.mapPicker.addModel(mesh);
		}
		return fmModel;
		//}
	},

	createPOIs: function(poi, layer) {
		var scope = this;

		if (typeof poi != 'object') {
			return;
		}

		var spoi = new fengmap.MapPoi(poi.groupID, poi, scope.mapTheme_);

		spoi.minLevel = poi.minLevel;
		spoi.maxLevel = poi.maxLevel;

		var fmFacility = new fengmap.FMFacility(poi, spoi, scope);

		layer.o3d_.boxCollision_ = new fengmap.MapBoxCollision();
		layer.o3d_.add(spoi);

		// support height parameter in data
		var _h = fmg(poi, 'height', 2.5);

		spoi.position.set(poi.vertex[0] - scope.sceneX_, _h, poi.vertex[1] - scope.sceneZ_);

		scope.map_.mapPicker.addPOI(spoi);

		return fmFacility;
	},

	createLabels: function(label, layer) {
		var scope = this;

		if (typeof label != 'object') {
			return;
		}

		if (label.name == '') {
			return;
		}

		var height = label.height >= 0 ? label.height : 6;
		var slbl = new fengmap.MapLabel(label.groupID, label, scope.mapTheme_.labelStyle_, scope.map_);

		slbl.minLevel = label.minLevel;
		slbl.maxLevel = label.maxLevel;

		var fmLabel = new fengmap.FMLabel(label, slbl, scope);

		layer.o3d_.boxCollision_ = new fengmap.MapBoxCollision();
		layer.o3d_.add(slbl);

		slbl.position.set(label.vertex[0] - scope.sceneX_,
			height,
			label.vertex[1] - scope.sceneZ_
		);

		scope.map_.mapPicker.addLabel(slbl);

		return fmLabel;
	},

	createExternalModels: function() {

		function convertToVector3(str) {
			var arr = str.split(',');
			return new fm.Vector3(parseFloat(arr[0]), parseFloat(arr[2]), parseFloat(arr[1]));
		}

		return function(externalModel, layer) {
			var scope = this;

			var themeData = scope.map_.mapTheme.externalModel[externalModel.FID];
			var modelName = externalModel.ename;

			if (!themeData || !modelName) {
				return;
			}
			externalModel.theme = themeData;

			// 因为模型有好多是复制的，并不需要同一个模型，每次使用都去重新去加载
			// 所以需要在类中对正在加载或已经加载的模型进行一下记录，之后有相同模型需求的时候
			// 就要去看一下是否这个模型已经加载了，如果已经加载完成了，就直接复制，如：还没有加载完成就先忽略掉
			// 不做处理
			var father = scope.externalModels[modelName];

			// 些模型正在加载中
			if (father === 'loading') {
				return;
			}

			var mesh = null;

			// 如果没有这个模型的加载记录，就去加载他
			if (!father) {

				scope.externalModels[modelName] = 'loading';
				scope.loadModelForLazy(modelName, layer, function(modelMesh) {
					scope.externalModels[modelName] = modelMesh;
					modelMesh.meta_ = {};
					modelMesh.name = modelName;

					var mats = modelMesh.material.materials || [modelMesh.material];
					mats.forEach(function(m) {
						if (m.map) {

							/////////////////////////////////
							// 20161207 如果材质有贴图就将颜色调成白色. 目的是将模型亮一些 //
							/////////////////////////////////
							m.color.setScalar(1);

							m.map.wrapS = fm.RepeatWrapping;
							m.map.wrapT = fm.RepeatWrapping;
						}
					});
				});

				return;

			} else {

				// 如果已经加载完了这个模型，还要看它是否已经有了初始的位置
				// 如果还没有被复制的话呢，就直接将它摆到这个位置，如果已经
				// 被放置过了，那么就进行复制
				if (father._located) {
					mesh = father.clone();
					mesh.material = father.material.clone();
				} else {
					mesh = father;
					mesh._located = true;
				}

				// add to layer
				layer.o3d_.add(mesh);

			}

			// add to picker
			// 这里可以在有外部模型的主题中增加一个 pickable 的字段
			// 如果没有此字段默认为true，用它来判定是否参与拾取的射线求交计算
			// 将不需要拾取的模型剔除掉，可以提升提取的效率
			if (!(themeData.pickable === false)) {
				scope.map_.mapPicker.addModel(mesh);
			}

			var pos = new fm.Vector3(externalModel.vertex[0] - scope.map_.mapScene.sceneX_,
				0, externalModel.vertex[1] - scope.map_.mapScene.sceneZ_);
			var offset = convertToVector3(themeData.translate);
			var scale = convertToVector3(themeData.scale);
			var rotate = convertToVector3(themeData.rotate).multiplyScalar(fm.Math.DEG2RAD);
			rotate.y += Math.PI;

			// translate | rotate | scale
			mesh.rotation.setFromVector3(rotate, 'YXZ');
			mesh.position.copy(pos.add(offset));
			mesh.scale.copy(scale);

			var ele = new fengmap.FMElement({
				o3d: mesh,
				type: fengmap.FMElementType.EXTERANL_MODEL,
				data: externalModel,
				scene: scope.map_.mapScene // 传Scene是为了得到mapCoord
			});

			return ele;
		}
	}(),

	loadModelForLazy: function(d, layer, cb) {
		var scope = this;

		var fileName = d + '.' + (scope.map_.options.modelFileSuffix || 'js');
		var url = scope.map_.options.mapServerURL + '/models/';
		scope.map_.loader.setTexturePath(url + 'maps/');

		scope.map_.loader.load(url + fileName, function(_mesh) {

			if (cb) {
				cb(_mesh);
			}

		});

	},

	/////////////////////////////////
	// 创建extent 
	/////////////////////////////////
	asyncBuidExtents: function(dg, o3dGroup, gid) {
		var scope 	= this;
		var promise = new fm.Promise();
		if(undefined == dg.geo_extentlayers){promise.resolve();return promise;}

		// console.log(scope.map_.sceneId_, gid, 'extent', scope.map_.mapView.camera.position);

		//var gel = dg['geo_extentlayers'];

		setTimeout(function() {
			console.time('build ' + gid + ' extents');

			var gel = dg.geo_extentlayers;
			for (var i in gel) {
				var el = gel[i];
				//jimguo add beg
				if(undefined == el || undefined == el.extents || 1>el.extents.length){continue;}
				//jimguo add end
				var models = el.extents;
				//jimguo delete beg
				// if (!models) {
				// 	continue;
				// }
				//jimguo delete end

				var fmExtentLayer = new fengmap.FMExtentLayer(el);
				o3dGroup.add(fmExtentLayer.o3d_);
                fmExtentLayer.o3d_.updateMatrixWorld();

				for (var j in models) {
					var fmMesh = scope.createExtents(models[j], fmExtentLayer);
					if(undefined == fmMesh){continue}
					//success to create, then add to octree
					var mesh = fmMesh.o3d_;
					var boundingSphere =  mesh.geometry.boundingSphere;
					if(boundingSphere.radius < 20.0){//add to octree
						scope.getO3dGroupOctree(gid).add(mesh);
						mesh.visible = false;
					}
                    //for box
                    var box = new fm.Box3();
                    box.setFromObject(mesh);
                    // box.copy( mesh.geometry.boundingBox);
                    // box.applyMatrix4(mesh.matrixWorld);
                    // box.applyMatrix4(scope.o3dGroups_[gid].matrixWorld);
                    if(undefined == scope.o3dGroupsBox_[gid]){scope.o3dGroupsBox_[gid]=box;}else{scope.getO3dGroupBox(gid).union(box);} 
				}//end for
			}

			scope.map_.emit('loadLayerComplete', gid, 'extent');

			console.timeEnd('build ' + gid + ' extents');

			promise.resolve();

		}, scope.asyncWaitTime);

		return promise;
	},

	asyncBuidModels: function(dg, o3dGroup, gid, cb) {
		var scope   = this;
		var promise = new fm.Promise();
		if(undefined == dg.geo_modellayers){promise.resolve();return;}
		//var _lineMat = null;

		// console.log(scope.map_.sceneId_, gid, 'model', scope.map_.mapView.camera.position);

		setTimeout(function() {

			console.time('build ' + gid + ' models');

			var gml = dg.geo_modellayers;
			for (var i in gml) {
				var ml = gml[i];
				if(undefined == ml || undefined == ml.models || 1>ml.models.length){continue;}
				// if (typeof ml != 'object') {
				// 	continue;
				// }

				var fmModelLayer = new fengmap.FMModelLayer(ml);
				o3dGroup.add(fmModelLayer.o3d_);
                fmModelLayer.o3d_.updateMatrixWorld();

				// ztc 创建一个线的Layer
				//jimguo delete beg 直接添加到Mesh中
				//var lineLayer = new fengmap.FMLayer(ml, fengmap.FMLayerType.MODEL_LINE);
				//o3dGroup.add(lineLayer.o3d_);
				//fmModelLayer.frameLineLayer = lineLayer;
				//jimguo delte end

				// store image layer
				var storeImageLayer = new fengmap.FMLayer({}, fengmap.FMLayerType.STORE_IMAGE);
				o3dGroup.add(storeImageLayer.o3d_);
                storeImageLayer.o3d_.updateMatrixWorld();

				var _lastType = null;
				var models = ml.models;
				for (var j in models) {
					var model = models[j]; //fid, type, oid, vertices, indices
					if (typeof model != 'object') {continue;}
					//var fmModel = scope.createModels(model, fmModelLayer, storeImageLayer, lineLayer, true, true, false, true);
					var fmModel = scope.createModels(model, fmModelLayer, storeImageLayer, undefined, false, false, false, false);
					if(undefined == fmModel){continue;}
					//success to create, then add to octree
					var mesh = fmModel.o3d_;
					var boundingSphere =  mesh.geometry.boundingSphere;
					if(boundingSphere.radius < 4.0){//add to octree
						scope.getO3dGroupOctree(gid).add(mesh);
						mesh.visible = false;
					}
                    //for box
                    var box = new fm.Box3();
                    box.setFromObject(mesh);
                    // box.copy( mesh.geometry.boundingBox);
                    // box.applyMatrix4(mesh.matrixWorld);
                    // box.applyMatrix4(scope.o3dGroups_[gid].matrixWorld);
                    if(undefined == scope.o3dGroupsBox_[gid]){scope.o3dGroupsBox_[gid]=box;}else{scope.getO3dGroupBox(gid).union(box);} 
					//jimguo delete beg 不需要回调
					//cb(fmModel.o3d_);
					//jimguo delte end

					// if (!model.fid) {
					// 	continue;
					// }
                    //
					// var amount = 5;
					// if (model.hasOwnProperty('height') && model.height != null && model.height > 0) {
					// 	amount = model.height;
					// }
                    //
					// model.height = amount;
                    //
					// // 将model的数据记录下来
					// scope.modelDatas[model.fid] = model;
                    //
					// // count property
					// if (!scope.modelDatas.count) {
					// 	scope.modelDatas.count = 1;
					// } else {
					// 	scope.modelDatas.count++;
					// }
                    //
					// var gs = scope.createGeometry_(model, amount);
					// if(undefined == gs){continue;}
                    //
					// // if (gs) {
                    //
					// /////////////////////////////////
					// // store image
					// /////////////////////////////////
					// var sidatas = scope.mapTheme_.storeImages[model.fid];
                    //
					// if (sidatas) {
					// 	/*var sidata = null;
					// 	 for (var i = 0; i < sidatas.length; i++) {
					// 	 sidata = sidatas[i];
					// 	 sidata.height = amount + 0.2;
                    //
					// 	 var si = new fengmap.FMStoreImage({
					// 	 gid: gid,
					// 	 fid: model.fid,
					// 	 style: sidata,
					// 	 map: this.map_
					// 	 });
                    //
					// 	 // storeImageLayer.add(si);
					// 	 storeImageLayer.addMarker(si);
					// 	 }*/
                    //
					// 	scope._createStoreImages(sidatas, model, storeImageLayer);
					// }
                    //
					// var modeltheme = scope.mapTheme_.getModelTheme(model);
					// // var mesh = new fengmap.ModelMesh(gs.geometry, scope.mapTheme_);
                    //
					// // console.log(model, modeltheme);
					// var mesh = new fengmap.ModelMesh(gs.geometry, model.storeApply || model.theme_);
                    //
					// //if extrude
					// mesh.rotation.set(Math.PI / 2, 0, 0, 'XYZ');
					// mesh.position.setY(amount);
                    //
					// //end if extrude
                    //
					// mesh.meta_ = model;
					// mesh.meta_.theme_ = modeltheme;
					// mesh.meta_.type_ = 'Model';
                    //
					// fmModelLayer.o3d_.add(mesh);
                    //
					// // mesh.updateMatrixWorld();
                    //
					// // mesh.frustumCulled = false;
                    //
					// // mesh.localToWorld(mesh.geometry.boundingSphere.center);
                    //
					// var fmModel = new fengmap.FMModel(model, mesh, scope);
                    //
					// cb(mesh);
                    //
					// /**
					//  * 画线框
					//  */
					// var points = gs.shape.createPointsGeometry();
					// if (points && points.vertices.length > 0) points.vertices.push(points.vertices[0]);
                    //
					// ////////////////////////////////////////////////////
					// /// 将 Line 变为 LineSegments 方便之后的合并工作 ///
					// ////////////////////////////////////////////////////
					// var segVerts = [];
					// var len = points.vertices.length;
                    //
					// for (var j = 0; j < len; j++) {
					// 	if (j == 0 || j == len - 1) {
					// 		segVerts.push(points.vertices[j]);
					// 	} else {
					// 		segVerts.push(points.vertices[j], points.vertices[j]);
					// 	}
					// }
					// points.vertices = segVerts;
					// /////////////////////////////////////////////////////
                    //
					// var lineStyle = model.storeApply || modeltheme;
                    //
					// // var lineBasicStyle = { color: 0xf0f0f0, linewidth: 1 };
					// var lineBasicStyle = {
					// 	color: lineStyle.strokeColor_,
					// 	linewidth: lineStyle.strokeWidth,
					// 	transparent: true,
					// 	opacity: lineStyle.alpha
					// };
                    //
					// if (!_lineMat || _lastType != model.type) {
					// 	_lastType = model.type;
					// 	_lineMat = new fm.LineBasicMaterial(lineBasicStyle);
					// }
                    //
					// var line = new fm.LineSegments(points, _lineMat);
					// line.castShadow = false;
					// line.renderOrder = fengmap.FMRenderOrder.modelLine;
                    //
					// // record oid to the mesh
					// line.fm_ = {
					// 	nodeType: fengmap.FMNodeType.LINE,
					// 	typeID: fmModel.typeID,
					// 	data_: {
					// 		minLevel: model.minLevel,
					// 		maxLevel: model.maxLevel
					// 	}
					// };
                    //
					// line.rotation.set(Math.PI / 2, 0, 0, 'XYZ');
                    //
					// // amout 加了一点距离, 是为了解决, 在2D或3D(垂直视角)时
					// // 中间的线段会消失的问题
					// line.position.setY(amount + amount * .005);
                    //
					// line.geometry.computeBoundingSphere();
                    //
					// fmModel.frameLine = line;
                    //
					// lineLayer.o3d_.add(line);
					// }
				}//end for models
			}//end for gml

			scope.map_.emit('loadLayerComplete', gid, 'model');

			console.timeEnd('build ' + gid + ' models');

			promise.resolve();

		}, scope.asyncWaitTime);


		return promise;
	},

	asyncBuildPOIs: function(dg, o3dGroup, gid) {
		var scope   = this;
		var promise = new fm.Promise();
		if(undefined == dg.geo_poilayers){promise.resolve();return;}

		var _boxCollision_ = null;
		scope.poiLayer = null;

		// console.log(scope.map_.sceneId_, gid, 'poi', scope.map_.mapView.camera.position);


		setTimeout(function() {

			console.time('build ' + gid + ' POIs');

			var layers = {};

			//poi
			var gpl = dg.geo_poilayers;
			for (var i in gpl) {
				var pl = gpl[i];
				if(undefined == pl || undefined == pl.pois || 1>pl.pois.length){continue;}
                //
				var pois = pl.pois;
				for (var j in pois) {
					var poi = pois[j];
					if (typeof poi != 'object') {continue;}

					/////////////////////////////////
					// create level layer
					var minl = poi.minLevel;
					var maxl = poi.maxLevel;

					var _str = '' + minl + maxl;

					var fmFacilityLayer = layers[_str];

					if (!fmFacilityLayer) {
						// set map property of fmFacilityLayer 20161205
						fmFacilityLayer = new fengmap.FMFacilityLayer(pl, scope.map_);
						o3dGroup.add(fmFacilityLayer.o3d_);
                        fmFacilityLayer.o3d_.updateMatrixWorld();
                        
						fmFacilityLayer.o3d_.boxCollision_ = _boxCollision_ || new fengmap.MapBoxCollision();

						if (!_boxCollision_) {
							_boxCollision_ = fmFacilityLayer.o3d_.boxCollision_;
						}

						if (!scope.poiLayer) {
							scope.poiLayer = fmFacilityLayer;
						}

						fmFacilityLayer.minLevel = minl;
						fmFacilityLayer.maxLevel = maxl;

						layers[_str] = fmFacilityLayer;
					}

					/////////////////////////////////

					var spoi = new fengmap.MapPoi(gid, poi, scope.mapTheme_);
					spoi.minLevel = poi.minLevel;
					spoi.maxLevel = poi.maxLevel;

					var fmFacility = new fengmap.FMFacility(poi, spoi, scope);

					fmFacilityLayer.o3d_.add(spoi);

					// support height parameter in data
					var _h = fmg(poi, 'height', 6);

					//由于透视的原因，远处的POI有可能陷入到模型中去，这个只有将来采用Orthographic方式分层渲染才可以做到完美解决。
					//目前可以采用基于底部的缩放来解决！
					// spoi.position.set(poi.vertex[0] - this.sceneX_, 5 + 1, poi.vertex[1] - this.sceneZ_);
					spoi.position.set(poi.vertex[0] - scope.sceneX_, _h, poi.vertex[1] - scope.sceneZ_);

					scope.map_.mapPicker.addPOI(spoi);
				}
			}

			scope.map_.emit('loadLayerComplete', gid, 'facility');

			console.timeEnd('build ' + gid + ' POIs');

			promise.resolve();

		}, scope.asyncWaitTime);


		return promise;
	},

	asyncBuildLabels: function(dg, o3dGroup, gid) {
		var scope   = this;
		var promise = new fm.Promise();
		if(undefined == dg.geo_labellayers){promise.resolve();return;}
		// console.log(scope.map_.sceneId_, gid, 'label', scope.map_.mapView.camera.position);

		var layers = {};

		setTimeout(function() {

			console.time('build ' + gid + ' labels');

			//poi
			var gll = dg.geo_labellayers;
			for (var i in gll) {
				var ll = gll[i];
				if(undefined == ll || undefined == ll.labels || 1>ll.labels.length){continue;}

				var labels = ll.labels;
				for (var j in labels) {
					var label = labels[j];
					if (typeof label != 'object' || label.name == '') {continue;}

					/////////////////////////////////
					// create level layer
					var minl = label.minLevel;
					var maxl = label.maxLevel;

					var _str = '' + minl + maxl;

					var fmLabelLayer = layers[_str];

					if (!fmLabelLayer) {
						fmLabelLayer = new fengmap.FMLabelLayer(ll, scope.map_);

						// if (minl!=-1 && maxl!=-1) {

						// 	if (minl < scope.map_.mapScaleLevel || maxl > scope.map_.mapScaleLevel) {
						// 		fmLabelLayer.visible = false;
						// 	}
						// }

						o3dGroup.add(fmLabelLayer.o3d_);
                        fmLabelLayer.o3d_.updateMatrixWorld();
						// fmLabelLayer.o3d_.boxCollision_ = _boxCollision_ || new fengmap.MapBoxCollision();
						fmLabelLayer.o3d_.boxCollision_ = new fengmap.MapBoxCollision();
						fmLabelLayer.poiLayer = scope.poiLayer;

						fmLabelLayer.minLevel = minl;
						fmLabelLayer.maxLevel = maxl;

						layers[_str] = fmLabelLayer;
					}

					/////////////////////////////////

					var height = label.height >= 0 ? label.height : 6;
					var slbl = new fengmap.MapLabel(gid, label, scope.mapTheme_.labelStyle_, scope.map_);
					slbl.minLevel = label.minLevel;
					slbl.maxLevel = label.maxLevel;

					var fmLabel = new fengmap.FMLabel(label, slbl, scope);
					// slbl.visible = false;

					fmLabelLayer.o3d_.add(slbl);

					slbl.position.set(label.vertex[0] - scope.sceneX_,
						height,
						label.vertex[1] - scope.sceneZ_
					);

					scope.map_.mapPicker.addLabel(slbl);
				}
			}

			scope.map_.emit('loadLayerComplete', gid, 'label');

			console.timeEnd('build ' + gid + ' labels');

			promise.resolve();
		}, scope.asyncWaitTime);

		return promise;
	},

	asyncBuildPolygons: function(dg, o3dGroup, gid) {
		var scope = this;
		var promise = new fm.Promise();
		if(undefined == dg.geo_polygonlayer){promise.resolve();return;}
		// console.log(scope.map_.sceneId_, gid, 'polygons', scope.map_.mapView.camera.position);

		setTimeout(function() {
			console.time('build ' + gid + ' polygons');

			var gpl = dg.geo_polygonlayer;
			for (var i in gpl) {
				var pl = gpl[i];
				if(undefined == pl || undefined == pl.polygons || 1>pl.polygons.length){continue;}

				var pll = new fengmap.FMLayer(pl, fengmap.FMLayerType.POLYGON);
				o3dGroup.add(pll.o3d_);
                pll.o3d_.updateMatrixWorld();

				var ps = pl.polygons;
				for (var j in ps) {
					var p = ps[j];
					var apmount = 0;
					if (p.hasOwnProperty('height') && p.height != null && p.height > 0) {
						apmount = p.height;
					}

					var _geo = scope.createGeometry_(p, apmount);
					if(undefined == _geo){continue;}
					// if (_geo) {
						var mesh = new fm.Mesh(_geo.geometry);
						mesh.rotation.set(Math.PI / 2, 0, 0, 'XYZ');
						mesh.position.y = apmount;

						new fengmap.FMElement({
							o3d: mesh,
							data: p,
							type: fengmap.FMElementType.POLYGON
						});

						pll.o3d_.add(mesh);

						mesh.material = scope.map_.mapTheme.polygonMap[p.typeID];
						if (mesh.material) {
							// MultiMaterial
							if (mesh.material.materials) {
								mesh.material.materials.forEach(function(mat) {
									mat.side = fm.DoubleSide;
								});
							} else {
								mesh.material.side = fm.DoubleSide;
							}
						}
						// shadow
						//mesh.receiveShadow = true;
					// }
				}
			}

			var gpgl = dg.geo_polygonlabellayer;
			for(var i in gpgl){
				var pll = gpgl[i];
				//jimguo add beg
				if(undefined == pll || undefined == pll.plabels || 1>pll.plabels.length){continue;}
				//jimguo add end

				var layer = new fengmap.FMLayer(pll, fengmap.FMLayerType.POLYGON_LABEL);
				o3dGroup.add(layer.o3d_);
                layer.o3d_.updateMatrixWorld();

				var pls = pll.plabels;
				for(var j in pls){
					var pl = pls[j];

					pl.sx = this.sceneX_;
					pl.sz = this.sceneZ_;

					var obj = new fengmap.FMPolygonLabel(pl);
					layer.o3d_.add(obj);
				}
			}

			scope.map_.emit('loadLayerComplete', gid, 'polygon');

			console.timeEnd('build ' + gid + ' polygons');

			promise.resolve();

		}, scope.asyncWaitTime);

		return promise;
	},

	asyncBuildStairs: function(dg, o3dGroup, gid) {
		var scope = this;
		var promise = new fm.Promise();
		if(undefined == dg.geo_stairlayers){promise.resolve();return;}

		// console.log(scope.map_.sceneId_, gid, 'stairs', scope.map_.mapView.camera.position);

		var center = scope.map_.center;
		var group = scope.map_.getFMGroup(gid);

		setTimeout(function() {

			console.time('build ' + gid + ' stairs');

			//stair layer
			var gsl = dg.geo_stairlayers;
			for(var i in gsl){
				var sl = gsl[i];
				if(undefined == sl || undefined == sl.stairs || 1>sl.stairs.length){continue;}

				var layer = new fm.Object3D();
				layer.visible = false;
				layer.name = 'stairsLayer';

				group.stairsLayer = layer;
				group.o3d_.add(layer);

				var config = scope.map_.options.stairsConfig;
				config.map = scope.map_;

				var sls = sl.stairs;
				for(var j in sls) {
					var s = sls[j];

					var stair = new fengmap.FMStairsPair(config);
					layer.add(stair.container);

					stair.position.set(s.vertex[0] + center.x, 0, s.vertex[1] - center.y);
				}
				// var data = sl.stairs;
				// data.forEach(function(itm) {
				// 	var config = scope.map_.options.stairsConfig;
				// 	config.map = scope.map_;
				// 	var stair = new fengmap.FMStairsPair(config);
				// 	layer.add(stair.container);
                //
				// 	stair.position.set(itm.vertex[0] + center.x, 0, itm.vertex[1] - center.y);
				// });
			}

			scope.map_.emit('loadLayerComplete', gid, 'stair');

			console.timeEnd('build ' + gid + ' stairs');

			promise.resolve();

		}, scope.asyncWaitTime);

		return promise;
	},

	asyncBuildExternalModels: function(dg, o3dGroup, gid) {
		var scope   = this;
        var promise = new fm.Promise();
		//function convertToVector3(str) {
		//	var arr = str.split(',');
		//	return new fm.Vector3(parseFloat(arr[0]), parseFloat(arr[2]), parseFloat(arr[1]));
		//}

		// console.log(scope.map_.sceneId_, gid, 'exmodel', scope.map_.mapView.camera.position);
        if(undefined == dg.geo_externalmodellayer){promise.resolve();return;}
        
        setTimeout(function() {
            console.time('build ' + gid + ' ExternalModels');

			//stair layer
			var gel = dg.geo_externalmodellayer;
			for(var i in gel){
				var el = gel[i];
				if(undefined == el || undefined == el.externals || 1>el.externals.length){continue;}
                
                // create layer
                var layer = new fengmap.FMExternalModelLayer(el);
                o3dGroup.add(layer.o3d_);
                layer.o3d_.updateMatrixWorld();
                
                var ms = {};
                var ele = el.externals;
				for(var j in ele) {
					var e  = ele[j];
                    var tm = scope.mapTheme_.externalModel[e.fid];
                    if(undefined == e.fid || undefined == tm){continue;}
                    
                    e.groupID = gid;

					var pos     = new fm.Vector3(e.vertex[0] - scope.map_.mapScene.sceneX_, 0, e.vertex[1] - scope.map_.mapScene.sceneZ_);
					var offset  = fengmap.MapUtil.convertToVector3(tm.translate);
					var scale   = fengmap.MapUtil.convertToVector3(tm.scale);
					var rotate  = fengmap.MapUtil.convertToVector3(tm.rotate).multiplyScalar(fm.Math.DEG2RAD);
					rotate.y    += Math.PI;

					var modelName = tm.theme_.model.split('.')[0];
					ms[modelName] = ms[modelName] || [];

					var element = new fengmap.FMElement({
							o3d: null,
							type: fengmap.FMElementType.EXTERANL_MODEL,
							data: e,
							scene: scope.map_.mapScene // 传Scene是为了得到mapCoord
						});

					ms[modelName].push({
						p: pos,
						o: offset,
						r: rotate,
						s: scale,
						tm: tm,
						ele: element
					});

					layer.addElement(element);
                }//end for ele
                
                var keys = Object.keys(ms);
                setTimeout(function() {
                    promise.resolve();
                    scope.asyncLoadModels(keys, ms, layer);
                }, scope.asyncWaitTime);
                
            }//end for gel
            
        }, scope.asyncWaitTime);//end setTimeout
		

		// // external models
		// dg.geo_externalmodellayer.forEach(function(itm) {
			// //jimguo add beg
			// if(undefined == itm || undefined == itm.externals){return;}
			// //jimguo add end

			// // create layer
			// var layer = new fengmap.FMExternalModelLayer(itm);
			// o3dGroup.add(layer.o3d_);

			// var ms = {};

			// itm.externals.forEach(function(obj) {
				// if (obj.fid) {
					// obj.groupID = gid;
					// var tm = scope.mapTheme_.externalModel[obj.fid];
					// if (!tm) {
						// return;
					// }
					// var pos = new fm.Vector3(obj.vertex[0] - scope.map_.mapScene.sceneX_, 0, obj.vertex[1] - scope.map_.mapScene.sceneZ_);
					// var offset = fengmap.MapUtil.convertToVector3(tm.translate);
					// var scale = fengmap.MapUtil.convertToVector3(tm.scale);
					// var rotate = fengmap.MapUtil.convertToVector3(tm.rotate).multiplyScalar(fm.Math.DEG2RAD);
					// rotate.y += Math.PI;

					// var modelName = tm.theme_.model.split('.')[0];
					// ms[modelName] = ms[modelName] || [];

					// var element = new fengmap.FMElement({
							// o3d: null,
							// type: fengmap.FMElementType.EXTERANL_MODEL,
							// data: obj,
							// scene: scope.map_.mapScene // 传Scene是为了得到mapCoord
						// });

					// ms[modelName].push({
						// p: pos,
						// o: offset,
						// r: rotate,
						// s: scale,
						// tm: tm,
						// ele: element
					// });

					// layer.addElement(element);
				// }
			// });

			// var keys = Object.keys(ms);

			// setTimeout(function() {
				// promise.resolve();
				// scope.asyncLoadModels(keys, ms, layer);
			// }, scope.asyncWaitTime);
		// });

		return promise;
	},

	asyncLoadModels: function() {

		// var _modelIndex = -1;
		// 防止多层同时调用, 这个公共的字段会被覆盖
		var _mi_ = {};

		return function(models, ms, layer) {
			var scope = this;

			if (_mi_[layer.groupID] === undefined) {
				_mi_[layer.groupID] = -1;
			}

			// _modelIndex ++;
			_mi_[layer.groupID]++;
			if (_mi_[layer.groupID] == models.length) {
				_mi_[layer.groupID] = -1;
				return;
			}

			// var d = models[_modelIndex];
			var d = models[_mi_[layer.groupID]];

			scope.loadModel(d, layer, ms, function(_mesh) {
                if(undefined != _mesh){//load successed
                    for (var i = 0; i < ms[d].length; i++) {
                        var mesh = _mesh;
                        if (0 < i) {//mesh = new fm.Mesh( _mesh.geometry, _mesh.material );
                            mesh = _mesh.clone();// clone mesh
                        }
                        mesh.name  = d;
                        mesh.meta_ = {};
                
                        scope.map_.mapPicker.addModel(mesh);

                        mesh.rotation.setFromVector3(ms[d][i].r, 'YXZ');
                        mesh.position.copy(ms[d][i].p.add(ms[d][i].o));
                        mesh.scale.copy(ms[d][i].s);

                        ms[d][i].ele.setO3d(mesh);
                        
                        //var gid = ms[d][i].ele.data_.groupID;
                        var gid = layer.groupID;

                        layer.o3d_.add(mesh);
                        mesh.updateMatrixWorld();
                        
                        var boundingSphere = new fm.Sphere(undefined, 10.0);
                        if(_mesh instanceof fm.Mesh){
                            boundingSphere.copy(mesh.geometry.boundingSphere);
                        }else if(_mesh instanceof fm.LOD){
                            var lvmesh = _mesh.levels[0].object;
                            boundingSphere.copy(lvmesh.geometry.boundingSphere);
                        }
                        //console.log(""+gid+" "+d+"exmodel boundingSphere.radius: "+boundingSphere.radius);
                        if(boundingSphere.radius < 3.4){//add to octree
                            scope.getO3dGroupOctree(gid).add(mesh);
                            mesh.visible = false;
                        }
                        //for box
                        var box = new fm.Box3();
                        box.setFromObject(mesh);
                        //box.copy( mesh.geometry.boundingBox);
                        //box.applyMatrix4(mesh.matrixWorld);
                        //box.applyMatrix4(scope.o3dGroups_[gid].matrixWorld);
                        if(undefined == scope.o3dGroupsBox_[gid]){scope.o3dGroupsBox_[gid]=box;}else{scope.getO3dGroupBox(gid).union(box);} 
                    }
                }//end if
				setTimeout(function() {
					scope.asyncLoadModels(models, ms, layer);
				}, 0);
			});
		}

	}(),

	loadModel: function(d, layer, ms, cb) {
		var scope     = this;
        var cbInvoked = false;
        var meshTarget = scope.mapTheme_.models[d];
        if(undefined != meshTarget){
            if (cb && !cbInvoked) {cbInvoked = true;cb(meshTarget);}
            return;
        }

		var fileName = d + '.' + (scope.map_.options.modelFileSuffix || 'js');
		var url = scope.map_.options.mapServerURL + '/models/';
		scope.map_.loader.setTexturePath(url + 'maps/');


		// timeout
		// 如果大于10秒钟了, 这个模型还没有加载进来. 那么直接
		// 调用回调,开始下载下一个模型
		//setTimeout(function() {
		//	cbInvoked = true;
		//	if (cb && !cbInvoked) {
		//		cb();
		//	}
		//}, 10000);

		var mesh = null;
		scope.map_.loader.load(url + fileName, function(_mesh) {
            if(undefined != _mesh && _mesh instanceof fm.Mesh){
                _mesh.geometry.computeBoundingSphere();
                _mesh.geometry.computeBoundingBox();
                //_mesh.castShadow = false;
                var mats = _mesh.material.materials || [_mesh.material];
                mats.forEach(function(mat) {
                    // mat.emissive = new fm.Color(0x222222);
                    if (undefined != mat.map) {
                        /////////////////////////////////
                        // 20161207 如果材质有贴图就将颜色调成白色. 目的是将模型亮一些 //
                        /////////////////////////////////
                        mat.color.setScalar(1);
                        mat.map.wrapS = fm.RepeatWrapping;
                        mat.map.wrapT = fm.RepeatWrapping;
                    }
                });
                // record to theme
                scope.mapTheme_.models[d] = _mesh;
            }else if(undefined != _mesh && _mesh instanceof fm.LOD){
                for(var i=0, l=_mesh.levels.length; i<l; ++i){
                    var lvmesh = _mesh.levels[i].object;
                    lvmesh.geometry.computeBoundingSphere();
                    lvmesh.geometry.computeBoundingBox();
                    //lvmesh.castShadow = false;
                    var mats = lvmesh.material.materials || [lvmesh.material];
                    mats.forEach(function(mat) {
                        // mat.emissive = new fm.Color(0x222222);
                        if (undefined != mat.map) {
                            /////////////////////////////////
                            // 20161207 如果材质有贴图就将颜色调成白色. 目的是将模型亮一些 //
                            /////////////////////////////////
                            mat.color.setScalar(1);
                            mat.map.wrapS = fm.RepeatWrapping;
                            mat.map.wrapT = fm.RepeatWrapping;
                        }
                    });
                }//end for
                // record to theme
                scope.mapTheme_.models[d] = _mesh;
            }
			
            if (cb && !cbInvoked) {cbInvoked = true;cb(_mesh);}
		});

	},

	collideLabel_: function(mapView, labels) {
		var bc = labels.boxCollision_;
		var requireCollide_ = labels.fm_.requireCollide_;

		var ver = this.map_.mapTheme.version;
		var val = ver == 1 ? 4 : 2;

		// if (labels.fm_ && labels.fm_ instanceof fengmap.FMFacilityLayer) {
		bc.clear();
		// }

		if (labels.fm_ && labels.fm_ instanceof fengmap.FMLabelLayer) {
			if (labels.fm_.poiLayer && labels.fm_.poiLayer.visible) {
				// bc.rects_ = bc.rects_.concat(labels.fm_.poiLayer.o3d_.boxCollision_.rects_);
				Array.prototype.push.apply(bc.rects_, labels.fm_.poiLayer.o3d_.boxCollision_.rects_);
			}
		}

		// return;

		for (var i in labels.children) {
			var label = labels.children[i];

			//
			// scaleLevel
			//
			var curMapScaleLevel = this.map_.mapScaleLevel;

			var inView = true;

			if (label.minLevel !== undefined && label.minLevel != -1 && (curMapScaleLevel < (label.minLevel + this.map_.options.levelShowOffset) ||
					curMapScaleLevel > (label.maxLevel + this.map_.options.levelShowOffset))) {
				inView = false;
			}

			//
			// 视锥剔除
			//
			if (this.map_.options.lazyCreateMode) {
				inView = inView && this.map_.mapView.inView(label, 'sprite');
			}

			if (inView && label.fm_) {
				var p2 = this.map_.project_(label);
				var w = label.width_ / ((label.scaleRatio_ || val) / 2) * 1.1; // 将避让的计算范围扩大1.1倍
				var h = label.height_ / ((label.scaleRatio_ || val) / 2) * 1.1;

				// real visible
				// if (!label.fm_.visible) {
				// 	label.visible = false;
				// 	continue;
				// }

				if (label.forceVisible) {
					label.fm_.visible = true;
				} else {
					if ((requireCollide_ && bc.push(label, {
							x: p2.x - w / 2,
							y: p2.y - h / 2,
							w: w,
							h: h
						}))) {
						label.fm_.visible = false;
					} else {
						label.fm_.visible = true;
					}
				}

				label.updateScreenSize(mapView);
				// if (requireCollide_ && bc.push(label, {x:p2.x-w/2, y:p2.y-h/2, w:w, h:h})) {
				// 	if (label.fm_ && label.fm_.constAlpha != undefined) {
				// 		label.updateScreenSize(mapView);
				// 		continue;
				// 	}

				// 	if (labels.fm_.noFade || this.map_.passiveMode) {
				// 		label.visible = false;
				// 		// label._visible = false;
				// 		label.fadeVisible = null;
				// 	} else {
				// 		label.fadeVisible = false;
				// 	}
				// 	// if (isPOI) {
				// 		// label.visible = false;
				// 		// label.fadeVisible = false;
				// 	// } else {
				// 	// 	// 20161202 fade effect 领导强调多次要加
				// 	// 	label.fade({
				// 	// 		out: true,
				// 	// 	});
				// 	// }

				// } else {
				// 	if (labels.fm_.noFade || this.map_.passiveMode) {
				// 		label.visible = true;
				// 		label.fadeVisible = null;
				// 	} else {
				// 		label.fadeVisible = true;
				// 	}
				// 	// if (isPOI) {
				// 		// label.visible = true;
				// 		// label.fadeVisible = true;
				// 	// } else {
				// 		// label.fade();
				// 	// }


				// 	label.updateScreenSize(mapView);
				// }
			}
		};
	},
	/*	
	collidePoi_:function(mapView, pois) {
		var bc = pois.boxCollision_;
		var requireCollide_ = pois.fm_.requireCollide_;
		bc.clear();

		for (var i in pois.children){
			var poi = pois.children[i];
			if (poi.forceVisible_) {
				var p2 = this.map_.project_(poi);
				var w = poi.width_ / 2;
				var h = poi.height_ / 2;

				if (requireCollide_ && bc.push(poi, {x:p2.x-w/2, y:p2.y-h/2, w:w, h:h})) {
					poi.visible = false;
				} else {
					poi.visible = true;
					poi.updateScreenSize(mapView);
				}
			}
		};
	},
	//*/
	updateCollide: function(mapView) {
        var scope = this;
		for (var k in scope.o3dGroups_) {
			var grp = scope.o3dGroups_[k];
            
            var box_ = scope.o3dGroupsBox_[k];
            if(undefined != box_){
                var c = box_.center();
                var s = box_.size().multiplyScalar(0.9);
                var box = new fm.Box3();
                box.setFromCenterAndSize(c, s);
                grp.visible = scope.map_.mapView.inView(box, 'box');
                //console.log("gid: "+k+" box: min("+box.min.x+","+box.min.y+","+box.min.z+") max("+box.max.x+","+box.max.y+","+box.max.z+") visible: "+grp.visible);
                
                if(grp.visible){
                    var camV = scope.map_.mapView.camera.position.clone();
                    camV.sub(box.center());
                    var dis = Math.abs(camV.y);
                    camV.normalize();
                    var dt = camV.dot(new fm.Vector3(0,1,0));
                    if(dis>160.0 && Math.abs(dt)>0.95){
                        grp.visible = false;
                    }
                    //console.log("gid: "+k+" dis: "+dis+" "+" dt: "+dt+" "+grp.visible);
                }
            }

			if(!grp.visible){continue;}

			//octree update
			var octree = this.o3dGroupsOctree_[k];
			octree.update();
			{
				//default to visible = false
				for(var kk in octree.objects){
					octree.objects[kk].visible = false;
				}
				var meshesSearch = [];
				var origin = new fm.Vector3();
				origin.copy( mapView.camera.position );
				meshesSearch = octree.search( origin, 100, false, undefined );
				for (var i = 0, il = meshesSearch.length; i < il; i++ ) {
					var object = meshesSearch[i].object;
                    if(undefined != object.parent && (false == object.parent.visible)){continue;}
                    if(object instanceof fm.LOD){
                        object.update( mapView.camera );
                        object.visible = true;
                        continue;
                    }
					var modelViewMatrix = new fm.Matrix4();
					modelViewMatrix.multiplyMatrices( mapView.camera.matrixWorldInverse, object.matrixWorld );
					var sphere = new fm.Sphere();
					sphere.copy(object.geometry.boundingSphere);
					sphere.applyMatrix4(modelViewMatrix);
					//console.log(""+sphere.center.length());
					if(sphere.center.length()-sphere.radius< 100.00){
						object.visible = true;
					}
				}
			}

			//
			for (var i = 0; i < grp.children.length; i++) {
				var layer = grp.children[i];
				var fm_ = layer.fm_;
				if (fm_ && fm_.visible) {
					if (fm_ instanceof fengmap.FMLabelLayer || fm_ instanceof fengmap.FMTextMarkerLayer) {
						this.collideLabel_(mapView, layer);
					} else if (fm_ instanceof fengmap.FMFacilityLayer ||
						fm_ instanceof fengmap.FMImageMarkerLayer ||
						fm_ instanceof fengmap.FMLocationMarkerLayer
					) {
						// this.collidePoi_(mapView, layer);
						this.collideLabel_(mapView, layer);
					}
				}
			}
		}//end for

	},
	drawNavigation: function(d, style) {
		// this.clearNavigation();
		var this_ = this;

		var ns = style || this.mapTheme_.navigateStyle_;

		var arr = [];
		var lastPoint = null;
		var results = d.results;
		for (var i in results) {
			var group = results[i];
			if (!group.points) {
				continue;
			}
			var g = this.o3dGroups_[group.groupid];
			var height = 0;

			// set original height
			if (g) {
				height = g.position.y + (fmg(ns, 'height', 1));
			}

			var points = group.points;
			for (var j in points) {
				var point = points[j];
				if (point.x == undefined) {
					continue;
				}

				var p = new fm.Vector3(-point.x - this.sceneX_, height, point.y - this.sceneZ_); //tempFlipX_
				if (lastPoint == null || !lastPoint.equals(p)) {
					arr.push(p);
				}

				lastPoint = p;
			}
		}

		//////////
		// 圆滑转角 //
		//////////
		ns.smooth = fmg(ns, 'smooth', true);
		// 自定义转角处的段数
		var segments = fmg(ns, 'segments', null);
		// if (ns.smooth) {
		arr = fengmap.MapSceneUtil.buildCurvePoints(arr, (segments || (ns.smooth ? 8 : 2)), this_.map_.options.cornerRoundLimit);
		// }

		var line = null;

		if (ns.lineType == 'raw') {
			line = new fengmap.RawLine(this_.map_, arr, ns);
		} else {
			line = new fengmap.Line(this_.map_, arr, ns);
		}

		this.map_.forceUpdate();
		this.o3dNavigation_.add(line);

		// line.visible = true;
		line.material.visible = true;

		// add offsetHeight
		if (ns.offsetHeight != undefined) {
			line.position.y += ns.offsetHeight;
		}

		// check if visible
		line.visibleGroupIDsChanged(this.map_.visibleGroupIDs);

		// 被动渲染
		if (this.map_.passiveMode) {
			// 更新一下, 为了是直接计算半径,避免闪一下的问题
			this.map_.forceUpdate(true);
		}

		return line;
	},

	clearNavigation: function(lm) {
		var c = [];
		if (lm) {
			c = c.concat(lm);
		} else {
			c = this.o3dNavigation_.children;
		}

		for (var i = c.length - 1; i >= 0; i--) {
			// this.o3dNavigation_.remove(c[i]);

			// use line's dispose to remove update funciton automic
			if (c[i].dispose) {
				c[i].dispose();
			}
		}
	},
	//
	drawLineMark: function(lm, style) {
		var d = {
			results: lm.segments
		};
		return this.drawNavigation(d, style);
	},
	clearLineMark: function(lm) {
		this.clearNavigation(lm);
	},

	// -------------------------------------------------------------------------
	// Private
	createGeometry_: function(model, amount) {
		var vs1 = model.vertices;
		if(vs1.length < 6){return undefined;}

		//if (vs1.length >= 6) {

		var geo;

		var shape = new fm.Shape();
		var sx = this.sceneX_;
		var sz = this.sceneZ_;
		if (model.holes && model.holes.length > 0) {

			var rm_holes = {};
			for (var i in model.holes) {
				var hole = model.holes[i];
				for (var j = 0; j < hole.length; j += 2) {
					var pt = '' + hole[j] + '-' + hole[j + 1];
					rm_holes[pt] = true;
				}
			}

			this.forEachVertForShape_(vs1, function(first, x, y) {
				if (first) {
					shape.moveTo(x - sx, y - sz);
				} else {
					if (!rm_holes['' + x + '-' + y]) {
						shape.lineTo(x - sx, y - sz);
					}
				}
			});

			for (var i in model.holes) {
				var hole = model.holes[i];
				var holePath = new fm.Path();
				this.forEachVertForShape_(hole, function(first, x, y) {
					if (first) {
						holePath.moveTo(x - sx, y - sz);
					} else {
						holePath.lineTo(x - sx, y - sz);
					}
				});
				shape.holes.push(holePath);
			}

		} else {
			this.forEachVertForShape_(vs1, function(first, x, y) {
				if (first) {
					shape.moveTo(x - sx, y - sz);
				} else {
					shape.lineTo(x - sx, y - sz);
				}
			});
		}


		if (amount == 0) {
			geo = new fm.ShapeGeometry(shape);
		} else {
			geo = new fm.ExtrudeGeometry(shape, {
				amount: amount,
				bevelEnabled: false,
				noSideFaces: this.map_.options.noSideFaces,
				// material: 0,			// not work anymore
				// extrudeMaterial: 0	// not work anymore
				// bevelThickness: 6,
				// bevelSize: 6-2,
				// bevelSegments: 3,
				// curveSegments: 12,
				// steps: 1,
				// uvGenerator: function
			});
		}

		// 将所有的 materialIndex 都设置为0,默认Extrude Side的Material Index为1
		// var fcnt = geo.faces.length;
		// for (var i = 0; i < fcnt; i++) {
		// 	geo.faces[i]._materialIndex = geo.faces[i].materialIndex;
		// }

		// uv for heatmap
		var _mx = this.map_.minX;
		var _my = this.map_.minY;
		var _w = this.map_.maxX - _mx;
		var _h = this.map_.maxY - _my;
		var _sx = this.map_.mapScene.sceneX_;
		var _sz = this.map_.mapScene.sceneZ_;

		/*for (var i = 0; i < geo.faceVertexUvs[0].length; i++) {
		 var f = geo.faceVertexUvs[0][i];
		 f.forEach(function(v) {
		 v.x = (v.x - _mx - _sx) / _w;
		 v.y = (v.y - _my + _sz) / _h;
		 });
		 }*/

		var faces = geo.faces,
			facesLen = faces.length;
		for (var i = 0; i < facesLen; i++) {
			var va = geo.vertices[faces[i].a];
			var vb = geo.vertices[faces[i].b];
			var vc = geo.vertices[faces[i].c];

			geo.faceVertexUvs[0][i][0].x = (va.x - _mx - _sx) / _w;
			geo.faceVertexUvs[0][i][0].y = (va.y - _my + _sz) / _h;
			geo.faceVertexUvs[0][i][1].x = (vb.x - _mx - _sx) / _w;
			geo.faceVertexUvs[0][i][1].y = (vb.y - _my + _sz) / _h;
			geo.faceVertexUvs[0][i][2].x = (vc.x - _mx - _sx) / _w;
			geo.faceVertexUvs[0][i][2].y = (vc.y - _my + _sz) / _h;
		}

		// 将普通的 Geometry ,转换为 BufferGeometry 提高效率
		// geo = new fm.BufferGeometry().fromGeometry(geo);

		//
		// swap boundingSphere's y and z
		//
		geo.computeBoundingSphere();
        geo.computeBoundingBox();

		return {
			geometry: geo,
			shape: shape
		};
		// } else {
		// 	return null;
		// }

	},
	forEachVertForShape_: function(vs1, cb) {
		var v = 0;
		cb(true, vs1[v], vs1[v + 1]);
		for (v = 2; v < vs1.length; v += 2) {
			cb(false, vs1[v], vs1[v + 1]);
		}
		v = 0;
		cb(false, vs1[v], vs1[v + 1]);
	},

};

fengmap.MapSceneUtil = {};
fengmap.MapSceneUtil.calcSceneBox3 = function(sd) {	//sd -> scene_data
	
	var min_ele = Number.POSITIVE_INFINITY;
	var max_ele = Number.NEGATIVE_INFINITY;
	var gs = sd['layerGroups'];
	for (var i in gs) {
		var ele = gs[i]['elevation'];
		min_ele = Math.min(min_ele, ele);
		max_ele = Math.max(max_ele, ele);
	}

	return new fm.Box3(new fm.Vector3(sd.minX,min_ele,sd.minY), new fm.Vector3(sd.maxX,max_ele,sd.maxY));
};

fengmap.MapSceneUtil.calcInitCamera = function(box3) {

	var c = box3.center();
	var s = box3.size();
	return {
		target:new fm.Vector3(0, c.y, 0),
		position:new fm.Vector3(s.x * 1, c.y + s.x * .75, - s.x * 1)
	};
};

fengmap.MapSceneUtil.buildCurvePoints = function(arr, segs, radius) {
	if (arr.length >= 3) {
		var min_a = Math.PI / 10;  // 20161115 change to / 30  last is / 90
		var max_a = Math.PI - min_a;
		var min_dist = radius || 1;
		var numSegs = segs == undefined ? 8 : segs;

		if (numSegs == 0) {
			return arr;
		}

		var dt = 1 / numSegs;

		///////////////////////////////////////////////
		// 20161114 把最后一个点,又添加了一次, 要不然,最后一个转角会不做平滑处理 //
		///////////////////////////////////////////////
		arr.push(arr[arr.length - 1]);

		var arr2 = [];
		for (var i=0;i<arr.length-2;) {
			var p1 = arr[i].clone();
			var p2 = arr[i+1].clone();
			var p3 = arr[i+2].clone();
			
			var v21 = p1.clone().sub(p2);
			var v23 = p3.clone().sub(p2);
			
			var a = v21.angleTo(v23);
			
			var l_v21 = v21.length();
			var l_v23 = v23.length();
			
			arr2.push(p1);

			if (a > min_a && a < max_a && l_v21 > min_dist && l_v23 > min_dist) {
				
				//push curve_start, curve_mid
				var p_curve_start = p2.clone().lerp(p1, min_dist/l_v21);
				var p_curve_end = p2.clone().lerp(p3, min_dist/l_v23);

				arr2.push(p_curve_start);

				//quadratic curves!
				//https://en.wikipedia.org/wiki/B%C3%A9zier_curve
				for (var t = dt; t < 0.999999; t += dt) {
					// var alpha = t/min_dist;
					var alpha = t;
					
					var q0 = p_curve_start.clone().lerp(p2,alpha); 
					var q1 = p2.clone().lerp(p_curve_end,alpha);
					arr2.push(q0.lerp(q1,alpha));
				}
				
				//change p2 to curve_end
				arr[i+1] = p_curve_end;
				
				i++;
			} else {
				i++;
			}
			
			if (i == arr.length-2) {
				// arr2.push(p2);    // 就是这个, 把最后一段弄混乱了
				arr2.push(p3);
			}
		}

		return arr2;
	} else {
		return arr;
	}
};




/**
 * 
 */

fengmap.ModelMesh = function(geometry, mapTheme) {
	var c = 0;
	var o = 1.0;
	if (undefined != mapTheme) {
		this.mapTheme_ = mapTheme;
		c =  mapTheme.color_;
		o = mapTheme.alpha;
	}

	var mat = fengmap.MapUtil.getOrCreateLambertMaterial(c, true, o);
	fm.Mesh.call(this, geometry, mat);
	//fm.Mesh.call(this, geometry, new fm.MeshLambertMaterial());
	
	// if (mapTheme) {
	// 	this.mapTheme_ = mapTheme;
    //
	// 	this.material.color.set(mapTheme.color_);
	// 	this.material.opacity = +mapTheme.alpha;
	// }

	//
	// 要可透明。。 要不然。亮度会诡异。。。
	//
	//this.material.transparent = true;

	// 透明的显示
	this.renderOrder = fengmap.FMRenderOrder.model;

	this.mouseSelected_ = false;
	this.selected_ = false;
	
	this.defaultMaterial_ = this.material;
	this.defaultColor = this.material.color.clone();
	
	this.selectedMaterial_ = null;
};

fengmap.ModelMesh.prototype = Object.create(fm.Mesh.prototype);

fengmap.ModelMesh.prototype.constructor = fengmap.ModelMesh; 

fengmap.ModelMesh.prototype.setDefaultTheme_ = function () {
	this.material.color = new fm.Color(this.meta_.theme_.color_);
};

fengmap.ModelMesh.prototype.setSelectedTheme_ = function (v) {
	var _v = v == undefined ? this.mapTheme_.selectedColor_ : v;
	this.material.color = new fm.Color(_v);
};

Object.defineProperty(fengmap.ModelMesh.prototype, "mouseSelected", {
	set: function (v) {
		if (v != this.mouseSelected_) {
			this.mouseSelected_ = v;
			if (this.selected_ || this.mouseSelected_) {
				this.setSelectedTheme_();
			} else {
				this.setDefaultTheme_();
			}
		}
	},
	get : function() {
		return this.mouseSelected_;
	}
});

Object.defineProperty(fengmap.ModelMesh.prototype, "selected", {
	set: function (v) {
		if (v != this.selected_) {
			this.selected_ = v;
			if (this.selected_ || this.mouseSelected_) {
				this.setSelectedTheme_();
			} else {
				this.setDefaultTheme_();
			}
		}
	},
	get : function() {
		return this.selected_;
	}
});

//add selectedColor property
Object.defineProperty(fengmap.ModelMesh.prototype, "selectedColor", {
	set: function (v) {
		v = new fm.Color(v);
		this.setSelectedTheme_(v);
	},
	get : function() {
		if (!this.selectedMaterial_)
			return this.mapTheme_.selectedColor_;			
		else 
			return this.selectedMaterial_.color;
	}
});
/**
 * 通用的Marker类
 */
fengmap.FMMarker = function (params) {
	this.ctx = document.createElement('canvas').getContext('2d');

}

fengmap.FMMarker.prototype = {
	constructor: fengmap.FMMarker,
	
};
/**
 * 对 fm.Material 类的封装
 */
fengmap.FMMaterial = function(params) {
	this.config = params || {color: 0x444444};
	this.config.opacity = fmg(this.config, 'opacity', 'alpha', 1);

	// avoid threejs alert "alpha is not property of material"
	delete this.config.alpha;

	fm.MeshLambertMaterial.call(this, this.config);

	// transparent = true; 这样热力图就不会混合颜色了
	this.transparent = true;

	// 因为给store添加材质, 需要2个, 一个顶面一个周边,
	// 他们的区别是, 顶面需要显示热力图,而侧边不需要, 所以只能分成
	// 2个材质,但在设置其颜色,透明度等属性的时候,又希望可以一起调节
	// 所以加入了这个属性,可以找到此材质对应的周边材质
	this.brother = null;
}

fengmap.FMMaterial.prototype = Object.create(fm.MeshLambertMaterial.prototype);

Object.assign(fengmap.FMMaterial.prototype, {
	constructor: fengmap.FMMaterial,

	setProperty: function(prop, value) {
		this[prop] = value;
		if (this.brother) {
			this.brother[prop] = value;
		}
	},

	setColor: function(color) {
		this.setProperty('color', new fm.Color(color));
	},

	setAlpha: function(val) {
		this.setProperty('opacity', val);
	},

	setEmissive: function(color) {
		this.setProperty('emissive', new fm.Color(color));
	}
});


/**
 * 画箭头
 * type: normal | arrow | fmarrow
 */
fengmap.FMNaviMap = function ( params ) {
	Object.assign(this, {
		type: 'normal',
		width: 128,
		height: 128,
		color: '#ff0000',
		arrowHeightPercent: .4,
		arrowWidthPercent: .7,
		arrowPercent: .1,
		lineType: null,
		dashArray: [2, 1],

		// god arrow property
		godHeightPercent: .5,
		godEdgePercent: .2,
		godArrowPercent: .3,
		godColor: '#33cc61',
		godEdgeColor: '#4a82d2',
		godArrowColor: '#F4FEFB',
		godArrowXScale: .6,
		godArrowWidthPercent: .07

	}, params);

	// 此贴图对应的材质的y偏移等信息
	this.materialInfo = {
		offset: 0
	};

	this.ctx = document.createElement('canvas').getContext('2d');
	this.update();
}

fengmap.FMNaviMap.prototype = {
	constructor: fengmap.FMNaviMap,

	get canvas() {
		return this.ctx.canvas;
	},

	update: function(params) {
		var s = this;
		Object.assign(s, params);

		// color type from 0x to #
		s._doColor();

		s.ctx.canvas.width = s.width;
		s.ctx.canvas.height = s.height;

		switch (s.type) {
			case 'normal':
				s._drawNormal();
			break;
			case 'arrow':
				s._drawArrow();
			break;
			case 'fmarrow':
				s._drawGodArrow();
			break;
		}
	},

	_doColor: function() {
		var s = this;
		var cs = ['color', 'godColor', 'godEdgeColor', 'godArrowColor'];

		cs.forEach(function(itm) {
			if (typeof s[itm] == 'number') {
				s[itm] = fengmap.Line.prototype._colorToStr(s[itm]);
			}
		});
	},

	_setMaterialInfo: function() {
		var s = this;
		s.materialInfo.offset = fmg(arguments, 0, 0);
		s.materialInfo.side = fmg(arguments, 1, 0);
	},

	_drawNormal: function() {
		var s = this;

		var all = s.dashArray.reduce(function(p, n) {
			return p + n;
		});

		var x = 0;
		s.dashArray.forEach(function(i, index) {
			if (index % 2 == 0) {
				s.ctx.fillStyle = s.color;
				s.ctx.fillRect(x / all * s.width, 0, i / all * s.width, s.height);
			}
			x += i;
		});

		s._setMaterialInfo(0);
	},

	_drawArrow: function() {
		var s = this;

		var sy = ((1 - s.arrowHeightPercent) * s.height) / 2;
		var hp = s.height * s.arrowHeightPercent;

		s.ctx.beginPath();
		s.ctx.moveTo(0, sy);
		var _p = s.width * (s.arrowWidthPercent - s.arrowPercent);
		s.ctx.lineTo(_p, sy);
		s.ctx.lineTo(s.width * s.arrowWidthPercent, sy + hp / 2);
		s.ctx.lineTo(_p, sy + hp);
		s.ctx.lineTo(0, sy + hp);
		s.ctx.lineTo(s.width * s.arrowPercent, sy + hp / 2);
		s.ctx.closePath();

		s.ctx.fillStyle = s.color;
		s.ctx.fill();

		s._setMaterialInfo(-.25, 2);
	},

	_drawGodArrow: function() {
		var s = this;

		// draw edge rect
		s.ctx.fillStyle = s.godEdgeColor;
		s.ctx.fillRect(0, (1 - s.godHeightPercent) * s.height / 2, s.width, s.godHeightPercent * s.height);

		// draw god rect
		s.ctx.fillStyle = s.godColor;
		var _y = (1 - s.godHeightPercent + s.godEdgePercent) * s.height / 2;
		var _h = (s.godHeightPercent - s.godEdgePercent) * s.height;
		s.ctx.fillRect(0, _y, s.width, _h);

		// draw arrow
		s.ctx.fillStyle = '#ffffff';
		s.ctx.shadowOffsetX = -2;
		s.ctx.shadowOffsetY = 2;
		s.ctx.shadowBlur = 4;
		s.ctx.shadowColor="rgba(0,0,0,0.5)";

		var center = {x: s.width / 2 , y: s.height / 2};
		/*var hs = s.width * s.godArrowPercent / 2;

		s.ctx.beginPath();
		s.ctx.moveTo(center.x - hs * s.godArrowXScale, center.y - hs);
		s.ctx.lineTo(center.x + hs * s.godArrowXScale, center.y);
		s.ctx.lineTo(center.x - hs * s.godArrowXScale, center.y + hs);

		s.ctx.lineWidth = s.godArrowWidth;

		s.ctx.strokeStyle = s.godArrowColor;
		s.ctx.stroke();*/

		var aw_all = s.width * s.godArrowPercent;
		var aw = s.width * s.godArrowWidthPercent;
		var aw_add = s.width * (s.godArrowPercent - s.godArrowWidthPercent) * s.godArrowXScale;

		var a_startX = center.x - aw_all / 2 * s.godArrowXScale;
		var a_startY = center.y - aw_all / 2;

		s.ctx.beginPath();
		s.ctx.moveTo(a_startX, a_startY);
		s.ctx.lineTo(a_startX + aw, a_startY);
		s.ctx.lineTo(a_startX + aw + aw_add, a_startY + aw_all / 2);
		s.ctx.lineTo(a_startX + aw, a_startY + aw_all);
		s.ctx.lineTo(a_startX, a_startY + aw_all);
		s.ctx.lineTo(a_startX + aw_add, a_startY + aw_all  / 2);
		s.ctx.closePath();

		s.ctx.fillStyle = s.godArrowColor;
		s.ctx.fill();

		s._setMaterialInfo(-.25, 2);
	},
};



/**
 * 
 * 楼梯Mesh类
 * 	• 继承: Mesh
 * 
 */
fengmap.FMStairs = function ( params ) {

	Object.assign(this, {
		steps: 15,			// 台阶的级数
		stepHeight: .2,		// 台阶高度
		stepDepth: .3,		// 台阶深度
		width: 1.5,			// 楼梯宽度
		color: 0x4EE996,	// 颜色
		inverse: true,		// 反向
		halfSpace: 2,		// 休息平台
		depth: true 		// 深度
	}, params);

	var _mat = new fm.MeshLambertMaterial({
		color: this._color,
	 	depthTest: this.depth,
	 	depthWrite: this.depth,
	 	transparent: true
	});

	var _geo = this.createGeometry();

	fm.Mesh.call(this, _geo, _mat);

	this.renderOrder = 11;

};

fengmap.FMStairs.prototype = Object.create(fm.Mesh.prototype, {
	height: {
		get: function() {
			return this.steps * this.stepHeight;
		}
	},
	upPoint: {
		get: function() {
			return this.position.clone().add(new fm.Vector3(this._stepDepth * this.steps, this.stepHeight * this.steps, 0));
		}
	},
	color: {
		get: function() {
			return this._color;
		},
		set: function(val) {
			this._color = val;
			if (this.material) {
				this.material.color.set(val);
			}
		}
	}
});

Object.assign(fengmap.FMStairs.prototype, {
	constructor: fengmap.FMStairs,

	createGeometry: function () {
		var pts = [];

		this._stepDepth = this.inverse ? -this.stepDepth : this.stepDepth;
		this._halfSpace = this.inverse ? -this.halfSpace : this.halfSpace;

		// 画楼梯的侧面截面
		for (var i = 0; i < this.steps; i++) {
			if (i == 0 && this._halfSpace != 0) {
				pts.push(new fm.Vector2(-this._halfSpace, 0));
				pts.push(new fm.Vector2(-this._halfSpace, this.stepHeight));
			} else {
				pts.push(new fm.Vector2(i * this._stepDepth, i * this.stepHeight));
				pts.push(new fm.Vector2(i * this._stepDepth, (i + 1) * this.stepHeight));
			}
		}

		pts.push(pts[pts.length - 1].clone().add(new fm.Vector2(this._stepDepth + this._halfSpace, 0)));
		pts.push(pts[pts.length - 1].clone().sub(new fm.Vector2(0 , this.stepHeight)));

		if (this._halfSpace != 0) {
			pts.push(pts[pts.length - 1].clone().sub(new fm.Vector2(this._halfSpace , 0)));
			pts.push(pts[0].clone().add(new fm.Vector2(this._stepDepth + this._halfSpace, 0)));
		} else {
			pts.push(pts[0].clone().add(new fm.Vector2(this._stepDepth, 0)));
		}

		var shape = new fm.Shape(pts);
		var options = {amount: this.width, bevelEnabled: false};

		var geo = new fm.ExtrudeGeometry(shape, options);

		// change pivot
		geo.applyMatrix(new fm.Matrix4().makeTranslation(0, 0, -this.width / 2));

		return geo;
	},

	update: function( params ) {
		Object.assign(this, params);
		this.geometry = this.createGeometry();
	}
});

/**
 * 成对的楼梯辅助类
 */
fengmap.FMStairsPair = function( params ) {
	this.container = new fm.Group();
	this.container.fm = this;

	this.id = this.getID();

	this.map = params.map || fengmap.Map.instance;

	this._init(params);
}

fengmap.FMStairsPair.prototype = {
	constructor: fengmap.FMStairsPair,

	getID: function () {
		var _id = -1;
		return function () {
			return ++_id;			
		}
	}(),

	get position() {
		return this.container.position;
	},

	get rotation() {
		return this.container.rotation;
	},

	get scale() {
		return this.container.scale;
	},

	get color() {
		return this.me.color;
	},

	set color(val) {
		this.me.color = val;
		this.up.color = val;
	},

	get height() {
		return this.me.height * 2 - this.me.stepHeight;
	},

	_init: function( params ) {
		var _params = Object.assign({}, params);

		if (!this.me) {
			this.me = new fengmap.FMStairs( _params );
		} else {
			this.me.update(_params);
		}

		if (!this.up) {
			this.up = this.me.clone();
		}

		_params.inverse = params.upInverse == false ? this.me.inverse : !this.me.inverse;

		this.up.update(_params);

		this.container.add(this.me, this.up);
		this.me.position.z = -this.me.width / 2;

		if (params.upInverse) {
			this.up.position.copy(this.me.upPoint.add(new fm.Vector3(0, -this.me.stepHeight, this.me.width)));
		} else {
			this.up.position.copy(this.me.upPoint.add(new fm.Vector3((_params.inverse ? -this.me.halfSpace : this.me._halfSpace), -this.me.stepHeight, this.me.width)));
		}
	},

	update: function( params ) {
		this.container.remove(this.me, this.up);
		this._init( params );
	},

	showUp: function(boo) {
		boo = boo == undefined ? true : boo;
		this.up.visible = boo;
	},

	connectTop: function(boo) {
		boo = boo == undefined ? true : boo;
		this.container.scale.y = boo ? (this.map.groupSpace / this.height) : 1;
	}
};

/**
 * 自动扶梯
 */
function FMEscalator(params) {
	Object.assign(this, {
		halfSpace: 2.5,
		width: 1.5,
		height: 1.3,
		depth: true,
		color: "#FDC2A3",
		color2: "#C79D86",
		segments: 10
	},params);

	if (!this.startPoint || !this.endPoint) {
		return;
	}

	this.map = this.map || fengmap.Map.instance;

	var _mat1 = new fm.MeshLambertMaterial({
		color: this.color,
	 	depthTest: this.depth,
	 	depthWrite: this.depth,
	 	transparent: false
	});

	var _mat2 = new fm.MeshLambertMaterial({
		color: this.color2,
	 	depthTest: this.depth,
	 	depthWrite: this.depth,
	 	transparent: false
	});

	var _mat = new fm.MultiMaterial([_mat1, _mat2]);

	var _geo = this.createGeometry();

	fm.Mesh.call(this, _geo, _mat);

	this.applyMatrix(this._matrix);

	this.renderOrder = 11;
}

FMEscalator.prototype = Object.assign(Object.create(fm.Mesh.prototype), {
	// add constructor could not clone mesh!
	// constructor: FMEscalator,

	createGeometry: function () {
		var s = this;
		var pts = [];

		var _st = s.map.toSceneCoord(s.startPoint),
			_ed = s.map.toSceneCoord(s.endPoint);

		var cha = _ed.clone().sub(_st);
		var _cha = cha.clone();
		var sign = Math.sign(cha.x);

		cha.x = Math.abs(cha.x);
		cha.y = Math.abs(cha.y);

		var vx = _cha.clone().normalize();

		var up = new fm.Vector3(0, 1, 0);
		var ang = vx.angleTo(up);

		var _extend = Math.tan((Math.PI / 2 - ang) / 2) * s.height;

		// matrix		
		var vz = new fm.Vector3().crossVectors(vx, up).normalize();
		var vx = new fm.Vector3().crossVectors(up, vz).normalize();

		s._matrix = new fm.Matrix4().makeBasis(vx, up, vz);
		s._matrix.setPosition(_st);

		// build shape points
		pts.push(new fm.Vector2(0, 0));

		var _c = new fm.Vector2(-_extend - s.halfSpace, 0);
		pts.push(_c);

		var _center = _c.clone().add(new fm.Vector2(0, s.height / 2));

		// round points
		var startAngle = Math.PI * 3 / 2;
		var delta = Math.PI / s.segments;

		for (var i = 0; i < s.segments - 1; i++) {
			var _ang = startAngle - delta * (i + 1);
			var _pt = new fm.Vector2(Math.cos(_ang) * s.height / 2, Math.sin(_ang) * s.height / 2);
			pts.push(_center.clone().add(_pt));
		}

		pts.push(_c.clone().add(new fm.Vector2(0, s.height)));
		_c = _c.clone().add(new fm.Vector2(s.halfSpace, s.height))
		pts.push(_c);
		_c = _c.clone().add(cha);
		pts.push(_c);
		_c = _c.clone().add(new fm.Vector2(_extend + s.halfSpace, 0))
		pts.push(_c);
		_center = _c.clone().add(new fm.Vector2(0, -s.height / 2));

		startAngle = Math.PI / 2;

		for (var i = 0; i < s.segments - 1; i++) {
			var _ang = startAngle - delta * (i + 1);
			var _pt = new fm.Vector2(Math.cos(_ang) * s.height / 2, Math.sin(_ang) * s.height / 2);
			pts.push(_center.clone().add(_pt));
		}

		_c = _c.clone().add(new fm.Vector2(0, -s.height));
		pts.push(_c);
		pts.push(_c.clone().add(new fm.Vector2(-s.halfSpace, 0)));


		var shape = new fm.Shape(pts);
		var options = {amount: s.width, bevelEnabled: false};

		var geo = new fm.ExtrudeGeometry(shape, options);

		// change pivot
		geo.applyMatrix(new fm.Matrix4().makeTranslation(0, 0, -s.width / 2));

		return geo;
	},

	update: function( params ) {
		Object.assign(this, params);
		this.geometry = this.createGeometry();
	}
});



/**
 * 线型物体, extends from fm.Mesh
 * 目前主要用于导航线
 *
 * style: {
 *     up: 向上向量, 默认: fm.Vector3(0, 1, 0);
 *     color: 0xff00ff || '#ff0000',
 *     alpha: 1,
 *     liineType:
 *     dashArray:, [3,1,1,1]
 *     lineWidth:,
 *     smooth: false,  
 * }
 * 
 */
fengmap.Line = function(map, points, style, config) {
    this._type_ = 'fmline';

    // extends from component for pick
    // componentManager and object
    fengmap.FMComponent.call(this, map.componentsManager, this);

    // 将传入的点数组进行复制,目的是不破坏原数组
    var _points = points.map(function(itm) {return itm.clone()});

    this.map = map;
    this.style = style;
    var ns = style;

    this.fixedWidth = ns.fixedWidth == undefined ? true : ns.fixedWidth;

    this.nodeType = fengmap.FMNodeType.LINE;

    config = config || {};

    config.up = config.up || style.up || new fm.Vector3(0, 1, 0);

    var _uvBaseLen = 1;

    switch (typeof ns.color) {
        case 'number':
            ns.color = this._colorToStr(ns.color);
        break;
    }

    ns.dash || (ns.dash = {
        size: 2,
        gap: 1
    });

    // if (!ns.lineType && ns.type && (ns.type == 'arrow' || ns.type == 'fmarrow')) {
    //     ns.lineType = ns.type;
    // }

    ns.type = 'normal';
    ns.lineMode = fengmap.FMLineMode.CIRCLE;

    if (ns.lineType == 'arrow' || ns.lineType == 'fmarrow') {
        ns.type = ns.lineType;
        ns.lineMode = fengmap.FMLineMode.PLANE;
    }

    ns.dashArray =  ns.dashArray || (ns.lineType && this.getDashArrayByLineType(ns.lineType)) || [ns.dash.size, ns.dash.gap];

    ns.lineWidth = fmg(ns, 'lineWidth', 'linewidth', 8);

    // ns.color = typeof ns.color == 'string' ? ns.color : '#' + ns.color.toString(16)

    /*
    // canvas to draw texture
    var canvas = document.createElement('canvas');
    this.ctx = canvas.getContext('2d');

    canvas.width  = 128;
    canvas.height = 128;

    this.ctx.fillStyle = typeof ns.color == 'string' ? ns.color : '#' + ns.color.toString(16);

    var _w = canvas.width;

    ns.dash || (ns.dash = {
        size: 2,
        gap: 1
    });

    // 如果有虚线的设置
    if (ns.dash) {
        _uvBaseLen = ns.dash.size + ns.dash.gap;
        _w = canvas.width * ns.dash.size / _uvBaseLen;
    }

    // 画虚线 canvas
    this.ctx.fillRect(0, 0, _w, 128);
    //*/


    // 如果有虚线的设置, 计算一个单位的长度
    if (ns.dashArray) {
        this.textureLength = ns.dashArray.reduce(function(p, n) {return p + n;});
    }

    _uvBaseLen = this.textureLength;

    var naviMapStyle = JSON.parse(JSON.stringify(ns));
    delete naviMapStyle.height;

    this.naviMap = new fengmap.FMNaviMap(naviMapStyle);

    var tex = new fm.Texture(this.naviMap.canvas);

    tex.minFilter = fm.NearestFilter;
    tex.needsUpdate = true;

    var geo = new fengmap.MapNavLineGeometry({
        radius: ns.lineWidth,
        pathVertices: _points,
        uvBaseLen: _uvBaseLen,
        up: (ns.up || config.up),
        notCenter: config.notCenter || style.notCenter,
        lineMode: ns.lineMode,
        yScale: ns.yScale,
        smooth: ns.smooth,
        billboard: ns.billboard
    });

    tex.wrapS = tex.wrapT = fm.RepeatWrapping;

    this.baseRepeatX = Math.ceil(geo.length / geo.uvBaseLen);
    tex.repeat.x = this.baseRepeatX;
    tex.repeat.y = 1;

    tex.needsUpdate = true;

    var mat = new fm.MeshBasicMaterial();

    mat.transparent = true;
    mat.opacity = ns.alpha == undefined ? 1 : ns.alpha;

    mat.map = tex;
    mat.needsUpdate = true;

    mat.visible = false;
    this.visible = false;

    // for arrow map etc.
    // mat.map.offset.y = -.25;

    // rend on top of other meshes
    // mat.depthTest = false;

    mat.depthWrite = false;

    fm.Mesh.call(this, geo, mat);
    this.position.copy(geo.center);
    this.renderOrder = fengmap.FMRenderOrder.lineObject;

    this._updateMaterialByNaviMap();

    // this.visible = false;

    // removed event
    this.addEventListener('removed', this.dispose);

    // update event
    this._update = this.update.bind(this);

    // this._update();

    this.map.on('update', this._update);

    // visible group ids change event
    this._visibleGroupIDsChanged = this.visibleGroupIDsChanged.bind(this);
    this.map.on('visibleGroupIDsChanged', this._visibleGroupIDsChanged);

    ////////////////////////////////////////////////////////////////////
    // clone a line and set renderOrder -1, use to transparent hidden //
    ////////////////////////////////////////////////////////////////////
    var _l = new fm.Mesh(this.geometry, this.material);
    _l.renderOrder = fengmap.FMRenderOrder.transparentLine;
    this.add(_l);

    this.transparentObj = _l;
};

fengmap.Line.prototype = Object.create(fm.Mesh.prototype, {
    height: {
        get: function() {
            return this.position.y;
        },
        set: function(val) {
            this.position.y = val;
        }
    },
    color: {
        get: function() {
            return this.style.color;
        },
        set: function(val) {
            if (typeof val == 'number') {
                val = this._colorToStr(val);
            }
            this.style.color = val;
            this.naviMap.update({color: val});
            this.material.map.needsUpdate = true;
        }
    },
    /*lineType: {
        get: function() {
            return this.style.lineType;
        },
        set: function(val) {
            if (typeof val == 'string') {
                this.updateStyle({lineType: val});
            } else if (val instanceof Array) {
                this.updateStyle({lineType: null, dashArray: val});
            }
        }
    },*/
    lineStyle: {
        get: function() {
            return this.style;
        },
        set: function(style) {
            /*if (typeof style == 'string') {
                style = {style: style};
            }

            this._lineStyle = style.style;

            this.updateStyle({
                type: style.style,
                dashArray: (this.getDashArrayByLineType((style.lineType || style.style)) || [2, 1])
            });*/
            this.updateStyle(style);
        }
    },
    alpha: {
        get: function() {
            return this.material.opacity;
        },
        set: function(val) {
            this.material.opacity = val;
        }
    },
    lineWidth: {
        get: function() {
            return this.style.lineWidth;
        },
        set: function(val) {
            this.updateStyle({lineWidth: val});
        }
    }
});

Object.assign(fengmap.Line.prototype, fengmap.FMComponent.prototype, {
    _colorToStr: function(val) {
        if (typeof val == 'number') {
            var _str = val.toString(16);
            while (_str.length < 6) {
                _str = '0' + _str;
            }
            return '#' + _str;
        }
        return val;
    },

    getDashArrayByLineType: function(lineType) {
        // 如果是数组
        if (lineType instanceof Array) {
            return lineType;
        }

        // 如果为字符串
        switch (lineType) {
            case fengmap.FMLineType.FULL:
                return [1, 0];
            break;
            case fengmap.FMLineType.DOTTED:
                return [1, 1];
            break;
            case fengmap.FMLineType.DOT_DASH:
                return [2.5, 1, .5, 1];
            break;
            case fengmap.FMLineType.CENTER:
                return [3, 1, 1.5, 1];
            break;
            case fengmap.FMLineType.DASH:
                return [2, 1];
            break;
            case fengmap.FMLineType.DOUBLE_DOT_DASH:
                return [2.5, .5, .5, .5, .5, .5];
            break;
            case fengmap.FMLineType.TRI_DOT_DASH:
                return [2.5, .5, .5, .5, .5, .5, .5, .5];
            break;
            case fengmap.FMLineType.ARROW:
                return [5, 0];
            break;
            case fengmap.FMLineType.FMARROW:
                return [7, 0];
            break;
        }
    },

    visibleGroupIDsChanged: function(gids) {
        var g = this.groupID;
        var have = true;
        if (typeof g == 'number') {
            if (gids.indexOf(g) == -1) {have = false;}
        } else if (g instanceof Array) {
            g.forEach(function(gid) {
                if (gids.indexOf(gid) == -1) {have = false;}
            });
        }

        this.visible = have;
    },

    updateStyle: function(style) {
        if (style.color && typeof style.color == 'number') {
            style.color = this._colorToStr(style.color);
        }
        Object.assign(this.style, style);

        this.style.type = 'normal';
        // this.geometry.yScale = 1;
        if (this.style.lineType == 'arrow' || this.style.lineType == 'fmarrow') {
            this.style.type = this.style.lineType;
            // this.geometry.yScale = .3;
        }

        if (style.lineType && !style.dashArray) {
            this.style.dashArray = this.getDashArrayByLineType(style.lineType);
        }

        delete this.style.height;
        this.naviMap.update(this.style);

        this._updateMaterialByNaviMap();
        this.material.map.needsUpdate = true;

        this.textureLength = this.style.dashArray.reduce(function(p, n) {return p + n;});

        // update my brothers
        if (this.brothers && this.brothers.length > 0) {
            this.brothers.forEach(function (itm) {
                itm.updateStyle(style);
            });
        }
    },

    _updateMaterialByNaviMap: function() {
        var info = this.naviMap.materialInfo;
        // 设置此贴图对应的材质属性
        this.material.map.offset.y = info.offset;
        this.material.side = fmg(info, 'side', 0);
    },

    _firstUpdate: true,

    update: function(delta) {
        // var this = this;
        if (this.map.options.naviLineAnimation && !this.style.noAnimate) {
            this.material.map.offset.x -= delta * (this.style.dash.speed || this.style.speed || 1);
        }

        // chanage radius
        var mapView = this.map.mapView;
        var camera = mapView.camera;

        var meterperpixel = 1;
        var version = this.map.mapTheme.version;

        if (version == 1) {
            var dist = this.localToWorld(new fm.Vector3(0,0,0)).distanceTo(camera.position);
            meterperpixel = dist / mapView.h_ * .3;
        } else {
            meterperpixel = fengmap.MapUtil.getSpriteScale(this.map, this);
        }

        // return;

        if (mapView.map_.viewMode_ == '3d') {
            if(mapView.h_ == 0) return;
            
            if (this.fixedWidth) {
                this.geometry.setRadius(meterperpixel * this.style.lineWidth * .7);
            }

            // 3d 显示时, billboard
            this._billboard();

            // this.material.map.repeat.x = Math.ceil( this.baseRepeatX * Math.pow(1 - meterperpixel, 1) );
        } else {
            if (this.fixedWidth) {
                if (version == 1) {
                    this.geometry.setRadius(meterperpixel * this.style.lineWidth * .7 / mapView.map_.currentCamera_.zoom);
                } else {
                    this.geometry.setRadius(meterperpixel * this.style.lineWidth * .7);
                }
            }
        }

        this.material.map.repeat.x = this.geometry.length / (this.textureLength * meterperpixel * 7 * (version == 1 ? 2 : 1));

        // if (this._firstUpdate) {
        //     this.map.forceUpdate();

        //     this._firstUpdate = false;
        //     this.material.visible = true;
        // }
    },

    // 向上的向量
    _upVec: new fm.Vector3(0, 1, 0),
    _zVec: new fm.Vector3(0, 0, 1),

    /**
     * billboard 跟随相机视角
     */
    _billboard: function() {
        if (this.style.billboard) {
            if (this.geometry.pathVertices.length == 2) {
                var pvs = this.geometry.pathVertices;
                var v = pvs[1].clone().sub(pvs[0]).normalize();

                // check 是向上, 还是向下
                var dot = v.dot(this._upVec);
                var sign = Math.sign(dot);

                var angle = sign * (this.map.controls.constraint.getAzimuthalAngle());

                this.quaternion.setFromAxisAngle(v, angle);
            }
        }
    },

    // 不被遮挡
    alwaysShow: fengmap.MapLabel.prototype.alwaysShow,

    // component picked function
    picked: function () {
        
    },

    dispose: function() {

        // dispose brothers first
        if (this.brothers && this.brothers.length > 0) {
            this.brothers.forEach(function (itm) {
                itm.dispose();
            });
        }

        // component super dispose
        fengmap.FMComponent.prototype.dispose.call(this);

        this.map.off('update', this._update);
        this.map.off('visibleGroupIDsChanged', this._visibleGroupIDsChanged);

        if (this.parent) {
            this.parent.remove(this);
        }

        this.geometry.dispose();
        this.material.map.dispose();
        this.material.dispose();
    },

    /**
     * 设置线的可见性
     * @param {Boolean} boo 是否可见
     */
    setVisible: function (boo) {
        this.visible = boo;

        if (this.brothers && this.brothers.length) {
            this.brothers.forEach(function (itm) {
                itm.visible = boo;
            })
        }
    }
});




/**
 * 原始的 WebGL 线, 因为不能改变成lineWidth所以主要用在fengmap.Line不能满足的情况下,
 * 如, 两个点之间的来加线(如:轨迹回放). 此时使用fengmap.Line无法正常的画出线型      
 * @param {fengmap.FMMap} map    fengmap.FMMap对象
 * @param {Array} points fengmap.FMMapCoord 数组
 * @param {JSON} style  线型的样式描述
 */
fengmap.RawLine = function (map, points, style, isMapCoord) {
    this._type_ = 'fmline';
    this.map = map;

    var vecPoints = [];

    if (isMapCoord) {
        vecPoints = points.map(function (itm) {
            return map.toSceneCoord(itm);
        });
    } else {
        vecPoints = points.slice();
    }

    // style
    style = style || {};

    if (typeof style.color == 'number') {
        style.color = fengmap.Line.prototype._colorToStr(style.color);
    }

    style.dashArray = style.dashArray || [3, 1];
    style.scale = style.scale || 1;

    // geometry
    var geo = new fm.Geometry();
    Array.prototype.push.apply(geo.vertices, vecPoints);

    // material
    var mat = new fm.LineDashedMaterial({
        color:      style.color,
        linewidth:  fmg(style, 'lineWidth', 'linewidth', 2),
        scale:      style.scale,
        dashSize:   style.dashArray[0],
        gapSize:    style.dashArray[1]
    });

    fm.Line.call(this, geo, mat);

    // visible group ids change event
    this._visibleGroupIDsChanged = this.visibleGroupIDsChanged.bind(this);
    this.map.on('visibleGroupIDsChanged', this._visibleGroupIDsChanged);
}

fengmap.RawLine.prototype = Object.assign(Object.create(fm.Line.prototype, {

    height: {
        get: function() {
            return this.position.y;
        },
        set: function (val) {
            this.position.y = val;
        }
    }

}), {
    visibleGroupIDsChanged: fengmap.Line.prototype.visibleGroupIDsChanged,

    dispose: function () {
        this.map.off('visibleGroupIDsChanged', this._visibleGroupIDsChanged);

        if (this.parent) {
            this.parent.remove(this);
        }

        this.geometry.dispose();
        this.material.dispose();
    }
});









/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/long.js for details
 */
//(function(global, factory) {
//
//    /* AMD */ if (typeof define === 'function' && define["amd"])
//        define([], factory);
//    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
//        module["exports"] = factory();
//    /* Global */ else
//        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();
//
//})(this, function() {
//    "use strict";

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */
    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         * @expose
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    Long.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @expose
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = (0 <= value && value < 256)) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
                UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = (-128 <= value && value < 128)) {
                cachedObj = INT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
                INT_CACHE[value] = obj;
            return obj;
        }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
            return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0)
                return UZERO;
            if (value >= TWO_PWR_64_DBL)
                return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL)
                return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
                return MAX_VALUE;
        }
        if (value < 0)
            return fromNumber(-value, unsigned).neg();
        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
        if (str.length === 0)
            throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return ZERO;
        if (typeof unsigned === 'number') // For goog.math.long compatibility
            radix = unsigned,
            unsigned = false;
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');

        var p;
        if ((p = str.indexOf('-')) > 0)
            throw Error('interior hyphen');
        else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));

        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @returns {!Long}
     * @inner
     */
    function fromValue(val) {
        if (val /* is compatible */ instanceof Long)
            return val;
        if (typeof val === 'number')
            return fromNumber(val);
        if (typeof val === 'string')
            return fromString(val);
        // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, val.unsigned);
    }

    /**
     * Converts the specified value to a Long.
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     * @expose
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     * @expose
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     * @expose
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     * @expose
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     * @expose
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     * @expose
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     * @expose
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     * @expose
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000|0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     * @expose
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     * @expose
     */
    LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     * @expose
     */
    LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     * @expose
     */
    LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');
        if (this.isZero())
            return '0';
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix),
                    div = this.div(radixLong),
                    rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else
                return '-' + this.neg().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
                return digits + result;
            else {
                while (digits.length < 6)
                    digits = '0' + digits;
                result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     * @expose
     */
    LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     * @expose
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     * @expose
     */
    LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     * @expose
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     * @expose
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
            if ((val & (1 << bit)) != 0)
                break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.equals = function equals(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(/* validates */ other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lessThan = function lessThan(other) {
        return this.comp(/* validates */ other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(/* validates */ other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(/* validates */ other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(/* validates */ other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     * @expose
     */
    LongPrototype.compare = function compare(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.eq(other))
            return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        // At this point the sign bits are the same
        if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     * @expose
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     * @expose
     */
    LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
        return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     * @expose
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     * @expose
     */
    LongPrototype.add = function add(addend) {
        if (!isLong(addend))
            addend = fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     * @expose
     */
    LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     * @expose
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     * @expose
     */
    LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
            return ZERO;
        if (!isLong(multiplier))
            multiplier = fromValue(multiplier);
        if (multiplier.isZero())
            return ZERO;
        if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative())
                return this.neg().mul(multiplier.neg());
            else
                return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();

        // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     * @expose
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     * @expose
     */
    LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        if (divisor.isZero())
            throw Error('division by zero');
        if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        res = ZERO;
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
                approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero())
                approxRes = ONE;

            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     * @expose
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     * @expose
     */
    LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     * @expose
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     * @expose
     */
    LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    LongPrototype.and = function and(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    LongPrototype.or = function or(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    LongPrototype.xor = function xor(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
        else
            return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
        else
            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
            return this;
        else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits === 32)
                return fromBits(high, 0, this.unsigned);
            else
                return fromBits(high >>> (numBits - 32), 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     * @expose
     */
    LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
            return this;
        return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     * @expose
     */
    LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
            return this;
        return fromBits(this.low, this.high, true);
    };

//    return Long;
//});


/*
 Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
 * Backing buffer: ArrayBuffer, Accessor: Uint8Array
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/bytebuffer.js for details
 */
//(function(global, factory) {
//
//    /* AMD */ if (typeof define === 'function' && define["amd"])
//        define(["long"], factory);
//    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
//        module['exports'] = (function() {
//            var Long; try { Long = require("long"); } catch (e) {}
//            return factory(Long);
//        })();
//    /* Global */ else
//        (global["dcodeIO"] = global["dcodeIO"] || {})["ByteBuffer"] = factory(global["dcodeIO"]["Long"]);
//
//})(this, function(Long) {
//    "use strict";

    /**
     * Constructs a new ByteBuffer.
     * @class The swiss army knife for binary data in JavaScript.
     * @exports ByteBuffer
     * @constructor
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @expose
     */
    var ByteBuffer = function(capacity, littleEndian, noAssert) {
        if (typeof capacity === 'undefined')
            capacity = ByteBuffer.DEFAULT_CAPACITY;
        if (typeof littleEndian === 'undefined')
            littleEndian = ByteBuffer.DEFAULT_ENDIAN;
        if (typeof noAssert === 'undefined')
            noAssert = ByteBuffer.DEFAULT_NOASSERT;
        if (!noAssert) {
            capacity = capacity | 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity");
            littleEndian = !!littleEndian;
            noAssert = !!noAssert;
        }

        /**
         * Backing ArrayBuffer.
         * @type {!ArrayBuffer}
         * @expose
         */
        this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);

        /**
         * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
         * @type {?Uint8Array}
         * @expose
         */
        this.view = capacity === 0 ? null : new Uint8Array(this.buffer);

        /**
         * Absolute read/write offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.offset = 0;

        /**
         * Marked offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#mark
         * @see ByteBuffer#reset
         */
        this.markedOffset = -1;

        /**
         * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.limit = capacity;

        /**
         * Whether to use little endian byte order, defaults to `false` for big endian.
         * @type {boolean}
         * @expose
         */
        this.littleEndian = littleEndian;

        /**
         * Whether to skip assertions of offsets and values, defaults to `false`.
         * @type {boolean}
         * @expose
         */
        this.noAssert = noAssert;
    };

    /**
     * ByteBuffer version.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.VERSION = "5.0.1";

    /**
     * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.LITTLE_ENDIAN = true;

    /**
     * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.BIG_ENDIAN = false;

    /**
     * Default initial capacity of `16`.
     * @type {number}
     * @expose
     */
    ByteBuffer.DEFAULT_CAPACITY = 16;

    /**
     * Default endianess of `false` for big endian.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;

    /**
     * Default no assertions flag of `false`.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_NOASSERT = false;

    /**
     * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
     *  and int64 support is not available.
     * @type {?Long}
     * @const
     * @see https://github.com/dcodeIO/long.js
     * @expose
     */
    ByteBuffer.Long = Long || null;

    /**
     * @alias ByteBuffer.prototype
     * @inner
     */
    var ByteBufferPrototype = ByteBuffer.prototype;

    /**
     * An indicator used to reliably determine if an object is a ByteBuffer or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    ByteBufferPrototype.__isByteBuffer__;

    Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    // helpers

    /**
     * @type {!ArrayBuffer}
     * @inner
     */
    var EMPTY_BUFFER = new ArrayBuffer(0);

    /**
     * String.fromCharCode reference for compile-time renaming.
     * @type {function(...number):string}
     * @inner
     */
    var stringFromCharCode = String.fromCharCode;

    /**
     * Creates a source function for a string.
     * @param {string} s String to read from
     * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
     *  no more characters left.
     * @throws {TypeError} If the argument is invalid
     * @inner
     */
    function stringSource(s) {
        var i=0; return function() {
            return i < s.length ? s.charCodeAt(i++) : null;
        };
    }

    /**
     * Creates a destination function for a string.
     * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
     *  Returns the final string when called without arguments.
     * @inner
     */
    function stringDestination() {
        var cs = [], ps = []; return function() {
            if (arguments.length === 0)
                return ps.join('')+stringFromCharCode.apply(String, cs);
            if (cs.length + arguments.length > 1024)
                ps.push(stringFromCharCode.apply(String, cs)),
                    cs.length = 0;
            Array.prototype.push.apply(cs, arguments);
        };
    }

    /**
     * Gets the accessor type.
     * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
     * @expose
     */
    ByteBuffer.accessor = function() {
        return Uint8Array;
    };
    /**
     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {
        return new ByteBuffer(capacity, littleEndian, noAssert);
    };

    /**
     * Concatenates multiple ByteBuffers into one.
     * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
     * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
     *  defaults to "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
     *  to {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} Concatenated ByteBuffer
     * @expose
     */
    ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {
        if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        var capacity = 0;
        for (var i=0, k=buffers.length, length; i<k; ++i) {
            if (!ByteBuffer.isByteBuffer(buffers[i]))
                buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
            length = buffers[i].limit - buffers[i].offset;
            if (length > 0) capacity += length;
        }
        if (capacity === 0)
            return new ByteBuffer(0, littleEndian, noAssert);
        var bb = new ByteBuffer(capacity, littleEndian, noAssert),
            bi;
        i=0; while (i<k) {
            bi = buffers[i++];
            length = bi.limit - bi.offset;
            if (length <= 0) continue;
            bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);
            bb.offset += length;
        }
        bb.limit = bb.offset;
        bb.offset = 0;
        return bb;
    };

    /**
     * Tests if the specified type is a ByteBuffer.
     * @param {*} bb ByteBuffer to test
     * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
     * @expose
     */
    ByteBuffer.isByteBuffer = function(bb) {
        return (bb && bb["__isByteBuffer__"]) === true;
    };
    /**
     * Gets the backing buffer type.
     * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
     * @expose
     */
    ByteBuffer.type = function() {
        return ArrayBuffer;
    };
    /**
     * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
     *  {@link ByteBuffer#limit} to the length of the wrapped data.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
     * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
     *  "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
     * @expose
     */
    ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) {
        if (typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        if (typeof buffer === 'string') {
            if (typeof encoding === 'undefined')
                encoding = "utf8";
            switch (encoding) {
                case "base64":
                    return ByteBuffer.fromBase64(buffer, littleEndian);
                case "hex":
                    return ByteBuffer.fromHex(buffer, littleEndian);
                case "binary":
                    return ByteBuffer.fromBinary(buffer, littleEndian);
                case "utf8":
                    return ByteBuffer.fromUTF8(buffer, littleEndian);
                case "debug":
                    return ByteBuffer.fromDebug(buffer, littleEndian);
                default:
                    throw Error("Unsupported encoding: "+encoding);
            }
        }
        if (buffer === null || typeof buffer !== 'object')
            throw TypeError("Illegal buffer");
        var bb;
        if (ByteBuffer.isByteBuffer(buffer)) {
            bb = ByteBufferPrototype.clone.call(buffer);
            bb.markedOffset = -1;
            return bb;
        }
        if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER
                bb.buffer = buffer.buffer;
                bb.offset = buffer.byteOffset;
                bb.limit = buffer.byteOffset + buffer.byteLength;
                bb.view = new Uint8Array(buffer.buffer);
            }
        } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.byteLength > 0) {
                bb.buffer = buffer;
                bb.offset = 0;
                bb.limit = buffer.byteLength;
                bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;
            }
        } else if (Object.prototype.toString.call(buffer) === "[object Array]") { // Create from octets
            bb = new ByteBuffer(buffer.length, littleEndian, noAssert);
            bb.limit = buffer.length;
            for (var i=0; i<buffer.length; ++i)
                bb.view[i] = buffer[i];
        } else
            throw TypeError("Illegal buffer"); // Otherwise fail
        return bb;
    };

    /**
     * Writes the array as a bitset.
     * @param {Array<boolean>} value Array of booleans to write
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.writeBitSet = function(value, offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;
      if (!this.noAssert) {
        if (!(value instanceof Array))
          throw TypeError("Illegal BitSet: Not an array");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset >>>= 0;
        if (offset < 0 || offset + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
      }

      var start = offset,
          bits = value.length,
          bytes = (bits >> 3),
          bit = 0,
          k;

      offset += this.writeVarint32(bits,offset);

      while(bytes--) {
        k = (!!value[bit++] & 1) |
            ((!!value[bit++] & 1) << 1) |
            ((!!value[bit++] & 1) << 2) |
            ((!!value[bit++] & 1) << 3) |
            ((!!value[bit++] & 1) << 4) |
            ((!!value[bit++] & 1) << 5) |
            ((!!value[bit++] & 1) << 6) |
            ((!!value[bit++] & 1) << 7);
        this.writeByte(k,offset++);
      }

      if(bit < bits) {
        var m = 0; k = 0;
        while(bit < bits) k = k | ((!!value[bit++] & 1) << (m++));
        this.writeByte(k,offset++);
      }

      if (relative) {
        this.offset = offset;
        return this;
      }
      return offset - start;
    }

    /**
     * Reads a BitSet as an array of booleans.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {Array<boolean>
     * @expose
     */
    ByteBufferPrototype.readBitSet = function(offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;

      var ret = this.readVarint32(offset),
          bits = ret.value,
          bytes = (bits >> 3),
          bit = 0,
          value = [],
          k;

      offset += ret.length;

      while(bytes--) {
        k = this.readByte(offset++);
        value[bit++] = !!(k & 0x01);
        value[bit++] = !!(k & 0x02);
        value[bit++] = !!(k & 0x04);
        value[bit++] = !!(k & 0x08);
        value[bit++] = !!(k & 0x10);
        value[bit++] = !!(k & 0x20);
        value[bit++] = !!(k & 0x40);
        value[bit++] = !!(k & 0x80);
      }

      if(bit < bits) {
        var m = 0;
        k = this.readByte(offset++);
        while(bit < bits) value[bit++] = !!((k >> (m++)) & 1);
      }

      if (relative) {
        this.offset = offset;
      }
      return value;
    }
    /**
     * Reads the specified number of bytes.
     * @param {number} length Number of bytes to read
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.readBytes = function(length, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + length > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
        }
        var slice = this.slice(offset, offset + length);
        if (relative) this.offset += length;
        return slice;
    };

    /**
     * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
     * @function
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;

    // types/ints/int8

    /**
     * Writes an 8bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeInt8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity0 = this.buffer.byteLength;
        if (offset > capacity0)
            this.resize((capacity0 *= 2) > offset ? capacity0 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;

    /**
     * Reads an 8bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;

    /**
     * Writes an 8bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUint8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity1 = this.buffer.byteLength;
        if (offset > capacity1)
            this.resize((capacity1 *= 2) > offset ? capacity1 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;

    /**
     * Reads an 8bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;

    // types/ints/int16

    /**
     * Writes a 16bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeInt16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity2 = this.buffer.byteLength;
        if (offset > capacity2)
            this.resize((capacity2 *= 2) > offset ? capacity2 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;

    /**
     * Reads a 16bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readInt16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;

    /**
     * Writes a 16bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUint16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity3 = this.buffer.byteLength;
        if (offset > capacity3)
            this.resize((capacity3 *= 2) > offset ? capacity3 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;

    /**
     * Reads a 16bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUint16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;

    // types/ints/int32

    /**
     * Writes a 32bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity4 = this.buffer.byteLength;
        if (offset > capacity4)
            this.resize((capacity4 *= 2) > offset ? capacity4 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;

    /**
     * Reads a 32bit signed integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        value |= 0; // Cast to signed
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;

    /**
     * Writes a 32bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity5 = this.buffer.byteLength;
        if (offset > capacity5)
            this.resize((capacity5 *= 2) > offset ? capacity5 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;

    /**
     * Reads a 32bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;

    // types/ints/int64

    if (Long) {

        /**
         * Writes a 64bit signed integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeInt64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity6 = this.buffer.byteLength;
            if (offset > capacity6)
                this.resize((capacity6 *= 2) > offset ? capacity6 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;

        /**
         * Reads a 64bit signed integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readInt64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, false);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;

        /**
         * Writes a 64bit unsigned integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity7 = this.buffer.byteLength;
            if (offset > capacity7)
                this.resize((capacity7 *= 2) > offset ? capacity7 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
         * @function
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;

        /**
         * Reads a 64bit unsigned integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, true);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
         * @function
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;

    } // Long


    // types/floats/float32

    /*
     ieee754 - https://github.com/feross/ieee754

     The MIT License (MIT)

     Copyright (c) Feross Aboukhadijeh

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE.
    */

    /**
     * Reads an IEEE754 float from a byte array.
     * @param {!Array} buffer
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @returns {number}
     * @inner
     */
    function ieee754_read(buffer, offset, isLE, mLen, nBytes) {
        var e, m,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            nBits = -7,
            i = isLE ? (nBytes - 1) : 0,
            d = isLE ? -1 : 1,
            s = buffer[offset + i];

        i += d;

        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
            e = 1 - eBias;
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity);
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    }

    /**
     * Writes an IEEE754 float to a byte array.
     * @param {!Array} buffer
     * @param {number} value
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @inner
     */
    function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
            i = isLE ? 0 : (nBytes - 1),
            d = isLE ? 1 : -1,
            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            } else {
                value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }

            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
    }

    /**
     * Writes a 32bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity8 = this.buffer.byteLength;
        if (offset > capacity8)
            this.resize((capacity8 *= 2) > offset ? capacity8 : offset);
        offset -= 4;
        ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;

    /**
     * Reads a 32bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;

    // types/floats/float64

    /**
     * Writes a 64bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat64 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 8;
        var capacity9 = this.buffer.byteLength;
        if (offset > capacity9)
            this.resize((capacity9 *= 2) > offset ? capacity9 : offset);
        offset -= 8;
        ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return this;
    };

    /**
     * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;

    /**
     * Reads a 64bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat64 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 8 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return value;
    };

    /**
     * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;


    // types/varints/varint32

    /**
     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
     * @type {number}
     * @const
     * @expose
     */
    ByteBuffer.MAX_VARINT32_BYTES = 5;

    /**
     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
     * @param {number} value Value to encode
     * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
     * @expose
     */
    ByteBuffer.calculateVarint32 = function(value) {
        // ref: src/google/protobuf/io/coded_stream.cc
        value = value >>> 0;
             if (value < 1 << 7 ) return 1;
        else if (value < 1 << 14) return 2;
        else if (value < 1 << 21) return 3;
        else if (value < 1 << 28) return 4;
        else                      return 5;
    };

    /**
     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
     * @param {number} n Signed 32bit integer
     * @returns {number} Unsigned zigzag encoded 32bit integer
     * @expose
     */
    ByteBuffer.zigZagEncode32 = function(n) {
        return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Decodes a zigzag encoded signed 32bit integer.
     * @param {number} n Unsigned zigzag encoded 32bit integer
     * @returns {number} Signed 32bit integer
     * @expose
     */
    ByteBuffer.zigZagDecode32 = function(n) {
        return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Writes a 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var size = ByteBuffer.calculateVarint32(value),
            b;
        offset += size;
        var capacity10 = this.buffer.byteLength;
        if (offset > capacity10)
            this.resize((capacity10 *= 2) > offset ? capacity10 : offset);
        offset -= size;
        value >>>= 0;
        while (value >= 0x80) {
            b = (value & 0x7f) | 0x80;
            this.view[offset++] = b;
            value >>>= 7;
        }
        this.view[offset++] = value;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return size;
    };

    /**
     * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {
        return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
    };

    /**
     * Reads a 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
     *  to fully decode the varint.
     * @expose
     */
    ByteBufferPrototype.readVarint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var c = 0,
            value = 0 >>> 0,
            b;
        do {
            if (!this.noAssert && offset > this.limit) {
                var err = Error("Truncated");
                err['truncated'] = true;
                throw err;
            }
            b = this.view[offset++];
            if (c < 5)
                value |= (b & 0x7f) << (7*c);
            ++c;
        } while ((b & 0x80) !== 0);
        value |= 0;
        if (relative) {
            this.offset = offset;
            return value;
        }
        return {
            "value": value,
            "length": c
        };
    };

    /**
     * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint
     * @expose
     */
    ByteBufferPrototype.readVarint32ZigZag = function(offset) {
        var val = this.readVarint32(offset);
        if (typeof val === 'object')
            val["value"] = ByteBuffer.zigZagDecode32(val["value"]);
        else
            val = ByteBuffer.zigZagDecode32(val);
        return val;
    };

    // types/varints/varint64

    if (Long) {

        /**
         * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
         * @type {number}
         * @const
         * @expose
         */
        ByteBuffer.MAX_VARINT64_BYTES = 10;

        /**
         * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
         * @param {number|!Long} value Value to encode
         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
         * @expose
         */
        ByteBuffer.calculateVarint64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            // ref: src/google/protobuf/io/coded_stream.cc
            var part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            if (part2 == 0) {
                if (part1 == 0) {
                    if (part0 < 1 << 14)
                        return part0 < 1 << 7 ? 1 : 2;
                    else
                        return part0 < 1 << 21 ? 3 : 4;
                } else {
                    if (part1 < 1 << 14)
                        return part1 < 1 << 7 ? 5 : 6;
                    else
                        return part1 < 1 << 21 ? 7 : 8;
                }
            } else
                return part2 < 1 << 7 ? 9 : 10;
        };

        /**
         * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
         * @param {number|!Long} value Signed long
         * @returns {!Long} Unsigned zigzag encoded long
         * @expose
         */
        ByteBuffer.zigZagEncode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
        };

        /**
         * Decodes a zigzag encoded signed 64bit integer.
         * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
         * @returns {!Long} Signed long
         * @expose
         */
        ByteBuffer.zigZagDecode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
        };

        /**
         * Writes a 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            var size = ByteBuffer.calculateVarint64(value),
                part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            offset += size;
            var capacity11 = this.buffer.byteLength;
            if (offset > capacity11)
                this.resize((capacity11 *= 2) > offset ? capacity11 : offset);
            offset -= size;
            switch (size) {
                case 10: this.view[offset+9] = (part2 >>>  7) & 0x01;
                case 9 : this.view[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;
                case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
                case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
                case 6 : this.view[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;
                case 5 : this.view[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;
                case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
                case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
                case 2 : this.view[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;
                case 1 : this.view[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;
            }
            if (relative) {
                this.offset += size;
                return this;
            } else {
                return size;
            }
        };

        /**
         * Writes a zig-zag encoded 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {
            return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
        };

        /**
         * Reads a 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
            }
            // ref: src/google/protobuf/io/coded_stream.cc
            var start = offset,
                part0 = 0,
                part1 = 0,
                part2 = 0,
                b  = 0;
            b = this.view[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) {
            b = this.view[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            throw Error("Buffer overrun"); }}}}}}}}}}
            var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);
            if (relative) {
                this.offset = offset;
                return value;
            } else {
                return {
                    'value': value,
                    'length': offset-start
                };
            }
        };

        /**
         * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64ZigZag = function(offset) {
            var val = this.readVarint64(offset);
            if (val && val['value'] instanceof Long)
                val["value"] = ByteBuffer.zigZagDecode64(val["value"]);
            else
                val = ByteBuffer.zigZagDecode64(val);
            return val;
        };

    } // Long


    // types/strings/cstring

    /**
     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
     *  characters itself.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  contained in `str` + 1 if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeCString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        var i,
            k = str.length;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            for (i=0; i<k; ++i) {
                if (str.charCodeAt(i) === 0)
                    throw RangeError("Illegal str: Contains NULL-characters");
            }
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        // UTF8 strings do not contain zero bytes in between except for the zero character, so:
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k+1;
        var capacity12 = this.buffer.byteLength;
        if (offset > capacity12)
            this.resize((capacity12 *= 2) > offset ? capacity12 : offset);
        offset -= k+1;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        this.view[offset++] = 0;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return k;
    };

    /**
     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
     *  itself.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readCString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            temp;
        // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
        var sd, b = -1;
        utfx.decodeUTF8toUTF16(function() {
            if (b === 0) return null;
            if (offset >= this.limit)
                throw RangeError("Illegal range: Truncated data, "+offset+" < "+this.limit);
            b = this.view[offset++];
            return b === 0 ? null : b;
        }.bind(this), sd = stringDestination(), true);
        if (relative) {
            this.offset = offset;
            return sd();
        } else {
            return {
                "string": sd(),
                "length": offset - start
            };
        }
    };

    // types/strings/istring

    /**
     * Writes a length as uint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeIString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        offset += 4+k;
        var capacity13 = this.buffer.byteLength;
        if (offset > capacity13)
            this.resize((capacity13 *= 2) > offset ? capacity13 : offset);
        offset -= 4+k;
        if (this.littleEndian) {
            this.view[offset+3] = (k >>> 24) & 0xFF;
            this.view[offset+2] = (k >>> 16) & 0xFF;
            this.view[offset+1] = (k >>>  8) & 0xFF;
            this.view[offset  ] =  k         & 0xFF;
        } else {
            this.view[offset  ] = (k >>> 24) & 0xFF;
            this.view[offset+1] = (k >>> 16) & 0xFF;
            this.view[offset+2] = (k >>>  8) & 0xFF;
            this.view[offset+3] =  k         & 0xFF;
        }
        offset += 4;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start + 4 + k)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+4+k));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as uint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readIString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readUint32(offset);
        var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };

    // types/strings/utf8string

    /**
     * Metrics representing number of UTF8 characters. Evaluates to `c`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_CHARS = 'c';

    /**
     * Metrics representing number of bytes. Evaluates to `b`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_BYTES = 'b';

    /**
     * Writes an UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeUTF8String = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var k;
        var start = offset;
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k;
        var capacity14 = this.buffer.byteLength;
        if (offset > capacity14)
            this.resize((capacity14 *= 2) > offset ? capacity14 : offset);
        offset -= k;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
     * @function
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;

    /**
     * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
     *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 characters
     * @expose
     */
    ByteBuffer.calculateUTF8Chars = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[0];
    };

    /**
     * Calculates the number of UTF8 bytes of a string.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateUTF8Bytes = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[1];
    };

    /**
     * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
     * @function
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;

    /**
     * Reads an UTF8 encoded string.
     * @param {number} length Number of characters or bytes to read.
     * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {
        if (typeof metrics === 'number') {
            offset = metrics;
            metrics = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var i = 0,
            start = offset,
            sd;
        if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser
            sd = stringDestination();
            utfx.decodeUTF8(function() {
                return i < length && offset < this.limit ? this.view[offset++] : null;
            }.bind(this), function(cp) {
                ++i; utfx.UTF8toUTF16(cp, sd);
            });
            if (i !== length)
                throw RangeError("Illegal range: Truncated data, "+i+" == "+length);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    "string": sd(),
                    "length": offset - start
                };
            }
        } else if (metrics === ByteBuffer.METRICS_BYTES) {
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + length > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
            }
            var k = offset + length;
            utfx.decodeUTF8toUTF16(function() {
                return offset < k ? this.view[offset++] : null;
            }.bind(this), sd = stringDestination(), this.noAssert);
            if (offset !== k)
                throw RangeError("Illegal range: Truncated data, "+offset+" == "+k);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    'string': sd(),
                    'length': offset - start
                };
            }
        } else
            throw TypeError("Unsupported metrics: "+metrics);
    };

    /**
     * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
     * @function
     * @param {number} length Number of characters or bytes to read
     * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;

    // types/strings/vstring

    /**
     * Writes a length as varint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeVString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k, l;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        l = ByteBuffer.calculateVarint32(k);
        offset += l+k;
        var capacity15 = this.buffer.byteLength;
        if (offset > capacity15)
            this.resize((capacity15 *= 2) > offset ? capacity15 : offset);
        offset -= l+k;
        offset += this.writeVarint32(k, offset);
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start+k+l)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+k+l));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as varint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readVString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readVarint32(offset);
        var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };


    /**
     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
     *  data's length.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
     * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
     */
    ByteBufferPrototype.append = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var length = source.limit - source.offset;
        if (length <= 0) return this; // Nothing to append
        offset += length;
        var capacity16 = this.buffer.byteLength;
        if (offset > capacity16)
            this.resize((capacity16 *= 2) > offset ? capacity16 : offset);
        offset -= length;
        this.view.set(source.view.subarray(source.offset, source.limit), offset);
        source.offset += length;
        if (relative) this.offset += length;
        return this;
    };

    /**
     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
        specified offset up to the length of this ByteBuffer's data.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#append
     */
    ByteBufferPrototype.appendTo = function(target, offset) {
        target.append(this, offset);
        return this;
    };

    /**
     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
     *  disable them if your code already makes sure that everything is valid.
     * @param {boolean} assert `true` to enable assertions, otherwise `false`
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.assert = function(assert) {
        this.noAssert = !assert;
        return this;
    };

    /**
     * Gets the capacity of this ByteBuffer's backing buffer.
     * @returns {number} Capacity of the backing buffer
     * @expose
     */
    ByteBufferPrototype.capacity = function() {
        return this.buffer.byteLength;
    };
    /**
     * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
     *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.clear = function() {
        this.offset = 0;
        this.limit = this.buffer.byteLength;
        this.markedOffset = -1;
        return this;
    };

    /**
     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
     *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
     * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
     * @returns {!ByteBuffer} Cloned instance
     * @expose
     */
    ByteBufferPrototype.clone = function(copy) {
        var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);
        if (copy) {
            bb.buffer = new ArrayBuffer(this.buffer.byteLength);
            bb.view = new Uint8Array(bb.buffer);
        } else {
            bb.buffer = this.buffer;
            bb.view = this.view;
        }
        bb.offset = this.offset;
        bb.markedOffset = this.markedOffset;
        bb.limit = this.limit;
        return bb;
    };

    /**
     * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
     *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
     *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.compact = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === 0 && end === this.buffer.byteLength)
            return this; // Already compacted
        var len = end - begin;
        if (len === 0) {
            this.buffer = EMPTY_BUFFER;
            this.view = null;
            if (this.markedOffset >= 0) this.markedOffset -= begin;
            this.offset = 0;
            this.limit = 0;
            return this;
        }
        var buffer = new ArrayBuffer(len);
        var view = new Uint8Array(buffer);
        view.set(this.view.subarray(begin, end));
        this.buffer = buffer;
        this.view = view;
        if (this.markedOffset >= 0) this.markedOffset -= begin;
        this.offset = 0;
        this.limit = len;
        return this;
    };

    /**
     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Copy
     * @expose
     */
    ByteBufferPrototype.copy = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return new ByteBuffer(0, this.littleEndian, this.noAssert);
        var capacity = end - begin,
            bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
        bb.offset = 0;
        bb.limit = capacity;
        if (bb.markedOffset >= 0) bb.markedOffset -= begin;
        this.copyTo(bb, 0, begin, end);
        return bb;
    };

    /**
     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
     *  by the number of bytes copied if omitted.
     * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
     *  number of bytes copied if omitted.
     * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {
        var relative,
            targetRelative;
        if (!this.noAssert) {
            if (!ByteBuffer.isByteBuffer(target))
                throw TypeError("Illegal target: Not a ByteBuffer");
        }
        targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;
        sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;
        sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;

        if (targetOffset < 0 || targetOffset > target.buffer.byteLength)
            throw RangeError("Illegal target range: 0 <= "+targetOffset+" <= "+target.buffer.byteLength);
        if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength)
            throw RangeError("Illegal source range: 0 <= "+sourceOffset+" <= "+this.buffer.byteLength);

        var len = sourceLimit - sourceOffset;
        if (len === 0)
            return target; // Nothing to copy

        target.ensureCapacity(targetOffset + len);

        target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);

        if (relative) this.offset += len;
        if (targetRelative) target.offset += len;

        return this;
    };

    /**
     * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
     *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
     *  the required capacity will be used instead.
     * @param {number} capacity Required capacity
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.ensureCapacity = function(capacity) {
        var current = this.buffer.byteLength;
        if (current < capacity)
            return this.resize((current *= 2) > capacity ? current : capacity);
        return this;
    };

    /**
     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
     * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted. defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} this
     * @expose
     * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
     */
    ByteBufferPrototype.fill = function(value, begin, end) {
        var relative = typeof begin === 'undefined';
        if (relative) begin = this.offset;
        if (typeof value === 'string' && value.length > 0)
            value = value.charCodeAt(0);
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin >= end)
            return this; // Nothing to fill
        while (begin < end) this.view[begin++] = value;
        if (relative) this.offset = begin;
        return this;
    };

    /**
     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
     *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.flip = function() {
        this.limit = this.offset;
        this.offset = 0;
        return this;
    };
    /**
     * Marks an offset on this ByteBuffer to be used later.
     * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @see ByteBuffer#reset
     * @expose
     */
    ByteBufferPrototype.mark = function(offset) {
        offset = typeof offset === 'undefined' ? this.offset : offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        this.markedOffset = offset;
        return this;
    };
    /**
     * Sets the byte order.
     * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.order = function(littleEndian) {
        if (!this.noAssert) {
            if (typeof littleEndian !== 'boolean')
                throw TypeError("Illegal littleEndian: Not a boolean");
        }
        this.littleEndian = !!littleEndian;
        return this;
    };

    /**
     * Switches (to) little endian byte order.
     * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.LE = function(littleEndian) {
        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;
        return this;
    };

    /**
     * Switches (to) big endian byte order.
     * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.BE = function(bigEndian) {
        this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;
        return this;
    };
    /**
     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
     *  modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
     * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
     */
    ByteBufferPrototype.prepend = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var len = source.limit - source.offset;
        if (len <= 0) return this; // Nothing to prepend
        var diff = len - offset;
        if (diff > 0) { // Not enough space before offset, so resize + move
            var buffer = new ArrayBuffer(this.buffer.byteLength + diff);
            var view = new Uint8Array(buffer);
            view.set(this.view.subarray(offset, this.buffer.byteLength), len);
            this.buffer = buffer;
            this.view = view;
            this.offset += diff;
            if (this.markedOffset >= 0) this.markedOffset += diff;
            this.limit += diff;
            offset += diff;
        } else {
            var arrayView = new Uint8Array(this.buffer);
        }
        this.view.set(source.view.subarray(source.offset, source.limit), offset - len);

        source.offset = source.limit;
        if (relative)
            this.offset -= len;
        return this;
    };

    /**
     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#prepend
     */
    ByteBufferPrototype.prependTo = function(target, offset) {
        target.prepend(this, offset);
        return this;
    };
    /**
     * Prints debug information about this ByteBuffer's contents.
     * @param {function(string)=} out Output function to call, defaults to console.log
     * @expose
     */
    ByteBufferPrototype.printDebug = function(out) {
        if (typeof out !== 'function') out = console.log.bind(console);
        out(
            this.toString()+"\n"+
            "-------------------------------------------------------------------\n"+
            this.toDebug(/* columns */ true)
        );
    };

    /**
     * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}, so this returns `limit - offset`.
     * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
     * @expose
     */
    ByteBufferPrototype.remaining = function() {
        return this.limit - this.offset;
    };
    /**
     * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
     *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
     *  marked, sets `offset = 0`.
     * @returns {!ByteBuffer} this
     * @see ByteBuffer#mark
     * @expose
     */
    ByteBufferPrototype.reset = function() {
        if (this.markedOffset >= 0) {
            this.offset = this.markedOffset;
            this.markedOffset = -1;
        } else {
            this.offset = 0;
        }
        return this;
    };
    /**
     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
     *  large or larger.
     * @param {number} capacity Capacity required
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `capacity` is not a number
     * @throws {RangeError} If `capacity < 0`
     * @expose
     */
    ByteBufferPrototype.resize = function(capacity) {
        if (!this.noAssert) {
            if (typeof capacity !== 'number' || capacity % 1 !== 0)
                throw TypeError("Illegal capacity: "+capacity+" (not an integer)");
            capacity |= 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity: 0 <= "+capacity);
        }
        if (this.buffer.byteLength < capacity) {
            var buffer = new ArrayBuffer(capacity);
            var view = new Uint8Array(buffer);
            view.set(this.view);
            this.buffer = buffer;
            this.view = view;
        }
        return this;
    };
    /**
     * Reverses this ByteBuffer's contents.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.reverse = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return this; // Nothing to reverse
        Array.prototype.reverse.call(this.view.subarray(begin, end));
        return this;
    };
    /**
     * Skips the next `length` bytes. This will just advance
     * @param {number} length Number of bytes to skip. May also be negative to move the offset back.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.skip = function(length) {
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
        }
        var offset = this.offset + length;
        if (!this.noAssert) {
            if (offset < 0 || offset > this.buffer.byteLength)
                throw RangeError("Illegal length: 0 <= "+this.offset+" + "+length+" <= "+this.buffer.byteLength);
        }
        this.offset = offset;
        return this;
    };

    /**
     * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
     * @expose
     */
    ByteBufferPrototype.slice = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var bb = this.clone();
        bb.offset = begin;
        bb.limit = end;
        return bb;
    };
    /**
     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
     *  possible. Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toBuffer = function(forceCopy) {
        var offset = this.offset,
            limit = this.limit;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: Not an integer");
            offset >>>= 0;
            if (typeof limit !== 'number' || limit % 1 !== 0)
                throw TypeError("Illegal limit: Not an integer");
            limit >>>= 0;
            if (offset < 0 || offset > limit || limit > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+offset+" <= "+limit+" <= "+this.buffer.byteLength);
        }
        // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
        // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:
        if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)
            return this.buffer;
        if (offset === limit)
            return EMPTY_BUFFER;
        var buffer = new ArrayBuffer(limit - offset);
        new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);
        return buffer;
    };

    /**
     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.
     * @function
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
     *  Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;

    /**
     * Converts the ByteBuffer's contents to a string.
     * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
     *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
     *  highlighted offsets.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {string} String representation
     * @throws {Error} If `encoding` is invalid
     * @expose
     */
    ByteBufferPrototype.toString = function(encoding, begin, end) {
        if (typeof encoding === 'undefined')
            return "ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";
        if (typeof encoding === 'number')
            encoding = "utf8",
            begin = encoding,
            end = begin;
        switch (encoding) {
            case "utf8":
                return this.toUTF8(begin, end);
            case "base64":
                return this.toBase64(begin, end);
            case "hex":
                return this.toHex(begin, end);
            case "binary":
                return this.toBinary(begin, end);
            case "debug":
                return this.toDebug();
            case "columns":
                return this.toColumns();
            default:
                throw Error("Unsupported encoding: "+encoding);
        }
    };

    // lxiv-embeddable

    /**
     * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/lxiv for details
     */
    var lxiv = function() {
        "use strict";

        /**
         * lxiv namespace.
         * @type {!Object.<string,*>}
         * @exports lxiv
         */
        var lxiv = {};

        /**
         * Character codes for output.
         * @type {!Array.<number>}
         * @inner
         */
        var aout = [
            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
            81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,
            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
            119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47
        ];

        /**
         * Character codes for input.
         * @type {!Array.<number>}
         * @inner
         */
        var ain = [];
        for (var i=0, k=aout.length; i<k; ++i)
            ain[aout[i]] = i;

        /**
         * Encodes bytes to base64 char codes.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
         *  there are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
         *  code.
         */
        lxiv.encode = function(src, dst) {
            var b, t;
            while ((b = src()) !== null) {
                dst(aout[(b>>2)&0x3f]);
                t = (b&0x3)<<4;
                if ((b = src()) !== null) {
                    t |= (b>>4)&0xf;
                    dst(aout[(t|((b>>4)&0xf))&0x3f]);
                    t = (b&0xf)<<2;
                    if ((b = src()) !== null)
                        dst(aout[(t|((b>>6)&0x3))&0x3f]),
                        dst(aout[b&0x3f]);
                    else
                        dst(aout[t&0x3f]),
                        dst(61);
                } else
                    dst(aout[t&0x3f]),
                    dst(61),
                    dst(61);
            }
        };

        /**
         * Decodes base64 char codes to bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         * @throws {Error} If a character code is invalid
         */
        lxiv.decode = function(src, dst) {
            var c, t1, t2;
            function fail(c) {
                throw Error("Illegal character code: "+c);
            }
            while ((c = src()) !== null) {
                t1 = ain[c];
                if (typeof t1 === 'undefined') fail(c);
                if ((c = src()) !== null) {
                    t2 = ain[c];
                    if (typeof t2 === 'undefined') fail(c);
                    dst((t1<<2)>>>0|(t2&0x30)>>4);
                    if ((c = src()) !== null) {
                        t1 = ain[c];
                        if (typeof t1 === 'undefined')
                            if (c === 61) break; else fail(c);
                        dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2);
                        if ((c = src()) !== null) {
                            t2 = ain[c];
                            if (typeof t2 === 'undefined')
                                if (c === 61) break; else fail(c);
                            dst(((t1&0x3)<<6)>>>0|t2);
                        }
                    }
                }
            }
        };

        /**
         * Tests if a string is valid base64.
         * @param {string} str String to test
         * @returns {boolean} `true` if valid, otherwise `false`
         */
        lxiv.test = function(str) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
        };

        return lxiv;
    }();

    // encodings/base64

    /**
     * Encodes this ByteBuffer's contents to a base64 encoded string.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
     * @returns {string} Base64 encoded string
     * @throws {RangeError} If `begin` or `end` is out of bounds
     * @expose
     */
    ByteBufferPrototype.toBase64 = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin = begin | 0; end = end | 0;
        if (begin < 0 || end > this.capacity || begin > end)
            throw RangeError("begin, end");
        var sd; lxiv.encode(function() {
            return begin < end ? this.view[begin++] : null;
        }.bind(this), sd = stringDestination());
        return sd();
    };

    /**
     * Decodes a base64 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBase64 = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var bb = new ByteBuffer(str.length/4*3, littleEndian),
            i = 0;
        lxiv.decode(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    /**
     * Encodes a binary string to base64 like `window.btoa` does.
     * @param {string} str Binary string
     * @returns {string} Base64 encoded string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
     * @expose
     */
    ByteBuffer.btoa = function(str) {
        return ByteBuffer.fromBinary(str).toBase64();
    };

    /**
     * Decodes a base64 encoded string to binary like `window.atob` does.
     * @param {string} b64 Base64 encoded string
     * @returns {string} Binary string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
     * @expose
     */
    ByteBuffer.atob = function(b64) {
        return ByteBuffer.fromBase64(b64).toBinary();
    };

    // encodings/binary

    /**
     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Binary encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toBinary = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin |= 0; end |= 0;
        if (begin < 0 || end > this.capacity() || begin > end)
            throw RangeError("begin, end");
        if (begin === end)
            return "";
        var chars = [],
            parts = [];
        while (begin < end) {
            chars.push(this.view[begin++]);
            if (chars.length >= 1024)
                parts.push(String.fromCharCode.apply(String, chars)),
                chars = [];
        }
        return parts.join('') + String.fromCharCode.apply(String, chars);
    };

    /**
     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBinary = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var i = 0,
            k = str.length,
            charCode,
            bb = new ByteBuffer(k, littleEndian);
        while (i<k) {
            charCode = str.charCodeAt(i);
            if (charCode > 0xff)
                throw RangeError("illegal char code: "+charCode);
            bb.view[i++] = charCode;
        }
        bb.limit = k;
        return bb;
    };

    // encodings/debug

    /**
     * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
     * * `<` : offset,
     * * `'` : markedOffset,
     * * `>` : limit,
     * * `|` : offset and limit,
     * * `[` : offset and markedOffset,
     * * `]` : markedOffset and limit,
     * * `!` : offset, markedOffset and limit
     * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
     * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
     * @expose
     * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
     * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
     * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
     * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
     */
    ByteBufferPrototype.toDebug = function(columns) {
        var i = -1,
            k = this.buffer.byteLength,
            b,
            hex = "",
            asc = "",
            out = "";
        while (i<k) {
            if (i !== -1) {
                b = this.view[i];
                if (b < 0x10) hex += "0"+b.toString(16).toUpperCase();
                else hex += b.toString(16).toUpperCase();
                if (columns)
                    asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';
            }
            ++i;
            if (columns) {
                if (i > 0 && i % 16 === 0 && i !== k) {
                    while (hex.length < 3*16+3) hex += " ";
                    out += hex+asc+"\n";
                    hex = asc = "";
                }
            }
            if (i === this.offset && i === this.limit)
                hex += i === this.markedOffset ? "!" : "|";
            else if (i === this.offset)
                hex += i === this.markedOffset ? "[" : "<";
            else if (i === this.limit)
                hex += i === this.markedOffset ? "]" : ">";
            else
                hex += i === this.markedOffset ? "'" : (columns || (i !== 0 && i !== k) ? " " : "");
        }
        if (columns && hex !== " ") {
            while (hex.length < 3*16+3)
                hex += " ";
            out += hex + asc + "\n";
        }
        return columns ? out : hex;
    };

    /**
     * Decodes a hex encoded string with marked offsets to a ByteBuffer.
     * @param {string} str Debug string to decode (not be generated with `columns = true`)
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     * @see ByteBuffer#toDebug
     */
    ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {
        var k = str.length,
            bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);
        var i = 0, j = 0, ch, b,
            rs = false, // Require symbol next
            ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?
            fail = false;
        while (i<k) {
            switch (ch = str.charAt(i++)) {
                case '!':
                    if (!noAssert) {
                        if (ho || hm || hl) {
                            fail = true;
                            break;
                        }
                        ho = hm = hl = true;
                    }
                    bb.offset = bb.markedOffset = bb.limit = j;
                    rs = false;
                    break;
                case '|':
                    if (!noAssert) {
                        if (ho || hl) {
                            fail = true;
                            break;
                        }
                        ho = hl = true;
                    }
                    bb.offset = bb.limit = j;
                    rs = false;
                    break;
                case '[':
                    if (!noAssert) {
                        if (ho || hm) {
                            fail = true;
                            break;
                        }
                        ho = hm = true;
                    }
                    bb.offset = bb.markedOffset = j;
                    rs = false;
                    break;
                case '<':
                    if (!noAssert) {
                        if (ho) {
                            fail = true;
                            break;
                        }
                        ho = true;
                    }
                    bb.offset = j;
                    rs = false;
                    break;
                case ']':
                    if (!noAssert) {
                        if (hl || hm) {
                            fail = true;
                            break;
                        }
                        hl = hm = true;
                    }
                    bb.limit = bb.markedOffset = j;
                    rs = false;
                    break;
                case '>':
                    if (!noAssert) {
                        if (hl) {
                            fail = true;
                            break;
                        }
                        hl = true;
                    }
                    bb.limit = j;
                    rs = false;
                    break;
                case "'":
                    if (!noAssert) {
                        if (hm) {
                            fail = true;
                            break;
                        }
                        hm = true;
                    }
                    bb.markedOffset = j;
                    rs = false;
                    break;
                case ' ':
                    rs = false;
                    break;
                default:
                    if (!noAssert) {
                        if (rs) {
                            fail = true;
                            break;
                        }
                    }
                    b = parseInt(ch+str.charAt(i++), 16);
                    if (!noAssert) {
                        if (isNaN(b) || b < 0 || b > 255)
                            throw TypeError("Illegal str: Not a debug encoded string");
                    }
                    bb.view[j++] = b;
                    rs = true;
            }
            if (fail)
                throw TypeError("Illegal str: Invalid symbol at "+i);
        }
        if (!noAssert) {
            if (!ho || !hl)
                throw TypeError("Illegal str: Missing offset or limit");
            if (j<bb.buffer.byteLength)
                throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" < "+k);
        }
        return bb;
    };

    // encodings/hex

    /**
     * Encodes this ByteBuffer's contents to a hex encoded string.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Hex encoded string
     * @expose
     */
    ByteBufferPrototype.toHex = function(begin, end) {
        begin = typeof begin === 'undefined' ? this.offset : begin;
        end = typeof end === 'undefined' ? this.limit : end;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var out = new Array(end - begin),
            b;
        while (begin < end) {
            b = this.view[begin++];
            if (b < 0x10)
                out.push("0", b.toString(16));
            else out.push(b.toString(16));
        }
        return out.join('');
    };

    /**
     * Decodes a hex encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromHex = function(str, littleEndian, noAssert) {
        if (!noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (str.length % 2 !== 0)
                throw TypeError("Illegal str: Length not a multiple of 2");
        }
        var k = str.length,
            bb = new ByteBuffer((k / 2) | 0, littleEndian),
            b;
        for (var i=0, j=0; i<k; i+=2) {
            b = parseInt(str.substring(i, i+2), 16);
            if (!noAssert)
                if (!isFinite(b) || b < 0 || b > 255)
                    throw TypeError("Illegal str: Contains non-hex characters");
            bb.view[j++] = b;
        }
        bb.limit = j;
        return bb;
    };

    // utfx-embeddable

    /**
     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/utfx for details
     */
    var utfx = function() {
        "use strict";

        /**
         * utfx namespace.
         * @inner
         * @type {!Object.<string,*>}
         */
        var utfx = {};

        /**
         * Maximum valid code point.
         * @type {number}
         * @const
         */
        utfx.MAX_CODEPOINT = 0x10FFFF;

        /**
         * Encodes UTF8 code points to UTF8 bytes.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
         */
        utfx.encodeUTF8 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src,
                src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp < 0x80)
                    dst(cp&0x7F);
                else if (cp < 0x800)
                    dst(((cp>>6)&0x1F)|0xC0),
                    dst((cp&0x3F)|0x80);
                else if (cp < 0x10000)
                    dst(((cp>>12)&0x0F)|0xE0),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                else
                    dst(((cp>>18)&0x07)|0xF0),
                    dst(((cp>>12)&0x3F)|0x80),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                cp = null;
            }
        };

        /**
         * Decodes UTF8 bytes to UTF8 code points.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
         *  remaining bytes.
         */
        utfx.decodeUTF8 = function(src, dst) {
            var a, b, c, d, fail = function(b) {
                b = b.slice(0, b.indexOf(null));
                var err = Error(b.toString());
                err.name = "TruncatedError";
                err['bytes'] = b;
                throw err;
            };
            while ((a = src()) !== null) {
                if ((a&0x80) === 0)
                    dst(a);
                else if ((a&0xE0) === 0xC0)
                    ((b = src()) === null) && fail([a, b]),
                    dst(((a&0x1F)<<6) | (b&0x3F));
                else if ((a&0xF0) === 0xE0)
                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),
                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));
                else if ((a&0xF8) === 0xF0)
                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),
                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));
                else throw RangeError("Illegal starting byte: "+a);
            }
        };

        /**
         * Converts UTF16 characters to UTF8 code points.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Code points destination as a function successively called with each converted code
         *  point.
         */
        utfx.UTF16toUTF8 = function(src, dst) {
            var c1, c2 = null;
            while (true) {
                if ((c1 = c2 !== null ? c2 : src()) === null)
                    break;
                if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                    if ((c2 = src()) !== null) {
                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);
                            c2 = null; continue;
                        }
                    }
                }
                dst(c1);
            }
            if (c2 !== null) dst(c2);
        };

        /**
         * Converts UTF8 code points to UTF16 characters.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a code point is out of range
         */
        utfx.UTF8toUTF16 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src, src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp <= 0xFFFF)
                    dst(cp);
                else
                    cp -= 0x10000,
                    dst((cp>>10)+0xD800),
                    dst((cp%0x400)+0xDC00);
                cp = null;
            }
        };

        /**
         * Converts and encodes UTF16 characters to UTF8 bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
         *  if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         */
        utfx.encodeUTF16toUTF8 = function(src, dst) {
            utfx.UTF16toUTF8(src, function(cp) {
                utfx.encodeUTF8(cp, dst);
            });
        };

        /**
         * Decodes and converts UTF8 bytes to UTF16 characters.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
         */
        utfx.decodeUTF8toUTF16 = function(src, dst) {
            utfx.decodeUTF8(src, function(cp) {
                utfx.UTF8toUTF16(cp, dst);
            });
        };

        /**
         * Calculates the byte length of an UTF8 code point.
         * @param {number} cp UTF8 code point
         * @returns {number} Byte length
         */
        utfx.calculateCodePoint = function(cp) {
            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
        };

        /**
         * Calculates the number of UTF8 bytes required to store UTF8 code points.
         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
         *  `null` if there are no more code points left.
         * @returns {number} The number of UTF8 bytes required
         */
        utfx.calculateUTF8 = function(src) {
            var cp, l=0;
            while ((cp = src()) !== null)
                l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            return l;
        };

        /**
         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
         */
        utfx.calculateUTF16asUTF8 = function(src) {
            var n=0, l=0;
            utfx.UTF16toUTF8(src, function(cp) {
                ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            });
            return [n,l];
        };

        return utfx;
    }();

    // encodings/utf8

    /**
     * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
     *  string.
     * @returns {string} Hex encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toUTF8 = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var sd; try {
            utfx.decodeUTF8toUTF16(function() {
                return begin < end ? this.view[begin++] : null;
            }.bind(this), sd = stringDestination());
        } catch (e) {
            if (begin !== end)
                throw RangeError("Illegal range: Truncated data, "+begin+" != "+end);
        }
        return sd();
    };

    /**
     * Decodes an UTF8 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {
        if (!noAssert)
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
        var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),
            i = 0;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

//    return ByteBuffer;
//});


/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license protobuf.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/protobuf.js for details
 */
//(function(global, factory) {
//
//    /* AMD */ if (typeof define === 'function' && define["amd"])
//        define(["bytebuffer"], factory);
//    /* CommonJS */ else if (typeof require === "function" && typeof module === "object" && module && module["exports"])
//        module["exports"] = factory(require("bytebuffer"), true);
//    /* Global */ else
//        (global["dcodeIO"] = global["dcodeIO"] || {})["ProtoBuf"] = factory(global["dcodeIO"]["ByteBuffer"]);
//
//})(this, function(ByteBuffer, isCommonJS) {
//    "use strict";

    /**
     * The ProtoBuf namespace.
     * @exports ProtoBuf
     * @namespace
     * @expose
     */
    var ProtoBuf = {};

    /**
     * @type {!function(new: ByteBuffer, ...[*])}
     * @expose
     */
    ProtoBuf.ByteBuffer = ByteBuffer;

    /**
     * @type {?function(new: Long, ...[*])}
     * @expose
     */
    ProtoBuf.Long = ByteBuffer.Long || null;

    /**
     * ProtoBuf.js version.
     * @type {string}
     * @const
     * @expose
     */
    ProtoBuf.VERSION = "5.0.1";

    /**
     * Wire types.
     * @type {Object.<string,number>}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES = {};

    /**
     * Varint wire type.
     * @type {number}
     * @expose
     */
    ProtoBuf.WIRE_TYPES.VARINT = 0;

    /**
     * Fixed 64 bits wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.BITS64 = 1;

    /**
     * Length delimited wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.LDELIM = 2;

    /**
     * Start group wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.STARTGROUP = 3;

    /**
     * End group wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.ENDGROUP = 4;

    /**
     * Fixed 32 bits wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.BITS32 = 5;

    /**
     * Packable wire types.
     * @type {!Array.<number>}
     * @const
     * @expose
     */
    ProtoBuf.PACKABLE_WIRE_TYPES = [
        ProtoBuf.WIRE_TYPES.VARINT,
        ProtoBuf.WIRE_TYPES.BITS64,
        ProtoBuf.WIRE_TYPES.BITS32
    ];

    /**
     * Types.
     * @dict
     * @type {!Object.<string,{name: string, wireType: number, defaultValue: *}>}
     * @const
     * @expose
     */
    ProtoBuf.TYPES = {
        // According to the protobuf spec.
        "int32": {
            name: "int32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "uint32": {
            name: "uint32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "sint32": {
            name: "sint32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "int64": {
            name: "int64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "uint64": {
            name: "uint64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
        },
        "sint64": {
            name: "sint64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "bool": {
            name: "bool",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: false
        },
        "double": {
            name: "double",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue: 0
        },
        "string": {
            name: "string",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: ""
        },
        "bytes": {
            name: "bytes",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: null // overridden in the code, must be a unique instance
        },
        "fixed32": {
            name: "fixed32",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "sfixed32": {
            name: "sfixed32",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "fixed64": {
            name: "fixed64",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue:  ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
        },
        "sfixed64": {
            name: "sfixed64",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "float": {
            name: "float",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "enum": {
            name: "enum",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "message": {
            name: "message",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: null
        },
        "group": {
            name: "group",
            wireType: ProtoBuf.WIRE_TYPES.STARTGROUP,
            defaultValue: null
        }
    };

    /**
     * Valid map key types.
     * @type {!Array.<!Object.<string,{name: string, wireType: number, defaultValue: *}>>}
     * @const
     * @expose
     */
    ProtoBuf.MAP_KEY_TYPES = [
        ProtoBuf.TYPES["int32"],
        ProtoBuf.TYPES["sint32"],
        ProtoBuf.TYPES["sfixed32"],
        ProtoBuf.TYPES["uint32"],
        ProtoBuf.TYPES["fixed32"],
        ProtoBuf.TYPES["int64"],
        ProtoBuf.TYPES["sint64"],
        ProtoBuf.TYPES["sfixed64"],
        ProtoBuf.TYPES["uint64"],
        ProtoBuf.TYPES["fixed64"],
        ProtoBuf.TYPES["bool"],
        ProtoBuf.TYPES["string"],
        ProtoBuf.TYPES["bytes"]
    ];

    /**
     * Minimum field id.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.ID_MIN = 1;

    /**
     * Maximum field id.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.ID_MAX = 0x1FFFFFFF;

    /**
     * If set to `true`, field names will be converted from underscore notation to camel case. Defaults to `false`.
     *  Must be set prior to parsing.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.convertFieldsToCamelCase = false;

    /**
     * By default, messages are populated with (setX, set_x) accessors for each field. This can be disabled by
     *  setting this to `false` prior to building messages.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.populateAccessors = true;

    /**
     * By default, messages are populated with default values if a field is not present on the wire. To disable
     *  this behavior, set this setting to `false`.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.populateDefaults = true;

    /**
     * @alias ProtoBuf.Util
     * @expose
     */
    ProtoBuf.Util = (function() {
        "use strict";

        /**
         * ProtoBuf utilities.
         * @exports ProtoBuf.Util
         * @namespace
         */
        var Util = {};

        /**
         * Flag if running in node or not.
         * @type {boolean}
         * @const
         * @expose
         */
        Util.IS_NODE = !!(
            typeof process === 'object' && process+'' === '[object process]' && !process['browser']
        );

        /**
         * Constructs a XMLHttpRequest object.
         * @return {XMLHttpRequest}
         * @throws {Error} If XMLHttpRequest is not supported
         * @expose
         */
        Util.XHR = function() {
            // No dependencies please, ref: http://www.quirksmode.org/js/xmlhttp.html
            var XMLHttpFactories = [
                function () {return new XMLHttpRequest()},
                function () {return new ActiveXObject("Msxml2.XMLHTTP")},
                function () {return new ActiveXObject("Msxml3.XMLHTTP")},
                function () {return new ActiveXObject("Microsoft.XMLHTTP")}
            ];
            /** @type {?XMLHttpRequest} */
            var xhr = null;
            for (var i=0;i<XMLHttpFactories.length;i++) {
                try { xhr = XMLHttpFactories[i](); }
                catch (e) { continue; }
                break;
            }
            if (!xhr)
                throw Error("XMLHttpRequest is not supported");
            return xhr;
        };

        /**
         * Fetches a resource.
         * @param {string} path Resource path
         * @param {function(?string)=} callback Callback receiving the resource's contents. If omitted the resource will
         *   be fetched synchronously. If the request failed, contents will be null.
         * @return {?string|undefined} Resource contents if callback is omitted (null if the request failed), else undefined.
         * @expose
         */
        Util.fetch = function(path, callback) {
            if (callback && typeof callback != 'function')
                callback = null;
            if (Util.IS_NODE) {
                var fs = require("fs");
                if (callback) {
                    fs.readFile(path, function(err, data) {
                        if (err)
                            callback(null);
                        else
                            callback(""+data);
                    });
                } else
                    try {
                        return fs.readFileSync(path);
                    } catch (e) {
                        return null;
                    }
            } else {
                var xhr = Util.XHR();
                xhr.open('GET', path, callback ? true : false);
                // xhr.setRequestHeader('User-Agent', 'XMLHTTP/1.0');
                xhr.setRequestHeader('Accept', 'text/plain');
                if (typeof xhr.overrideMimeType === 'function') xhr.overrideMimeType('text/plain');
                if (callback) {
                    xhr.onreadystatechange = function() {
                        if (xhr.readyState != 4) return;
                        if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
                            callback(xhr.responseText);
                        else
                            callback(null);
                    };
                    if (xhr.readyState == 4)
                        return;
                    xhr.send(null);
                } else {
                    xhr.send(null);
                    if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
                        return xhr.responseText;
                    return null;
                }
            }
        };

        /**
         * Converts a string to camel case.
         * @param {string} str
         * @returns {string}
         * @expose
         */
        Util.toCamelCase = function(str) {
            return str.replace(/_([a-zA-Z])/g, function ($0, $1) {
                return $1.toUpperCase();
            });
        };

        return Util;
    })();

    /**
     * Language expressions.
     * @type {!Object.<string,!RegExp>}
     * @expose
     */
    ProtoBuf.Lang = {

        // Characters always ending a statement
        DELIM: /[\s\{\}=;:\[\],'"\(\)<>]/g,

        // Field rules
        RULE: /^(?:required|optional|repeated|map)$/,

        // Field types
        TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,

        // Names
        NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,

        // Type definitions
        TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,

        // Type references
        TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,

        // Fully qualified type references
        FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,

        // All numbers
        NUMBER: /^-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+|([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?)|inf|nan)$/,

        // Decimal numbers
        NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,

        // Hexadecimal numbers
        NUMBER_HEX: /^0[xX][0-9a-fA-F]+$/,

        // Octal numbers
        NUMBER_OCT: /^0[0-7]+$/,

        // Floating point numbers
        NUMBER_FLT: /^([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?|inf|nan)$/,

        // Booleans
        BOOL: /^(?:true|false)$/i,

        // Id numbers
        ID: /^(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,

        // Negative id numbers (enum values)
        NEGID: /^\-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,

        // Whitespaces
        WHITESPACE: /\s/,

        // All strings
        STRING: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")|(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,

        // Double quoted strings
        STRING_DQ: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,

        // Single quoted strings
        STRING_SQ: /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g
    };

    /**
     * @alias ProtoBuf.DotProto
     * @expose
     */
    ProtoBuf.DotProto = (function(ProtoBuf, Lang) {
        "use strict";

        /**
         * Utilities to parse .proto files.
         * @exports ProtoBuf.DotProto
         * @namespace
         */
        var DotProto = {};

        /**
         * Constructs a new Tokenizer.
         * @exports ProtoBuf.DotProto.Tokenizer
         * @class prototype tokenizer
         * @param {string} proto Proto to tokenize
         * @constructor
         */
        var Tokenizer = function(proto) {

            /**
             * Source to parse.
             * @type {string}
             * @expose
             */
            this.source = proto+"";

            /**
             * Current index.
             * @type {number}
             * @expose
             */
            this.index = 0;

            /**
             * Current line.
             * @type {number}
             * @expose
             */
            this.line = 1;

            /**
             * Token stack.
             * @type {!Array.<string>}
             * @expose
             */
            this.stack = [];

            /**
             * Opening character of the current string read, if any.
             * @type {?string}
             * @private
             */
            this._stringOpen = null;
        };

        /**
         * @alias ProtoBuf.DotProto.Tokenizer.prototype
         * @inner
         */
        var TokenizerPrototype = Tokenizer.prototype;

        /**
         * Reads a string beginning at the current index.
         * @return {string}
         * @private
         */
        TokenizerPrototype._readString = function() {
            var re = this._stringOpen === '"'
                ? Lang.STRING_DQ
                : Lang.STRING_SQ;
            re.lastIndex = this.index - 1; // Include the open quote
            var match = re.exec(this.source);
            if (!match)
                throw Error("unterminated string");
            this.index = re.lastIndex;
            this.stack.push(this._stringOpen);
            this._stringOpen = null;
            return match[1];
        };

        /**
         * Gets the next token and advances by one.
         * @return {?string} Token or `null` on EOF
         * @expose
         */
        TokenizerPrototype.next = function() {
            if (this.stack.length > 0)
                return this.stack.shift();
            if (this.index >= this.source.length)
                return null;
            if (this._stringOpen !== null)
                return this._readString();

            var repeat,
                prev,
                next;
            do {
                repeat = false;

                // Strip white spaces
                while (Lang.WHITESPACE.test(next = this.source.charAt(this.index))) {
                    if (next === '\n')
                        ++this.line;
                    if (++this.index === this.source.length)
                        return null;
                }

                // Strip comments
                if (this.source.charAt(this.index) === '/') {
                    ++this.index;
                    if (this.source.charAt(this.index) === '/') { // Line
                        while (this.source.charAt(++this.index) !== '\n')
                            if (this.index == this.source.length)
                                return null;
                        ++this.index;
                        ++this.line;
                        repeat = true;
                    } else if ((next = this.source.charAt(this.index)) === '*') { /* Block */
                        do {
                            if (next === '\n')
                                ++this.line;
                            if (++this.index === this.source.length)
                                return null;
                            prev = next;
                            next = this.source.charAt(this.index);
                        } while (prev !== '*' || next !== '/');
                        ++this.index;
                        repeat = true;
                    } else
                        return '/';
                }
            } while (repeat);

            if (this.index === this.source.length)
                return null;

            // Read the next token
            var end = this.index;
            Lang.DELIM.lastIndex = 0;
            var delim = Lang.DELIM.test(this.source.charAt(end++));
            if (!delim)
                while(end < this.source.length && !Lang.DELIM.test(this.source.charAt(end)))
                    ++end;
            var token = this.source.substring(this.index, this.index = end);
            if (token === '"' || token === "'")
                this._stringOpen = token;
            return token;
        };

        /**
         * Peeks for the next token.
         * @return {?string} Token or `null` on EOF
         * @expose
         */
        TokenizerPrototype.peek = function() {
            if (this.stack.length === 0) {
                var token = this.next();
                if (token === null)
                    return null;
                this.stack.push(token);
            }
            return this.stack[0];
        };

        /**
         * Skips a specific token and throws if it differs.
         * @param {string} expected Expected token
         * @throws {Error} If the actual token differs
         */
        TokenizerPrototype.skip = function(expected) {
            var actual = this.next();
            if (actual !== expected)
                throw Error("illegal '"+actual+"', '"+expected+"' expected");
        };

        /**
         * Omits an optional token.
         * @param {string} expected Expected optional token
         * @returns {boolean} `true` if the token exists
         */
        TokenizerPrototype.omit = function(expected) {
            if (this.peek() === expected) {
                this.next();
                return true;
            }
            return false;
        };

        /**
         * Returns a string representation of this object.
         * @return {string} String representation as of "Tokenizer(index/length)"
         * @expose
         */
        TokenizerPrototype.toString = function() {
            return "Tokenizer ("+this.index+"/"+this.source.length+" at line "+this.line+")";
        };

        /**
         * @alias ProtoBuf.DotProto.Tokenizer
         * @expose
         */
        DotProto.Tokenizer = Tokenizer;

        /**
         * Constructs a new Parser.
         * @exports ProtoBuf.DotProto.Parser
         * @class prototype parser
         * @param {string} source Source
         * @constructor
         */
        var Parser = function(source) {

            /**
             * Tokenizer.
             * @type {!ProtoBuf.DotProto.Tokenizer}
             * @expose
             */
            this.tn = new Tokenizer(source);

            /**
             * Whether parsing proto3 or not.
             * @type {boolean}
             */
            this.proto3 = false;
        };

        /**
         * @alias ProtoBuf.DotProto.Parser.prototype
         * @inner
         */
        var ParserPrototype = Parser.prototype;

        /**
         * Parses the source.
         * @returns {!Object}
         * @throws {Error} If the source cannot be parsed
         * @expose
         */
        ParserPrototype.parse = function() {
            var topLevel = {
                "name": "[ROOT]", // temporary
                "package": null,
                "messages": [],
                "enums": [],
                "imports": [],
                "options": {},
                "services": []
                // "syntax": undefined
            };
            var token,
                head = true,
                weak;
            try {
                while (token = this.tn.next()) {
                    switch (token) {
                        case 'package':
                            if (!head || topLevel["package"] !== null)
                                throw Error("unexpected 'package'");
                            token = this.tn.next();
                            if (!Lang.TYPEREF.test(token))
                                throw Error("illegal package name: " + token);
                            this.tn.skip(";");
                            topLevel["package"] = token;
                            break;
                        case 'import':
                            if (!head)
                                throw Error("unexpected 'import'");
                            token = this.tn.peek();
                            if (token === "public" || (weak = token === "weak")) // token ignored
                                this.tn.next();
                            token = this._readString();
                            this.tn.skip(";");
                            if (!weak) // import ignored
                                topLevel["imports"].push(token);
                            break;
                        case 'syntax':
                            if (!head)
                                throw Error("unexpected 'syntax'");
                            this.tn.skip("=");
                            if ((topLevel["syntax"] = this._readString()) === "proto3")
                                this.proto3 = true;
                            this.tn.skip(";");
                            break;
                        case 'message':
                            this._parseMessage(topLevel, null);
                            head = false;
                            break;
                        case 'enum':
                            this._parseEnum(topLevel);
                            head = false;
                            break;
                        case 'option':
                            this._parseOption(topLevel);
                            break;
                        case 'service':
                            this._parseService(topLevel);
                            break;
                        case 'extend':
                            this._parseExtend(topLevel);
                            break;
                        default:
                            throw Error("unexpected '" + token + "'");
                    }
                }
            } catch (e) {
                e.message = "Parse error at line "+this.tn.line+": " + e.message;
                throw e;
            }
            delete topLevel["name"];
            return topLevel;
        };

        /**
         * Parses the specified source.
         * @returns {!Object}
         * @throws {Error} If the source cannot be parsed
         * @expose
         */
        Parser.parse = function(source) {
            return new Parser(source).parse();
        };

        // ----- Conversion ------

        /**
         * Converts a numerical string to an id.
         * @param {string} value
         * @param {boolean=} mayBeNegative
         * @returns {number}
         * @inner
         */
        function mkId(value, mayBeNegative) {
            var id = -1,
                sign = 1;
            if (value.charAt(0) == '-') {
                sign = -1;
                value = value.substring(1);
            }
            if (Lang.NUMBER_DEC.test(value))
                id = parseInt(value);
            else if (Lang.NUMBER_HEX.test(value))
                id = parseInt(value.substring(2), 16);
            else if (Lang.NUMBER_OCT.test(value))
                id = parseInt(value.substring(1), 8);
            else
                throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
            id = (sign*id)|0; // Force to 32bit
            if (!mayBeNegative && id < 0)
                throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
            return id;
        }

        /**
         * Converts a numerical string to a number.
         * @param {string} val
         * @returns {number}
         * @inner
         */
        function mkNumber(val) {
            var sign = 1;
            if (val.charAt(0) == '-') {
                sign = -1;
                val = val.substring(1);
            }
            if (Lang.NUMBER_DEC.test(val))
                return sign * parseInt(val, 10);
            else if (Lang.NUMBER_HEX.test(val))
                return sign * parseInt(val.substring(2), 16);
            else if (Lang.NUMBER_OCT.test(val))
                return sign * parseInt(val.substring(1), 8);
            else if (val === 'inf')
                return sign * Infinity;
            else if (val === 'nan')
                return NaN;
            else if (Lang.NUMBER_FLT.test(val))
                return sign * parseFloat(val);
            throw Error("illegal number value: " + (sign < 0 ? '-' : '') + val);
        }

        // ----- Reading ------

        /**
         * Reads a string.
         * @returns {string}
         * @private
         */
        ParserPrototype._readString = function() {
            var value = "",
                token,
                delim;
            do {
                delim = this.tn.next();
                if (delim !== "'" && delim !== '"')
                    throw Error("illegal string delimiter: "+delim);
                value += this.tn.next();
                this.tn.skip(delim);
                token = this.tn.peek();
            } while (token === '"' || token === '"'); // multi line?
            return value;
        };

        /**
         * Reads a value.
         * @param {boolean=} mayBeTypeRef
         * @returns {number|boolean|string}
         * @private
         */
        ParserPrototype._readValue = function(mayBeTypeRef) {
            var token = this.tn.peek(),
                value;
            if (token === '"' || token === "'")
                return this._readString();
            this.tn.next();
            if (Lang.NUMBER.test(token))
                return mkNumber(token);
            if (Lang.BOOL.test(token))
                return (token.toLowerCase() === 'true');
            if (mayBeTypeRef && Lang.TYPEREF.test(token))
                return token;
            throw Error("illegal value: "+token);

        };

        // ----- Parsing constructs -----

        /**
         * Parses a namespace option.
         * @param {!Object} parent Parent definition
         * @param {boolean=} isList
         * @private
         */
        ParserPrototype._parseOption = function(parent, isList) {
            var token = this.tn.next(),
                custom = false;
            if (token === '(') {
                custom = true;
                token = this.tn.next();
            }
            if (!Lang.TYPEREF.test(token))
                // we can allow options of the form google.protobuf.* since they will just get ignored anyways
                // if (!/google\.protobuf\./.test(token)) // FIXME: Why should that not be a valid typeref?
                    throw Error("illegal option name: "+token);
            var name = token;
            if (custom) { // (my_method_option).foo, (my_method_option), some_method_option, (foo.my_option).bar
                this.tn.skip(')');
                name = '('+name+')';
                token = this.tn.peek();
                if (Lang.FQTYPEREF.test(token)) {
                    name += token;
                    this.tn.next();
                }
            }
            this.tn.skip('=');
            this._parseOptionValue(parent, name);
            if (!isList)
                this.tn.skip(";");
        };

        /**
         * Sets an option on the specified options object.
         * @param {!Object.<string,*>} options
         * @param {string} name
         * @param {string|number|boolean} value
         * @inner
         */
        function setOption(options, name, value) {
            if (typeof options[name] === 'undefined')
                options[name] = value;
            else {
                if (!Array.isArray(options[name]))
                    options[name] = [ options[name] ];
                options[name].push(value);
            }
        }

        /**
         * Parses an option value.
         * @param {!Object} parent
         * @param {string} name
         * @private
         */
        ParserPrototype._parseOptionValue = function(parent, name) {
            var token = this.tn.peek();
            if (token !== '{') { // Plain value
                setOption(parent["options"], name, this._readValue(true));
            } else { // Aggregate options
                this.tn.skip("{");
                while ((token = this.tn.next()) !== '}') {
                    if (!Lang.NAME.test(token))
                        throw Error("illegal option name: " + name + "." + token);
                    if (this.tn.omit(":"))
                        setOption(parent["options"], name + "." + token, this._readValue(true));
                    else
                        this._parseOptionValue(parent, name + "." + token);
                }
            }
        };

        /**
         * Parses a service definition.
         * @param {!Object} parent Parent definition
         * @private
         */
        ParserPrototype._parseService = function(parent) {
            var token = this.tn.next();
            if (!Lang.NAME.test(token))
                throw Error("illegal service name at line "+this.tn.line+": "+token);
            var name = token;
            var svc = {
                "name": name,
                "rpc": {},
                "options": {}
            };
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (token === "option")
                    this._parseOption(svc);
                else if (token === 'rpc')
                    this._parseServiceRPC(svc);
                else
                    throw Error("illegal service token: "+token);
            }
            this.tn.omit(";");
            parent["services"].push(svc);
        };

        /**
         * Parses a RPC service definition of the form ['rpc', name, (request), 'returns', (response)].
         * @param {!Object} svc Service definition
         * @private
         */
        ParserPrototype._parseServiceRPC = function(svc) {
            var type = "rpc",
                token = this.tn.next();
            if (!Lang.NAME.test(token))
                throw Error("illegal rpc service method name: "+token);
            var name = token;
            var method = {
                "request": null,
                "response": null,
                "request_stream": false,
                "response_stream": false,
                "options": {}
            };
            this.tn.skip("(");
            token = this.tn.next();
            if (token.toLowerCase() === "stream") {
              method["request_stream"] = true;
              token = this.tn.next();
            }
            if (!Lang.TYPEREF.test(token))
                throw Error("illegal rpc service request type: "+token);
            method["request"] = token;
            this.tn.skip(")");
            token = this.tn.next();
            if (token.toLowerCase() !== "returns")
                throw Error("illegal rpc service request type delimiter: "+token);
            this.tn.skip("(");
            token = this.tn.next();
            if (token.toLowerCase() === "stream") {
              method["response_stream"] = true;
              token = this.tn.next();
            }
            method["response"] = token;
            this.tn.skip(")");
            token = this.tn.peek();
            if (token === '{') {
                this.tn.next();
                while ((token = this.tn.next()) !== '}') {
                    if (token === 'option')
                        this._parseOption(method);
                    else
                        throw Error("illegal rpc service token: " + token);
                }
                this.tn.omit(";");
            } else
                this.tn.skip(";");
            if (typeof svc[type] === 'undefined')
                svc[type] = {};
            svc[type][name] = method;
        };

        /**
         * Parses a message definition.
         * @param {!Object} parent Parent definition
         * @param {!Object=} fld Field definition if this is a group
         * @returns {!Object}
         * @private
         */
        ParserPrototype._parseMessage = function(parent, fld) {
            var isGroup = !!fld,
                token = this.tn.next();
            var msg = {
                "name": "",
                "fields": [],
                "enums": [],
                "messages": [],
                "options": {},
                "services": [],
                "oneofs": {}
                // "extensions": undefined
            };
            if (!Lang.NAME.test(token))
                throw Error("illegal "+(isGroup ? "group" : "message")+" name: "+token);
            msg["name"] = token;
            if (isGroup) {
                this.tn.skip("=");
                fld["id"] = mkId(this.tn.next());
                msg["isGroup"] = true;
            }
            token = this.tn.peek();
            if (token === '[' && fld)
                this._parseFieldOptions(fld);
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (Lang.RULE.test(token))
                    this._parseMessageField(msg, token);
                else if (token === "oneof")
                    this._parseMessageOneOf(msg);
                else if (token === "enum")
                    this._parseEnum(msg);
                else if (token === "message")
                    this._parseMessage(msg);
                else if (token === "option")
                    this._parseOption(msg);
                else if (token === "service")
                    this._parseService(msg);
                else if (token === "extensions")
                    msg["extensions"] = this._parseExtensionRanges();
                else if (token === "reserved")
                    this._parseIgnored(); // TODO
                else if (token === "extend")
                    this._parseExtend(msg);
                else if (Lang.TYPEREF.test(token)) {
                    if (!this.proto3)
                        throw Error("illegal field rule: "+token);
                    this._parseMessageField(msg, "optional", token);
                } else
                    throw Error("illegal message token: "+token);
            }
            this.tn.omit(";");
            parent["messages"].push(msg);
            return msg;
        };

        /**
         * Parses an ignored statement.
         * @private
         */
        ParserPrototype._parseIgnored = function() {
            while (this.tn.peek() !== ';')
                this.tn.next();
            this.tn.skip(";");
        };

        /**
         * Parses a message field.
         * @param {!Object} msg Message definition
         * @param {string} rule Field rule
         * @param {string=} type Field type if already known (never known for maps)
         * @returns {!Object} Field descriptor
         * @private
         */
        ParserPrototype._parseMessageField = function(msg, rule, type) {
            if (!Lang.RULE.test(rule))
                throw Error("illegal message field rule: "+rule);
            var fld = {
                "rule": rule,
                "type": "",
                "name": "",
                "options": {},
                "id": 0
            };
            var token;
            if (rule === "map") {

                if (type)
                    throw Error("illegal type: " + type);
                this.tn.skip('<');
                token = this.tn.next();
                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token))
                    throw Error("illegal message field type: " + token);
                fld["keytype"] = token;
                this.tn.skip(',');
                token = this.tn.next();
                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token))
                    throw Error("illegal message field: " + token);
                fld["type"] = token;
                this.tn.skip('>');
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("illegal message field name: " + token);
                fld["name"] = token;
                this.tn.skip("=");
                fld["id"] = mkId(this.tn.next());
                token = this.tn.peek();
                if (token === '[')
                    this._parseFieldOptions(fld);
                this.tn.skip(";");

            } else {

                type = typeof type !== 'undefined' ? type : this.tn.next();

                if (type === "group") {

                    // "A [legacy] group simply combines a nested message type and a field into a single declaration. In your
                    // code, you can treat this message just as if it had a Result type field called result (the latter name is
                    // converted to lower-case so that it does not conflict with the former)."
                    var grp = this._parseMessage(msg, fld);
                    if (!/^[A-Z]/.test(grp["name"]))
                        throw Error('illegal group name: '+grp["name"]);
                    fld["type"] = grp["name"];
                    fld["name"] = grp["name"].toLowerCase();
                    this.tn.omit(";");

                } else {

                    if (!Lang.TYPE.test(type) && !Lang.TYPEREF.test(type))
                        throw Error("illegal message field type: " + type);
                    fld["type"] = type;
                    token = this.tn.next();
                    if (!Lang.NAME.test(token))
                        throw Error("illegal message field name: " + token);
                    fld["name"] = token;
                    this.tn.skip("=");
                    fld["id"] = mkId(this.tn.next());
                    token = this.tn.peek();
                    if (token === "[")
                        this._parseFieldOptions(fld);
                    this.tn.skip(";");

                }
            }
            msg["fields"].push(fld);
            return fld;
        };

        /**
         * Parses a message oneof.
         * @param {!Object} msg Message definition
         * @private
         */
        ParserPrototype._parseMessageOneOf = function(msg) {
            var token = this.tn.next();
            if (!Lang.NAME.test(token))
                throw Error("illegal oneof name: "+token);
            var name = token,
                fld;
            var fields = [];
            this.tn.skip("{");
            while ((token = this.tn.next()) !== "}") {
                fld = this._parseMessageField(msg, "optional", token);
                fld["oneof"] = name;
                fields.push(fld["id"]);
            }
            this.tn.omit(";");
            msg["oneofs"][name] = fields;
        };

        /**
         * Parses a set of field option definitions.
         * @param {!Object} fld Field definition
         * @private
         */
        ParserPrototype._parseFieldOptions = function(fld) {
            this.tn.skip("[");
            var token,
                first = true;
            while ((token = this.tn.peek()) !== ']') {
                if (!first)
                    this.tn.skip(",");
                this._parseOption(fld, true);
                first = false;
            }
            this.tn.next();
        };

        /**
         * Parses an enum.
         * @param {!Object} msg Message definition
         * @private
         */
        ParserPrototype._parseEnum = function(msg) {
            var enm = {
                "name": "",
                "values": [],
                "options": {}
            };
            var token = this.tn.next();
            if (!Lang.NAME.test(token))
                throw Error("illegal name: "+token);
            enm["name"] = token;
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (token === "option")
                    this._parseOption(enm);
                else {
                    if (!Lang.NAME.test(token))
                        throw Error("illegal name: "+token);
                    this.tn.skip("=");
                    var val = {
                        "name": token,
                        "id": mkId(this.tn.next(), true)
                    };
                    token = this.tn.peek();
                    if (token === "[")
                        this._parseFieldOptions({ "options": {} });
                    this.tn.skip(";");
                    enm["values"].push(val);
                }
            }
            this.tn.omit(";");
            msg["enums"].push(enm);
        };

        /**
         * Parses extension / reserved ranges.
         * @returns {!Array.<!Array.<number>>}
         * @private
         */
        ParserPrototype._parseExtensionRanges = function() {
            var ranges = [];
            var token,
                range,
                value;
            do {
                range = [];
                while (true) {
                    token = this.tn.next();
                    switch (token) {
                        case "min":
                            value = ProtoBuf.ID_MIN;
                            break;
                        case "max":
                            value = ProtoBuf.ID_MAX;
                            break;
                        default:
                            value = mkNumber(token);
                            break;
                    }
                    range.push(value);
                    if (range.length === 2)
                        break;
                    if (this.tn.peek() !== "to") {
                        range.push(value);
                        break;
                    }
                    this.tn.next();
                }
                ranges.push(range);
            } while (this.tn.omit(","));
            this.tn.skip(";");
            return ranges;
        };

        /**
         * Parses an extend block.
         * @param {!Object} parent Parent object
         * @private
         */
        ParserPrototype._parseExtend = function(parent) {
            var token = this.tn.next();
            if (!Lang.TYPEREF.test(token))
                throw Error("illegal extend reference: "+token);
            var ext = {
                "ref": token,
                "fields": []
            };
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (Lang.RULE.test(token))
                    this._parseMessageField(ext, token);
                else if (Lang.TYPEREF.test(token)) {
                    if (!this.proto3)
                        throw Error("illegal field rule: "+token);
                    this._parseMessageField(ext, "optional", token);
                } else
                    throw Error("illegal extend token: "+token);
            }
            this.tn.omit(";");
            parent["messages"].push(ext);
            return ext;
        };

        // ----- General -----

        /**
         * Returns a string representation of this parser.
         * @returns {string}
         */
        ParserPrototype.toString = function() {
            return "Parser at line "+this.tn.line;
        };

        /**
         * @alias ProtoBuf.DotProto.Parser
         * @expose
         */
        DotProto.Parser = Parser;

        return DotProto;

    })(ProtoBuf, ProtoBuf.Lang);

    /**
     * @alias ProtoBuf.Reflect
     * @expose
     */
    ProtoBuf.Reflect = (function(ProtoBuf) {
        "use strict";

        /**
         * Reflection types.
         * @exports ProtoBuf.Reflect
         * @namespace
         */
        var Reflect = {};

        /**
         * Constructs a Reflect base class.
         * @exports ProtoBuf.Reflect.T
         * @constructor
         * @abstract
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {?ProtoBuf.Reflect.T} parent Parent object
         * @param {string} name Object name
         */
        var T = function(builder, parent, name) {

            /**
             * Builder reference.
             * @type {!ProtoBuf.Builder}
             * @expose
             */
            this.builder = builder;

            /**
             * Parent object.
             * @type {?ProtoBuf.Reflect.T}
             * @expose
             */
            this.parent = parent;

            /**
             * Object name in namespace.
             * @type {string}
             * @expose
             */
            this.name = name;

            /**
             * Fully qualified class name
             * @type {string}
             * @expose
             */
            this.className;
        };

        /**
         * @alias ProtoBuf.Reflect.T.prototype
         * @inner
         */
        var TPrototype = T.prototype;

        /**
         * Returns the fully qualified name of this object.
         * @returns {string} Fully qualified name as of ".PATH.TO.THIS"
         * @expose
         */
        TPrototype.fqn = function() {
            var name = this.name,
                ptr = this;
            do {
                ptr = ptr.parent;
                if (ptr == null)
                    break;
                name = ptr.name+"."+name;
            } while (true);
            return name;
        };

        /**
         * Returns a string representation of this Reflect object (its fully qualified name).
         * @param {boolean=} includeClass Set to true to include the class name. Defaults to false.
         * @return String representation
         * @expose
         */
        TPrototype.toString = function(includeClass) {
            return (includeClass ? this.className + " " : "") + this.fqn();
        };

        /**
         * Builds this type.
         * @throws {Error} If this type cannot be built directly
         * @expose
         */
        TPrototype.build = function() {
            throw Error(this.toString(true)+" cannot be built directly");
        };

        /**
         * @alias ProtoBuf.Reflect.T
         * @expose
         */
        Reflect.T = T;

        /**
         * Constructs a new Namespace.
         * @exports ProtoBuf.Reflect.Namespace
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {?ProtoBuf.Reflect.Namespace} parent Namespace parent
         * @param {string} name Namespace name
         * @param {Object.<string,*>=} options Namespace options
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Namespace = function(builder, parent, name, options, syntax) {
            T.call(this, builder, parent, name);

            /**
             * @override
             */
            this.className = "Namespace";

            /**
             * Children inside the namespace.
             * @type {!Array.<ProtoBuf.Reflect.T>}
             */
            this.children = [];

            /**
             * Options.
             * @type {!Object.<string, *>}
             */
            this.options = options || {};

            /**
             * Syntax level (e.g., proto2 or proto3).
             * @type {!string}
             */
            this.syntax = syntax || "proto2";
        };

        /**
         * @alias ProtoBuf.Reflect.Namespace.prototype
         * @inner
         */
        var NamespacePrototype = Namespace.prototype = Object.create(T.prototype);

        /**
         * Returns an array of the namespace's children.
         * @param {ProtoBuf.Reflect.T=} type Filter type (returns instances of this type only). Defaults to null (all children).
         * @return {Array.<ProtoBuf.Reflect.T>}
         * @expose
         */
        NamespacePrototype.getChildren = function(type) {
            type = type || null;
            if (type == null)
                return this.children.slice();
            var children = [];
            for (var i=0, k=this.children.length; i<k; ++i)
                if (this.children[i] instanceof type)
                    children.push(this.children[i]);
            return children;
        };

        /**
         * Adds a child to the namespace.
         * @param {ProtoBuf.Reflect.T} child Child
         * @throws {Error} If the child cannot be added (duplicate)
         * @expose
         */
        NamespacePrototype.addChild = function(child) {
            var other;
            if (other = this.getChild(child.name)) {
                // Try to revert camelcase transformation on collision
                if (other instanceof Message.Field && other.name !== other.originalName && this.getChild(other.originalName) === null)
                    other.name = other.originalName; // Revert previous first (effectively keeps both originals)
                else if (child instanceof Message.Field && child.name !== child.originalName && this.getChild(child.originalName) === null)
                    child.name = child.originalName;
                else
                    throw Error("Duplicate name in namespace "+this.toString(true)+": "+child.name);
            }
            this.children.push(child);
        };

        /**
         * Gets a child by its name or id.
         * @param {string|number} nameOrId Child name or id
         * @return {?ProtoBuf.Reflect.T} The child or null if not found
         * @expose
         */
        NamespacePrototype.getChild = function(nameOrId) {
            var key = typeof nameOrId === 'number' ? 'id' : 'name';
            for (var i=0, k=this.children.length; i<k; ++i)
                if (this.children[i][key] === nameOrId)
                    return this.children[i];
            return null;
        };

        /**
         * Resolves a reflect object inside of this namespace.
         * @param {string|!Array.<string>} qn Qualified name to resolve
         * @param {boolean=} excludeNonNamespace Excludes non-namespace types, defaults to `false`
         * @return {?ProtoBuf.Reflect.Namespace} The resolved type or null if not found
         * @expose
         */
        NamespacePrototype.resolve = function(qn, excludeNonNamespace) {
            var part = typeof qn === 'string' ? qn.split(".") : qn,
                ptr = this,
                i = 0;
            if (part[i] === "") { // Fully qualified name, e.g. ".My.Message'
                while (ptr.parent !== null)
                    ptr = ptr.parent;
                i++;
            }
            var child;
            do {
                do {
                    if (!(ptr instanceof Reflect.Namespace)) {
                        ptr = null;
                        break;
                    }
                    child = ptr.getChild(part[i]);
                    if (!child || !(child instanceof Reflect.T) || (excludeNonNamespace && !(child instanceof Reflect.Namespace))) {
                        ptr = null;
                        break;
                    }
                    ptr = child; i++;
                } while (i < part.length);
                if (ptr != null)
                    break; // Found
                // Else search the parent
                if (this.parent !== null)
                    return this.parent.resolve(qn, excludeNonNamespace);
            } while (ptr != null);
            return ptr;
        };

        /**
         * Determines the shortest qualified name of the specified type, if any, relative to this namespace.
         * @param {!ProtoBuf.Reflect.T} t Reflection type
         * @returns {string} The shortest qualified name or, if there is none, the fqn
         * @expose
         */
        NamespacePrototype.qn = function(t) {
            var part = [], ptr = t;
            do {
                part.unshift(ptr.name);
                ptr = ptr.parent;
            } while (ptr !== null);
            for (var len=1; len <= part.length; len++) {
                var qn = part.slice(part.length-len);
                if (t === this.resolve(qn, t instanceof Reflect.Namespace))
                    return qn.join(".");
            }
            return t.fqn();
        };

        /**
         * Builds the namespace and returns the runtime counterpart.
         * @return {Object.<string,Function|Object>} Runtime namespace
         * @expose
         */
        NamespacePrototype.build = function() {
            /** @dict */
            var ns = {};
            var children = this.children;
            for (var i=0, k=children.length, child; i<k; ++i) {
                child = children[i];
                if (child instanceof Namespace)
                    ns[child.name] = child.build();
            }
            if (Object.defineProperty)
                Object.defineProperty(ns, "$options", { "value": this.buildOpt() });
            return ns;
        };

        /**
         * Builds the namespace's '$options' property.
         * @return {Object.<string,*>}
         */
        NamespacePrototype.buildOpt = function() {
            var opt = {},
                keys = Object.keys(this.options);
            for (var i=0, k=keys.length; i<k; ++i) {
                var key = keys[i],
                    val = this.options[keys[i]];
                // TODO: Options are not resolved, yet.
                // if (val instanceof Namespace) {
                //     opt[key] = val.build();
                // } else {
                opt[key] = val;
                // }
            }
            return opt;
        };

        /**
         * Gets the value assigned to the option with the specified name.
         * @param {string=} name Returns the option value if specified, otherwise all options are returned.
         * @return {*|Object.<string,*>}null} Option value or NULL if there is no such option
         */
        NamespacePrototype.getOption = function(name) {
            if (typeof name === 'undefined')
                return this.options;
            return typeof this.options[name] !== 'undefined' ? this.options[name] : null;
        };

        /**
         * @alias ProtoBuf.Reflect.Namespace
         * @expose
         */
        Reflect.Namespace = Namespace;

        /**
         * Constructs a new Element implementation that checks and converts values for a
         * particular field type, as appropriate.
         *
         * An Element represents a single value: either the value of a singular field,
         * or a value contained in one entry of a repeated field or map field. This
         * class does not implement these higher-level concepts; it only encapsulates
         * the low-level typechecking and conversion.
         *
         * @exports ProtoBuf.Reflect.Element
         * @param {{name: string, wireType: number}} type Resolved data type
         * @param {ProtoBuf.Reflect.T|null} resolvedType Resolved type, if relevant
         * (e.g. submessage field).
         * @param {boolean} isMapKey Is this element a Map key? The value will be
         * converted to string form if so.
         * @param {string} syntax Syntax level of defining message type, e.g.,
         * proto2 or proto3.
         * @constructor
         */
        var Element = function(type, resolvedType, isMapKey, syntax) {

            /**
             * Element type, as a string (e.g., int32).
             * @type {{name: string, wireType: number}}
             */
            this.type = type;

            /**
             * Element type reference to submessage or enum definition, if needed.
             * @type {ProtoBuf.Reflect.T|null}
             */
            this.resolvedType = resolvedType;

            /**
             * Element is a map key.
             * @type {boolean}
             */
            this.isMapKey = isMapKey;

            /**
             * Syntax level of defining message type, e.g., proto2 or proto3.
             * @type {string}
             */
            this.syntax = syntax;

            if (isMapKey && ProtoBuf.MAP_KEY_TYPES.indexOf(type) < 0)
                throw Error("Invalid map key type: " + type.name);
        };

        var ElementPrototype = Element.prototype;

        /**
         * Obtains a (new) default value for the specified type.
         * @param type {string|{name: string, wireType: number}} Field type
         * @returns {*} Default value
         * @inner
         */
        function mkDefault(type) {
            if (typeof type === 'string')
                type = ProtoBuf.TYPES[type];
            if (typeof type.defaultValue === 'undefined')
                throw Error("default value for type "+type.name+" is not supported");
            if (type == ProtoBuf.TYPES["bytes"])
                return new ByteBuffer(0);
            return type.defaultValue;
        }

        /**
         * Returns the default value for this field in proto3.
         * @function
         * @param type {string|{name: string, wireType: number}} the field type
         * @returns {*} Default value
         */
        Element.defaultFieldValue = mkDefault;

        /**
         * Makes a Long from a value.
         * @param {{low: number, high: number, unsigned: boolean}|string|number} value Value
         * @param {boolean=} unsigned Whether unsigned or not, defaults to reuse it from Long-like objects or to signed for
         *  strings and numbers
         * @returns {!Long}
         * @throws {Error} If the value cannot be converted to a Long
         * @inner
         */
        function mkLong(value, unsigned) {
            if (value && typeof value.low === 'number' && typeof value.high === 'number' && typeof value.unsigned === 'boolean'
                && value.low === value.low && value.high === value.high)
                return new ProtoBuf.Long(value.low, value.high, typeof unsigned === 'undefined' ? value.unsigned : unsigned);
            if (typeof value === 'string')
                return ProtoBuf.Long.fromString(value, unsigned || false, 10);
            if (typeof value === 'number')
                return ProtoBuf.Long.fromNumber(value, unsigned || false);
            throw Error("not convertible to Long");
        }

        /**
         * Checks if the given value can be set for an element of this type (singular
         * field or one element of a repeated field or map).
         * @param {*} value Value to check
         * @return {*} Verified, maybe adjusted, value
         * @throws {Error} If the value cannot be verified for this element slot
         * @expose
         */
        ElementPrototype.verifyValue = function(value) {
            var self = this;
            function fail(val, msg) {
                throw Error("Illegal value for "+self.toString(true)+" of type "+self.type.name+": "+val+" ("+msg+")");
            }
            switch (this.type) {
                // Signed 32bit
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                    // Account for !NaN: value === value
                    if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                        fail(typeof value, "not an integer");
                    return value > 4294967295 ? value | 0 : value;

                // Unsigned 32bit
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                        fail(typeof value, "not an integer");
                    return value < 0 ? value >>> 0 : value;

                // Signed 64bit
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]: {
                    if (ProtoBuf.Long)
                        try {
                            return mkLong(value, false);
                        } catch (e) {
                            fail(typeof value, e.message);
                        }
                    else
                        fail(typeof value, "requires Long.js");
                }

                // Unsigned 64bit
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]: {
                    if (ProtoBuf.Long)
                        try {
                            return mkLong(value, true);
                        } catch (e) {
                            fail(typeof value, e.message);
                        }
                    else
                        fail(typeof value, "requires Long.js");
                }

                // Bool
                case ProtoBuf.TYPES["bool"]:
                    if (typeof value !== 'boolean')
                        fail(typeof value, "not a boolean");
                    return value;

                // Float
                case ProtoBuf.TYPES["float"]:
                case ProtoBuf.TYPES["double"]:
                    if (typeof value !== 'number')
                        fail(typeof value, "not a number");
                    return value;

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    if (typeof value !== 'string' && !(value && value instanceof String))
                        fail(typeof value, "not a string");
                    return ""+value; // Convert String object to string

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]:
                    if (ByteBuffer.isByteBuffer(value))
                        return value;
                    return ByteBuffer.wrap(value, "base64");

                // Constant enum value
                case ProtoBuf.TYPES["enum"]: {
                    var values = this.resolvedType.getChildren(ProtoBuf.Reflect.Enum.Value);
                    for (i=0; i<values.length; i++)
                        if (values[i].name == value)
                            return values[i].id;
                        else if (values[i].id == value)
                            return values[i].id;

                    if (this.syntax === 'proto3') {
                        // proto3: just make sure it's an integer.
                        if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                            fail(typeof value, "not an integer");
                        if (value > 4294967295 || value < 0)
                            fail(typeof value, "not in range for uint32")
                        return value;
                    } else {
                        // proto2 requires enum values to be valid.
                        fail(value, "not a valid enum value");
                    }
                }
                // Embedded message
                case ProtoBuf.TYPES["group"]:
                case ProtoBuf.TYPES["message"]: {
                    if (!value || typeof value !== 'object')
                        fail(typeof value, "object expected");
                    if (value instanceof this.resolvedType.clazz)
                        return value;
                    if (value instanceof ProtoBuf.Builder.Message) {
                        // Mismatched type: Convert to object (see: https://github.com/dcodeIO/ProtoBuf.js/issues/180)
                        var obj = {};
                        for (var i in value)
                            if (value.hasOwnProperty(i))
                                obj[i] = value[i];
                        value = obj;
                    }
                    // Else let's try to construct one from a key-value object
                    return new (this.resolvedType.clazz)(value); // May throw for a hundred of reasons
                }
            }

            // We should never end here
            throw Error("[INTERNAL] Illegal value for "+this.toString(true)+": "+value+" (undefined type "+this.type+")");
        };

        /**
         * Calculates the byte length of an element on the wire.
         * @param {number} id Field number
         * @param {*} value Field value
         * @returns {number} Byte length
         * @throws {Error} If the value cannot be calculated
         * @expose
         */
        ElementPrototype.calculateLength = function(id, value) {
            if (value === null) return 0; // Nothing to encode
            // Tag has already been written
            var n;
            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                    return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["uint32"]:
                    return ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["sint32"]:
                    return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));
                case ProtoBuf.TYPES["fixed32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["float"]:
                    return 4;
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["uint64"]:
                    return ByteBuffer.calculateVarint64(value);
                case ProtoBuf.TYPES["sint64"]:
                    return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));
                case ProtoBuf.TYPES["fixed64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                    return 8;
                case ProtoBuf.TYPES["bool"]:
                    return 1;
                case ProtoBuf.TYPES["enum"]:
                    return ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["double"]:
                    return 8;
                case ProtoBuf.TYPES["string"]:
                    n = ByteBuffer.calculateUTF8Bytes(value);
                    return ByteBuffer.calculateVarint32(n) + n;
                case ProtoBuf.TYPES["bytes"]:
                    if (value.remaining() < 0)
                        throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
                    return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();
                case ProtoBuf.TYPES["message"]:
                    n = this.resolvedType.calculate(value);
                    return ByteBuffer.calculateVarint32(n) + n;
                case ProtoBuf.TYPES["group"]:
                    n = this.resolvedType.calculate(value);
                    return n + ByteBuffer.calculateVarint32((id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
            }
            // We should never end here
            throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
        };

        /**
         * Encodes a value to the specified buffer. Does not encode the key.
         * @param {number} id Field number
         * @param {*} value Field value
         * @param {ByteBuffer} buffer ByteBuffer to encode to
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If the value cannot be encoded
         * @expose
         */
        ElementPrototype.encodeValue = function(id, value, buffer) {
            if (value === null) return buffer; // Nothing to encode
            // Tag has already been written

            switch (this.type) {
                // 32bit signed varint
                case ProtoBuf.TYPES["int32"]:
                    // "If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes
                    // long – it is, effectively, treated like a very large unsigned integer." (see #122)
                    if (value < 0)
                        buffer.writeVarint64(value);
                    else
                        buffer.writeVarint32(value);
                    break;

                // 32bit unsigned varint
                case ProtoBuf.TYPES["uint32"]:
                    buffer.writeVarint32(value);
                    break;

                // 32bit varint zig-zag
                case ProtoBuf.TYPES["sint32"]:
                    buffer.writeVarint32ZigZag(value);
                    break;

                // Fixed unsigned 32bit
                case ProtoBuf.TYPES["fixed32"]:
                    buffer.writeUint32(value);
                    break;

                // Fixed signed 32bit
                case ProtoBuf.TYPES["sfixed32"]:
                    buffer.writeInt32(value);
                    break;

                // 64bit varint as-is
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["uint64"]:
                    buffer.writeVarint64(value); // throws
                    break;

                // 64bit varint zig-zag
                case ProtoBuf.TYPES["sint64"]:
                    buffer.writeVarint64ZigZag(value); // throws
                    break;

                // Fixed unsigned 64bit
                case ProtoBuf.TYPES["fixed64"]:
                    buffer.writeUint64(value); // throws
                    break;

                // Fixed signed 64bit
                case ProtoBuf.TYPES["sfixed64"]:
                    buffer.writeInt64(value); // throws
                    break;

                // Bool
                case ProtoBuf.TYPES["bool"]:
                    if (typeof value === 'string')
                        buffer.writeVarint32(value.toLowerCase() === 'false' ? 0 : !!value);
                    else
                        buffer.writeVarint32(value ? 1 : 0);
                    break;

                // Constant enum value
                case ProtoBuf.TYPES["enum"]:
                    buffer.writeVarint32(value);
                    break;

                // 32bit float
                case ProtoBuf.TYPES["float"]:
                    buffer.writeFloat32(value);
                    break;

                // 64bit float
                case ProtoBuf.TYPES["double"]:
                    buffer.writeFloat64(value);
                    break;

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    buffer.writeVString(value);
                    break;

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]:
                    if (value.remaining() < 0)
                        throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
                    var prevOffset = value.offset;
                    buffer.writeVarint32(value.remaining());
                    buffer.append(value);
                    value.offset = prevOffset;
                    break;

                // Embedded message
                case ProtoBuf.TYPES["message"]:
                    var bb = new ByteBuffer().LE();
                    this.resolvedType.encode(value, bb);
                    buffer.writeVarint32(bb.offset);
                    buffer.append(bb.flip());
                    break;

                // Legacy group
                case ProtoBuf.TYPES["group"]:
                    this.resolvedType.encode(value, buffer);
                    buffer.writeVarint32((id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
                    break;

                default:
                    // We should never end here
                    throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
            }
            return buffer;
        };

        /**
         * Decode one element value from the specified buffer.
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {number} wireType The field wire type
         * @param {number} id The field number
         * @return {*} Decoded value
         * @throws {Error} If the field cannot be decoded
         * @expose
         */
        ElementPrototype.decode = function(buffer, wireType, id) {
            if (wireType != this.type.wireType)
                throw Error("Unexpected wire type for element");

            var value, nBytes;
            switch (this.type) {
                // 32bit signed varint
                case ProtoBuf.TYPES["int32"]:
                    return buffer.readVarint32() | 0;

                // 32bit unsigned varint
                case ProtoBuf.TYPES["uint32"]:
                    return buffer.readVarint32() >>> 0;

                // 32bit signed varint zig-zag
                case ProtoBuf.TYPES["sint32"]:
                    return buffer.readVarint32ZigZag() | 0;

                // Fixed 32bit unsigned
                case ProtoBuf.TYPES["fixed32"]:
                    return buffer.readUint32() >>> 0;

                case ProtoBuf.TYPES["sfixed32"]:
                    return buffer.readInt32() | 0;

                // 64bit signed varint
                case ProtoBuf.TYPES["int64"]:
                    return buffer.readVarint64();

                // 64bit unsigned varint
                case ProtoBuf.TYPES["uint64"]:
                    return buffer.readVarint64().toUnsigned();

                // 64bit signed varint zig-zag
                case ProtoBuf.TYPES["sint64"]:
                    return buffer.readVarint64ZigZag();

                // Fixed 64bit unsigned
                case ProtoBuf.TYPES["fixed64"]:
                    return buffer.readUint64();

                // Fixed 64bit signed
                case ProtoBuf.TYPES["sfixed64"]:
                    return buffer.readInt64();

                // Bool varint
                case ProtoBuf.TYPES["bool"]:
                    return !!buffer.readVarint32();

                // Constant enum value (varint)
                case ProtoBuf.TYPES["enum"]:
                    // The following Builder.Message#set will already throw
                    return buffer.readVarint32();

                // 32bit float
                case ProtoBuf.TYPES["float"]:
                    return buffer.readFloat();

                // 64bit float
                case ProtoBuf.TYPES["double"]:
                    return buffer.readDouble();

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    return buffer.readVString();

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]: {
                    nBytes = buffer.readVarint32();
                    if (buffer.remaining() < nBytes)
                        throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());
                    value = buffer.clone(); // Offset already set
                    value.limit = value.offset+nBytes;
                    buffer.offset += nBytes;
                    return value;
                }

                // Length-delimited embedded message
                case ProtoBuf.TYPES["message"]: {
                    nBytes = buffer.readVarint32();
                    return this.resolvedType.decode(buffer, nBytes);
                }

                // Legacy group
                case ProtoBuf.TYPES["group"]:
                    return this.resolvedType.decode(buffer, -1, id);
            }

            // We should never end here
            throw Error("[INTERNAL] Illegal decode type");
        };

        /**
         * Converts a value from a string to the canonical element type.
         *
         * Legal only when isMapKey is true.
         *
         * @param {string} str The string value
         * @returns {*} The value
         */
        ElementPrototype.valueFromString = function(str) {
            if (!this.isMapKey) {
                throw Error("valueFromString() called on non-map-key element");
            }

            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    return this.verifyValue(parseInt(str));

                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]:
                      // Long-based fields support conversions from string already.
                      return this.verifyValue(str);

                case ProtoBuf.TYPES["bool"]:
                      return str === "true";

                case ProtoBuf.TYPES["string"]:
                      return this.verifyValue(str);

                case ProtoBuf.TYPES["bytes"]:
                      return ByteBuffer.fromBinary(str);
            }
        };

        /**
         * Converts a value from the canonical element type to a string.
         *
         * It should be the case that `valueFromString(valueToString(val))` returns
         * a value equivalent to `verifyValue(val)` for every legal value of `val`
         * according to this element type.
         *
         * This may be used when the element must be stored or used as a string,
         * e.g., as a map key on an Object.
         *
         * Legal only when isMapKey is true.
         *
         * @param {*} val The value
         * @returns {string} The string form of the value.
         */
        ElementPrototype.valueToString = function(value) {
            if (!this.isMapKey) {
                throw Error("valueToString() called on non-map-key element");
            }

            if (this.type === ProtoBuf.TYPES["bytes"]) {
                return value.toString("binary");
            } else {
                return value.toString();
            }
        };

        /**
         * @alias ProtoBuf.Reflect.Element
         * @expose
         */
        Reflect.Element = Element;

        /**
         * Constructs a new Message.
         * @exports ProtoBuf.Reflect.Message
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Namespace} parent Parent message or namespace
         * @param {string} name Message name
         * @param {Object.<string,*>=} options Message options
         * @param {boolean=} isGroup `true` if this is a legacy group
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Message = function(builder, parent, name, options, isGroup, syntax) {
            Namespace.call(this, builder, parent, name, options, syntax);

            /**
             * @override
             */
            this.className = "Message";

            /**
             * Extensions range.
             * @type {!Array.<number>|undefined}
             * @expose
             */
            this.extensions = undefined;

            /**
             * Runtime message class.
             * @type {?function(new:ProtoBuf.Builder.Message)}
             * @expose
             */
            this.clazz = null;

            /**
             * Whether this is a legacy group or not.
             * @type {boolean}
             * @expose
             */
            this.isGroup = !!isGroup;

            // The following cached collections are used to efficiently iterate over or look up fields when decoding.

            /**
             * Cached fields.
             * @type {?Array.<!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fields = null;

            /**
             * Cached fields by id.
             * @type {?Object.<number,!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fieldsById = null;

            /**
             * Cached fields by name.
             * @type {?Object.<string,!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fieldsByName = null;
        };

        /**
         * @alias ProtoBuf.Reflect.Message.prototype
         * @inner
         */
        var MessagePrototype = Message.prototype = Object.create(Namespace.prototype);

        /**
         * Builds the message and returns the runtime counterpart, which is a fully functional class.
         * @see ProtoBuf.Builder.Message
         * @param {boolean=} rebuild Whether to rebuild or not, defaults to false
         * @return {ProtoBuf.Reflect.Message} Message class
         * @throws {Error} If the message cannot be built
         * @expose
         */
        MessagePrototype.build = function(rebuild) {
            if (this.clazz && !rebuild)
                return this.clazz;

            // Create the runtime Message class in its own scope
            var clazz = (function(ProtoBuf, T) {

                var fields = T.getChildren(ProtoBuf.Reflect.Message.Field),
                    oneofs = T.getChildren(ProtoBuf.Reflect.Message.OneOf);

                /**
                 * Constructs a new runtime Message.
                 * @name ProtoBuf.Builder.Message
                 * @class Barebone of all runtime messages.
                 * @param {!Object.<string,*>|string} values Preset values
                 * @param {...string} var_args
                 * @constructor
                 * @throws {Error} If the message cannot be created
                 */
                var Message = function(values, var_args) {
                    ProtoBuf.Builder.Message.call(this);

                    // Create virtual oneof properties
                    for (var i=0, k=oneofs.length; i<k; ++i)
                        this[oneofs[i].name] = null;
                    // Create fields and set default values
                    for (i=0, k=fields.length; i<k; ++i) {
                        var field = fields[i];
                        this[field.name] =
                            field.repeated ? [] :
                            (field.map ? new ProtoBuf.Map(field) : null);
                        if ((field.required || T.syntax === 'proto3') &&
                            field.defaultValue !== null)
                            this[field.name] = field.defaultValue;
                    }

                    if (arguments.length > 0) {
                        var value;
                        // Set field values from a values object
                        if (arguments.length === 1 && values !== null && typeof values === 'object' &&
                            /* not _another_ Message */ (typeof values.encode !== 'function' || values instanceof Message) &&
                            /* not a repeated field */ !Array.isArray(values) &&
                            /* not a Map */ !(values instanceof ProtoBuf.Map) &&
                            /* not a ByteBuffer */ !ByteBuffer.isByteBuffer(values) &&
                            /* not an ArrayBuffer */ !(values instanceof ArrayBuffer) &&
                            /* not a Long */ !(ProtoBuf.Long && values instanceof ProtoBuf.Long)) {
                            this.$set(values);
                        } else // Set field values from arguments, in declaration order
                            for (i=0, k=arguments.length; i<k; ++i)
                                if (typeof (value = arguments[i]) !== 'undefined')
                                    this.$set(fields[i].name, value); // May throw
                    }
                };

                /**
                 * @alias ProtoBuf.Builder.Message.prototype
                 * @inner
                 */
                var MessagePrototype = Message.prototype = Object.create(ProtoBuf.Builder.Message.prototype);

                /**
                 * Adds a value to a repeated field.
                 * @name ProtoBuf.Builder.Message#add
                 * @function
                 * @param {string} key Field name
                 * @param {*} value Value to add
                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be added
                 * @expose
                 */
                MessagePrototype.add = function(key, value, noAssert) {
                    var field = T._fieldsByName[key];
                    if (!noAssert) {
                        if (!field)
                            throw Error(this+"#"+key+" is undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: "+field.toString(true)); // May throw if it's an enum or embedded message
                        if (!field.repeated)
                            throw Error(this+"#"+key+" is not a repeated field");
                        value = field.verifyValue(value, true);
                    }
                    if (this[key] === null)
                        this[key] = [];
                    this[key].push(value);
                    return this;
                };

                /**
                 * Adds a value to a repeated field. This is an alias for {@link ProtoBuf.Builder.Message#add}.
                 * @name ProtoBuf.Builder.Message#$add
                 * @function
                 * @param {string} key Field name
                 * @param {*} value Value to add
                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be added
                 * @expose
                 */
                MessagePrototype.$add = MessagePrototype.add;

                /**
                 * Sets a field's value.
                 * @name ProtoBuf.Builder.Message#set
                 * @function
                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
                 * @param {boolean=} noAssert Whether to not assert for an actual field / proper value type, defaults to `false`
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be set
                 * @expose
                 */
                MessagePrototype.set = function(keyOrObj, value, noAssert) {
                    if (keyOrObj && typeof keyOrObj === 'object') {
                        noAssert = value;
                        for (var ikey in keyOrObj)
                            if (keyOrObj.hasOwnProperty(ikey) && typeof (value = keyOrObj[ikey]) !== 'undefined')
                                this.$set(ikey, value, noAssert);
                        return this;
                    }
                    var field = T._fieldsByName[keyOrObj];
                    if (!noAssert) {
                        if (!field)
                            throw Error(this+"#"+keyOrObj+" is not a field: undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+keyOrObj+" is not a field: "+field.toString(true));
                        this[field.name] = (value = field.verifyValue(value)); // May throw
                    } else
                        this[keyOrObj] = value;
                    if (field && field.oneof) { // Field is part of an OneOf (not a virtual OneOf field)
                        var currentField = this[field.oneof.name]; // Virtual field references currently set field
                        if (value !== null) {
                            if (currentField !== null && currentField !== field.name)
                                this[currentField] = null; // Clear currently set field
                            this[field.oneof.name] = field.name; // Point virtual field at this field
                        } else if (/* value === null && */currentField === keyOrObj)
                            this[field.oneof.name] = null; // Clear virtual field (current field explicitly cleared)
                    }
                    return this;
                };

                /**
                 * Sets a field's value. This is an alias for [@link ProtoBuf.Builder.Message#set}.
                 * @name ProtoBuf.Builder.Message#$set
                 * @function
                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                 * @throws {Error} If the value cannot be set
                 * @expose
                 */
                MessagePrototype.$set = MessagePrototype.set;

                /**
                 * Gets a field's value.
                 * @name ProtoBuf.Builder.Message#get
                 * @function
                 * @param {string} key Key
                 * @param {boolean=} noAssert Whether to not assert for an actual field, defaults to `false`
                 * @return {*} Value
                 * @throws {Error} If there is no such field
                 * @expose
                 */
                MessagePrototype.get = function(key, noAssert) {
                    if (noAssert)
                        return this[key];
                    var field = T._fieldsByName[key];
                    if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field))
                        throw Error(this+"#"+key+" is not a field: undefined");
                    if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                        throw Error(this+"#"+key+" is not a field: "+field.toString(true));
                    return this[field.name];
                };

                /**
                 * Gets a field's value. This is an alias for {@link ProtoBuf.Builder.Message#$get}.
                 * @name ProtoBuf.Builder.Message#$get
                 * @function
                 * @param {string} key Key
                 * @return {*} Value
                 * @throws {Error} If there is no such field
                 * @expose
                 */
                MessagePrototype.$get = MessagePrototype.get;

                // Getters and setters

                for (var i=0; i<fields.length; i++) {
                    var field = fields[i];
                    // no setters for extension fields as these are named by their fqn
                    if (field instanceof ProtoBuf.Reflect.Message.ExtensionField)
                        continue;

                    if (T.builder.options['populateAccessors'])
                        (function(field) {
                            // set/get[SomeValue]
                            var Name = field.originalName.replace(/(_[a-zA-Z])/g, function(match) {
                                return match.toUpperCase().replace('_','');
                            });
                            Name = Name.substring(0,1).toUpperCase() + Name.substring(1);

                            // set/get_[some_value] FIXME: Do we really need these?
                            var name = field.originalName.replace(/([A-Z])/g, function(match) {
                                return "_"+match;
                            });

                            /**
                             * The current field's unbound setter function.
                             * @function
                             * @param {*} value
                             * @param {boolean=} noAssert
                             * @returns {!ProtoBuf.Builder.Message}
                             * @inner
                             */
                            var setter = function(value, noAssert) {
                                this[field.name] = noAssert ? value : field.verifyValue(value);
                                return this;
                            };

                            /**
                             * The current field's unbound getter function.
                             * @function
                             * @returns {*}
                             * @inner
                             */
                            var getter = function() {
                                return this[field.name];
                            };

                            if (T.getChild("set"+Name) === null)
                                /**
                                 * Sets a value. This method is present for each field, but only if there is no name conflict with
                                 *  another field.
                                 * @name ProtoBuf.Builder.Message#set[SomeField]
                                 * @function
                                 * @param {*} value Value to set
                                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                                 * @returns {!ProtoBuf.Builder.Message} this
                                 * @abstract
                                 * @throws {Error} If the value cannot be set
                                 */
                                MessagePrototype["set"+Name] = setter;

                            if (T.getChild("set_"+name) === null)
                                /**
                                 * Sets a value. This method is present for each field, but only if there is no name conflict with
                                 *  another field.
                                 * @name ProtoBuf.Builder.Message#set_[some_field]
                                 * @function
                                 * @param {*} value Value to set
                                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                                 * @returns {!ProtoBuf.Builder.Message} this
                                 * @abstract
                                 * @throws {Error} If the value cannot be set
                                 */
                                MessagePrototype["set_"+name] = setter;

                            if (T.getChild("get"+Name) === null)
                                /**
                                 * Gets a value. This method is present for each field, but only if there is no name conflict with
                                 *  another field.
                                 * @name ProtoBuf.Builder.Message#get[SomeField]
                                 * @function
                                 * @abstract
                                 * @return {*} The value
                                 */
                                MessagePrototype["get"+Name] = getter;

                            if (T.getChild("get_"+name) === null)
                                /**
                                 * Gets a value. This method is present for each field, but only if there is no name conflict with
                                 *  another field.
                                 * @name ProtoBuf.Builder.Message#get_[some_field]
                                 * @function
                                 * @return {*} The value
                                 * @abstract
                                 */
                                MessagePrototype["get_"+name] = getter;

                        })(field);
                }

                // En-/decoding

                /**
                 * Encodes the message.
                 * @name ProtoBuf.Builder.Message#$encode
                 * @function
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ByteBuffer in the `encoded` property on the error.
                 * @expose
                 * @see ProtoBuf.Builder.Message#encode64
                 * @see ProtoBuf.Builder.Message#encodeHex
                 * @see ProtoBuf.Builder.Message#encodeAB
                 */
                MessagePrototype.encode = function(buffer, noVerify) {
                    if (typeof buffer === 'boolean')
                        noVerify = buffer,
                        buffer = undefined;
                    var isNew = false;
                    if (!buffer)
                        buffer = new ByteBuffer(),
                        isNew = true;
                    var le = buffer.littleEndian;
                    try {
                        T.encode(this, buffer.LE(), noVerify);
                        return (isNew ? buffer.flip() : buffer).LE(le);
                    } catch (e) {
                        buffer.LE(le);
                        throw(e);
                    }
                };

                /**
                 * Encodes a message using the specified data payload.
                 * @param {!Object.<string,*>} data Data payload
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @expose
                 */
                Message.encode = function(data, buffer, noVerify) {
                    return new Message(data).encode(buffer, noVerify);
                };

                /**
                 * Calculates the byte length of the message.
                 * @name ProtoBuf.Builder.Message#calculate
                 * @function
                 * @returns {number} Byte length
                 * @throws {Error} If the message cannot be calculated or if required fields are missing.
                 * @expose
                 */
                MessagePrototype.calculate = function() {
                    return T.calculate(this);
                };

                /**
                 * Encodes the varint32 length-delimited message.
                 * @name ProtoBuf.Builder.Message#encodeDelimited
                 * @function
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ByteBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeDelimited = function(buffer, noVerify) {
                    var isNew = false;
                    if (!buffer)
                        buffer = new ByteBuffer(),
                        isNew = true;
                    var enc = new ByteBuffer().LE();
                    T.encode(this, enc, noVerify).flip();
                    buffer.writeVarint32(enc.remaining());
                    buffer.append(enc);
                    return isNew ? buffer.flip() : buffer;
                };

                /**
                 * Directly encodes the message to an ArrayBuffer.
                 * @name ProtoBuf.Builder.Message#encodeAB
                 * @function
                 * @return {ArrayBuffer} Encoded message as ArrayBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeAB = function() {
                    try {
                        return this.encode().toArrayBuffer();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toArrayBuffer();
                        throw(e);
                    }
                };

                /**
                 * Returns the message as an ArrayBuffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeAB}.
                 * @name ProtoBuf.Builder.Message#toArrayBuffer
                 * @function
                 * @return {ArrayBuffer} Encoded message as ArrayBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toArrayBuffer = MessagePrototype.encodeAB;

                /**
                 * Directly encodes the message to a node Buffer.
                 * @name ProtoBuf.Builder.Message#encodeNB
                 * @function
                 * @return {!Buffer}
                 * @throws {Error} If the message cannot be encoded, not running under node.js or if required fields are
                 *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeNB = function() {
                    try {
                        return this.encode().toBuffer();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toBuffer();
                        throw(e);
                    }
                };

                /**
                 * Returns the message as a node Buffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeNB}.
                 * @name ProtoBuf.Builder.Message#toBuffer
                 * @function
                 * @return {!Buffer}
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded node Buffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toBuffer = MessagePrototype.encodeNB;

                /**
                 * Directly encodes the message to a base64 encoded string.
                 * @name ProtoBuf.Builder.Message#encode64
                 * @function
                 * @return {string} Base64 encoded string
                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                 *  still returns the encoded base64 string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encode64 = function() {
                    try {
                        return this.encode().toBase64();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toBase64();
                        throw(e);
                    }
                };

                /**
                 * Returns the message as a base64 encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encode64}.
                 * @name ProtoBuf.Builder.Message#toBase64
                 * @function
                 * @return {string} Base64 encoded string
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded base64 string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toBase64 = MessagePrototype.encode64;

                /**
                 * Directly encodes the message to a hex encoded string.
                 * @name ProtoBuf.Builder.Message#encodeHex
                 * @function
                 * @return {string} Hex encoded string
                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                 *  still returns the encoded hex string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeHex = function() {
                    try {
                        return this.encode().toHex();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toHex();
                        throw(e);
                    }
                };

                /**
                 * Returns the message as a hex encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encodeHex}.
                 * @name ProtoBuf.Builder.Message#toHex
                 * @function
                 * @return {string} Hex encoded string
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded hex string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toHex = MessagePrototype.encodeHex;

                /**
                 * Clones a message object or field value to a raw object.
                 * @param {*} obj Object to clone
                 * @param {boolean} binaryAsBase64 Whether to include binary data as base64 strings or as a buffer otherwise
                 * @param {boolean} longsAsStrings Whether to encode longs as strings
                 * @param {!ProtoBuf.Reflect.T=} resolvedType The resolved field type if a field
                 * @returns {*} Cloned object
                 * @inner
                 */
                function cloneRaw(obj, binaryAsBase64, longsAsStrings, resolvedType) {
                    if (obj === null || typeof obj !== 'object') {
                        // Convert enum values to their respective names
                        if (resolvedType && resolvedType instanceof ProtoBuf.Reflect.Enum) {
                            var name = ProtoBuf.Reflect.Enum.getName(resolvedType.object, obj);
                            if (name !== null)
                                return name;
                        }
                        // Pass-through string, number, boolean, null...
                        return obj;
                    }
                    // Convert ByteBuffers to raw buffer or strings
                    if (ByteBuffer.isByteBuffer(obj))
                        return binaryAsBase64 ? obj.toBase64() : obj.toBuffer();
                    // Convert Longs to proper objects or strings
                    if (ProtoBuf.Long.isLong(obj))
                        return longsAsStrings ? obj.toString() : ProtoBuf.Long.fromValue(obj);
                    var clone;
                    // Clone arrays
                    if (Array.isArray(obj)) {
                        clone = [];
                        obj.forEach(function(v, k) {
                            clone[k] = cloneRaw(v, binaryAsBase64, longsAsStrings, resolvedType);
                        });
                        return clone;
                    }
                    clone = {};
                    // Convert maps to objects
                    if (obj instanceof ProtoBuf.Map) {
                        var it = obj.entries();
                        for (var e = it.next(); !e.done; e = it.next())
                            clone[obj.keyElem.valueToString(e.value[0])] = cloneRaw(e.value[1], binaryAsBase64, longsAsStrings, obj.valueElem.resolvedType);
                        return clone;
                    }
                    // Everything else is a non-null object
                    var type = obj.$type,
                        field = undefined;
                    for (var i in obj)
                        if (obj.hasOwnProperty(i)) {
                            if (type && (field = type.getChild(i)))
                                clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings, field.resolvedType);
                            else
                                clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings);
                        }
                    return clone;
                }

                /**
                 * Returns the message's raw payload.
                 * @param {boolean=} binaryAsBase64 Whether to include binary data as base64 strings instead of Buffers, defaults to `false`
                 * @param {boolean} longsAsStrings Whether to encode longs as strings
                 * @returns {Object.<string,*>} Raw payload
                 * @expose
                 */
                MessagePrototype.toRaw = function(binaryAsBase64, longsAsStrings) {
                    return cloneRaw(this, !!binaryAsBase64, !!longsAsStrings, this.$type);
                };

                /**
                 * Encodes a message to JSON.
                 * @returns {string} JSON string
                 * @expose
                 */
                MessagePrototype.encodeJSON = function() {
                    return JSON.stringify(
                        cloneRaw(this,
                             /* binary-as-base64 */ true,
                             /* longs-as-strings */ true,
                             this.$type
                        )
                    );
                };

                /**
                 * Decodes a message from the specified buffer or string.
                 * @name ProtoBuf.Builder.Message.decode
                 * @function
                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                 * @param {(number|string)=} length Message length. Defaults to decode all the remainig data.
                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 * @see ProtoBuf.Builder.Message.decode64
                 * @see ProtoBuf.Builder.Message.decodeHex
                 */
                Message.decode = function(buffer, length, enc) {
                    if (typeof length === 'string')
                        enc = length,
                        length = -1;
                    if (typeof buffer === 'string')
                        buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
                    buffer = ByteBuffer.isByteBuffer(buffer) ? buffer : ByteBuffer.wrap(buffer); // May throw
                    var le = buffer.littleEndian;
                    try {
                        var msg = T.decode(buffer.LE());
                        buffer.LE(le);
                        return msg;
                    } catch (e) {
                        buffer.LE(le);
                        throw(e);
                    }
                };

                /**
                 * Decodes a varint32 length-delimited message from the specified buffer or string.
                 * @name ProtoBuf.Builder.Message.decodeDelimited
                 * @function
                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                 * @return {ProtoBuf.Builder.Message} Decoded message or `null` if not enough bytes are available yet
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decodeDelimited = function(buffer, enc) {
                    if (typeof buffer === 'string')
                        buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
                    buffer = ByteBuffer.isByteBuffer(buffer) ? buffer : ByteBuffer.wrap(buffer); // May throw
                    if (buffer.remaining() < 1)
                        return null;
                    var off = buffer.offset,
                        len = buffer.readVarint32();
                    if (buffer.remaining() < len) {
                        buffer.offset = off;
                        return null;
                    }
                    try {
                        var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());
                        buffer.offset += len;
                        return msg;
                    } catch (err) {
                        buffer.offset += len;
                        throw err;
                    }
                };

                /**
                 * Decodes the message from the specified base64 encoded string.
                 * @name ProtoBuf.Builder.Message.decode64
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decode64 = function(str) {
                    return Message.decode(str, "base64");
                };

                /**
                 * Decodes the message from the specified hex encoded string.
                 * @name ProtoBuf.Builder.Message.decodeHex
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decodeHex = function(str) {
                    return Message.decode(str, "hex");
                };

                /**
                 * Decodes the message from a JSON string.
                 * @name ProtoBuf.Builder.Message.decodeJSON
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are
                 * missing.
                 * @expose
                 */
                Message.decodeJSON = function(str) {
                    return new Message(JSON.parse(str));
                };

                // Utility

                /**
                 * Returns a string representation of this Message.
                 * @name ProtoBuf.Builder.Message#toString
                 * @function
                 * @return {string} String representation as of ".Fully.Qualified.MessageName"
                 * @expose
                 */
                MessagePrototype.toString = function() {
                    return T.toString();
                };

                // Properties

                /**
                 * Message options.
                 * @name ProtoBuf.Builder.Message.$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $optionsS; // cc needs this

                /**
                 * Message options.
                 * @name ProtoBuf.Builder.Message#$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $options;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Message.$type
                 * @type {!ProtoBuf.Reflect.Message}
                 * @expose
                 */
                var $typeS;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Message#$type
                 * @type {!ProtoBuf.Reflect.Message}
                 * @expose
                 */
                var $type;

                if (Object.defineProperty)
                    Object.defineProperty(Message, '$options', { "value": T.buildOpt() }),
                    Object.defineProperty(MessagePrototype, "$options", { "value": Message["$options"] }),
                    Object.defineProperty(Message, "$type", { "value": T }),
                    Object.defineProperty(MessagePrototype, "$type", { "value": T });

                return Message;

            })(ProtoBuf, this);

            // Static enums and prototyped sub-messages / cached collections
            this._fields = [];
            this._fieldsById = {};
            this._fieldsByName = {};
            for (var i=0, k=this.children.length, child; i<k; i++) {
                child = this.children[i];
                if (child instanceof Enum || child instanceof Message || child instanceof Service) {
                    if (clazz.hasOwnProperty(child.name))
                        throw Error("Illegal reflect child of "+this.toString(true)+": "+child.toString(true)+" cannot override static property '"+child.name+"'");
                    clazz[child.name] = child.build();
                } else if (child instanceof Message.Field)
                    child.build(),
                    this._fields.push(child),
                    this._fieldsById[child.id] = child,
                    this._fieldsByName[child.name] = child;
                else if (!(child instanceof Message.OneOf) && !(child instanceof Extension)) // Not built
                    throw Error("Illegal reflect child of "+this.toString(true)+": "+this.children[i].toString(true));
            }

            return this.clazz = clazz;
        };

        /**
         * Encodes a runtime message's contents to the specified buffer.
         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
         * @param {ByteBuffer} buffer ByteBuffer to write to
         * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If required fields are missing or the message cannot be encoded for another reason
         * @expose
         */
        MessagePrototype.encode = function(message, buffer, noVerify) {
            var fieldMissing = null,
                field;
            for (var i=0, k=this._fields.length, val; i<k; ++i) {
                field = this._fields[i];
                val = message[field.name];
                if (field.required && val === null) {
                    if (fieldMissing === null)
                        fieldMissing = field;
                } else
                    field.encode(noVerify ? val : field.verifyValue(val), buffer, message);
            }
            if (fieldMissing !== null) {
                var err = Error("Missing at least one required field for "+this.toString(true)+": "+fieldMissing);
                err["encoded"] = buffer; // Still expose what we got
                throw(err);
            }
            return buffer;
        };

        /**
         * Calculates a runtime message's byte length.
         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
         * @returns {number} Byte length
         * @throws {Error} If required fields are missing or the message cannot be calculated for another reason
         * @expose
         */
        MessagePrototype.calculate = function(message) {
            for (var n=0, i=0, k=this._fields.length, field, val; i<k; ++i) {
                field = this._fields[i];
                val = message[field.name];
                if (field.required && val === null)
                   throw Error("Missing at least one required field for "+this.toString(true)+": "+field);
                else
                    n += field.calculate(val, message);
            }
            return n;
        };

        /**
         * Skips all data until the end of the specified group has been reached.
         * @param {number} expectedId Expected GROUPEND id
         * @param {!ByteBuffer} buf ByteBuffer
         * @returns {boolean} `true` if a value as been skipped, `false` if the end has been reached
         * @throws {Error} If it wasn't possible to find the end of the group (buffer overrun or end tag mismatch)
         * @inner
         */
        function skipTillGroupEnd(expectedId, buf) {
            var tag = buf.readVarint32(), // Throws on OOB
                wireType = tag & 0x07,
                id = tag >>> 3;
            switch (wireType) {
                case ProtoBuf.WIRE_TYPES.VARINT:
                    do tag = buf.readUint8();
                    while ((tag & 0x80) === 0x80);
                    break;
                case ProtoBuf.WIRE_TYPES.BITS64:
                    buf.offset += 8;
                    break;
                case ProtoBuf.WIRE_TYPES.LDELIM:
                    tag = buf.readVarint32(); // reads the varint
                    buf.offset += tag;        // skips n bytes
                    break;
                case ProtoBuf.WIRE_TYPES.STARTGROUP:
                    skipTillGroupEnd(id, buf);
                    break;
                case ProtoBuf.WIRE_TYPES.ENDGROUP:
                    if (id === expectedId)
                        return false;
                    else
                        throw Error("Illegal GROUPEND after unknown group: "+id+" ("+expectedId+" expected)");
                case ProtoBuf.WIRE_TYPES.BITS32:
                    buf.offset += 4;
                    break;
                default:
                    throw Error("Illegal wire type in unknown group "+expectedId+": "+wireType);
            }
            return true;
        }

        /**
         * Decodes an encoded message and returns the decoded message.
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {number=} length Message length. Defaults to decode all remaining data.
         * @param {number=} expectedGroupEndId Expected GROUPEND id if this is a legacy group
         * @return {ProtoBuf.Builder.Message} Decoded message
         * @throws {Error} If the message cannot be decoded
         * @expose
         */
        MessagePrototype.decode = function(buffer, length, expectedGroupEndId) {
            length = typeof length === 'number' ? length : -1;
            var start = buffer.offset,
                msg = new (this.clazz)(),
                tag, wireType, id, field;
            while (buffer.offset < start+length || (length === -1 && buffer.remaining() > 0)) {
                tag = buffer.readVarint32();
                wireType = tag & 0x07;
                id = tag >>> 3;
                if (wireType === ProtoBuf.WIRE_TYPES.ENDGROUP) {
                    if (id !== expectedGroupEndId)
                        throw Error("Illegal group end indicator for "+this.toString(true)+": "+id+" ("+(expectedGroupEndId ? expectedGroupEndId+" expected" : "not a group")+")");
                    break;
                }
                if (!(field = this._fieldsById[id])) {
                    // "messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing."
                    switch (wireType) {
                        case ProtoBuf.WIRE_TYPES.VARINT:
                            buffer.readVarint32();
                            break;
                        case ProtoBuf.WIRE_TYPES.BITS32:
                            buffer.offset += 4;
                            break;
                        case ProtoBuf.WIRE_TYPES.BITS64:
                            buffer.offset += 8;
                            break;
                        case ProtoBuf.WIRE_TYPES.LDELIM:
                            var len = buffer.readVarint32();
                            buffer.offset += len;
                            break;
                        case ProtoBuf.WIRE_TYPES.STARTGROUP:
                            while (skipTillGroupEnd(id, buffer)) {}
                            break;
                        default:
                            throw Error("Illegal wire type for unknown field "+id+" in "+this.toString(true)+"#decode: "+wireType);
                    }
                    continue;
                }
                if (field.repeated && !field.options["packed"]) {
                    msg[field.name].push(field.decode(wireType, buffer));
                } else if (field.map) {
                    var keyval = field.decode(wireType, buffer);
                    msg[field.name].set(keyval[0], keyval[1]);
                } else {
                    msg[field.name] = field.decode(wireType, buffer);
                    if (field.oneof) { // Field is part of an OneOf (not a virtual OneOf field)
                        var currentField = msg[field.oneof.name]; // Virtual field references currently set field
                        if (currentField !== null && currentField !== field.name)
                            msg[currentField] = null; // Clear currently set field
                        msg[field.oneof.name] = field.name; // Point virtual field at this field
                    }
                }
            }

            // Check if all required fields are present and set default values for optional fields that are not
            for (var i=0, k=this._fields.length; i<k; ++i) {
                field = this._fields[i];
                if (msg[field.name] === null) {
                    if (this.syntax === "proto3") { // Proto3 sets default values by specification
                        msg[field.name] = field.defaultValue;
                    } else if (field.required) {
                        var err = Error("Missing at least one required field for " + this.toString(true) + ": " + field.name);
                        err["decoded"] = msg; // Still expose what we got
                        throw(err);
                    } else if (ProtoBuf.populateDefaults && field.defaultValue !== null)
                        msg[field.name] = field.defaultValue;
                }
            }
            return msg;
        };

        /**
         * @alias ProtoBuf.Reflect.Message
         * @expose
         */
        Reflect.Message = Message;

        /**
         * Constructs a new Message Field.
         * @exports ProtoBuf.Reflect.Message.Field
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} rule Rule, one of requried, optional, repeated
         * @param {string?} keytype Key data type, if any.
         * @param {string} type Data type, e.g. int32
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @param {Object.<string,*>=} options Options
         * @param {!ProtoBuf.Reflect.Message.OneOf=} oneof Enclosing OneOf
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Field = function(builder, message, rule, keytype, type, name, id, options, oneof, syntax) {
            T.call(this, builder, message, name);

            /**
             * @override
             */
            this.className = "Message.Field";

            /**
             * Message field required flag.
             * @type {boolean}
             * @expose
             */
            this.required = rule === "required";

            /**
             * Message field repeated flag.
             * @type {boolean}
             * @expose
             */
            this.repeated = rule === "repeated";

            /**
             * Message field map flag.
             * @type {boolean}
             * @expose
             */
            this.map = rule === "map";

            /**
             * Message field key type. Type reference string if unresolved, protobuf
             * type if resolved. Valid only if this.map === true, null otherwise.
             * @type {string|{name: string, wireType: number}|null}
             * @expose
             */
            this.keyType = keytype || null;

            /**
             * Message field type. Type reference string if unresolved, protobuf type if
             * resolved. In a map field, this is the value type.
             * @type {string|{name: string, wireType: number}}
             * @expose
             */
            this.type = type;

            /**
             * Resolved type reference inside the global namespace.
             * @type {ProtoBuf.Reflect.T|null}
             * @expose
             */
            this.resolvedType = null;

            /**
             * Unique message field id.
             * @type {number}
             * @expose
             */
            this.id = id;

            /**
             * Message field options.
             * @type {!Object.<string,*>}
             * @dict
             * @expose
             */
            this.options = options || {};

            /**
             * Default value.
             * @type {*}
             * @expose
             */
            this.defaultValue = null;

            /**
             * Enclosing OneOf.
             * @type {?ProtoBuf.Reflect.Message.OneOf}
             * @expose
             */
            this.oneof = oneof || null;

            /**
             * Syntax level of this definition (e.g., proto3).
             * @type {string}
             * @expose
             */
            this.syntax = syntax || 'proto2';

            /**
             * Original field name.
             * @type {string}
             * @expose
             */
            this.originalName = this.name; // Used to revert camelcase transformation on naming collisions

            /**
             * Element implementation. Created in build() after types are resolved.
             * @type {ProtoBuf.Element}
             * @expose
             */
            this.element = null;

            /**
             * Key element implementation, for map fields. Created in build() after
             * types are resolved.
             * @type {ProtoBuf.Element}
             * @expose
             */
            this.keyElement = null;

            // Convert field names to camel case notation if the override is set
            if (this.builder.options['convertFieldsToCamelCase'] && !(this instanceof Message.ExtensionField))
                this.name = ProtoBuf.Util.toCamelCase(this.name);
        };

        /**
         * @alias ProtoBuf.Reflect.Message.Field.prototype
         * @inner
         */
        var FieldPrototype = Field.prototype = Object.create(T.prototype);

        /**
         * Builds the field.
         * @override
         * @expose
         */
        FieldPrototype.build = function() {
            this.element = new Element(this.type, this.resolvedType, false, this.syntax);
            if (this.map)
                this.keyElement = new Element(this.keyType, undefined, true, this.syntax);

            // In proto3, fields do not have field presence, and every field is set to
            // its type's default value ("", 0, 0.0, or false).
            if (this.syntax === 'proto3' && !this.repeated && !this.map)
                this.defaultValue = Element.defaultFieldValue(this.type);

            // Otherwise, default values are present when explicitly specified
            else if (typeof this.options['default'] !== 'undefined')
                this.defaultValue = this.verifyValue(this.options['default']);
        };

        /**
         * Checks if the given value can be set for this field.
         * @param {*} value Value to check
         * @param {boolean=} skipRepeated Whether to skip the repeated value check or not. Defaults to false.
         * @return {*} Verified, maybe adjusted, value
         * @throws {Error} If the value cannot be set for this field
         * @expose
         */
        FieldPrototype.verifyValue = function(value, skipRepeated) {
            skipRepeated = skipRepeated || false;
            var self = this;
            function fail(val, msg) {
                throw Error("Illegal value for "+self.toString(true)+" of type "+self.type.name+": "+val+" ("+msg+")");
            }
            if (value === null) { // NULL values for optional fields
                if (this.required)
                    fail(typeof value, "required");
                if (this.syntax === 'proto3' && this.type !== ProtoBuf.TYPES["message"])
                    fail(typeof value, "proto3 field without field presence cannot be null");
                return null;
            }
            var i;
            if (this.repeated && !skipRepeated) { // Repeated values as arrays
                if (!Array.isArray(value))
                    value = [value];
                var res = [];
                for (i=0; i<value.length; i++)
                    res.push(this.element.verifyValue(value[i]));
                return res;
            }
            if (this.map && !skipRepeated) { // Map values as objects
                if (!(value instanceof ProtoBuf.Map)) {
                    // If not already a Map, attempt to convert.
                    if (!(value instanceof Object)) {
                        fail(typeof value,
                             "expected ProtoBuf.Map or raw object for map field");
                    }
                    return new ProtoBuf.Map(this, value);
                } else {
                    return value;
                }
            }
            // All non-repeated fields expect no array
            if (!this.repeated && Array.isArray(value))
                fail(typeof value, "no array expected");

            return this.element.verifyValue(value);
        };

        /**
         * Determines whether the field will have a presence on the wire given its
         * value.
         * @param {*} value Verified field value
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @return {boolean} Whether the field will be present on the wire
         */
        FieldPrototype.hasWirePresence = function(value, message) {
            if (this.syntax !== 'proto3')
                return (value !== null);
            if (this.oneof && message[this.oneof.name] === this.name)
                return true;
            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    return value !== 0;

                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]:
                    return value.low !== 0 || value.high !== 0;

                case ProtoBuf.TYPES["bool"]:
                    return value;

                case ProtoBuf.TYPES["float"]:
                case ProtoBuf.TYPES["double"]:
                    return value !== 0.0;

                case ProtoBuf.TYPES["string"]:
                    return value.length > 0;

                case ProtoBuf.TYPES["bytes"]:
                    return value.remaining() > 0;

                case ProtoBuf.TYPES["enum"]:
                    return value !== 0;

                case ProtoBuf.TYPES["message"]:
                    return value !== null;
                default:
                    return true;
            }
        };

        /**
         * Encodes the specified field value to the specified buffer.
         * @param {*} value Verified field value
         * @param {ByteBuffer} buffer ByteBuffer to encode to
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If the field cannot be encoded
         * @expose
         */
        FieldPrototype.encode = function(value, buffer, message) {
            if (this.type === null || typeof this.type !== 'object')
                throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
            if (value === null || (this.repeated && value.length == 0))
                return buffer; // Optional omitted
            try {
                if (this.repeated) {
                    var i;
                    // "Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire
                    // types) can be declared 'packed'."
                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                        // "All of the elements of the field are packed into a single key-value pair with wire type 2
                        // (length-delimited). Each element is encoded the same way it would be normally, except without a
                        // tag preceding it."
                        buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                        buffer.ensureCapacity(buffer.offset += 1); // We do not know the length yet, so let's assume a varint of length 1
                        var start = buffer.offset; // Remember where the contents begin
                        for (i=0; i<value.length; i++)
                            this.element.encodeValue(this.id, value[i], buffer);
                        var len = buffer.offset-start,
                            varintLen = ByteBuffer.calculateVarint32(len);
                        if (varintLen > 1) { // We need to move the contents
                            var contents = buffer.slice(start, buffer.offset);
                            start += varintLen-1;
                            buffer.offset = start;
                            buffer.append(contents);
                        }
                        buffer.writeVarint32(len, start-varintLen);
                    } else {
                        // "If your message definition has repeated elements (without the [packed=true] option), the encoded
                        // message has zero or more key-value pairs with the same tag number"
                        for (i=0; i<value.length; i++)
                            buffer.writeVarint32((this.id << 3) | this.type.wireType),
                            this.element.encodeValue(this.id, value[i], buffer);
                    }
                } else if (this.map) {
                    // Write out each map entry as a submessage.
                    value.forEach(function(val, key, m) {
                        // Compute the length of the submessage (key, val) pair.
                        var length =
                            ByteBuffer.calculateVarint32((1 << 3) | this.keyType.wireType) +
                            this.keyElement.calculateLength(1, key) +
                            ByteBuffer.calculateVarint32((2 << 3) | this.type.wireType) +
                            this.element.calculateLength(2, val);

                        // Submessage with wire type of length-delimited.
                        buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                        buffer.writeVarint32(length);

                        // Write out the key and val.
                        buffer.writeVarint32((1 << 3) | this.keyType.wireType);
                        this.keyElement.encodeValue(1, key, buffer);
                        buffer.writeVarint32((2 << 3) | this.type.wireType);
                        this.element.encodeValue(2, val, buffer);
                    }, this);
                } else {
                    if (this.hasWirePresence(value, message)) {
                        buffer.writeVarint32((this.id << 3) | this.type.wireType);
                        this.element.encodeValue(this.id, value, buffer);
                    }
                }
            } catch (e) {
                throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
            }
            return buffer;
        };

        /**
         * Calculates the length of this field's value on the network level.
         * @param {*} value Field value
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @returns {number} Byte length
         * @expose
         */
        FieldPrototype.calculate = function(value, message) {
            value = this.verifyValue(value); // May throw
            if (this.type === null || typeof this.type !== 'object')
                throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
            if (value === null || (this.repeated && value.length == 0))
                return 0; // Optional omitted
            var n = 0;
            try {
                if (this.repeated) {
                    var i, ni;
                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                        n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                        ni = 0;
                        for (i=0; i<value.length; i++)
                            ni += this.element.calculateLength(this.id, value[i]);
                        n += ByteBuffer.calculateVarint32(ni);
                        n += ni;
                    } else {
                        for (i=0; i<value.length; i++)
                            n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType),
                            n += this.element.calculateLength(this.id, value[i]);
                    }
                } else if (this.map) {
                    // Each map entry becomes a submessage.
                    value.forEach(function(val, key, m) {
                        // Compute the length of the submessage (key, val) pair.
                        var length =
                            ByteBuffer.calculateVarint32((1 << 3) | this.keyType.wireType) +
                            this.keyElement.calculateLength(1, key) +
                            ByteBuffer.calculateVarint32((2 << 3) | this.type.wireType) +
                            this.element.calculateLength(2, val);

                        n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                        n += ByteBuffer.calculateVarint32(length);
                        n += length;
                    }, this);
                } else {
                    if (this.hasWirePresence(value, message)) {
                        n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType);
                        n += this.element.calculateLength(this.id, value);
                    }
                }
            } catch (e) {
                throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
            }
            return n;
        };

        /**
         * Decode the field value from the specified buffer.
         * @param {number} wireType Leading wire type
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {boolean=} skipRepeated Whether to skip the repeated check or not. Defaults to false.
         * @return {*} Decoded value: array for packed repeated fields, [key, value] for
         *             map fields, or an individual value otherwise.
         * @throws {Error} If the field cannot be decoded
         * @expose
         */
        FieldPrototype.decode = function(wireType, buffer, skipRepeated) {
            var value, nBytes;

            // We expect wireType to match the underlying type's wireType unless we see
            // a packed repeated field, or unless this is a map field.
            var wireTypeOK =
                (!this.map && wireType == this.type.wireType) ||
                (!skipRepeated && this.repeated && this.options["packed"] &&
                 wireType == ProtoBuf.WIRE_TYPES.LDELIM) ||
                (this.map && wireType == ProtoBuf.WIRE_TYPES.LDELIM);
            if (!wireTypeOK)
                throw Error("Illegal wire type for field "+this.toString(true)+": "+wireType+" ("+this.type.wireType+" expected)");

            // Handle packed repeated fields.
            if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                if (!skipRepeated) {
                    nBytes = buffer.readVarint32();
                    nBytes = buffer.offset + nBytes; // Limit
                    var values = [];
                    while (buffer.offset < nBytes)
                        values.push(this.decode(this.type.wireType, buffer, true));
                    return values;
                }
                // Read the next value otherwise...
            }

            // Handle maps.
            if (this.map) {
                // Read one (key, value) submessage, and return [key, value]
                var key = Element.defaultFieldValue(this.keyType);
                value = Element.defaultFieldValue(this.type);

                // Read the length
                nBytes = buffer.readVarint32();
                if (buffer.remaining() < nBytes)
                    throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());

                // Get a sub-buffer of this key/value submessage
                var msgbuf = buffer.clone();
                msgbuf.limit = msgbuf.offset + nBytes;
                buffer.offset += nBytes;

                while (msgbuf.remaining() > 0) {
                    var tag = msgbuf.readVarint32();
                    wireType = tag & 0x07;
                    var id = tag >>> 3;
                    if (id === 1) {
                        key = this.keyElement.decode(msgbuf, wireType, id);
                    } else if (id === 2) {
                        value = this.element.decode(msgbuf, wireType, id);
                    } else {
                        throw Error("Unexpected tag in map field key/value submessage");
                    }
                }

                return [key, value];
            }

            // Handle singular and non-packed repeated field values.
            return this.element.decode(buffer, wireType, this.id);
        };

        /**
         * @alias ProtoBuf.Reflect.Message.Field
         * @expose
         */
        Reflect.Message.Field = Field;

        /**
         * Constructs a new Message ExtensionField.
         * @exports ProtoBuf.Reflect.Message.ExtensionField
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} rule Rule, one of requried, optional, repeated
         * @param {string} type Data type, e.g. int32
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @param {!Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Message.Field
         */
        var ExtensionField = function(builder, message, rule, type, name, id, options) {
            Field.call(this, builder, message, rule, /* keytype = */ null, type, name, id, options);

            /**
             * Extension reference.
             * @type {!ProtoBuf.Reflect.Extension}
             * @expose
             */
            this.extension;
        };

        // Extends Field
        ExtensionField.prototype = Object.create(Field.prototype);

        /**
         * @alias ProtoBuf.Reflect.Message.ExtensionField
         * @expose
         */
        Reflect.Message.ExtensionField = ExtensionField;

        /**
         * Constructs a new Message OneOf.
         * @exports ProtoBuf.Reflect.Message.OneOf
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} name OneOf name
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var OneOf = function(builder, message, name) {
            T.call(this, builder, message, name);

            /**
             * Enclosed fields.
             * @type {!Array.<!ProtoBuf.Reflect.Message.Field>}
             * @expose
             */
            this.fields = [];
        };

        /**
         * @alias ProtoBuf.Reflect.Message.OneOf
         * @expose
         */
        Reflect.Message.OneOf = OneOf;

        /**
         * Constructs a new Enum.
         * @exports ProtoBuf.Reflect.Enum
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.T} parent Parent Reflect object
         * @param {string} name Enum name
         * @param {Object.<string,*>=} options Enum options
         * @param {string?} syntax The syntax level (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Enum = function(builder, parent, name, options, syntax) {
            Namespace.call(this, builder, parent, name, options, syntax);

            /**
             * @override
             */
            this.className = "Enum";

            /**
             * Runtime enum object.
             * @type {Object.<string,number>|null}
             * @expose
             */
            this.object = null;
        };

        /**
         * Gets the string name of an enum value.
         * @param {!ProtoBuf.Builder.Enum} enm Runtime enum
         * @param {number} value Enum value
         * @returns {?string} Name or `null` if not present
         * @expose
         */
        Enum.getName = function(enm, value) {
            var keys = Object.keys(enm);
            for (var i=0, key; i<keys.length; ++i)
                if (enm[key = keys[i]] === value)
                    return key;
            return null;
        };

        /**
         * @alias ProtoBuf.Reflect.Enum.prototype
         * @inner
         */
        var EnumPrototype = Enum.prototype = Object.create(Namespace.prototype);

        /**
         * Builds this enum and returns the runtime counterpart.
         * @param {boolean} rebuild Whether to rebuild or not, defaults to false
         * @returns {!Object.<string,number>}
         * @expose
         */
        EnumPrototype.build = function(rebuild) {
            if (this.object && !rebuild)
                return this.object;
            var enm = new ProtoBuf.Builder.Enum(),
                values = this.getChildren(Enum.Value);
            for (var i=0, k=values.length; i<k; ++i)
                enm[values[i]['name']] = values[i]['id'];
            if (Object.defineProperty)
                Object.defineProperty(enm, '$options', {
                    "value": this.buildOpt(),
                    "enumerable": false
                });
            return this.object = enm;
        };

        /**
         * @alias ProtoBuf.Reflect.Enum
         * @expose
         */
        Reflect.Enum = Enum;

        /**
         * Constructs a new Enum Value.
         * @exports ProtoBuf.Reflect.Enum.Value
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Enum} enm Enum reference
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Value = function(builder, enm, name, id) {
            T.call(this, builder, enm, name);

            /**
             * @override
             */
            this.className = "Enum.Value";

            /**
             * Unique enum value id.
             * @type {number}
             * @expose
             */
            this.id = id;
        };

        // Extends T
        Value.prototype = Object.create(T.prototype);

        /**
         * @alias ProtoBuf.Reflect.Enum.Value
         * @expose
         */
        Reflect.Enum.Value = Value;

        /**
         * An extension (field).
         * @exports ProtoBuf.Reflect.Extension
         * @constructor
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.T} parent Parent object
         * @param {string} name Object name
         * @param {!ProtoBuf.Reflect.Message.Field} field Extension field
         */
        var Extension = function(builder, parent, name, field) {
            T.call(this, builder, parent, name);

            /**
             * Extended message field.
             * @type {!ProtoBuf.Reflect.Message.Field}
             * @expose
             */
            this.field = field;
        };

        // Extends T
        Extension.prototype = Object.create(T.prototype);

        /**
         * @alias ProtoBuf.Reflect.Extension
         * @expose
         */
        Reflect.Extension = Extension;

        /**
         * Constructs a new Service.
         * @exports ProtoBuf.Reflect.Service
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Namespace} root Root
         * @param {string} name Service name
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Service = function(builder, root, name, options) {
            Namespace.call(this, builder, root, name, options);

            /**
             * @override
             */
            this.className = "Service";

            /**
             * Built runtime service class.
             * @type {?function(new:ProtoBuf.Builder.Service)}
             */
            this.clazz = null;
        };

        /**
         * @alias ProtoBuf.Reflect.Service.prototype
         * @inner
         */
        var ServicePrototype = Service.prototype = Object.create(Namespace.prototype);

        /**
         * Builds the service and returns the runtime counterpart, which is a fully functional class.
         * @see ProtoBuf.Builder.Service
         * @param {boolean=} rebuild Whether to rebuild or not
         * @return {Function} Service class
         * @throws {Error} If the message cannot be built
         * @expose
         */
        ServicePrototype.build = function(rebuild) {
            if (this.clazz && !rebuild)
                return this.clazz;

            // Create the runtime Service class in its own scope
            return this.clazz = (function(ProtoBuf, T) {

                /**
                 * Constructs a new runtime Service.
                 * @name ProtoBuf.Builder.Service
                 * @param {function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))=} rpcImpl RPC implementation receiving the method name and the message
                 * @class Barebone of all runtime services.
                 * @constructor
                 * @throws {Error} If the service cannot be created
                 */
                var Service = function(rpcImpl) {
                    ProtoBuf.Builder.Service.call(this);

                    /**
                     * Service implementation.
                     * @name ProtoBuf.Builder.Service#rpcImpl
                     * @type {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))}
                     * @expose
                     */
                    this.rpcImpl = rpcImpl || function(name, msg, callback) {
                        // This is what a user has to implement: A function receiving the method name, the actual message to
                        // send (type checked) and the callback that's either provided with the error as its first
                        // argument or null and the actual response message.
                        setTimeout(callback.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0); // Must be async!
                    };
                };

                /**
                 * @alias ProtoBuf.Builder.Service.prototype
                 * @inner
                 */
                var ServicePrototype = Service.prototype = Object.create(ProtoBuf.Builder.Service.prototype);

                /**
                 * Asynchronously performs an RPC call using the given RPC implementation.
                 * @name ProtoBuf.Builder.Service.[Method]
                 * @function
                 * @param {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))} rpcImpl RPC implementation
                 * @param {ProtoBuf.Builder.Message} req Request
                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                 *  the error if any and the response either as a pre-parsed message or as its raw bytes
                 * @abstract
                 */

                /**
                 * Asynchronously performs an RPC call using the instance's RPC implementation.
                 * @name ProtoBuf.Builder.Service#[Method]
                 * @function
                 * @param {ProtoBuf.Builder.Message} req Request
                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                 *  the error if any and the response either as a pre-parsed message or as its raw bytes
                 * @abstract
                 */

                var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);
                for (var i=0; i<rpc.length; i++) {
                    (function(method) {

                        // service#Method(message, callback)
                        ServicePrototype[method.name] = function(req, callback) {
                            try {
                                try {
                                    // If given as a buffer, decode the request. Will throw a TypeError if not a valid buffer.
                                    req = method.resolvedRequestType.clazz.decode(ByteBuffer.wrap(req));
                                } catch (err) {
                                    if (!(err instanceof TypeError))
                                        throw err;
                                }
                                if (req === null || typeof req !== 'object')
                                    throw Error("Illegal arguments");
                                if (!(req instanceof method.resolvedRequestType.clazz))
                                    req = new method.resolvedRequestType.clazz(req);
                                this.rpcImpl(method.fqn(), req, function(err, res) { // Assumes that this is properly async
                                    if (err) {
                                        callback(err);
                                        return;
                                    }
                                    // Coalesce to empty string when service response has empty content
                                    if (res === null)
                                        res = ''
                                    try { res = method.resolvedResponseType.clazz.decode(res); } catch (notABuffer) {}
                                    if (!res || !(res instanceof method.resolvedResponseType.clazz)) {
                                        callback(Error("Illegal response type received in service method "+ T.name+"#"+method.name));
                                        return;
                                    }
                                    callback(null, res);
                                });
                            } catch (err) {
                                setTimeout(callback.bind(this, err), 0);
                            }
                        };

                        // Service.Method(rpcImpl, message, callback)
                        Service[method.name] = function(rpcImpl, req, callback) {
                            new Service(rpcImpl)[method.name](req, callback);
                        };

                        if (Object.defineProperty)
                            Object.defineProperty(Service[method.name], "$options", { "value": method.buildOpt() }),
                            Object.defineProperty(ServicePrototype[method.name], "$options", { "value": Service[method.name]["$options"] });
                    })(rpc[i]);
                }

                // Properties

                /**
                 * Service options.
                 * @name ProtoBuf.Builder.Service.$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $optionsS; // cc needs this

                /**
                 * Service options.
                 * @name ProtoBuf.Builder.Service#$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $options;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Service.$type
                 * @type {!ProtoBuf.Reflect.Service}
                 * @expose
                 */
                var $typeS;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Service#$type
                 * @type {!ProtoBuf.Reflect.Service}
                 * @expose
                 */
                var $type;

                if (Object.defineProperty)
                    Object.defineProperty(Service, "$options", { "value": T.buildOpt() }),
                    Object.defineProperty(ServicePrototype, "$options", { "value": Service["$options"] }),
                    Object.defineProperty(Service, "$type", { "value": T }),
                    Object.defineProperty(ServicePrototype, "$type", { "value": T });

                return Service;

            })(ProtoBuf, this);
        };

        /**
         * @alias ProtoBuf.Reflect.Service
         * @expose
         */
        Reflect.Service = Service;

        /**
         * Abstract service method.
         * @exports ProtoBuf.Reflect.Service.Method
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Service} svc Service
         * @param {string} name Method name
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Method = function(builder, svc, name, options) {
            T.call(this, builder, svc, name);

            /**
             * @override
             */
            this.className = "Service.Method";

            /**
             * Options.
             * @type {Object.<string, *>}
             * @expose
             */
            this.options = options || {};
        };

        /**
         * @alias ProtoBuf.Reflect.Service.Method.prototype
         * @inner
         */
        var MethodPrototype = Method.prototype = Object.create(T.prototype);

        /**
         * Builds the method's '$options' property.
         * @name ProtoBuf.Reflect.Service.Method#buildOpt
         * @function
         * @return {Object.<string,*>}
         */
        MethodPrototype.buildOpt = NamespacePrototype.buildOpt;

        /**
         * @alias ProtoBuf.Reflect.Service.Method
         * @expose
         */
        Reflect.Service.Method = Method;

        /**
         * RPC service method.
         * @exports ProtoBuf.Reflect.Service.RPCMethod
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Service} svc Service
         * @param {string} name Method name
         * @param {string} request Request message name
         * @param {string} response Response message name
         * @param {boolean} request_stream Whether requests are streamed
         * @param {boolean} response_stream Whether responses are streamed
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Service.Method
         */
        var RPCMethod = function(builder, svc, name, request, response, request_stream, response_stream, options) {
            Method.call(this, builder, svc, name, options);

            /**
             * @override
             */
            this.className = "Service.RPCMethod";

            /**
             * Request message name.
             * @type {string}
             * @expose
             */
            this.requestName = request;

            /**
             * Response message name.
             * @type {string}
             * @expose
             */
            this.responseName = response;

            /**
             * Whether requests are streamed
             * @type {bool}
             * @expose
             */
            this.requestStream = request_stream;

            /**
             * Whether responses are streamed
             * @type {bool}
             * @expose
             */
            this.responseStream = response_stream;

            /**
             * Resolved request message type.
             * @type {ProtoBuf.Reflect.Message}
             * @expose
             */
            this.resolvedRequestType = null;

            /**
             * Resolved response message type.
             * @type {ProtoBuf.Reflect.Message}
             * @expose
             */
            this.resolvedResponseType = null;
        };

        // Extends Method
        RPCMethod.prototype = Object.create(Method.prototype);

        /**
         * @alias ProtoBuf.Reflect.Service.RPCMethod
         * @expose
         */
        Reflect.Service.RPCMethod = RPCMethod;

        return Reflect;

    })(ProtoBuf);

    /**
     * @alias ProtoBuf.Builder
     * @expose
     */
    ProtoBuf.Builder = (function(ProtoBuf, Lang, Reflect) {
        "use strict";

        /**
         * Constructs a new Builder.
         * @exports ProtoBuf.Builder
         * @class Provides the functionality to build protocol messages.
         * @param {Object.<string,*>=} options Options
         * @constructor
         */
        var Builder = function(options) {

            /**
             * Namespace.
             * @type {ProtoBuf.Reflect.Namespace}
             * @expose
             */
            this.ns = new Reflect.Namespace(this, null, ""); // Global namespace

            /**
             * Namespace pointer.
             * @type {ProtoBuf.Reflect.T}
             * @expose
             */
            this.ptr = this.ns;

            /**
             * Resolved flag.
             * @type {boolean}
             * @expose
             */
            this.resolved = false;

            /**
             * The current building result.
             * @type {Object.<string,ProtoBuf.Builder.Message|Object>|null}
             * @expose
             */
            this.result = null;

            /**
             * Imported files.
             * @type {Array.<string>}
             * @expose
             */
            this.files = {};

            /**
             * Import root override.
             * @type {?string}
             * @expose
             */
            this.importRoot = null;

            /**
             * Options.
             * @type {!Object.<string, *>}
             * @expose
             */
            this.options = options || {};
        };

        /**
         * @alias ProtoBuf.Builder.prototype
         * @inner
         */
        var BuilderPrototype = Builder.prototype;

        // ----- Definition tests -----

        /**
         * Tests if a definition most likely describes a message.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isMessage = function(def) {
            // Messages require a string name
            if (typeof def["name"] !== 'string')
                return false;
            // Messages do not contain values (enum) or rpc methods (service)
            if (typeof def["values"] !== 'undefined' || typeof def["rpc"] !== 'undefined')
                return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes a message field.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isMessageField = function(def) {
            // Message fields require a string rule, name and type and an id
            if (typeof def["rule"] !== 'string' || typeof def["name"] !== 'string' || typeof def["type"] !== 'string' || typeof def["id"] === 'undefined')
                return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes an enum.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isEnum = function(def) {
            // Enums require a string name
            if (typeof def["name"] !== 'string')
                return false;
            // Enums require at least one value
            if (typeof def["values"] === 'undefined' || !Array.isArray(def["values"]) || def["values"].length === 0)
                return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes a service.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isService = function(def) {
            // Services require a string name and an rpc object
            if (typeof def["name"] !== 'string' || typeof def["rpc"] !== 'object' || !def["rpc"])
                return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes an extended message
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isExtend = function(def) {
            // Extends rquire a string ref
            if (typeof def["ref"] !== 'string')
                return false;
            return true;
        };

        // ----- Building -----

        /**
         * Resets the pointer to the root namespace.
         * @returns {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.reset = function() {
            this.ptr = this.ns;
            return this;
        };

        /**
         * Defines a namespace on top of the current pointer position and places the pointer on it.
         * @param {string} namespace
         * @return {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.define = function(namespace) {
            if (typeof namespace !== 'string' || !Lang.TYPEREF.test(namespace))
                throw Error("illegal namespace: "+namespace);
            namespace.split(".").forEach(function(part) {
                var ns = this.ptr.getChild(part);
                if (ns === null) // Keep existing
                    this.ptr.addChild(ns = new Reflect.Namespace(this, this.ptr, part));
                this.ptr = ns;
            }, this);
            return this;
        };

        /**
         * Creates the specified definitions at the current pointer position.
         * @param {!Array.<!Object>} defs Messages, enums or services to create
         * @returns {!ProtoBuf.Builder} this
         * @throws {Error} If a message definition is invalid
         * @expose
         */
        BuilderPrototype.create = function(defs) {
            if (!defs)
                return this; // Nothing to create
            if (!Array.isArray(defs))
                defs = [defs];
            else {
                if (defs.length === 0)
                    return this;
                defs = defs.slice();
            }

            // It's quite hard to keep track of scopes and memory here, so let's do this iteratively.
            var stack = [defs];
            while (stack.length > 0) {
                defs = stack.pop();

                if (!Array.isArray(defs)) // Stack always contains entire namespaces
                    throw Error("not a valid namespace: "+JSON.stringify(defs));

                while (defs.length > 0) {
                    var def = defs.shift(); // Namespaces always contain an array of messages, enums and services

                    if (Builder.isMessage(def)) {
                        var obj = new Reflect.Message(this, this.ptr, def["name"], def["options"], def["isGroup"], def["syntax"]);

                        // Create OneOfs
                        var oneofs = {};
                        if (def["oneofs"])
                            Object.keys(def["oneofs"]).forEach(function(name) {
                                obj.addChild(oneofs[name] = new Reflect.Message.OneOf(this, obj, name));
                            }, this);

                        // Create fields
                        if (def["fields"])
                            def["fields"].forEach(function(fld) {
                                if (obj.getChild(fld["id"]|0) !== null)
                                    throw Error("duplicate or invalid field id in "+obj.name+": "+fld['id']);
                                if (fld["options"] && typeof fld["options"] !== 'object')
                                    throw Error("illegal field options in "+obj.name+"#"+fld["name"]);
                                var oneof = null;
                                if (typeof fld["oneof"] === 'string' && !(oneof = oneofs[fld["oneof"]]))
                                    throw Error("illegal oneof in "+obj.name+"#"+fld["name"]+": "+fld["oneof"]);
                                fld = new Reflect.Message.Field(this, obj, fld["rule"], fld["keytype"], fld["type"], fld["name"], fld["id"], fld["options"], oneof, def["syntax"]);
                                if (oneof)
                                    oneof.fields.push(fld);
                                obj.addChild(fld);
                            }, this);

                        // Push children to stack
                        var subObj = [];
                        if (def["enums"])
                            def["enums"].forEach(function(enm) {
                                subObj.push(enm);
                            });
                        if (def["messages"])
                            def["messages"].forEach(function(msg) {
                                subObj.push(msg);
                            });
                        if (def["services"])
                            def["services"].forEach(function(svc) {
                                subObj.push(svc);
                            });

                        // Set extension ranges
                        if (def["extensions"]) {
                            if (typeof def["extensions"][0] === 'number') // pre 5.0.1
                                obj.extensions = [ def["extensions"] ];
                            else
                                obj.extensions = def["extensions"];
                        }

                        // Create on top of current namespace
                        this.ptr.addChild(obj);
                        if (subObj.length > 0) {
                            stack.push(defs); // Push the current level back
                            defs = subObj; // Continue processing sub level
                            subObj = null;
                            this.ptr = obj; // And move the pointer to this namespace
                            obj = null;
                            continue;
                        }
                        subObj = null;

                    } else if (Builder.isEnum(def)) {

                        obj = new Reflect.Enum(this, this.ptr, def["name"], def["options"], def["syntax"]);
                        def["values"].forEach(function(val) {
                            obj.addChild(new Reflect.Enum.Value(this, obj, val["name"], val["id"]));
                        }, this);
                        this.ptr.addChild(obj);

                    } else if (Builder.isService(def)) {

                        obj = new Reflect.Service(this, this.ptr, def["name"], def["options"]);
                        Object.keys(def["rpc"]).forEach(function(name) {
                            var mtd = def["rpc"][name];
                            obj.addChild(new Reflect.Service.RPCMethod(this, obj, name, mtd["request"], mtd["response"], !!mtd["request_stream"], !!mtd["response_stream"], mtd["options"]));
                        }, this);
                        this.ptr.addChild(obj);

                    } else if (Builder.isExtend(def)) {

                        obj = this.ptr.resolve(def["ref"], true);
                        if (obj) {
                            def["fields"].forEach(function(fld) {
                                if (obj.getChild(fld['id']|0) !== null)
                                    throw Error("duplicate extended field id in "+obj.name+": "+fld['id']);
                                // Check if field id is allowed to be extended
                                if (obj.extensions) {
                                    var valid = false;
                                    obj.extensions.forEach(function(range) {
                                        if (fld["id"] >= range[0] && fld["id"] <= range[1])
                                            valid = true;
                                    });
                                    if (!valid)
                                        throw Error("illegal extended field id in "+obj.name+": "+fld['id']+" (not within valid ranges)");
                                }
                                // Convert extension field names to camel case notation if the override is set
                                var name = fld["name"];
                                if (this.options['convertFieldsToCamelCase'])
                                    name = ProtoBuf.Util.toCamelCase(name);
                                // see #161: Extensions use their fully qualified name as their runtime key and...
                                var field = new Reflect.Message.ExtensionField(this, obj, fld["rule"], fld["type"], this.ptr.fqn()+'.'+name, fld["id"], fld["options"]);
                                // ...are added on top of the current namespace as an extension which is used for
                                // resolving their type later on (the extension always keeps the original name to
                                // prevent naming collisions)
                                var ext = new Reflect.Extension(this, this.ptr, fld["name"], field);
                                field.extension = ext;
                                this.ptr.addChild(ext);
                                obj.addChild(field);
                            }, this);

                        } else if (!/\.?google\.protobuf\./.test(def["ref"])) // Silently skip internal extensions
                            throw Error("extended message "+def["ref"]+" is not defined");

                    } else
                        throw Error("not a valid definition: "+JSON.stringify(def));

                    def = null;
                    obj = null;
                }
                // Break goes here
                defs = null;
                this.ptr = this.ptr.parent; // Namespace done, continue at parent
            }
            this.resolved = false; // Require re-resolve
            this.result = null; // Require re-build
            return this;
        };

        /**
         * Propagates syntax to all children.
         * @param {!Object} parent
         * @inner
         */
        function propagateSyntax(parent) {
            if (parent['messages']) {
                parent['messages'].forEach(function(child) {
                    child["syntax"] = parent["syntax"];
                    propagateSyntax(child);
                });
            }
            if (parent['enums']) {
                parent['enums'].forEach(function(child) {
                    child["syntax"] = parent["syntax"];
                });
            }
        }

        /**
         * Imports another definition into this builder.
         * @param {Object.<string,*>} json Parsed import
         * @param {(string|{root: string, file: string})=} filename Imported file name
         * @returns {!ProtoBuf.Builder} this
         * @throws {Error} If the definition or file cannot be imported
         * @expose
         */
        BuilderPrototype["import"] = function(json, filename) {
            var delim = '/';

            // Make sure to skip duplicate imports

            if (typeof filename === 'string') {

                if (ProtoBuf.Util.IS_NODE)
                    filename = require("path")['resolve'](filename);
                if (this.files[filename] === true)
                    return this.reset();
                this.files[filename] = true;

            } else if (typeof filename === 'object') { // Object with root, file.

                var root = filename.root;
                if (ProtoBuf.Util.IS_NODE)
                    root = require("path")['resolve'](root);
                if (root.indexOf("\\") >= 0 || filename.file.indexOf("\\") >= 0)
                    delim = '\\';
                var fname = root + delim + filename.file;
                if (this.files[fname] === true)
                    return this.reset();
                this.files[fname] = true;
            }

            // Import imports

            if (json['imports'] && json['imports'].length > 0) {
                var importRoot,
                    resetRoot = false;

                if (typeof filename === 'object') { // If an import root is specified, override

                    this.importRoot = filename["root"]; resetRoot = true; // ... and reset afterwards
                    importRoot = this.importRoot;
                    filename = filename["file"];
                    if (importRoot.indexOf("\\") >= 0 || filename.indexOf("\\") >= 0)
                        delim = '\\';

                } else if (typeof filename === 'string') {

                    if (this.importRoot) // If import root is overridden, use it
                        importRoot = this.importRoot;
                    else { // Otherwise compute from filename
                        if (filename.indexOf("/") >= 0) { // Unix
                            importRoot = filename.replace(/\/[^\/]*$/, "");
                            if (/* /file.proto */ importRoot === "")
                                importRoot = "/";
                        } else if (filename.indexOf("\\") >= 0) { // Windows
                            importRoot = filename.replace(/\\[^\\]*$/, "");
                            delim = '\\';
                        } else
                            importRoot = ".";
                    }

                } else
                    importRoot = null;

                for (var i=0; i<json['imports'].length; i++) {
                    if (typeof json['imports'][i] === 'string') { // Import file
                        if (!importRoot)
                            throw Error("cannot determine import root");
                        var importFilename = json['imports'][i];
                        if (importFilename === "google/protobuf/descriptor.proto")
                            continue; // Not needed and therefore not used
                        importFilename = importRoot + delim + importFilename;
                        if (this.files[importFilename] === true)
                            continue; // Already imported
                        if (/\.proto$/i.test(importFilename) && !ProtoBuf.DotProto)       // If this is a light build
                            importFilename = importFilename.replace(/\.proto$/, ".json"); // always load the JSON file
                        var contents = ProtoBuf.Util.fetch(importFilename);
                        if (contents === null)
                            throw Error("failed to import '"+importFilename+"' in '"+filename+"': file not found");
                        if (/\.json$/i.test(importFilename)) // Always possible
                            this["import"](JSON.parse(contents+""), importFilename); // May throw
                        else
                            this["import"](ProtoBuf.DotProto.Parser.parse(contents), importFilename); // May throw
                    } else // Import structure
                        if (!filename)
                            this["import"](json['imports'][i]);
                        else if (/\.(\w+)$/.test(filename)) // With extension: Append _importN to the name portion to make it unique
                            this["import"](json['imports'][i], filename.replace(/^(.+)\.(\w+)$/, function($0, $1, $2) { return $1+"_import"+i+"."+$2; }));
                        else // Without extension: Append _importN to make it unique
                            this["import"](json['imports'][i], filename+"_import"+i);
                }
                if (resetRoot) // Reset import root override when all imports are done
                    this.importRoot = null;
            }

            // Import structures

            if (json['package'])
                this.define(json['package']);
            if (json['syntax'])
                propagateSyntax(json);
            var base = this.ptr;
            if (json['options'])
                Object.keys(json['options']).forEach(function(key) {
                    base.options[key] = json['options'][key];
                });
            if (json['messages'])
                this.create(json['messages']),
                this.ptr = base;
            if (json['enums'])
                this.create(json['enums']),
                this.ptr = base;
            if (json['services'])
                this.create(json['services']),
                this.ptr = base;
            if (json['extends'])
                this.create(json['extends']);

            return this.reset();
        };

        /**
         * Resolves all namespace objects.
         * @throws {Error} If a type cannot be resolved
         * @returns {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.resolveAll = function() {
            // Resolve all reflected objects
            var res;
            if (this.ptr == null || typeof this.ptr.type === 'object')
                return this; // Done (already resolved)

            if (this.ptr instanceof Reflect.Namespace) { // Resolve children

                this.ptr.children.forEach(function(child) {
                    this.ptr = child;
                    this.resolveAll();
                }, this);

            } else if (this.ptr instanceof Reflect.Message.Field) { // Resolve type

                if (!Lang.TYPE.test(this.ptr.type)) {
                    if (!Lang.TYPEREF.test(this.ptr.type))
                        throw Error("illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                    res = (this.ptr instanceof Reflect.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, true);
                    if (!res)
                        throw Error("unresolvable type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                    this.ptr.resolvedType = res;
                    if (res instanceof Reflect.Enum) {
                        this.ptr.type = ProtoBuf.TYPES["enum"];
                        if (this.ptr.syntax === 'proto3' && res.syntax !== 'proto3')
                            throw Error("proto3 message cannot reference proto2 enum");
                    }
                    else if (res instanceof Reflect.Message)
                        this.ptr.type = res.isGroup ? ProtoBuf.TYPES["group"] : ProtoBuf.TYPES["message"];
                    else
                        throw Error("illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                } else
                    this.ptr.type = ProtoBuf.TYPES[this.ptr.type];

                // If it's a map field, also resolve the key type. The key type can be only a numeric, string, or bool type
                // (i.e., no enums or messages), so we don't need to resolve against the current namespace.
                if (this.ptr.map) {
                    if (!Lang.TYPE.test(this.ptr.keyType))
                        throw Error("illegal key type for map field in "+this.ptr.toString(true)+": "+this.ptr.keyType);
                    this.ptr.keyType = ProtoBuf.TYPES[this.ptr.keyType];
                }

            } else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {

                if (this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod) {
                    res = this.ptr.parent.resolve(this.ptr.requestName, true);
                    if (!res || !(res instanceof ProtoBuf.Reflect.Message))
                        throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.requestName);
                    this.ptr.resolvedRequestType = res;
                    res = this.ptr.parent.resolve(this.ptr.responseName, true);
                    if (!res || !(res instanceof ProtoBuf.Reflect.Message))
                        throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.responseName);
                    this.ptr.resolvedResponseType = res;
                } else // Should not happen as nothing else is implemented
                    throw Error("illegal service type in "+this.ptr.toString(true));

            } else if (
                !(this.ptr instanceof ProtoBuf.Reflect.Message.OneOf) && // Not built
                !(this.ptr instanceof ProtoBuf.Reflect.Extension) && // Not built
                !(this.ptr instanceof ProtoBuf.Reflect.Enum.Value) // Built in enum
            )
                throw Error("illegal object in namespace: "+typeof(this.ptr)+": "+this.ptr);

            return this.reset();
        };

        /**
         * Builds the protocol. This will first try to resolve all definitions and, if this has been successful,
         * return the built package.
         * @param {(string|Array.<string>)=} path Specifies what to return. If omitted, the entire namespace will be returned.
         * @returns {!ProtoBuf.Builder.Message|!Object.<string,*>}
         * @throws {Error} If a type could not be resolved
         * @expose
         */
        BuilderPrototype.build = function(path) {
            this.reset();
            if (!this.resolved)
                this.resolveAll(),
                this.resolved = true,
                this.result = null; // Require re-build
            if (this.result === null) // (Re-)Build
                this.result = this.ns.build();
            if (!path)
                return this.result;
            var part = typeof path === 'string' ? path.split(".") : path,
                ptr = this.result; // Build namespace pointer (no hasChild etc.)
            for (var i=0; i<part.length; i++)
                if (ptr[part[i]])
                    ptr = ptr[part[i]];
                else {
                    ptr = null;
                    break;
                }
            return ptr;
        };

        /**
         * Similar to {@link ProtoBuf.Builder#build}, but looks up the internal reflection descriptor.
         * @param {string=} path Specifies what to return. If omitted, the entire namespace wiil be returned.
         * @param {boolean=} excludeNonNamespace Excludes non-namespace types like fields, defaults to `false`
         * @returns {?ProtoBuf.Reflect.T} Reflection descriptor or `null` if not found
         */
        BuilderPrototype.lookup = function(path, excludeNonNamespace) {
            return path ? this.ns.resolve(path, excludeNonNamespace) : this.ns;
        };

        /**
         * Returns a string representation of this object.
         * @return {string} String representation as of "Builder"
         * @expose
         */
        BuilderPrototype.toString = function() {
            return "Builder";
        };

        // ----- Base classes -----
        // Exist for the sole purpose of being able to "... instanceof ProtoBuf.Builder.Message" etc.

        /**
         * @alias ProtoBuf.Builder.Message
         */
        Builder.Message = function() {};

        /**
         * @alias ProtoBuf.Builder.Enum
         */
        Builder.Enum = function() {};

        /**
         * @alias ProtoBuf.Builder.Message
         */
        Builder.Service = function() {};

        return Builder;

    })(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect);

    /**
     * @alias ProtoBuf.Map
     * @expose
     */
    ProtoBuf.Map = (function(ProtoBuf, Reflect) {
        "use strict";

        /**
         * Constructs a new Map. A Map is a container that is used to implement map
         * fields on message objects. It closely follows the ES6 Map API; however,
         * it is distinct because we do not want to depend on external polyfills or
         * on ES6 itself.
         *
         * @exports ProtoBuf.Map
         * @param {!ProtoBuf.Reflect.Field} field Map field
         * @param {Object.<string,*>=} contents Initial contents
         * @constructor
         */
        var Map = function(field, contents) {
            if (!field.map)
                throw Error("field is not a map");

            /**
             * The field corresponding to this map.
             * @type {!ProtoBuf.Reflect.Field}
             */
            this.field = field;

            /**
             * Element instance corresponding to key type.
             * @type {!ProtoBuf.Reflect.Element}
             */
            this.keyElem = new Reflect.Element(field.keyType, null, true, field.syntax);

            /**
             * Element instance corresponding to value type.
             * @type {!ProtoBuf.Reflect.Element}
             */
            this.valueElem = new Reflect.Element(field.type, field.resolvedType, false, field.syntax);

            /**
             * Internal map: stores mapping of (string form of key) -> (key, value)
             * pair.
             *
             * We provide map semantics for arbitrary key types, but we build on top
             * of an Object, which has only string keys. In order to avoid the need
             * to convert a string key back to its native type in many situations,
             * we store the native key value alongside the value. Thus, we only need
             * a one-way mapping from a key type to its string form that guarantees
             * uniqueness and equality (i.e., str(K1) === str(K2) if and only if K1
             * === K2).
             *
             * @type {!Object<string, {key: *, value: *}>}
             */
            this.map = {};

            /**
             * Returns the number of elements in the map.
             */
            Object.defineProperty(this, "size", {
                get: function() { return Object.keys(this.map).length; }
            });

            // Fill initial contents from a raw object.
            if (contents) {
                var keys = Object.keys(contents);
                for (var i = 0; i < keys.length; i++) {
                    var key = this.keyElem.valueFromString(keys[i]);
                    var val = this.valueElem.verifyValue(contents[keys[i]]);
                    this.map[this.keyElem.valueToString(key)] =
                        { key: key, value: val };
                }
            }
        };

        var MapPrototype = Map.prototype;

        /**
         * Helper: return an iterator over an array.
         * @param {!Array<*>} arr the array
         * @returns {!Object} an iterator
         * @inner
         */
        function arrayIterator(arr) {
            var idx = 0;
            return {
                next: function() {
                    if (idx < arr.length)
                        return { done: false, value: arr[idx++] };
                    return { done: true };
                }
            }
        }

        /**
         * Clears the map.
         */
        MapPrototype.clear = function() {
            this.map = {};
        };

        /**
         * Deletes a particular key from the map.
         * @returns {boolean} Whether any entry with this key was deleted.
         */
        MapPrototype["delete"] = function(key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            var hadKey = keyValue in this.map;
            delete this.map[keyValue];
            return hadKey;
        };

        /**
         * Returns an iterator over [key, value] pairs in the map.
         * @returns {Object} The iterator
         */
        MapPrototype.entries = function() {
            var entries = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0, entry; i < strKeys.length; i++)
                entries.push([(entry=this.map[strKeys[i]]).key, entry.value]);
            return arrayIterator(entries);
        };

        /**
         * Returns an iterator over keys in the map.
         * @returns {Object} The iterator
         */
        MapPrototype.keys = function() {
            var keys = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0; i < strKeys.length; i++)
                keys.push(this.map[strKeys[i]].key);
            return arrayIterator(keys);
        };

        /**
         * Returns an iterator over values in the map.
         * @returns {!Object} The iterator
         */
        MapPrototype.values = function() {
            var values = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0; i < strKeys.length; i++)
                values.push(this.map[strKeys[i]].value);
            return arrayIterator(values);
        };

        /**
         * Iterates over entries in the map, calling a function on each.
         * @param {function(this:*, *, *, *)} cb The callback to invoke with value, key, and map arguments.
         * @param {Object=} thisArg The `this` value for the callback
         */
        MapPrototype.forEach = function(cb, thisArg) {
            var strKeys = Object.keys(this.map);
            for (var i = 0, entry; i < strKeys.length; i++)
                cb.call(thisArg, (entry=this.map[strKeys[i]]).value, entry.key, this);
        };

        /**
         * Sets a key in the map to the given value.
         * @param {*} key The key
         * @param {*} value The value
         * @returns {!ProtoBuf.Map} The map instance
         */
        MapPrototype.set = function(key, value) {
            var keyValue = this.keyElem.verifyValue(key);
            var valValue = this.valueElem.verifyValue(value);
            this.map[this.keyElem.valueToString(keyValue)] =
                { key: keyValue, value: valValue };
            return this;
        };

        /**
         * Gets the value corresponding to a key in the map.
         * @param {*} key The key
         * @returns {*|undefined} The value, or `undefined` if key not present
         */
        MapPrototype.get = function(key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            if (!(keyValue in this.map))
                return undefined;
            return this.map[keyValue].value;
        };

        /**
         * Determines whether the given key is present in the map.
         * @param {*} key The key
         * @returns {boolean} `true` if the key is present
         */
        MapPrototype.has = function(key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            return (keyValue in this.map);
        };

        return Map;
    })(ProtoBuf, ProtoBuf.Reflect);


    /**
     * Loads a .proto string and returns the Builder.
     * @param {string} proto .proto file contents
     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.loadProto = function(proto, builder, filename) {
        if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
            filename = builder,
            builder = undefined;
        return ProtoBuf.loadJson(ProtoBuf.DotProto.Parser.parse(proto), builder, filename);
    };

    /**
     * Loads a .proto string and returns the Builder. This is an alias of {@link ProtoBuf.loadProto}.
     * @function
     * @param {string} proto .proto file contents
     * @param {(ProtoBuf.Builder|string)=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.protoFromString = ProtoBuf.loadProto; // Legacy

    /**
     * Loads a .proto file and returns the Builder.
     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.loadProtoFile = function(filename, callback, builder) {
        if (callback && typeof callback === 'object')
            builder = callback,
            callback = null;
        else if (!callback || typeof callback !== 'function')
            callback = null;
        if (callback)
            return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
                if (contents === null) {
                    callback(Error("Failed to fetch file"));
                    return;
                }
                try {
                    callback(null, ProtoBuf.loadProto(contents, builder, filename));
                } catch (e) {
                    callback(e);
                }
            });
        var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
        return contents === null ? null : ProtoBuf.loadProto(contents, builder, filename);
    };

    /**
     * Loads a .proto file and returns the Builder. This is an alias of {@link ProtoBuf.loadProtoFile}.
     * @function
     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {!ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile; // Legacy


    /**
     * Constructs a new empty Builder.
     * @param {Object.<string,*>=} options Builder options, defaults to global options set on ProtoBuf
     * @return {!ProtoBuf.Builder} Builder
     * @expose
     */
    ProtoBuf.newBuilder = function(options) {
        options = options || {};
        if (typeof options['convertFieldsToCamelCase'] === 'undefined')
            options['convertFieldsToCamelCase'] = ProtoBuf.convertFieldsToCamelCase;
        if (typeof options['populateAccessors'] === 'undefined')
            options['populateAccessors'] = ProtoBuf.populateAccessors;
        return new ProtoBuf.Builder(options);
    };

    /**
     * Loads a .json definition and returns the Builder.
     * @param {!*|string} json JSON definition
     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.loadJson = function(json, builder, filename) {
        if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
            filename = builder,
            builder = null;
        if (!builder || typeof builder !== 'object')
            builder = ProtoBuf.newBuilder();
        if (typeof json === 'string')
            json = JSON.parse(json);
        builder["import"](json, filename);
        builder.resolveAll();
        return builder;
    };

    /**
     * Loads a .json file and returns the Builder.
     * @param {string|!{root: string, file: string}} filename Path to json file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.loadJsonFile = function(filename, callback, builder) {
        if (callback && typeof callback === 'object')
            builder = callback,
            callback = null;
        else if (!callback || typeof callback !== 'function')
            callback = null;
        if (callback)
            return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
                if (contents === null) {
                    callback(Error("Failed to fetch file"));
                    return;
                }
                try {
                    callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));
                } catch (e) {
                    callback(e);
                }
            });
        var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
        return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);
    };

//    return ProtoBuf;
//});




var _rootfloor = /*dcodeIO.*/ProtoBuf.newBuilder({})['import']({
    // "package": "protobuf",
    // "syntax": "proto2",
    // "options": {
    //     "java_package": "com.fengmap.platform.protobuf",
    //     "java_outer_classname": "FloorConfigProtoBuf"
    // },
    "messages": [
        {
            "name": "FloorGeo",
            "syntax": "proto2",
            "fields": [
                {
                    "rule": "required",
                    "type": "string",
                    "name": "mid",
                    "id": 1
                },
                {
                    "rule": "required",
                    "type": "int32",
                    "name": "gid",
                    "id": 2
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "height",
                    "id": 3
                },
                {
                    "rule": "repeated",
                    "type": "GeneralGeoInfo",
                    "name": "extentLayer",
                    "id": 4
                },
                {
                    "rule": "repeated",
                    "type": "GeneralGeoInfo",
                    "name": "modelLayer",
                    "id": 5
                },
                {
                    "rule": "repeated",
                    "type": "GeneralGeoInfo",
                    "name": "labelLayer",
                    "id": 6
                },
                {
                    "rule": "repeated",
                    "type": "GeneralGeoInfo",
                    "name": "poiLayer",
                    "id": 7
                },
                {
                    "rule": "repeated",
                    "type": "GeneralGeoInfo",
                    "name": "polygonLayer",
                    "id": 8
                },
                {
                    "rule": "repeated",
                    "type": "GeneralGeoInfo",
                    "name": "polygonLabelLayer",
                    "id": 9
                },
                {
                    "rule": "repeated",
                    "type": "GeneralGeoInfo",
                    "name": "liftLayer",
                    "id": 10
                },
                {
                    "rule": "repeated",
                    "type": "GeneralGeoInfo",
                    "name": "stairLayer",
                    "id": 11
                },
                {
                    "rule": "repeated",
                    "type": "GeneralGeoInfo",
                    "name": "escalatorLayer",
                    "id": 12
                },
                {
                    "rule": "repeated",
                    "type": "GeneralGeoInfo",
                    "name": "externalModelLayer",
                    "id": 13
                }
            ],
            "messages": [
                {
                    "name": "GeneralGeoInfo",
                    "syntax": "proto2",
                    "fields": [
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "eid",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "geo",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "float",
                            "name": "height",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "float",
                            "name": "area",
                            "id": 4
                        }
                    ]
                }
            ]
        },
        {
            "name": "FloorBiz",
            "syntax": "proto2",
            "fields": [
                {
                    "rule": "required",
                    "type": "string",
                    "name": "mid",
                    "id": 1
                },
                {
                    "rule": "required",
                    "type": "int32",
                    "name": "gid",
                    "id": 2
                },
                {
                    "rule": "repeated",
                    "type": "ExtentBizInfo",
                    "name": "extentLayer",
                    "id": 3
                },
                {
                    "rule": "repeated",
                    "type": "ModelBizInfo",
                    "name": "modelLayer",
                    "id": 4
                },
                {
                    "rule": "repeated",
                    "type": "LabelBizInfo",
                    "name": "labelLayer",
                    "id": 5
                },
                {
                    "rule": "repeated",
                    "type": "POIBizInfo",
                    "name": "poiLayer",
                    "id": 6
                },
                {
                    "rule": "repeated",
                    "type": "PolygonBizInfo",
                    "name": "polygonLayer",
                    "id": 7
                },
                {
                    "rule": "repeated",
                    "type": "LiftBizInfo",
                    "name": "liftLayer",
                    "id": 8
                },
                {
                    "rule": "repeated",
                    "type": "StairBizInfo",
                    "name": "stairLayer",
                    "id": 9
                },
                {
                    "rule": "repeated",
                    "type": "PolygonLabelBizInfo",
                    "name": "polygonLabelLayer",
                    "id": 10
                },
                {
                    "rule": "repeated",
                    "type": "ExternalModelBizInfo",
                    "name": "externalModelLayer",
                    "id": 11
                }
            ],
            "messages": [
                {
                    "name": "ExtentBizInfo",
                    "syntax": "proto2",
                    "fields": [
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "eid",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "fid",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "type",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "name",
                            "id": 4
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "ename",
                            "id": 5
                        }
                    ]
                },
                {
                    "name": "ModelBizInfo",
                    "syntax": "proto2",
                    "fields": [
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "eid",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "fid",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "type",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "name",
                            "id": 4
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "ename",
                            "id": 5
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "minlevel",
                            "id": 6
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "maxlevel",
                            "id": 7
                        }
                    ]
                },
                {
                    "name": "LabelBizInfo",
                    "syntax": "proto2",
                    "fields": [
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "eid",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "fid",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "type",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "name",
                            "id": 4
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "ename",
                            "id": 5
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "minlevel",
                            "id": 6
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "maxlevel",
                            "id": 7
                        }
                    ]
                },
                {
                    "name": "PolygonBizInfo",
                    "syntax": "proto2",
                    "fields": [
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "eid",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "fid",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "type",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "name",
                            "id": 4
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "ename",
                            "id": 5
                        }
                    ]
                },
                {
                    "name": "POIBizInfo",
                    "syntax": "proto2",
                    "fields": [
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "eid",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "fid",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "type",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "name",
                            "id": 4
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "ename",
                            "id": 5
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "minlevel",
                            "id": 6
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "maxlevel",
                            "id": 7
                        }
                    ]
                },
                {
                    "name": "LiftBizInfo",
                    "syntax": "proto2",
                    "fields": [
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "eid",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "fid",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "type",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "flag",
                            "id": 4
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "floor",
                            "id": 5
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "minlevel",
                            "id": 6
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "maxlevel",
                            "id": 7
                        }
                    ]
                },
                {
                    "name": "StairBizInfo",
                    "syntax": "proto2",
                    "fields": [
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "eid",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "fid",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "type",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "flag",
                            "id": 4
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "minlevel",
                            "id": 5
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "maxlevel",
                            "id": 6
                        }
                    ]
                },
                {
                    "name": "PolygonLabelBizInfo",
                    "syntax": "proto2",
                    "fields": [
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "eid",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "fid",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "type",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "float",
                            "name": "width",
                            "id": 4
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "name",
                            "id": 5
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "ename",
                            "id": 6
                        },
                        {
                            "rule": "optional",
                            "type": "float",
                            "name": "angle",
                            "id": 7
                        }
                    ]
                },
                {
                    "name": "ExternalModelBizInfo",
                    "syntax": "proto2",
                    "fields": [
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "eid",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "fid",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "type",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "name",
                            "id": 4
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "ename",
                            "id": 5
                        }
                    ]
                }
            ]
        },
        {
            "name": "FloorNavi",
            "syntax": "proto2",
            "fields": [
                {
                    "rule": "required",
                    "type": "string",
                    "name": "mid",
                    "id": 1
                },
                {
                    "rule": "required",
                    "type": "int32",
                    "name": "gid",
                    "id": 2
                },
                {
                    "rule": "repeated",
                    "type": "NaviNode",
                    "name": "naviNodes",
                    "id": 3
                },
                {
                    "rule": "repeated",
                    "type": "NaviSegment",
                    "name": "naviSegments",
                    "id": 4
                },
                {
                    "rule": "repeated",
                    "type": "NaviZone",
                    "name": "zones",
                    "id": 5
                }
            ],
            "messages": [
                {
                    "name": "NaviNode",
                    "syntax": "proto2",
                    "fields": [
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "nodeId",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "nodeType",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "liftType",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "liftFlag",
                            "id": 4
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "liftEntry",
                            "id": 5
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "liftFloor",
                            "id": 6
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "linkSeg",
                            "id": 7
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "geo",
                            "id": 8
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "entranceType",
                            "id": 9
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "entranceFloor",
                            "id": 10
                        }
                    ]
                },
                {
                    "name": "NaviSegment",
                    "syntax": "proto2",
                    "fields": [
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "segmentId",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "snode",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "enode",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "double",
                            "name": "length",
                            "id": 4
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "rank",
                            "id": 5
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "name",
                            "id": 6
                        },
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "entry",
                            "id": 7
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "desc",
                            "id": 8
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "geo",
                            "id": 9
                        }
                    ]
                },
                {
                    "name": "NaviZone",
                    "syntax": "proto2",
                    "fields": [
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "id",
                            "id": 1
                        },
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "type",
                            "id": 2,
                            "options": {
                                "default": 0
                            }
                        },
                        {
                            "rule": "required",
                            "type": "string",
                            "name": "geo",
                            "id": 3
                        },
                        {
                            "rule": "repeated",
                            "type": "int32",
                            "name": "rejects",
                            "id": 4
                        }
                    ]
                }
            ]
        }
    ],
    // "isNamespace": true
});
/**
 * Created by CastingJ on 16/3/11.
 */

var _rootmap = /*dcodeIO.*/ProtoBuf.newBuilder({})['import']({
    // "package": "protobuf",
    // "options": {
    //     "java_package": "com.fengmap.platform.protobuf",
    //     "java_outer_classname": "MapProtoBuf"
    // },
    "messages": [
        {
            "name": "Map",
            "fields": [
                {
                    "rule": "required",
                    "type": "string",
                    "name": "mid",
                    "id": 1
                },
                {
                    "rule": "required",
                    "type": "int32",
                    "name": "file_ver",
                    "id": 2
                },
                {
                    "rule": "required",
                    "type": "uint64",
                    "name": "date_ver",
                    "id": 3
                },
                {
                    "rule": "required",
                    "type": "string",
                    "name": "mname",
                    "id": 4
                },
                {
                    "rule": "required",
                    "type": "string",
                    "name": "hash_code",
                    "id": 5
                },
                {
                    "rule": "optional",
                    "type": "string",
                    "name": "key",
                    "id": 6
                },
                {
                    "rule": "optional",
                    "type": "string",
                    "name": "file_date",
                    "id": 7
                },
                {
                    "rule": "optional",
                    "type": "string",
                    "name": "desc",
                    "id": 8
                },
                {
                    "rule": "optional",
                    "type": "bool",
                    "name": "read_only",
                    "id": 9,
                    "options": {
                        "default": false
                    }
                },
                {
                    "rule": "repeated",
                    "type": "Buffer",
                    "name": "buffers",
                    "id": 10
                }
            ],
            "messages": [
                {
                    "name": "Buffer",
                    "fields": [
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "gid",
                            "id": 1
                        },
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "file_ver",
                            "id": 2
                        },
                        {
                            "rule": "required",
                            "type": "int32",
                            "name": "btype",
                            "id": 3
                        },
                        {
                            "rule": "required",
                            "type": "uint64",
                            "name": "len",
                            "id": 4
                        },
                        {
                            "rule": "required",
                            "type": "bytes",
                            "name": "data",
                            "id": 5
                        }
                    ]
                }
            ]
        }
    ]
});
var _rootscene = /*dcodeIO.*/ProtoBuf.newBuilder({})['import']({
    //"package": "protobuf",
    //"options": {
        //"java_package": "com.fengmap.platform.protobuf",
        //"java_outer_classname": "SceneConfigProtoBuf"
    //},
    "messages": [
        {
            "name": "Scene",
            "fields": [
                {
                    "rule": "required",
                    "type": "string",
                    "name": "mid",
                    "id": 19
                },
                {
                    "rule": "required",
                    "type": "int32",
                    "name": "file_ver",
                    "id": 20
                },
                {
                    "rule": "required",
                    "type": "uint64",
                    "name": "date_ver",
                    "id": 21
                },
                {
                    "rule": "required",
                    "type": "string",
                    "name": "mname",
                    "id": 22
                },
                {
                    "rule": "required",
                    "type": "string",
                    "name": "hash_code",
                    "id": 23
                },
                {
                    "rule": "optional",
                    "type": "string",
                    "name": "key",
                    "id": 24
                },
                {
                    "rule": "optional",
                    "type": "string",
                    "name": "desc",
                    "id": 25
                },
                {
                    "rule": "optional",
                    "type": "bool",
                    "name": "read_only",
                    "id": 26,
                    "options": {
                        "default": false
                    }
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "x",
                    "id": 1
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "y",
                    "id": 2
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "z",
                    "id": 3
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "minX",
                    "id": 4
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "minY",
                    "id": 5
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "maxX",
                    "id": 6
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "maxY",
                    "id": 7
                },
                {
                    "rule": "optional",
                    "type": "string",
                    "name": "defGid",
                    "id": 8
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "defCenX",
                    "id": 9
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "defCenY",
                    "id": 10
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "defCenZ",
                    "id": 11
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "height",
                    "id": 12
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "rotateAngleX",
                    "id": 13
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "rotateAngleY",
                    "id": 14
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "rotateAngleZ",
                    "id": 15
                },
                {
                    "rule": "optional",
                    "type": "float",
                    "name": "scale",
                    "id": 16
                },
                {
                    "rule": "optional",
                    "type": "string",
                    "name": "scaleLevel",
                    "id": 17
                },
                {
                    "rule": "repeated",
                    "type": "LayerGroup",
                    "name": "layerGroups",
                    "id": 18
                }
            ],
            "messages": [
                {
                    "name": "Layer",
                    "fields": [
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "lid",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "lname",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "alias",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "Type",
                            "name": "ltype",
                            "id": 4
                        },
                        {
                            "rule": "optional",
                            "type": "float",
                            "name": "offsetX",
                            "id": 5
                        },
                        {
                            "rule": "optional",
                            "type": "float",
                            "name": "offsetY",
                            "id": 6
                        },
                        {
                            "rule": "optional",
                            "type": "float",
                            "name": "height",
                            "id": 7
                        },
                        {
                            "rule": "optional",
                            "type": "float",
                            "name": "rotateAngleX",
                            "id": 8
                        },
                        {
                            "rule": "optional",
                            "type": "float",
                            "name": "rotateAngleY",
                            "id": 9
                        },
                        {
                            "rule": "optional",
                            "type": "float",
                            "name": "rotateAngleZ",
                            "id": 10
                        },
                        {
                            "rule": "optional",
                            "type": "float",
                            "name": "minScaleLevel",
                            "id": 11
                        },
                        {
                            "rule": "optional",
                            "type": "float",
                            "name": "maxScaleLevel",
                            "id": 12
                        },
                        {
                            "rule": "optional",
                            "type": "bool",
                            "name": "isVisible",
                            "id": 13
                        },
                        {
                            "rule": "optional",
                            "type": "bool",
                            "name": "isSelectable",
                            "id": 14
                        },
                        {
                            "rule": "optional",
                            "type": "bool",
                            "name": "isEditable",
                            "id": 15
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "desc",
                            "id": 16
                        }
                    ],
                    "enums": [
                        {
                            "name": "Type",
                            "values": [
                                {
                                    "name": "GEOPOINT",
                                    "id": 1
                                },
                                {
                                    "name": "GEOPOINT_ESCALATOR",
                                    "id": 2
                                },
                                {
                                    "name": "GEOPOINT_LIFT",
                                    "id": 3
                                },
                                {
                                    "name": "GEOPOINT_STAIR",
                                    "id": 4
                                },
                                {
                                    "name": "GEOPOINT_PANORAMA",
                                    "id": 5
                                },
                                {
                                    "name": "GEOPOINT_POI",
                                    "id": 6
                                },
                                {
                                    "name": "GEOPOINT_STORELABEL",
                                    "id": 7
                                },
                                {
                                    "name": "GEOPOINT_NAVINODE",
                                    "id": 8
                                },
                                {
                                    "name": "GEOPOINT_MODEL",
                                    "id": 9
                                },
                                {
                                    "name": "GEOLINE",
                                    "id": 20
                                },
                                {
                                    "name": "GEOLINE_NAVISEGMENT",
                                    "id": 21
                                },
                                {
                                    "name": "GEOLINE_BORDER",
                                    "id": 22
                                },
                                {
                                    "name": "GEOPOLYGON",
                                    "id": 30
                                },
                                {
                                    "name": "GEOPOLYGON_EXTENT",
                                    "id": 31
                                },
                                {
                                    "name": "GEOPOLYGON_STORE",
                                    "id": 32
                                },
                                {
                                    "name": "GEOPOLYGON_LABEL",
                                    "id": 33
                                },
                                {
                                    "name": "RASTERATA",
                                    "id": 40
                                },
                                {
                                    "name": "OVERLAYDATA",
                                    "id": 50
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "LayerGroup",
                    "fields": [
                        {
                            "rule": "optional",
                            "type": "int32",
                            "name": "gid",
                            "id": 1
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "gname",
                            "id": 2
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "alias",
                            "id": 3
                        },
                        {
                            "rule": "optional",
                            "type": "float",
                            "name": "height",
                            "id": 4
                        },
                        {
                            "rule": "optional",
                            "type": "string",
                            "name": "desc",
                            "id": 5
                        },
                        {
                            "rule": "repeated",
                            "type": "Layer",
                            "name": "layers",
                            "id": 6
                        }
                    ]
                }
            ]
        }
    ]
});
/**
 * Created by CastingJ on 16/3/10.
 */

// 反序列化*.fmap文件
function fmMapDecode(data) {
    var map = _rootmap.build("Map").decode(data);
    var mapObj = {};
    mapObj.scene = null;
    mapObj.floors = [];

    for(var i = 0,l = map.buffers.length; i < l; i++)
    {
        var buffer = map.buffers[i];
        var len = buffer.len;
        var start = buffer.data.offset;
        var end = buffer.data.offset + len.low;
        var bufferdata = buffer.data.buffer;
        if(buffer.btype == 1)
        {
            var scene = _rootscene.build("Scene").decode(bufferdata.slice(start,end));
            mapObj.scene = scene;
        }
        else {
            var gid = buffer.gid;
            var existfloor = containsFloor(gid,mapObj.floors);
            var floor = existfloor.floor;
            if(existfloor.index < 0) {
                floor.gid  = gid;
                floor.biz  = [];
                floor.navi = [];
                floor.geo  = [];
            }

            if(buffer.btype == 2)
            {
                var floorGeo = _rootfloor.build("FloorGeo").decode(bufferdata.slice(start,end));
                floor.geo.push(floorGeo);
            }

            if(buffer.btype == 3)
            {
                var floorBiz = _rootfloor.build("FloorBiz").decode(bufferdata.slice(start,end));
                floor.biz.push(floorBiz);
            }

            if(buffer.btype == 4)
            {
                var floorNavi = _rootfloor.build("FloorNavi").decode(bufferdata.slice(start,end));
                floor.navi.push(floorNavi);
            }

            if(existfloor.index < 0) mapObj.floors.push(floor);
            else mapObj.floors[existfloor.index] = floor;
        }
    }

    return mapObj;
}

function containsFloor(gid,floors) {
    for(var i= 0 ,len = floors.length; i <  len; i++) {
        if (floors[i].gid == gid) return {index:i,floor:floors[i]};
    }
    return {index:-1,floor:{}};
}

// 反序列化*.scene.fmap文件
function fmSceneDecode(data) {
    var scene = _rootscene.build("Scene").decode(data);
    return scene;
}

// 反序列化*.floor.geo.fmap文件
function fmFloorGeoDecode(data) {
    var floorGeo = _rootfloor.build("FloorGeo").decode(data);
    return floorGeo;
}

// 反序列化*.floor.biz.fmap文件
function fmFloorBizDecode(data) {
    var floorBiz = _rootfloor.build("FloorBiz").decode(data);
    return floorBiz;
}

// 反序列化*.floor.navi.fmap文件
function fmFloorNaviDecode(data) {
    var floorNavi = _rootfloor.build("FloorNavi").decode(data);
    return floorNavi;
}
/**
 * 
 */

var geo = geo || {};


geo.GData = function() {
	this.points_; // = [];
	this.holes_; // = [[],..]
};

geo.GLEN1 = 'MULTIPOLYGON((('.length;
geo.GLEN2 = 'POINT('.length;

geo.GData.prototype = {
	parse: function(txt) {
		this.points_ = [];
		this.holes_ = [];
		//console.log(txt);
		if (txt.indexOf('MULTIPOLYGON(((') == 0) {

			var xys_s = txt.substring(geo.GLEN1, txt.length - 3).split(/\),\(/);
			//console.log(xys_s.length);
			for (var j = 0; j < xys_s.length; j++) {
				var xys = xys_s[j].split(/,/);
				//console.log(xys);
				if (j == 0) {
					for (var i = 0; i < xys.length; i++) {
						var xy = xys[i].split(' ');
						this.points_.push({
							x: parseFloat(xy[0]),
							y: parseFloat(xy[1])
						});
					}
				} else { //> 0
					var hole = [];
					for (var i = 0; i < xys.length; i++) {
						var xy = xys[i].split(' ');
						hole.push({
							x: parseFloat(xy[0]),
							y: parseFloat(xy[1])
						});
					}
					this.holes_.push(hole);
				}
			}
		} else if (txt.indexOf('POINT(') == 0) {
			var xy = txt.substring(geo.GLEN2, txt.length - 1).split(' ');
			this.points_.push({
				x: parseFloat(xy[0]),
				y: parseFloat(xy[1])
			});
		}

		return this;
	},
	//存储点保留2位，目的是缩小内存
	toFixed: function(val) {
		return +(val.toFixed(2));
	},
	//去除重复的点
	mergePnts: function(arr) {
		var uniqueArr = [],
			ilen = arr.length;
		for (var i = 0; i < ilen; i++) {
			var p = arr[i],
				pt = {
					x: this.toFixed(p.x),
					y: this.toFixed(p.y)
				};
			jlen = uniqueArr.length, isExist = false;
			for (var j = 0; j < jlen; j++) {
				var t = uniqueArr[j];
				if (t.x == pt.x && t.y == pt.y) {
					isExist = true;
					break;
				}
			}

			if (!isExist) uniqueArr.push(pt);
		}

		return uniqueArr;
	},
	toStrip: function(removeLast) {
		var strip = [];
		var len = this.points_.length;
		if (len <= 0) return strip;

		var lastPnt = this.points_.splice(len - 1, 1)[0];
		var uniquePnts = this.mergePnts(this.points_),
			ulen = uniquePnts.length;

		for (var i = 0; i < ulen; i++) {
			var p = uniquePnts[i];
			strip.push(p.x, p.y);
		}

		if (removeLast === true) {

		} else {
			t = {
				x: this.toFixed(lastPnt.x),
				y: this.toFixed(lastPnt.y)
			};
			strip.push(t.x, t.y);
			this.points_.push(lastPnt);
		}
		return strip;
	},
	//	toStrip:function() {
	//		var strip = [];
	//		var len = this.points_.length;
	//		for (var i=0; i<len; i++) {
	//			var p = this.points_[i];
	//			strip.push(p.x, p.y);
	//		}
	//		return strip;
	//	},
	hasHoles: function() {
		return this.holes_ != null && this.holes_.length > 0;
	},
	toStripHoles: function(removeLast) {
		var holes = [];
		for (var j = 0; j < this.holes_.length; j++) {
			var hole = this.holes_[j];
			var strip = [];
			var len = hole.length;

			var lastPnt = hole.splice(len - 1, 1)[0];
			var uniquePnts = this.mergePnts(hole),
				ulen = uniquePnts.length;

			for (var i = 0; i < ulen; i++) {
				var p = uniquePnts[i];
				strip.push(p.x, p.y);
			}

			if (removeLast === true) {

			} else {
				t = {
					x: this.toFixed(lastPnt.x),
					y: this.toFixed(lastPnt.y)
				};
				strip.push(t.x, t.y);
				//hole.push(lastPnt);
			}

			// if (removeLast === true) {
			// 	if (len >= 1) {
			// 		for (var i = 0; i < len - 1; i++) {
			// 			var p = hole[i];
			// 			strip.push(this.toFixed(p.x), this.toFixed(p.y));
			// 		}
			// 	}
			// } else {
			// 	for (var i = 0; i < len; i++) {
			// 		var p = hole[i];
			// 		strip.push(this.toFixed(p.x), this.toFixed(p.y));
			// 	}
			//}
			holes.push(strip);
		}
		return holes;
	},
};
/**
 * 支持自定义轴心的Sprite
 * @param {SpriteMaterial} material Sprite' Material
 * @param {Camera} camera   anchor need a camera
 *
 * prop:
 *     width
 *     height
 *     map
 *     camera: map.currentCamera_
 *     fixedSize: true
 *
 * method:
 *     setAnchor (vector2 | x, y)
 *     setAnchor (('top' | 'left' | 'right' | 'bottom' | 'leftTop' | 'rightTop' | 'leftBottom' | 'rightBottom'), offset([x, y] optional))
 *     setPosition (Vector3 | x, y, z)
 *     setSize(width, height)
 *     update();
 */
(function () {
    function FMSprite(params) {
        // events emitter
        fm.Evento.convert(this);

        fm.Sprite.call(this);

        ///////////////////////
        // inherit FMComponent //
        ///////////////////////
        fengmap.FMComponent.call(this, params.map.componentsManager, this);

        this.anchor = new fm.Vector3();
        this.anchorInput = null;

        this.originPosition = new fm.Vector3();

        this._width = 100;
        this._height = 100;

        this.map = params.map;
        this.camera = params.camera || (params.map && params.map.currentCamera_);

        this._scale = 1;

        this.originScale = new fm.Vector3(1, 1, 1);

        this.fixedSize = params.fixedSize == undefined ? true : params.fixedSize;

        if (params.width && params.height) {
            this.setSize(params.width, params.height);
        }

        if (params.anchor) {
            this.setAnchor(params.anchor);
        }
    }

    FMSprite.prototype = Object.create(fm.Sprite.prototype);

    Object.defineProperties(FMSprite.prototype, {
        width: {
            get: function () {
                return this._width;
            },
            set: function (value) {
                this.setSize(value, this.height);

                if (this.anchorInput) {
                    this.setAnchor.apply(this, this.anchorInput);
                }
            }
        },
        height: {
            get: function () {
                return this._height;
            },
            set: function (value) {
                this.setSize(this.width, value);

                if (this.anchorInput) {
                    this.setAnchor.apply(this, this.anchorInput);
                }
            }
        }
    });

    Object.assign(FMSprite.prototype, fengmap.FMComponent.prototype, {
        constructor: FMSprite,

        // dispose: function () {
        //     Component.prototype.dispose.call(this);
        // },

        // start: function () {
        //     console.log('FMSprite start!');
        // },

        picked: function () {
            console.log('FMSprite picked ---->', this.name);
            this.emit('picked');
        },

        setAnchor: function function_name(vec2) {
            var s = this;

            // record anchor input 
            // use at change size then update anchor
            s.anchorInput = arguments;

            if (arguments.length == 2 && typeof vec2 == 'number') {
                Array.prototype.push.call(arguments, 0);
            } else if (typeof vec2 == 'string') {
                var hw = s.width / 2 ; //* this.originScale.x,
                var hh = s.height / 2; // * this.originScale.y;

                var offset = arguments.length == 2 ? arguments[1] : [0, 0];
                if (offset.length == 1) {offset.push(0);}

                switch (vec2) {
                    case 'center':
                        arguments = [0, 0, 0];
                    break;
                    case 'top':
                        arguments = [0, -hh, 0];
                    break;
                    case 'bottom':
                        arguments = [0, hh, 0];
                    break;
                    case 'left':
                        arguments = [hw, 0, 0];
                    break;
                    case 'right':
                        arguments = [-hw, 0, 0];
                    break;
                    case 'leftTop':
                        arguments = [hw, -hh, 0];
                    break;
                    case 'rightTop':
                        arguments = [-hw, -hh, 0];
                    break;
                    case 'leftBottom':
                        arguments = [hw, hh, 0];
                    break;
                    case 'rightBottom':
                        arguments = [-hw, hh, 0];
                    break;
                    default:
                        arguments = [0, 0, 0];
                    break;
                }

                arguments[0] -= offset[0] * hw * 2;
                arguments[1] -= offset[1] * hh * 2;
            }

            this._setVec3.bind(this, 'anchor').apply(this, arguments);
        },

        setSize: function (width, height) {
            this._width = width;
            this._height = height;

            this._scale = this.getScale();
            this.scale.set(width * this._scale * this.originScale.x, height * this._scale * this.originScale.y);

            if (this.anchorInput) {
                this.setAnchor.apply(this, this.anchorInput);
            }
        },

        getPosition: function () {
            return this.originPosition;
        },

        setPosition: function (vec3) {
            this._setVec3.bind(this, 'originPosition').apply(this, arguments);
        },

        _setVec3: function (prop, vec3) {
            if (vec3 instanceof fm.Vector3) {
                this[prop].copy(vec3);
            } else if (arguments.length == 4) {
                this[prop].set(arguments[1], arguments[2], arguments[3]);
            }
        },

        getScale: function () {
            if (!this.camera || !this.map) {return;}

            var currentCamera = this.map.currentCamera_;

            if (currentCamera instanceof fm.PerspectiveCamera) {

                var v = new fm.Vector3();

                if (this.parent) {
                    v = this.parent.getWorldPosition();
                }

                var hfov = currentCamera.fov * fm.Math.DEG2RAD / 2;
                var dis = currentCamera.position.distanceTo(v.add(this.originPosition));
                return Math.tan(hfov) * dis * 2 / this.map.height;

            } else if (currentCamera instanceof fm.OrthographicCamera ) {

                return currentCamera.top * 2 / currentCamera.zoom / this.map.height;

            }
            
            return 1;
        },

        updateAnchor: function () {
            if (!this.camera) {return;}
            var m = new fm.Matrix4().makeRotationFromQuaternion(this.camera.quaternion);

            if (this.parent) {
                var _m = new fm.Matrix4().makeRotationFromQuaternion(this.parent.quaternion);
                m = m.premultiply(_m.getInverse(_m));
            }

            var v = this.anchor.clone().multiply(this.originScale).applyMatrix4(m).multiplyScalar(this.fixedSize ? this._scale : 1);

            this.position.copy(this.originPosition.clone().add( v ));
        },

        updateSize: function () {
            this._scale = this.getScale();
            this.scale.set(this.width * this._scale * this.originScale.x, this.height * this._scale * this.originScale.y, 1);
        },

        update: function () {
            if (this.fixedSize) {
                this.updateSize();
            }
            this.updateAnchor();
        }

    });

    fengmap.FMSprite = FMSprite;
})();
/**
 * 地图模块是核心。实现加载场景、显示模型、遍历模型、图层控制、主题变换、指南针等方法。同时包含了旋转、点击、模型拾取、放大、缩小等操作控制。
 * @module FMMap
 */

/**
 *	FMMap 是加载场景、显示模型、遍历模型等的主类，一个页面中必须且至少包含一个FMMap对象
 * 	@class FMMap
 *	@constructor
 * 	@module FMMap
 *   @namespace fengmap
 *   @param {object} opts
 *             @param {object} opts.container  加载模型html容器
 *             @param {string} opts.mapServerURL 设置模型路径
 *             @param {string} opts.mapThemeURL  设置主题路径
 *             @param {boolean} opts.useStatic    是否使用静态数据
 *   @demo map/模型初始化.js
 */
fengmap['FMMap'] = function(opts) {
    fengmap.Map.call(this, opts);
    this.gestureEnableController_ = new fengmap.FMMapGestureEnableController(this.mapPicker, this.controls);
    this.popMarkers_ = [];

    // 比例尺
    this.mapScaleLevels = [295829355.45, 147914677.73, 73957338.86, 36978669.43, 18489334.72,
        9244667.36, 4622333.68, 2311166.84, 1155583.42, 577791.71, 288895.85,
        144447.93, 72223.96, 36111.98, 18056, 9028, 4514, 2257, 1128, 564, 282,
        141, 70, 35, 17, 8, 4, 2, 1];

    // attatch function from fengmap.MapUtil
    this._attatchMapUtil();

    // compass
    this.compass = this.compass_;

    this.groupDatas = {};

    // componets manager
    this.componentsManager = new fengmap.FMComponentsManager(this);
};

fengmap['FMMap'].prototype = Object.create(fengmap.Map.prototype, {

});

fengmap['FMMap'].prototype.constructor = fengmap['FMMap'];



/**
 * 根据矩形左下角坐标和右上角坐标获取地图当前的显示级别
 * @method getScalelevelValueByVectics
 * @param {fengmap.mapCoord} startPnt 左下角坐标
 * @param {fengmap.mapCoord} endPnt 右上角坐标
 * @return {int} 当前级别
 * @since v2.0.0
 */

Object.assign(fengmap['FMMap'].prototype, {

    /**
     * 将fengmap.MapUtil常用方法直接挂在Map上
     * 方便调用
     */
    _attatchMapUtil: function() {
        var s = this;
        var fs = [
            // 'setModelMaterialToDefault',
            // 'setModelMaterial',
            'getControlsInfo',
            'getPlatform',

            /**
             * 根据类型别名获取指定楼层上面的某图层
             * @method getLayerByAlias
             * @param {int} groupID  楼层的groupID
             * @param {string} layerAlias  别名，extent, model, label, facility,textMarker,imageMarker
             * @param  {function} callback 查找到后的回调函数
             * @return {array} 包含该类型的图层数组
             * @demo map/图层控制.js
             * @since v2.0.0
             */
            'getLayerByAlias',

            /**
             * 根据类型别名获取所有楼层上面的该类型图层。
             * @method callAllLayersByAlias
             * @param {string | Array} layerAlias  别名，extent, model, label, facility,textMarker,imageMarker
             * @param {function} callback 依次返回所有楼层的图层回调
             * @param {object} callback.layer 查询到的某一楼层的图层
             * @demo map/图层控制.js
             * @since v2.0.0
             */
            'callAllLayersByAlias',
            'getObjectsByAlias',

            /**
             * 根据类型别名获取地图元素数据
             * @method getDatasByAlias
             * @param {int} groupID 楼层的groupID
             * @param {string | Array} alias 别名, 可以为一个string值或一个string数组, 别名: extent, model, label, facility,textMarker,imageMarker
             * @param {function} filter 过滤方法
             * @return {array} 得到的地图元素数据
             */
            'getDatasByAlias',

            /**
             * 数据检索方法
             * @method search
             * @param {fengmap.FMMap} map  当前地图对象。
             * @param {int|Array} gids  待查询的楼层ID数组或某一楼层的楼层ID
             * @param {function} callback  完成查询后的回调，返回查询结果
             * @param  {JSON} query
             *         @param {fengmap.FMNodeType} query.nodeType  某一种查询类型。
             *         @param {string} query.name  地图元素名称，英文字母区分大小写。
             *         @param {string} query.keyword  地图元素关键字，英文字母区分大小写。
             *         @param {string} query.FID  地图元素模型的FID属性
             *         @param {string} query.ID  地图元素ID，针对所有地图元素
             *         @param {string} query.typeID  地图元素的typeID属性，针对'model'和'facility'类型
             *         @param {array}  query.types  查询类型，包括['model', 'label', 'facility', 'imageMarker', 'textMarker', 'locationMarker']，默认是所有。
             * @return {array} 检索到的数据
             * @since v1.2.0
             * @demo search/查询第一层的所有地图元素.js
             * @demo search/根据ID查询模型.JSON
             */
            'search',
            'showAllStairs',
            'stairsConnect',
            'stairsConnectAll',
            'getScalelevelValueByVectics',
            'getMapCoordDistance',
            'getModelLabelObject',
            'getOrCreateLayer'
        ];

        //
        // 不能绑定到 prototype 上，因为有同时多张地图的情况
        //

        // var ptype = Object.getPrototypeOf(s);

        fs.forEach(function(f) {
            // ptype[f] = fengmap.MapUtil[f].bind(null, s);


            s[f] = fengmap.MapUtil[f].bind(null, s);
        });
    },

    /**
     * 地图坐标转场景坐标
     */
    toMapCoord: function(coord) {
        var _y = coord.y;
        var _z = coord.z;
        if (coord instanceof fm.Vector3) {
            _y = coord.z;
            _z = coord.y;
        }
        return {
            x: this.center.x - coord.x,
            y: this.center.y + _y,
            z: _z
        };
    },

    /**
     * 场景坐标转地图坐标
     */
    toSceneCoord: function(coord) {
        var _z = null;
        if (coord.groupID) {
            _z = this.getGroupHeight(coord.groupID);
        }
        return new fm.Vector3(
            this.center.x - coord.x,
            (coord.z || _z || 0),
            coord.y - this.center.y
        );
    },

    visibleOrCreateByFrustum: function() {
        var mp = {
            extent: {
                type: 'extents',
                method: 'createExtents',
                layerAlias: 'extentLayer'
            },
            model: {
                type: 'models',
                method: 'createModels',
                layerAlias: 'modelLayer'
            },
            poi: {
                type: 'pois',
                method: 'createPOIs',
                layerAlias: 'poiLayer'
            },
            label: {
                type: 'labels',
                method: 'createLabels',
                layerAlias: 'labelLayer'
            },
            externalModel: {
                type: 'externalModels',
                method: 'createExternalModels',
                layerAlias: 'externalModelLayer'
            }
        };
        return function(group, gd, type) {
            var s = this;
            var curMapScaleLevel = this.mapScaleLevel;

            var type_ = ['extend', 'model', 'externalModel'].indexOf(type) > 0 ? 'sphere' : null;

            // 这里面是从下面的那个getGroupData方法中向map.mapService.staticScene_.scene_._a
            // 里面添加的一些提取出来的数据
            gd[mp[type].type].forEach(function(et) {


                /**
                 * 在元素实体创建之前调用的过滤回调
                 * fengmap.Map#preCreateFiler
                 */
                if (s.preCreateFilter) {
                    if (s.preCreateFilter(et)) {

                        //
                        // 如果过滤掉了，就直接返回
                        //
                        return;

                    }
                }

                //
                // 如果是label类型，那么先去判断它的 name 属性
                // 如果没有name就直接跳过
                //
                if (type === 'label' && !et.name) {
                    return;
                }

                // add groupID property
                et.groupID = group.groupID;

                var boo = true;

                if (et.minLevel !== undefined && et.minLevel != -1 && (curMapScaleLevel < (et.minLevel + s.options.levelShowOffset) ||
                        curMapScaleLevel > (et.maxLevel + s.options.levelShowOffset))) {
                    boo = false;
                }

                // frustum
                boo = boo && s.mapView.inView(et.collider, type_);

                if (boo && !et.entity) {
                    if (!gd[mp[type].layerAlias]) {
                        gd[mp[type].layerAlias] = group.getOrCreateLayer(type, et, s);

                        //
                        // POI与label一起避让
                        //
                        if (mp[type].layerAlias === 'labelLayer') {
                            gd['labelLayer'].poiLayer = gd['poiLayer'];
                        }

                    }

                    var obj = s.mapScene[mp[type].method](et, gd[mp[type].layerAlias]);

                    if (!obj) {
                        return;
                    }

                    // et.entity = obj.o3d_;
                    et.entity = obj;

                    //
                    // init by initData
                    //
                    if (et.initData) {
                        var keys = Object.keys(et.initData);
                        keys.forEach(function(itm) {
                            et[itm](et.initData[itm]);
                        })

                        delete et.initData;
                    }

                    //
                    // 创建之后的过滤器
                    //
                    /**
                     * 在元素实体创建之后调用的过滤回调
                     * objectCreated
                     */
                    if (s.objectCreated) {
                        s.objectCreated(et);
                    }
                }

                if (et.entity) {

                    if (et.entity.fm_) {
                        et.entity.fm_.show = boo;

                    } else {
                        et.entity.show = boo;

                    }
                }
            });
        }
    }(),

    // lazy create objects
    // query group data
    getGroupData: function(gid, cb) {
        var s = this;

        if (s.groupDatas[gid]) {
            if (cb) {
                cb(s.groupDatas[gid]);
            }

            return s.groupDatas[gid];
        }

        s.mapScene.groups_[gid] = s.mapScene.scene_.scene_data.layerGroups[gid - 1];
        s.mapService.queryGroup(s.sceneId_, gid, function(d) {
            // record
            s.groupDatas[gid] = d;

            s.groupIDs.push(gid);
            s.mapScene.putGroup(gid, d);

            //
            // 计算extent, model, poi, label的collider(boundingSphere)与basePoint
            //
            s._calculateBoundingAndBasePoint(gid, d);

            if (cb) {
                cb(d);
            }
        });
    },

    /**
     * 计算所有元数据的包围盒与基点（sprite）用于视锥创建
     */
    _calculateBoundingAndBasePoint: function() {

        // 计算boundingSphere
        function calculateBoundingSphere(map, arr) {
            var ps = [];
            for (var i = 0, il = arr.length; i < il; i += 2) {
                var p = map.toSceneCoord({
                    x: -arr[i],
                    y: arr[i + 1]
                });
                ps.push(p);
            }

            var bs = new fm.Sphere();

            bs.setFromPoints(ps);
            // 针对点只有一点的数据，如：外部加载的模型，只有一个位置点数据
            if (ps.length === 1) {
                bs.radius = 10;
            }

            return bs;
        }

        // 计算basePoint
        function calculateBasePoint(map, v) {
            return map.toSceneCoord({
                x: -v[0],
                y: v[1]
            });
        }

        /// -----------------------------------------
        /// Node class
        /// ------------------START------------------

        function Node(data) {

            Object.assign(this, data);

            //
            // 在实体未创建之前，用户可以调用一些初始化的简单方法
            // 比如： setColor
            //
            this.initData = {};

        }

        Object.defineProperties(Node.prototype, {

        });

        Node.prototype = {
            constructor: Node,

            setProp: function(method, value) {
                if (this.entity) {
                    if (this.entity[method]) {
                        this.entity[method](value);
                    }
                } else {
                    this.initData[method] = value;
                }
            },

            setColor: function(color) {
                this.setProp('setColor', color);
            }
        }

        /// -------------------END-------------------


        return function(gid, data) {
            var s = this;

            // visibleGroupIDs
            if (s.visibleGroupIDs.indexOf(gid) > -1) {
                s.mapScene.o3dGroups_[gid].visible = true;
            }

            data.extents = data.extents || [];
            data.models = data.models || [];
            data.pois = data.pois || [];
            data.labels = data.labels || [];
            data.externalModels = data.externalModels || [];

            // extents
            data.geo_extentlayers.forEach(function(lay) {
                lay.extents.forEach(function(obj) {
                    obj.groupID = obj.gid;
                    obj.collider = calculateBoundingSphere(s, obj.vertices);
                    obj.collider.center.y += s.options.defaultGroupSpace * (gid - 1);
                    data.extents.push(obj);
                });
            });

            // models
            data.geo_modellayers.forEach(function(lay) {
                lay.models.forEach(function(obj) {

                    // Node
                    obj = new Node(obj);

                    obj.groupID = obj.gid;
                    obj.collider = calculateBoundingSphere(s, obj.vertices);
                    obj.collider.center.y += s.options.defaultGroupSpace * (gid - 1);
                    obj.mapCoord = s.toMapCoord(obj.collider.center);
                    obj.nodeType = 5;
                    obj.ID = obj.oid;
                    obj.FID = obj.fid;
                    obj.typeID = obj.type;
                    data.models.push(obj);
                });
            });

            // external models
            data.geo_externalmodellayer.forEach(function(lay) {
                lay.externals.forEach(function(obj) {
                    obj.groupID = obj.gid;
                    // 注意这里是vertex不是vertices
                    obj.collider = calculateBoundingSphere(s, obj.vertex);
                    obj.collider.center.y += s.options.defaultGroupSpace * (gid - 1);
                    obj.mapCoord = s.toMapCoord(obj.collider.center);
                    obj.nodeType = 100;
                    obj.ID = obj.eid;
                    obj.FID = obj.fid;
                    obj.typeID = obj.type;
                    data.externalModels.push(obj);
                });
            });

            // poi
            data.geo_poilayers.forEach(function(lay) {
                lay.pois.forEach(function(obj) {

                    // Node
                    obj = new Node(obj);

                    obj.groupID = obj.gid;
                    obj.collider = calculateBasePoint(s, obj.vertex);
                    obj.collider.y += s.options.defaultGroupSpace * (gid - 1);
                    obj.mapCoord = s.toMapCoord(obj.collider);
                    obj.nodeType = 11;
                    data.pois.push(obj);
                });
            });

            // label
            data.geo_labellayers.forEach(function(lay) {
                lay.labels.forEach(function(obj) {

                    // Node
                    obj = new Node(obj);

                    obj.groupID = obj.gid;
                    obj.collider = calculateBasePoint(s, obj.vertex);
                    obj.collider.y += s.options.defaultGroupSpace * (gid - 1);
                    obj.mapCoord = s.toMapCoord(obj.collider);
                    obj.nodeType = 12;
                    data.labels.push(obj);
                });
            });
        }

    }(),

    getDataVersion: function() {
        try {
            var ver = this.mapService.staticScene_.scene.date_ver;
            if (ver.low < 0 || ver.low > 100) {
                return 0;
            } else {
                return ver.toInt();
            }
        } catch (e) {
            return 0;
        }
    },

    isOnLine: function(success, failed) {
        // 使用百度Logo判断
        var img = new Image();
        img.onload = function() {
            if (success) {
                success();
            }
        };
        img.onerror = function() {
            if (failed) {
                failed();
            }
        }
        img.style.display = 'none';
        img.src = 'http://www.baidu.com/img/baidu_sylogo1.gif?' + ('' + Math.random()).slice(-6);

        // 使用xhr HEAD 请求判断
        // TODO:
    },

    /**
     * 根据地图ID打开地图。
     * @method openMapById
     * @param  {string|number} sid 场景id
     * @param  {function} failed 遇到错误时的回调函数 (可选)
     */
    openMapById: function(bid, failed) {
        // this.openMap(bid, true);
        // return;

        var s = this;

        s._failedCallback = failed;

        if (!bid) {
            fm.warn(fm.gs(fm.ss.warn_nomapid));
            return;
        }

        if (!fm.getKey(s)) {
            fm.warn(fm.gs(fm.ss.warn_nokey));
            return;
        }

        // check key's format
        var reg = /^[a-zA-z\d]{32}$/;
        if (!reg.test(s.options.key)) {
            fm.warn(fm.gs(fm.ss.warn_keynotright));
            return;
        }

        if (!fm.getAppName(s)) {
            fm.warn(fm.gs(fm.ss.warn_noappname));
            return;
        }

        /**
         * 为了防止有人绕过调用 openMapById
         * 而直接调用openMap 或 openMap_
         * 所以设置一个变量累加做为标识
         */
        s._zopStep_ = 1;

        // 在线处理方法
        function _onLine() {

            fengmap.checkIsOnLine(s, function() {

                fengmap.checkOnLine(s, bid, function(res) {
                    // 成功
                    s.openMap(bid, true);
                }, function(res) {
                    if (res) {
                        // 在线验证返回 success: false
                        // 说明在线认证没有通过
                        // 不打开地图文件

                        // {"error_code":2009,"error_message":"错误的请求"}

                        fm.warn(res.error_code, res.error_message);
                        if (failed) {
                            failed({
                                msg: '线上验证失败!',
                                data: res
                            });
                        }
                    } else {
                        console.warn('offLine 2');
                        // ** 测试使用 ** 在线上验证不通过的情况下
                        // 及打开地图
                        s.openMap(bid, true);
                    }
                });
                // }, 1000);   // 1s timeout

            }, function() {
                console.warn('offLine 1');
                s.openMap(bid, true);
            }, 1000);

        }

        // 离线处理方法
        function _offLine() {
            // 无网,直接打开本地数据
            // 进行本地验证
            s.openMap(bid, true);
        }

        // 这里添加一个设置
        // 主要是为了避免不同的浏览器在navigator.onLine判断是否在线时
        // 有时不能正确的返回结果
        // 所以默认的情况下我们使用navigator.onLine来判断
        // 用户也可以设置另一个兼容一些的onLine判断
        if (s.options.useCompatibleOnLineCheck) {
            s.isOnLine(_onLine, _offLine);
        } else {
            if (navigator.onLine) {
                _onLine();
            } else {
                _offLine();
            }
        }
    },

    // openMapByPath: function(path, success, failed) {
    //     var s = this;
    //     if (navigator.onLine) {
    //         fengmap.checkOnLine(s, bid, function () {
    //            // 成功
    //            s.openMap(bid, true);
    //         }, function () {
    //            // 失败
    //            s.openMap(bid, true);
    //         });
    //     } else {
    //         s.openMap(bid, true);
    //     }
    // },

    // __moveToId: -1,

    /**
     * 视野中心移动到指定位置,如果不是当前聚焦层，将先设置目标层为聚焦层在跳转
     * @method moveTo
     * @param  {JSON} opts
     *         @param {float} opts.x  地图坐标x值。
     *         @param {float} opts.y  地图坐标y值。
     *         @param {float} opts.z  地图坐标z值。
     *         @param {int} opts.groupID  楼层id,跳转到指定位置，并聚焦该楼层。
     *         @param {int} opts.time 目标层不是聚焦层时跳转的动画时间间隔。
     *         @param {function} opts.callback  完成moveTo事件后的回调，返回目标层gid。
     */
    moveTo: function(params) {
        if (!params) {
            return;
        }

        var self = this;

        var groupId = params.groupID ? params.groupID : this.focusGroupId_;
        var group = this.mapScene.getO3dGroup(groupId);

        // 如果跳转层不是当前的焦点层
        // 不要使用 map.focusGroupID = xx; 因为会与 MoveTo 的缓动冲突
        if (groupId != this.focusGroupId_) {
            this.focusGroup_(groupId, {
                notMove: true
            });
            self.emit('focusGroupIDChanged', groupId);
        }

        //*
        var lastPos = this.mapView.camera.position.clone();
        var _y = lastPos.y - this.controls.target.y;

        var pt = new fm.Vector3(-params.x - this.mapScene.sceneX_, group.position.y, params.y - this.mapScene.sceneZ_);

        var lastTarget = self.controls.target.clone();
        var delta = pt.clone().sub(lastTarget);

        // var _del = lastPos.clone().sub(lastTarget);

        // var _newObjectPos = pt.clone().add(_del);

        // var _dir = delta.clone().normalize();
        // var _dis = delta.length();

        // get duration
        var _duration = fmg(params, 'time', 'duration', self.options.moveToAnimateTime);

        clearInterval(this.__moveToId);
        this.__moveToId = fm.Tween.action(
            self.mapView.camera.position,
            self.options.moveToAnimateMode ? _duration : 0,
            null, null,
            function() {
                // 回调
                if (params.callback) {
                    params.callback(groupId);
                }
            },
            function(f) {
                self.controls.target.copy(lastTarget.clone().add(delta.clone().multiplyScalar(f)));
                if (self.viewMode == 'top') {
                    self.mapView.camera.position.copy(lastPos.clone().add(delta.clone().multiplyScalar(f)));
                }
                // else {
                //     var targetPos = self.controls.target.clone();
                //     self.mapView.camera.position.copy(targetPos.add(_dir.clone().multiplyScalar(_dis)));
                // }

                // self.forceUpdate(true);

                self.controls.update({
                    forceTheta: self.controls.constraint.getAzimuthalAngle(),
                    forcePhi: self.controls.constraint.getPolarAngle()
                });

                fengmap.MapUtil.handleLevelShow(self);
            }
        );
        //*/

        this.groupCenter_ = pt;

        return this.__moveToId;
    },

    /**
     * 将视野移动到当前聚焦层的中心点
     * @method moveToCenter
     * @param  {JSON} data {x:, y:, groupID:, duration:(opt), callback:(opt)}
     * @return {null}      null
     */
    moveToCenter: function(data) {
        data = data || {};
        return this.moveTo({
            x: data.x || this.center.x,
            y: data.y || this.center.y,
            groupID: this.focusGroupID,
            duration: fmg(data, 'time', 'duration', .3),
            callback: data.callback
        });
    },

    /**
     * 根据楼层ID，获取某一层模型数据。
     * @method getFMGroup
     * @param  {number} groupID 模型id
     * @return  {fengmap.FMGroup} 返回group对象
     */
    'getFMGroup': function(groupID) {
        var sg = this.mapScene.o3dGroups_[groupID];

        return sg == undefined ? null : sg.fm_; // || new fengmap.FMGroup(sg); // remove lazy method!
    },

    'addPopInfoWin': function(opts) {
        var popMarker = new fengmap.FMPopInfoWindow(this, opts);
        this.popMarkers_.push(popMarker);
        return popMarker;
    },

    'removePopInfoWin': function(marker) {
        if (marker) marker.close();
    },

    'removeAllPopInfoWins': function() {
        for (var i = 0, ilen = this.popMarkers_.length; i < ilen; i++) {
            this.popMarkers_[i].close();
        }
        this.popMarkers_ = [];
    }

});

Object.defineProperties(fengmap['FMMap'].prototype, {

    /**
     * 获取手势绘制类
     * @method getGestureEnableController
     * @return  {fengmap.GestureEnableController} 返回GestureEnableController对象
     * @final
     */
    'gestureEnableController': {
        get: function() {
            return this.gestureEnableController_;
        }
    },

    /**
     * 获取浏览器支持全屏显示状态
     * @method fullScreenAvaliable
     * @return  {bool} true支持，false不支持。返回true时才能使用fullScreen属性设置全屏
     */
    'fullScreenAvaliable': {
        get: function() {
            return fengmap.util.FullScreen.available;
        }
    },

    /**
     * 设置模型窗口全屏状态
     * @property fullScreen
     * @type {boolean}
     * @default false
     */
    'fullScreen': {
        get: function() {
            return fengmap.util.FullScreen.activated;
        },
        set: function(v) {
            if (v) {
                fengmap.util.FullScreen.request(this.mapView.container_);
            } else {
                fengmap.util.FullScreen.canel();
            }
        }
    },

    /**
     * 获取查询类，使用此类可根据ID，GroupID ,KeyWord, name等查询模型、公共设施、自定义标注等地图元素。
     * @property searchAnalyser
     * @type {fengmap.FMSearchAnalyser}
     * @final
     */
    'searchAnalyser': {
        get: function() {
            if (!this.searchAnalyser_) {
                this.searchAnalyser_ = new fengmap.FMSearchAnalyser(this);
                //				console.log(this.searchAnalyser_);
            }
            return this.searchAnalyser_;
        }
    },

    /**
     * 地图针对楼层高度的偏移量，坐标转换的时候z值需要楼层高度+此偏移
     * @property layerLocalHeight
     * @type {int}
     * @final
     */
    "layerLocalHeight": {
        get: function() {
            return 5 + 1;
        }
    }
});

/**
 * 
 */
/*
fengmap.FMGroupInfo = function(sg) {

	this.meta_ = sg.meta_;
	
	//console.log(this.o3d_);
};

fengmap.FMGroupInfo.prototype = {
	
	get groupAlias () {
		return this.meta_.alias;
	},
	get groupDesc () {
		return this.meta_.desc;
	},
	get groupHeight () {
		return this.meta_.height;
	},
	get groupID () {
		return this.meta_.gid;
	},
	get groupLayerCount () {
		return this.meta_.layers.length;
	},
	get groupName() {
		return this.meta_.gname;
	}
	
};
*/

/**
 * 
 */

fengmap.FMLayerInfo = function(sl) {
	
	//this.meta_ = sl.meta_;
	
	this.editable_ = true;
};

fengmap.FMLayerInfo.prototype = {
	get ID() {
		
	},
	get alias() {
		
	},
	get desc() {
		
	},
	get height() {
		
	},
	get name() {
		
	},
	get offsetX() {
		return 0;
	},
	get offsetY() {
		return 0;
	},
	get rotateAngleX() {
		return 0;
	},
	get rotateAngleY() {
		return 0;
	},
	get rotateAngleZ() {
		return 0;
	},
	get type() {
		return 0;
	},
	get editable() {
		this.editable_;
	}
};

/**
 * 
 */


window.onerror = null;












/**
*	FMMapCoord 地图坐标对象
* 	@class FMMapCoord
*	@constructor FMMapCoord
* 	@module FMMap
*   @namespace fengmap
*   @param {float} x  x坐标
*   @param {float} y  y坐标
*   @param {float} z  z坐标
*   @demo map/地图坐标.js
*/

fengmap['FMMapCoord'] = function(x,y,z) {
	
	/**
	 * x坐标
	 * @property x
	 * @type {float}
	 */
	this.x = x;

	/**
	 * y坐标
	 * @property y
	 * @type {float}
	 */
	this.y = y;

	/**
	 * z坐标
	 * @property z
	 * @type {float}
	 */
	this.z = z;
	
	//navi 要调用这个方法 (20161102 将这个方法放到了 prototype 上, 减少内存的占用)
	/*this.setGeoPoint=function(other)
	{
		this.x = other.x;
		this.y = other.y;
	}*/
};

fengmap.FMMapCoord.prototype = {
	constructor: fengmap.FMMapCoord,

	setGeoPoint: function(other) {
		this.x = other.x;
		this.y = other.y;
	}
};

/**
*	FMScreenCoord 屏幕坐标对象
* 	@class FMScreenCoord
*	@constructor
* 	@module FMMap
*   @namespace fengmap
*   @param {float} x  x坐标
*   @param {float} y  y坐标
*/
fengmap['FMScreenCoord'] = function(x, y) {
	/**
	 * x坐标
	 * @property x
	 * @type {float}
	 */
	this.x = x;
	
	/**
	 * y坐标
	 * @property y
	 * @type {float}
	 */
	this.y = y;
}



/**
*	FMMapGestureEnableController 是控制模型能否旋转、倾斜、缩放、点击、移动的类。
* 	@class FMMapGestureEnableController
*	@constructor
* 	@module FMMap
*   @namespace fengmap  
*   @demo map/手势控制.js
*/
fengmap.FMMapGestureEnableController = function(mapPicker, controls) {
	
	this.mapPicker_ = mapPicker;
	
	this.controls_ = controls;

	this.enableMapPan_ = true;
	
	this.enableMapRotate_ = true;
	this.enableMapIncline_ = true;

	this.enableMapPinch_ = true;
	
	this.enableMapSingleTap_ = true;

	this.enableMapHover_ = false;
	
//	this.enableMapDoubletap_ = true;
//	this.enableMapLongPress_ = true;
//	this.enableMapSwipe_ = true;
	
};

fengmap.FMMapGestureEnableController.prototype = {
	/**
	 * 设置能否移动模型
	 * @method enableMapPan
	 * @param  {boolean} value ture是可移动，false不可移动
	 */
	get enableMapPan() {
		return this.enableMapPan_;
	},
	set enableMapPan(value) {
		if (value != this.enableMapPan_) {
			this.enableMapPan_ = value;
			this.controls_.enablePan = value;
		}
	},
	
	/**
	 * 设置能否旋转模型
	 * @method enableMapRotate
	 * @param  {boolean} value ture是可旋转，false不可旋转
	 */
	get enableMapRotate() {
		return this.enableMapRotate_;
	},
	set enableMapRotate(value) {
		if (value != this.enableMapRotate_) {
			this.enableMapRotate_ = value;
			//invalid
//			console.log('set enableMapRotate', value);
//			this.controls_.enableRotate = value;
			//
			
			this.controls_.enableGestureRotate = value;
			
		}
	},

	/**
	 * 设置能否倾斜模型
	 * @method enableMapIncline
	 * @param  {boolean} value ture是可倾斜，false不可倾斜
	 */
	get enableMapIncline() {
		return this.enableMapIncline_;
	},
	set enableMapIncline(value) {
		if (value != this.enableMapIncline_) {
			this.enableMapIncline_ = value;
			//
			
			this.controls_.enableGestureIncline = value;
		}
	},

	/**
	 * 设置能否缩放
	 * @method enableMapPinch
	 * @param  {boolean} value ture是可缩放，false不可缩放
	 */
	get enableMapPinch() {
		return this.enableMapPinch_;
	},
	set enableMapPinch(value) {
		if (value != this.enableMapPinch_) {
			this.enableMapPinch_ = value;
			this.controls_.enableZoom = value;
		}
	},
	
	/**
	 * 设置能否拾取
	 * @method enableMapSingleTap
	 * @param  {boolean} value ture是可拾取，false不可拾取
	 */
	get enableMapSingleTap() {
		return this.enableMapSingleTap_;
	},
	set enableMapSingleTap(value) {
		if (value != this.enableMapSingleTap_) {
			this.enableMapSingleTap_ = value;

			this.mapPicker_.enableClick = value;
			
		}
	},

	/**
	 * 设置能否悬停(PC)
	 * @method enableMapHover
	 * @param  {boolean} value ture是可悬停，false不可悬停
	 */
	get enableMapHover() {
		return this.enableMapHover_;
	},
	set enableMapHover(value) {
		if (value != this.enableMapHover_) {
			this.enableMapHover_ = value;

			this.mapPicker_.enableHover = value;
			
		}
	},
};




/**
 * fengmap JavaScript SDK 支持多种地图元素的图层控制。
 * 包括设置某楼层的文本标签层和公共设施层的隐藏和显示；模型的选中；绘制线图层等。
 * 各个地图元素又包含其固有属性，如地图坐标，ID，楼层ID等信息。
 * @module FMNode
 */

/**
*	FMNode 表示地图元素的基类
* 	@class FMNode
*	@constructor
* 	@module FMNode
*   @namespace fengmap
*/
fengmap.FMNode = function(nodeType, data, o3d, scene) {
//	if (!scene) {
//		console.warn('Must be use map.createXxx create Node!');
//		return;
//	}
	
	if (o3d) {
		o3d.fm_ = this;
	}
	
	this._show = true;
	this._visible = true;

	this._description = {};

	Object.defineProperties(this, {
		/**
		 * 地图元素类型
		 * @property nodeType
		 * @type {object} 返回FMNodeType类型对象
		 */
		'nodeType': {
			enumerable: true,
			get:function(){
				return nodeType;
			}
		},
		scene_: {
			get:function(){
				return scene;
			},
			set:function(v) {
				scene = v;
			}
		},
		o3d_: {
			get:function(){
				return o3d;
			},
			set:function(v){
				o3d = v;
				if (o3d) {
					o3d.fm_ = this;
				}
			},

			// 允许删除此项
			// 因为模型可以合并,原模型会被删除,
			// 去掉这个引用,便于内存的释放
			configurable: true,
			enumerable: false
		},
		data_: {
			enumerable: true,
			get:function() {
				return data;
			}
		}
		
	});

};

//Object.assign(fengmap.FMNode.prototype, {
//});

Object.defineProperties(fengmap.FMNode.prototype, {
	//it's map coord!
	/**
	 * 地图元素中心点对应地图坐标x,
	 * @property x
	 * @type {float}
	 */
	'x':{
		get: function() {
			if (this.scene_) {
				return -this.o3d_.position.x-this.scene_.sceneX_;
			} else {
				return 0;
			}
		},
		set: function(v) {
			if (this.scene_) {
				this.o3d_.position.setX(-v -this.scene_.sceneX_);
			} else {
				this.opts_ = this.opts_ || {};
				this.opts_.x = v;
			}
		}
	},
	/**
	 * 地图元素中心点对应地图坐标y
	 * @property y
	 * @type {float}
	 */
	'y':{
		get: function() {
			if (this.scene_) {
				return this.o3d_.position.z + this.scene_.sceneZ_;
			} else {
				return 0;
			}
		},
		set: function(v) {
			if (this.scene_) {
				this.o3d_.position.setZ(v -this.scene_.sceneZ_);
			} else {
				this.opts_ = this.opts_ || {};
				this.opts_.y = v;
			}
		}
	},
	/**
	 * 地图元素中心点对应地图坐标z
	 * @property z
	 * @type {float}
	 */
	'z':{
		get: function() {
			if (this.scene_) {
				return this.o3d_.position.y;
			} else {
				return 0;
			}
		},
		set: function(v) {
//			if (this.scene_) {
//				this.o3d_.position.setY(this.z_);
//			}
		}
	},
	/**
	 * 地图元素中心点对应地图坐标对象
	 * @property mapCoord
	 * @type {object} 返回FMMapCoord地图坐标对象
	 * @readOnly
	 * @uses fengmap.FMMapCoord
	 */
	'mapCoord':{
		get: function() {
			return new fengmap['FMMapCoord'](this['x'], this['y'], this['z']);
		}
	},
	'parent': {
		get :function() {
			if (this.o3d_.parent) {
				return this.o3d_.parent.fm_;
			} else {
				return null;
			}
		}
	},
	 
	'visible': {
		set: function(value) {

			this._visible = value;
			this.o3d_.visible = this._visible && this._show;
		},		
		get: function() {

			return this._visible;
		}
	},

	/**
	 * 地图元素的显示与隐藏
	 * @property show
	 * @type {boolean} true可见，false不可见
	 */
	show: {
		set: function (value) {
			
			this._show = value;
			this.o3d_.visible = this._visible && this._show;
		},

		get: function () {
			return this._show;
		}
	},
	
	'group': {
		get: function() {
			if (this instanceof fengmap['FMGroup']) {
				return this;
			} else {
				var p = this.parent;
				if (p) {
					if (p instanceof fengmap['FMGroup']) {
						return p;
					} else {
						var pp = p.parent;
						if (pp && pp instanceof fengmap['FMGroup']) {
							return pp;
						}
					}
				}
			}
			return null;
		}
	},
	/**
	 * 获取地图元素所在模型楼层ID
	 * @property groupID
	 * @type {int}
	 * @final
	 */
	'groupID': {
		get: function() {
			if(!this['group']) return null;
			return this['group']['groupID'];
		}
	},

	/**
	 * 地图元素的高度
	 * @property height
	 * @type {int} 高度值
	 */
	height: {
		get: function() {
			if (this.o3d_) {
				if (this.o3d_.initY_ != undefined) {
					return this.o3d_.initY_;	
				} else {
					if (this.o3d_.position) {
						return this.o3d_.position.y;
					}
				}
			}
			return 0;
		},
		set: function(val) {
			if (this.o3d_) {
				if (this.o3d_.initY_ != undefined) {
					this.o3d_.initY_ = val;
				} else if (this.o3d_.position) {
					this.o3d_.position.y = val;
				}
			}
		}
	},

	description: {
		get: function() {
			return this._description;
		},
		set: function(json) {
			Object.assign(this._description, json);
		}
	}
});

Object.assign(fengmap.FMNode.prototype, {
	/**
	 * Node 的 dispose 方法
	 * 将会在父物体上移除
	 */
	dispose: function() {
		if (!this.o3d_) {return;}

		this.o3d_.visible = false;
		var parent = this.o3d_.parent;
		if (parent) {

			// 运行用户自定义的dispose方法,目前用于,从mapPicker中移除物体
			if (this._dispose_) {
				this._dispose_();
			}

			parent.remove(this.o3d_);

			/// -----------------------------------------
			/// remove from webgl
			/// ------------------START------------------
			
			if (this.o3d_.geometry) {
				this.o3d_.geometry.dispose();	
			}
			
			if (this.o3d_.material) {
				this.o3d_.material.dispose();

				if (this.o3d_.material.map) {
					this.o3d_.material.map.dispose();
				}
			}
			
			/// -------------------END-------------------
			

			// 被动模式时, 需要触发一下 update
			if (this.scene_ && this.scene_.map_.passiveMode) {
				this.scene_.map_.forceUpdate(true);
			}

			return true;
		}
	},

	/**
     * 闪烁文本标注，为由小变大的动画效果，次数为1次。
     * @method flash
     * @param {float} time 闪烁时间间隔。默认0.5
     * @param {float} scale 变大级别,值越大标签越大。默认1.5
     */
/*    flash: function(time,scale) {
        this.o3d_.flash({
            scale: scale,
            time: time
        }); //闪烁
    },*/

    // setDescription: function(json) {

    // }
});


/**
 * 初始相机的角度枚举
 */

/**
*	FMDirection 地图方向状态枚举
* 	@class FMDirection
* 	@module FMEnum
*   @namespace fengmap
*/
fengmap.FMDirection = {
	/**
	 * 正北
	 * @property NORTH
	 * @type {string}
	 * @final
	 */
    NORTH: 'n',
    /**
	 * 正南
	 * @property SOUTH
	 * @type {string}
	 * @final
	 */
    SOUTH: 's',
    /**
	 * 正西
	 * @property WEST
	 * @type {string}
	 * @final
	 */
    WEST:  'w',
    /**
	 * 正东
	 * @property EAST
	 * @type {string}
	 * @final
	 */
    EAST:  'e',
    /**
	 * 东北
	 * @property NORTH_EAST
	 * @type {string}
	 * @final
	 */
    NORTH_EAST: 'ne',
    /**
	 * 西北
	 * @property NORTH_WEST
	 * @type {string}
	 * @final
	 */
    NORTH_WEST: 'nw',
    /**
	 * 东南
	 * @property SOUTH_EAST
	 * @type {string}
	 * @final
	 */
    SOUTH_EAST: 'se',
    /**
	 * 西南
	 * @property SOUTH_WEST
	 * @type {string}
	 * @final
	 */
    SOUTH_WEST: 'sw'
};

/**
 * fengmap layer type
 */
fengmap.FMLayerType = {
    NONE: 'none',                   // 空类型
    MODEL_LINE: 'modelLine',        // 模型上面的线框层
    STORE_IMAGE: 'storeImage',      // 店铺上的图片
    POLYGON: 'polygon',
    POLYGON_LABEL: 'polygonLabel',
    EXTERANL_MODEL: 'externalModel',
    IMAGE_MARKER: 'imageMarker',
    STORE_IMAGE: 'storeImage',
    TEXT_MARKER: 'textMarker',
    POLYGON_MARKER: 'polygonMarker'
};

/**
*	FMElementType 通用元素类型枚举
* 	@class FMElementType
* 	@module FMEnum
*   @namespace fengmap
*/
fengmap.FMElementType = {
	/**
	 * 通用类型
	 * @property NONE
	 * @type {string}
	 * @final
	 */
    NONE: 'none',
    STORE_IMAGE: 'storeImage',
    POLYGON: 'polygon',
    POLYGON_LABEL: 'polygonLabel',
    /**
	 * 外部模型。
	 * @property EXTERANL_MODEL
	 * @type {string}
	 * @final
	 */
    EXTERANL_MODEL: 'externalModel',
    POLYGON_MARKER: 'polygonMarker'
};

/**
*	FMLanguageType 语言类型，中文、英文枚举
* 	@class FMLanguageType
* 	@module FMEnum
*   @namespace fengmap
*/
fengmap.FMLanguageType = {
	/**
	 * 中文
	 * @property CHN
	 * @type {string}
	 * @final
	 */
	CHN:'chn',
	/**
	 * 英文
	 * @property EN
	 * @type {string}
	 * @final
	 */
	EN:'en'
}

/**
 * fengmap 渲染顺序 (测试阶段)
 */
fengmap.FMRenderOrder = {
	polygon: 2,
	lineObject: 3,
	transparentLine: 1,  // 线的子物体需要透过 * 但现在还是在被extent挡到.
	extent: 2,
	model: 2,
	storeImage: 3,
	modelLine: 11,
	polygonMarker: 13,
	externalModel: 20,
	label: 30,
	facility: 30,
	textMarker: 40,
	imageMarker: 50,
	locationMarker: 60
};

/**
 * fengmap 交互模式
 */
fengmap.FMInputMode = {
	SELECT: 'select',
	DRAWING: 'drawing',
	NONE: 'none'
};

/**
 * enum FMLineType
	{
	    FMLINE_FULL=0,
	    
	    FMLINE_DOTTED,     //点线 1000100010001000, 表示实际画线的点，反序后转换成16进制就是0x1111 dotted
	    //.  .  .  .  .  .  .  .  .  .  .  .  .  .
	    FMLINE_DOTDASH,    //点划线    1111111111100100  dot dash
	    //____ . ____ . _____ . _____. _____
	    FMLINE_CENTER,     //中心线    1111111111001100  centre line
	    //_____ _ _____ _ _____ _ _____ _ _____
	    FMLINE_DASHED,     //虚线  1111110011111100   dashed
	    //____  ____  ____  ____  ____  ____  ____
	    FMLINE_DOUBLEDOTDASH,      //双点划线  1111111100100100  double dot dash
	    // ____ . . ____ . . ____ . . ____ . . ____
	    FMLINE_TRIDOTDASH,      //三点划线  111111110101010 tri_dot_dash
	    // ____ . . ____ . . ____ . . ____ . . ____
	    FMLINE_TEXTURE//纹理缘着线方向repeat,但与设置的线颜射混合
	};
 */

 /**
*	FMLineType 线型枚举
* 	@class FMLineType
* 	@module FMEnum
*   @namespace fengmap
*/
fengmap.FMLineType = {
	/**
	 * 全线。————————————
	 * @property FULL
	 * @type {string}
	 * @final
	 */
	FULL: 'full',
	/**
	 * 点线。.  .  .  .  .  .  .  .  .  .  .  .  .  .
	 * @property DOTTED
	 * @type {string}
	 * @final
	 */
	DOTTED: 'dotted',
	/**
	 * 点画线。____ . ____ . _____ . _____. _____
	 * @property DOT_DASH
	 * @type {string}
	 * @final
	 */
	DOT_DASH: 'dotDash',
	/**
	 * 中心线。_____ _ _____ _ _____ _ _____ _ _____
	 * @property CENTER
	 * @type {string}
	 * @final
	 */
	CENTER: 'center',
	/**
	 * 虚线。____  ____  ____  ____  ____  ____  ____
	 * @property DASH
	 * @type {string}
	 * @final
	 */
	DASH: 'dash',
	/**
	 * 双点画线。____ . . ____ . . ____ . . ____ . . ____
	 * @property DOUBLE_DOT_DASH
	 * @type {string}
	 * @final
	 */
	DOUBLE_DOT_DASH: 'doubleDotDash',
	/**
	 * 三点画线。____ . . ____ . . ____ . . ____ . . ____
	 * @property TRI_DOT_DASH
	 * @type {string}
	 * @final
	 */
	TRI_DOT_DASH: 'triDotDash',
	NORMAL: 'normal',
	ARROW: 'arrow',
	RAW: 'raw',
	/**
	 * 带有箭头样式的导航线样式。
	 * @property FMARROW
	 * @type {string}
	 * @final
	 */
	FMARROW: 'fmarrow',
	TEXTURE: 'texture'
};

fengmap.FMLineMode = {
	PLANE: 'plane',
	CIRCLE: 'circle'
};




/**
*	FMEnum 模块包含了常用结构体对象
* 	@module FMEnum
*   @namespace fengmap
*/

/**
*	FMNodeType 地图元素类型枚举
* 	@class FMNodeType
* 	@module FMEnum
*   @namespace fengmap
*/
fengmap['FMNodeType'] = {
	/**
	 * 未知类型
	 * @property NONE
	 * @type {number}
	 * @final
	 */
	"NONE":0,

	//extent!
	"FLOOR":4,
	
	/**
	 * 模型
	 * @property MODEL
	 * @type {number}
	 * @final
	 */
	"MODEL":5,


	/**
	 * 公共设施
	 * @property FACILITY
	 * @type {number}
	 * @final
	 */
	"FACILITY":11,

	/**
	 * 文本标签
	 * @property LABEL
	 * @type {number}
	 * @final
	 */
	"LABEL":12,

	/**
	 * 线标注
	 * @property LINE
	 * @type {number}
	 * @final
	 */
	"LINE":21,

	/**
	 * 图片标注
	 * @property IMAGE_MARKER
	 * @type {number}
	 * @final
	 */
	"IMAGE_MARKER":31,

	/**
	 * 自定义文本标注
	 * @property TEXT_MARKER
	 * @type {number}
	 * @final
	 */
	"TEXT_MARKER":32,

	/**
	 * 定位标注
	 * @property LOCATION_MARKER
	 * @type {number}
	 * @final
	 */
	"LOCATION_MARKER":33,
	
	/**
	 * 所有类型
	 * @property ALL
	 * @final
	 * @type 值类型
	 */
	"ALL":0xffff,

	/**
	 * FM通用元素
	 */
	"ELEMENT": 100
};


/**
*	FMViewMode 模型视图模式枚举
* 	@class FMViewMode
* 	@module FMEnum
*   @namespace fengmap
*/

fengmap['FMViewMode'] = {
	/**
	 * 三维模式
	 * @property MODE_3D
	 * @type {string}
	 * @final
	 * @readOnly
	 */
	'MODE_3D':'3d',

	/**
	 * 二维模式
	 * @property MODE_2D
	 * @type {string}
	 * @final
	 * @readOnly
	 */
	'MODE_2D':'top'
};

/////////////////////
// FMAnimation class //
/////////////////////
(function () {
	function FMAnimation(work, frameRate) {
		this.work = work;
		this.frameRate = frameRate || 30;
		this._stop = false;
		this._cnt = 0;
		this._lastTime = null;
	}

	FMAnimation.prototype = {
		constructor: FMAnimation,

		get frameRate() {
			return this._frameRate;
		},

		set frameRate(value) {
			value = Math.max(Math.min(60, value), 1);
			this._frameRate = value;
			this._renderStep = 60 / value;
		},
		
		play: function (params) {
			this._stop = false;
			this._frame();
		},
		stop: function () {
			this._stop = true;
		},
		_frame: function () {
			this._cnt += 1;

			if (!this._lastTime) {
				this._lastTime = Date.now();
			}

			if (this._cnt >= this._renderStep) {
				this._cnt = 0;

				var time = Date.now();
				var delta = time - this._lastTime;
				this._lastTime = time;

				if (this.work) {
					this.work(delta / 1000);
				}
			}

			if (!this._stop) {
				requestAnimationFrame(this._frame.bind(this));
			}
		}
	};	
	
	fengmap.FMAnimation = FMAnimation;
})();






/**
 * FMMarker 类
 * 		提供高级别的自定义Marker的方法
 *
 * 继承 FMSprite 类
 */

(function () {
	function FMMarker(params) {
		fengmap.FMSprite.call(this, params);
		
	}

	FMMarker.prototype = Object.create(fengmap.FMSprite.prototype);

	fengmap.FMMarker = FMMarker;
})();
/**
 * FMMarkerCanvas class
 *
 * style: {
 * 		width: 256, 
 * 		height: 128,
 * 		color: 0x444444,				(default color)
 * 		fontColor: 0x000000,			(default font color)
 * 		font: "32px Arial", 			(default font format)
 * 		background: {
 * 			color: 0xffffff,
 * 			alpha: 0
 * 		},
 * 		elements: [
 * 			{
 * 				type: 'image' | 'text',
 * 				name:
 * 				url:, 					(image only)
 * 				color:,					(text only if no only stroke)
 * 				strokeColor:, 			(text only if no only fill)
 * 				strokeAlpha:, 			(text only if no only fill)
 * 				text:, 					(text only)
 * 				font:, 					(css font format: "italic small-caps bold 12px arial")
 * 				lineWidth: 3, 			(text only)
 * 				width:, 				(<= 1 : percent, > 1 : value)
 * 				height:, 				...
 * 				x:, 					...
 * 				y:, 					...
 * 				shadow: {
 * 					offsetX:,
 * 					offsetY:,
 * 					color:,
 * 					alpha:,
 * 					blur:,
 * 				}
 * 			},
 * 			{
 * 				type: 'shape',			// shape
 * 				name:,
 * 				points: [
 * 					{
 * 						x:, y:
 * 					}
 * 				],
 * 				color:,
 * 				strokeColor:,
 * 				strokeAlpha:,
 * 				lineWidth:,
 * 				shadow:
 * 			},
 * 			{
 * 				type: 'roundRect',		// rect width round corner
 * 				name:,
 * 				points: [{
 * 					x:, y:
 * 				}],
 * 				radius:,
 * 				color:,
 * 				strokeColor:,
 * 				strokeAlpha:,
 * 				lineWidth:,
 * 				shadow:
 * 			},
 * 			{
 * 				type: 'rect',			// rectangle
 * 				name:,
 * 				point: {x:, y:},
 * 				width:,
 * 				height,
 * 				color:,
 * 				strokeColor:,
 * 				strokeAlpha:,
 * 				lineWidth:,
 * 				shadow:
 * 			},
 * 			{
 * 				type: 'circle',			// circle
 * 				name:,
 * 				point: {x:, y:},
 * 				radius:,
 * 				color:,
 * 				strokeColor:,
 * 				strokeAlpha:,
 * 				lineWidth:,
 * 				shadow:
 * 			}
 * 		]
 * }
 */
 (function () {
	function FMMarkerCanvas(params) {
		var s = this;

		fm.Evento.convert(s);

		s.style = {};

		Object.assign(s.style, {
			width: 256,
			height: 128,
			color: 0x444444,
			fontColor: 0x000000,
			font: '24px 微软雅黑',
			elements: [],
			background: {
				color: 0xffffff,
				alpha: 0
			}
		}, params);

		s.ctx = document.createElement('canvas').getContext('2d');

		// drawing state
		s.isDrawing = false;

		s._elements = [];

		s.ctx.canvas.width = s.style.width;
		s.ctx.canvas.height = s.style.height;
	}

	FMMarkerCanvas.prototype =  {
		constructor: FMMarkerCanvas,

		toRgba: function (color, alpha) {
			var r, g, b;
			alpha = alpha == undefined ? 1 : alpha;

			// 0x value to length 6
			function colorLen(str) {
				if (str.length < 6) {
					var cnt = 6 - str.length;
					for (var i = 0; i < cnt; i++) {
						str = '0' + str;
					}
				}
				return str;
			}

			if (typeof color == 'number') {
				color = color.toString(16);
				color = colorLen(color);
			} else if (typeof color == 'string') {
				color = color.slice(1);
			}

			if (color.length != 6) {
				throw 'wrong color length: color 0xffffff, or #ffffff length = 6';
			}

			function toInt(str , s, e) {
				return parseInt('0x' + str.slice(s, e));
			}

			r = toInt(color, 0, 2);
			g = toInt(color, 2, 4);
			b = toInt(color, 4, 6);

			return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';
		},

		setStyle: function (params) {
			var s = this;

			if (!params) {return;}

			// set background
			if (params.background) {
				Object.assign(s.style.background, params.background);
			}

			// get element setting by name
			function getElementSetting(name) {
				for (var i = 0; i < s.style.elements.length; i++) {
					if (s.style.elements[i].name == name) {
						return s.style.elements[i];
					}
				}
			}

			// set elements
			if (params.elements) {
				params.elements.forEach(function (itm) {
					if (itm.name) {
						var setting = getElementSetting(itm.name);
						Object.assign(setting, itm);
					}
				});
			}
		},

		readElementSytle: function (data) {
			var s = this;

			if (data.color != undefined) {
				s.ctx.fillStyle = s.toRgba(data.color, data.alpha);
			}

			if (data.strokeColor != undefined) {
				s.ctx.strokeStyle = s.toRgba(data.strokeColor, data.strokeAlpha);
			}

			if (data.lineWidth) {
				s.ctx.lineWidth = data.lineWidth;
			}

			if (data.textBaseline) {
				s.ctx.textBaseline = data.textBaseline;
			} else {
				s.ctx.textBaseline = 'top';
			}

			if (data.shadow) {
				if (data.shadow.offsetX != undefined) {
					s.ctx.shadowOffsetX = data.shadow.offsetX;
				}
				if (data.shadow.offsetY != undefined) {
					s.ctx.shadowOffsetY = data.shadow.offsetY;
				}
				if (data.shadow.blur != undefined) {
					s.ctx.shadowBlur = data.shadow.blur;
				}
				if (data.shadow.color != undefined) {
					s.ctx.shadowColor = s.toRgba(data.shadow.color, data.shadow.alpha);
				}
			} else {
				s.ctx.shadowBlur = 0;
				s.ctx.shadowOffsetX = 0;
				s.ctx.shadowOffsetY = 0;
			}
		},

		getValue: function (data, prop, isWidth) {
			var value = data[prop];
			var offset = {x: 0, y: 0};
			if (data.groups && (prop == 'x' || prop == 'y')) {
				var offset = data.groups.reduce(function(p, n) {
					return {
						x: p.x + n.x,
						y: p.y + n.y
					};
				}, offset);
			}
			if (value <= 1 && value >= 0) {  	// 0 ~ 1
				return isWidth ? this.style.width * value + offset.x : this.style.height * value + offset.y;
			} else if (value < 0) {				// < 0
				return isWidth ? this.style.width + value + offset.x: this.style.height + value + offset.y;
			} else {
				return isWidth ? value + offset.x : value + offset.y;
			}
		},

		getStyleByName: function (name) {
			var res = null;
			(function _get(obj) {
				if (obj.elements && !res) {
					for (var i = 0; i < obj.elements.length; i++) {
						var itm = obj.elements[i];
						if (itm.name == name) {
							res = itm;
						}
						_get(itm);
					}
				}
			})(this.style);

			return res;
		},

		drawBackground: function () {
			this.ctx.fillStyle = this.toRgba(this.style.background.color, this.style.background.alpha);
			this.ctx.fillRect(0, 0, this.style.width, this.style.height);
		},
		
		drawRoundRect: function (data, isRound) {
			var s = this;
			s.readElementSytle(data);

			if (!data.width || !data.height) {return;}

			var x = s.getValue(data, 'x', true);
			var y = s.getValue(data, 'y');
			var w = s.getValue(data, 'width', true);
			var h = s.getValue(data, 'height');

			s.ctx.beginPath();
			if (isRound) {
				s.ctx.roundRect(x, y, w, h, (data.radius || 5));
			} else {
				s.ctx.rect(x, y, w, h);
			}
			s.ctx.closePath();

			if (data.lineWidth != undefined && data.strokeColor != undefined) {
				s.ctx.stroke();
			}

			if (data.color != undefined) {
				s.ctx.fill();
			}
			s.next();
		},

		drawCircle: function (data) {
			var s = this;
			if (data.radius == undefined || data.point == undefined) {return;}
			
			s.readElementSytle(data);

			var x = s.getValue(data.point, 'x', true);
			var y = s.getValue(data.point, 'y');

			s.ctx.beginPath();
			s.ctx.arc(x, y, data.radius, 0, Math.PI * 2, true);
			s.ctx.closePath();

			if (data.lineWidth != undefined && data.strokeColor != undefined) {
				s.ctx.stroke();
			}

			if (data.color != undefined) {
				s.ctx.fill();
			}
			s.next();
		},

		drawShape: function (data) {
			var s = this;
			if (data.points == undefined && data.points.length < 3) {return;}
			
			s.readElementSytle(data);

			s.ctx.beginPath();
			for (var i = 0; i < data.points.length; i++) {
				var x = s.getValue(data.points[i], 'x', true);
				var y = s.getValue(data.points[i], 'y');

				if (i == 0) {
					s.ctx.moveTo(x, y);
				} else {
					s.ctx.lineTo(x, y);
				}
			}
			s.ctx.closePath();

			if (data.lineWidth != undefined && data.strokeColor != undefined) {
				s.ctx.stroke();
			}

			if (data.color != undefined) {
				s.ctx.fill();
			}

			s.next();
		},

		drawImage: function (data) {
			var s = this;
			var img = null;

			function _drawImage() {
				s.readElementSytle(data);

				var x = s.getValue(data, 'x', true);
				var y = s.getValue(data, 'y');

				if (data.width && data.height) {
					var w = s.getValue(data, 'width', true);
					var h = s.getValue(data, 'height');

					s.ctx.drawImage(data.image, x, y, w, h);
				} else {
					s.ctx.drawImage(data.image, x, y);
				}
			}

			if (!data.image) {
				img = new Image();
				img.src = data.url;
				img.onload = function () {
					data.image = img;
					_drawImage(img);
					s.next();
				}
			} else {
				_drawImage(data.img);
				s.next();
			}
		},

		drawText: function (data) {
			var s = this;
			var font = data.font || s.style.font;
			var sizes = font.match(/\d+/);
			var size = 24;
			if (sizes.length > 0) {
				size = parseInt(sizes[0]);
			}

			s.readElementSytle(data);

			s.ctx.font = font;

			var x = s.getValue(data, 'x', true);
			var y = s.getValue(data, 'y');

			if (data.lineWidth) {
				s.ctx.lineWidth = data.lineWidth;
				s.ctx.strokeStyle = data.strokeColor || 0xffffff;
				s.ctx.strokeText(data.text, x, y);
			}

			s.ctx.fillText(data.text, x, y);

			s.next();
		},

		drawElement: function (data) {
			// visible
			if (data.visible === false) {
				this.next();
				return;
			}

			// groups visible
			if (data.groups) {
				for (var i = 0; i < data.groups.length; i++) {
					if (data.groups[i].visible === false) {
						this.next();
						return;
					}
				}
			}

			switch (data.type) {
				case 'image':
					this.drawImage(data);
				break;
				case 'text':
					this.drawText(data);
				break;
				case 'roundRect':
					this.drawRoundRect(data, true);
				break;
				case 'rect':
					this.drawRoundRect(data, false);
				break;
				case 'circle':
					this.drawCircle(data);
				break;
				case 'shape':
					this.drawShape(data);
				break;
			}
		},

		/**
		 * 将原始的group嵌套的绘制描述,"拉平"为同一级
		 */
		normalizeStyle: function (obj, groups) {
			if (obj.elements) {
				for (var i = 0; i < obj.elements.length; i++) {
					var itm = obj.elements[i];
			
					if (itm.type == 'group') {
						var res = [];
						if (groups) {
							res = groups.slice();
							res.push(itm);
						} else {
							res = [itm];
						}
						this.normalizeStyle(obj.elements[i], res);
					} else {
						if (groups) {
							itm.groups = groups;
						}
						
						this._elements.push(itm);
					}
				}
			}
		},

		next: function () {
			var s = this;
			s.index ++;
			if (s.index < s._elements.length) {
				s.drawElement(s._elements[s.index]);
			} else {
				s.isDrawing = false;

				s.emit('complete');

				// 调用绘制完成后的回调函数
				if (s.callback) {
					s.callback();
				}
			}
		},

		init: function (callback) {
			this.update(null, true);

			if (callback) {
				this.once('complete', callback);
			}
		},

		update: function (params, needNormalize) {
			var s = this;

			if (s.isDrawing) {return;}

			if (needNormalize) {
				s._elements = [];
				s.normalizeStyle(s.style);
			}

			s.isDrawing = true;
			s.index = -1;

			// update style
			s.setStyle(params);

			// width & height
			var w = s.style.width;
			var h = s.style.height;

			if (w != s.ctx.canvas.width) {
				s.ctx.canvas.width = w;
			}

			if (h != s.ctx.canvas.height) {
				s.ctx.canvas.height = h;
			}

			// clear first
			s.ctx.clearRect(0, 0, w, h);

			// background
			s.drawBackground(params);

			// elements
			s.next();
		}
	};
 	
 	fengmap.FMMarkerCanvas = FMMarkerCanvas;
 })();
/**
 *  通用元素对象 外部建模模型为该对象，继承FMNode 属性。
 *  @class FMElement
 *  @constructor
 *  @module FMNode
 *  @extends fengmap.FMNode
 *  @namespace fengmap
 */
fengmap.FMElement = function(params) {
    params = params || {};
    this.params = params;
    var _data = params.data;

    if (params.type == fengmap.FMElementType.EXTERANL_MODEL && !params.o3d) {
        fengmap.FMNode.call(this, fengmap.FMNodeType.ELEMENT , _data, null,
                        (params.scene || fengmap.Map.instance.mapScene));
        this._highLight = null;
    }else{
        fengmap.FMNode.call(this, fengmap.FMNodeType.ELEMENT , _data, (params.o3d || new fm.Object3D()),
                        (params.scene || fengmap.Map.instance.mapScene));
    }


    if (_data && _data.typeID != undefined) {
        this.typeID = params.data.typeID;
    }

    this._type_ = params.type || fengmap.FMElementType.NONE;
};

fengmap.FMElement.prototype = Object.create(fengmap.FMNode.prototype);
fengmap.FMElement.prototype.constructor = fengmap.FMElement;

Object.defineProperties(fengmap.FMElement.prototype, {
    'elementType':{
        get: function() {
            return this._type_;
        }
    },

    /**
     * 模型FID,整个建筑内唯一ID。
     * @property FID
     * @type {number}
     * @final
     */
    'FID': {
        get: function() {
            if (this._type_ == fengmap.FMElementType.EXTERANL_MODEL)
                return this.data_['fid'];
        }
    },

    /**
     * 模型类型ID
     * @property typeID
     * @type {string}
     * @final
     */
    'typeID': {
        get: function() {
             if (this._type_ == fengmap.FMElementType.EXTERANL_MODEL)
                return this.data_['type'];
        }
    },

    /**
     * 模型名称
     * @property name
     * @type {number}
     * @final
     */
    'name': {
        get: function() {
            if (this._type_ == fengmap.FMElementType.EXTERANL_MODEL)
                return this.data_['name'];
        }
    },
    'x': {
        get: function() {
            if (this._type_ == fengmap.FMElementType.EXTERANL_MODEL)
                return -this.data_['vertex'][0];
        }
    },
    'y': {
        get: function() {
            if (this._type_ == fengmap.FMElementType.EXTERANL_MODEL)
                return this.data_['vertex'][1];
        }
    },
    'z': {
        get: function() {
            if (this._type_ == fengmap.FMElementType.EXTERANL_MODEL)
                return 0;
        }
    },
    'mapCoord': {
        get: function() {
            if (!this.coord_) {
                this.coord_ = {'x':this.x,'y':this.y,'z':0}
            }
            return this.coord_;
        }
    },
    'groupID': {
        get: function() {
            if (this._type_ == fengmap.FMElementType.EXTERANL_MODEL)
                return this.data_['groupID'];
        }
    }
});

// 添加一些 Element 的共用方法吧~
Object.assign(fengmap.FMElement.prototype, {
    flash: function(cb) {
        var self = this;

        if (self._isFlashing) {return;}

        if (self._type_ == fengmap.FMElementType.EXTERANL_MODEL) {
            fm.Tween.kill(self._flashID);

            var mats = self.o3d_.material.materials || [self.o3d_.material];

            self._isFlashing = true;
            self._flashID = fm.Tween.actionArray(mats, .4, {
                emissive: self.params.scene.map_.mapTheme.selectModelMat.color
            }, fm.Tween.pingPongSin, function() {
                self._isFlashing = false;
                if (cb) {
                    cb();
                }
            });
        }
    },
    highLight :function(color) {

        if (this._type_ != fengmap.FMElementType.EXTERANL_MODEL)
            return;

        if (this.o3d_ == null){
            this._highLight = color;
            return;
        }

        var mats = this.o3d_.material.materials || [this.o3d_.material];

        if (color) {
            
            var emissive = null;
            if (color instanceof fm.Color) {
                emissive = color;
            }else{
                emissive = new fm.Color(color);
            }
            
            var mats = this.o3d_.material.materials || [this.o3d_.material];
            for (var i = 0; i < mats.length; i++) {
                if (!mats[i].emissive_) {
                    mats[i].emissive_ = mats[i].emissive;
                }
                mats[i].emissive = emissive;
            }
        }else{

            var mats = this.o3d_.material.materials || [this.o3d_.material];
            for (var i = 0; i < mats.length; i++) {
                if (mats[i].emissive_) {
                    mats[i].emissive = mats[i].emissive_;
                }
            }
            this._highLight = null;
        }
    },
    setO3d:function(v) {
        if (v) {
            this.o3d_ = v;
            this.o3d_.fm_ = this;
        }

        if (this._highLight) {
            this.highLight(this._highLight);
        }
    },

});
/**
*	FMFacility 公共设施对象，为地图图层。并继承FMNode 属性
* 	@class FMFacility
*	@constructor
* 	@module FMNode
* 	@extends fengmap.FMNode
*   @namespace fengmap
*/

fengmap['FMFacility'] = function(data, o3d, scene) {
	fengmap.FMNode.call(this, fengmap['FMNodeType']['FACILITY'], data, o3d, scene);
	// this.o3d_.forceVisible_ = this.o3d_.visible;
	this.o3d_.forceVisible_ = false;
	this.visibleState = 0;

};

fengmap['FMFacility'].prototype = Object.create(fengmap.FMNode.prototype);

fengmap['FMFacility'].prototype.constructor = fengmap['FMFacility'];

////////////////////////////////////////////////////////////////
// parentFunctions & MarkerFuntions added in FMImageMarker.js //
////////////////////////////////////////////////////////////////

//Object.assign(fengmap['FMFacility'].prototype, {});
Object.defineProperties(fengmap['FMFacility'].prototype, {
	/**
	 * 公共设施ID
	 * @property ID
	 * @type {number}
	 * @final
	 */
	'ID': {
		get: function() {
			return this.data_['fid'];
		}
	},

	/**
	 * 公共设施名称
	 * @property name
	 * @type {string}
	 * @final
	 */
	'name': {
		get: function() {
			return this.data_['name'];
		}
	},

	/**
	 * 公共设施类型ID
	 * @property typeID
	 * @type {string}
	 * @final
	 */
	'typeID': {
		get: function() {
			return this.data_['type'];
		}
	},
	
	// Override!
	
	'x':{
		get: function() {
			return this.coord_.x;
		},
		set: function(v) {
		}
	},
	'y':{
		get: function() {
			return this.coord_.y;
		},
		set: function(v) {
		}
	},
	'z':{
		get: function() {
			return this.coord_.z;
		},
		set: function(v) {
		}
	},
	'mapCoord':{
		get: function() {
			if (!this.coord_) {
				var v = this.data_['vertex'];
				this.coord_ = new fengmap.FMMapCoord(
					-v[0], 
					v[1],
					this.o3d_.parent.localToWorld(new fm.Vector3(0,6,0)).y
				);
			}
			return this.coord_;
		}
	},
	/*_visible: {
		get: function() {
			if (this.constAlpha != undefined) {
				return true;
			}
			return this.o3d_.forceVisible_ && this.o3d_.fadeVisible;
		},
		set: function(v) {
			this.o3d_.forceVisible_ = v;
			this.o3d_.visible = v;
		}
	},*/
	// visible: {
		// get: function () {
		// 	this._visible_ = this._visible_ == undefined ? true : this._visible_;
		// 	return this._visible_;
		// },
		// set: function (val) {
		// 	this._visible_ = val;
		// 	// this._visible = val;

		// 	if (!val) {this.fadeVisible = null;}
		// }
		// get: function () {
		// 	return this.o3d_.visible;
		// },
		// set: function (val) {
		// 	this.o3d_.forceVisible_ = this.o3d_.visible = val;
		// 	this.visibleState = val ? 0 : -1;
		// }
	// }
	// visible: fengmap.FMLabel.prototype.visible.bind(this),
	
});
/**
*	FMImageMarker 自定义图片标注对象，为自定义图层。继承FMNode 属性
* 	@class FMImageMarker
*	@constructor
* 	@module FMNode
* 	@extends fengmap.FMNode
*   @namespace fengmap
*   @param {object} opts
*          @param {float} opts.x  图片地图位置x值
*          @param {float} opts.y 图片地图位置y值
*          @param {int} opts.size  图片尺寸
*          @param {int} opts.height  标注高度
*          @param {string} opts.url    图片地址
*          @param {function} opts.callback  imageMarker成功加载后的回调
*		   @demo layer/添加图片标注.js
*/
fengmap['FMImageMarker'] = function(opts) {
	fengmap.FMNode.call(this, fengmap['FMNodeType']['IMAGE_MARKER'], {}, new fm.Object3D());
	this.o3d_.forceVisible_ = this.o3d_.visible;
	this.alias = 'imageMarker';
	this.opts_ = opts || {};
};

fengmap['FMImageMarker'].prototype = Object.create(fengmap.FMNode.prototype, {
	forceVisible_: {
		get: function () {
			return this.o3d_.forceVisible_;
		},
		set: function (val) {
			this.o3d_.forceVisible_ = val;
		}
	}
});

fengmap['FMImageMarker'].prototype.constructor = fengmap['FMImageMarker']; 

fengmap.FMImageMarker.MarkerFunctions = {
	/**
	 * 设置Marker的位置。
	 * @method setPosition
	 * @param {float} x 地图坐标x值
	 * @param {float} y 地图坐标y值
	 * @param {int} gid 楼层id,决定定位标注的高度
	 * @param {int} height 高度的偏移量
	 */
	setPosition: function(x, y, gid, zOffset) {
		if (typeof x == 'object') {
			y = x.y;
			gid = fmg(x, 'gid', 'groupID', 'groupId', 1);
			zOffset = fmg(x, 'height', 'zOffset', 'offset', 'offsetHeight', 0);
			x = x.x;
		}

		this.x = x;
		this.y = y;

		if (this instanceof fengmap.FMLocationMarker) {
			gid = gid || this.scene_.map_.focusGroupId_ || this._gid;
			// this._gid = gid;
			this.groupID = gid;

			this.o3d_.initY_ = this.scene_.map_.getGroupHeight(gid) + (zOffset || 0);
		} else {
			if (gid != undefined) {
				this.o3d_.initY_ = gid;
			}
		}
	},

	/**
	 * 得到Marker的位置信息
	 * @method getPosition
	 * @return {Json} {x:, y:, z:(not use), groupID:}
	 */
	getPosition: function() {
		return {
			x: this.x,
			y: this.y,
			z: (this.o3d_.initY_ || 0),
			groupID: this.groupID
		};
	},

	/**
	 * 将marker移到指定的层上, 如果目标层没有对应的layer会自动创建	
	 * @method moveToGroup 
	 * @param  {int} groupID 目标层的groupID
	 */
	moveToGroup: function (groupID, type) {
		var g = this.scene_.map_.getFMGroup(groupID);
		var layer = g.getOrCreateLayer(type || this.alias);

		layer.o3d_.add(this.o3d_);
		this.groupID = groupID;
	}, 

	/*quicklyRemove: function () {
		var s = this;

		s.opts_.callback = function () {
			console.log('hahahahaah');
			s.dispose();
		}

		s.dispose();
	}*/
};

Object.assign(fengmap['FMImageMarker'].prototype, {	
	tryCreate_:function(fmLayer) {
		if (this.o3d_ instanceof fm.Object3D) {
			if (!fmLayer.parent) {
				fmLayer.o3d_.add(this.o3d_);
			} else {
				fmLayer.o3d_.remove(this.o3d_);
				
				var fmGroup = fmLayer.parent;
				var scene = fmGroup.scene_;
				this.scene_ = scene;
				var uo = fengmap.util.Option;
				
				this.x_ = uo.getValue(this.opts_, 'x', fmGroup.mapCoord.x);
				this.y_ = uo.getValue(this.opts_, 'y', fmGroup.mapCoord.y);
				
				this.opts_.url = uo.getValue(this.opts_, 'url', 
					'../static/img/user-icons/user_group.png'
				);

				this.name_ = uo.getValue(this.opts_, 'name', null);
				this.id_   = uo.getValue(this.opts_, 'id', fengmap.util.id ++);
				this.size_ = uo.getValue(this.opts_, 'size', 32);
				
				var self = this;
				
				//fid, vertex, name, type
				var fv = this.o3d_.forceVisible_;
				this.o3d_ = new fengmap.MapPoi2(fmGroup.groupID, {
					fid: this.id_,
					vertex:[this.x_, this.y_], 
					name:this.name_,
					size_: this.size_
				}, this.opts_.url, function(tex) {
					setTimeout(function() {
					    // self.o3d_.forceVisible_ = fv;
					    self.visible = fv;
						fmLayer.o3d_.add(self.o3d_);
						
						var _h = 0;

						if (self.opts_.height != undefined) {
							_h = self.opts_.height;
						} else if (self.opts_.z != undefined) {
							_h = self.opts_.z;
						} else {
							_h = 6;
						}

						self.o3d_.position.set(-self.x_- scene.sceneX_, _h, self.y_ - scene.sceneZ_);
						self.o3d_.initY_ = _h;

						// 被动渲染
						if (self.scene_.map_.passiveMode) {
							self.scene_.map_.forceUpdate(true);
						}

						// callback
						if (self.opts_.callback) {
							self.opts_.callback(self);
						}
					}, 0);
					self.scene_.map_.update_(true);
				});

				this.o3d_.forceVisible_ = false;
				this.o3d_.visible = false;
				this.o3d_.fm_ = this;

				// 不写入 depthWrite 这样, 可以使用 renderOrder 来手动的设置其渲染的顺序
				this.o3d_.material.depthWrite = false;
				//this.o3d_.renderOrder = 100;

				scene.map_.mapPicker.addUserPOI(this.o3d_);
			}
		}
	},

	// override FMNode dispose method
	// because 有可能用户在image还没有下载完成的时候,就dispose了,
	// 但在imagemarker的callback里, 还会将其add到layer上
	dispose: function () {
		var s = this;

		s.opts_.callback = function () {
			fengmap.FMNode.prototype.dispose.call(s);
		}

		fengmap.FMNode.prototype.dispose.call(s);
	},

	_init_: function() {
	    
	},

	// 目前用于在mapPicker中移除
	_dispose_: function () {
		this.scene_.map_.mapPicker.removeObject(this.o3d_);
	}

	/**
	 * 设置图片标注在最上层,不被其他图层遮挡.注:此方法在imageMarker创建后生效.可在创建imageMarker的callback方法中调用.
	 * @method alwaysShow
	 */
	// alwaysShow: function() {fengmap.MapLabel.prototype.alwaysShow.call(this.o3d_);}
}, fengmap.MapLabel.parentFunctions, fengmap.FMImageMarker.MarkerFunctions);

 /**
 * 将imageMarker移动到指定的位置
 * @method moveTo
 * @param {JSON} opts  参数配置
	 * @param {float} opts.x x 坐标
	 * @param {float} opts.y y 坐标
	 * @param {float} opts.duration|time 移动到指定位置所用的时间（秒）
	 * @param {function} opts.callback 移动到指定位置后的回调函数
	 * @param {function} opts.update 动画执行过程中位置更新时的回调函数，返回实时坐标{x,y}
 */

 /**
  * 停止imageMarker的移动
  * @method stopMoveTo
  */

//////////////
// Facility //
//////////////
Object.assign(fengmap.FMFacility.prototype, fengmap.MapLabel.parentFunctions, fengmap.FMImageMarker.MarkerFunctions);

Object.defineProperties(fengmap['FMImageMarker'].prototype, {
	/**
	 * 图片URL
	 * @property url
	 * @type {string}
	 */
	"url":{
		get: function() {
			return this.opts_.url;
		},
		set: function(v) {
			this.opts_.url = v;
			if (this.scene_) {
				this.o3d_.setUrl(v);
			}
		}
	},	
	image: {
		set: function (img) {
			if (this.scene_) {
				this.o3d_.setUrl(img);
			}
		}
	},
	// 'visible': {
	// 	get: function() {
	// 		return this.o3d_.visible;
	// 	},
	// 	set: function(v) {
	// 		this.o3d_.forceVisible_ = v;
	// 		this.o3d_.visible = v;
	// 	}
	// },

	/**
	 * 自定义图片标注的ID
	 * @property ID
	 * @type {number}
	 * @final
	 */
	'ID': {
		get: function() {
			return this.id_;
		}
	},
	
	/**
	 * 自定义图片标注名称s
	 * @property name
	 * @type {string}
	 * @final
	 */
	'name': {
		get: function() {
			return this.name_;
		}
	},

	/*'mapCoord':{
		get: function() {
			return new fengmap['FMMapCoord'](this['x_'], this['y_'], this['z']);
		}
	}*/
});



/**
 *	FMLabel 文本标签对象，为地图图层,只读，不可实例化。并继承FMNode 属性
 * 	@class FMLabel
 *	@constructor
 * 	@module FMNode
 * 	@extends fengmap.FMNode
 *   @namespace fengmap
 */
fengmap['FMLabel'] = function(data, o3d, scene) {
	fengmap.FMNode.call(this, fengmap['FMNodeType']['LABEL'], data, o3d, scene);
	// this.o3d_.forceVisible_ = this.o3d_.visible;
	this.o3d_.forceVisible_ = false;
	this.visibleState = 0;
};

fengmap['FMLabel'].prototype = Object.create(fengmap.FMNode.prototype);

fengmap['FMLabel'].prototype.constructor = fengmap['FMLabel'];

Object.assign(fengmap.FMLabel.prototype, fengmap.MapLabel.parentFunctions);

//Object.assign(fengmap['FMLabel'].prototype, {});
Object.defineProperties(fengmap['FMLabel'].prototype, {
	/**
	 * 文本标签ID
	 * @property ID
	 * @type {number}
	 * @final
	 */
	'ID': {
		get: function() {
			return this.data_['oid'];
		}
	},
	/**
	 * 文本标签名称
	 * @property name
	 * @type {string}
	 * @final
	 */
	'name': {
		get: function() {
			return this.data_['name'];
		}
	},

	/**
	 * 文本标签英文名称
	 * @property eName
	 * @type {string}
	 * @final
	 */
	'eName': {
		get: function() {
			return this.data_['ename']||'';
		}
	},

	// Override!
	//*
	// 'x':{
	// 	get: function() {
	// 		return this.coord_.x;
	// 	},
	// 	set: function(v) {
	// 	}
	// },
	// 'y':{
	// 	get: function() {
	// 		return this.coord_.y;
	// 	},
	// 	set: function(v) {
	// 	}
	// },
	// 'z':{
	// 	get: function() {
	// 		return this.coord_.z;
	// 	},
	// 	set: function(v) {
	// 	}
	// },

	'x': {
		get: function() {
			if (this.scene_) {
				return -this.o3d_.position.x - this.scene_.sceneX_;
			} else {
				return 0;
			}
		},
		set: function(v) {
			if (this.scene_) {
				this.o3d_.position.x = -v - this.scene_.sceneX_;
			} else {
				this.opts_ = this.opts_ || {};
				this.opts_.x = v;
			}
		}
	},
	/**
	 * 地图元素中心点对应地图坐标y
	 * @property y
	 * @type {float}
	 */
	'y': {
		get: function() {
			if (this.scene_) {
				return this.o3d_.position.z + this.scene_.sceneZ_;
			} else {
				return 0;
			}
		},
		set: function(v) {
			if (this.scene_) {
				this.o3d_.position.z = v - this.scene_.sceneZ_;
			} else {
				this.opts_ = this.opts_ || {};
				this.opts_.y = v;
			}
		}
	},
	z: {
		get: function() {
			return this.o3d_.position.y;
		},
		set: function(v) {
			this.o3d_.position.y = v;
		}
	},
	'mapCoord': {
		get: function() {
			if (!this.coord_) {
				var v = this.data_['vertex'];
				this.coord_ = new fengmap.FMMapCoord(-v[0],
					v[1],
					this.o3d_.parent.localToWorld(new fm.Vector3(0, 6, 0)).y
				);
			}
			return this.coord_;
		}
	},

	/**
	 * 修改FMLabel上的文字内容
	 * @method setText
	 * @param {string} text 文字内容
	 */
	setText: {
		value: function(text) {
			this.o3d_.setText(text);
		}
	},

	/*'visible': {
		get: function() {
			if (this.constAlpha != undefined) {
				return true;
			}
			return this.o3d_.forceVisible_ && this.o3d_.fadeVisible;
		},
		set: function(v) {
			this.o3d_.forceVisible_ = v;
			this.o3d_.visible = v;
		}
	}*/
	// visible: {
	// 	get: function () {
	// 		return this.o3d_.visible;
	// 	},
	// 	set: function (val) {
	// 		this.o3d_.forceVisible_ = this.o3d_.visible = val;
	// 		this.visibleState = val ? 0 : -1;
	// 	}
	// }
	// visible: fengmap.FMFacility.prototype.visible.bind(this),
	//*/
});
/**
 *	FMLocationMarker 自定义图片标注对象，为自定义图层。继承FMNode 属性
 * 	@class FMLocationMarker
 *	@constructor
 * 	@module FMNode
 *   @namespace fengmap
 * 	@extends fengmap.FMNode
 *   @param {object} opts
 *          @param {float} opts.x  图片地图位置x值
 *          @param {float} opts.y 图片地图位置y值
 *          @param {int} opts.groupID 楼层id,决定定位标注的高度
 *          @param {int} opts.size  图片尺寸
 *          @param {string} opts.url 图片地址
 *          @param {int} opts.height  标注高度
 *          @param {function} opts.callback  LocationMarker成功加载后的回调
 */

/**
 * 设置Marker的位置。
 * @method setPosition
 * @param {float} x 地图坐标x值
 * @param {float} y 地图坐标y值
 * @param {int} groupID 楼层id,决定定位标注的高度
 * @param {int} offset 高度的偏移量
 */

fengmap['FMLocationMarker'] = function(opts) {
	fengmap.FMNode.call(this, fengmap['FMNodeType']['LOCATION_MARKER'], {}, new fm.Object3D());
	this.o3d_.forceVisible_ = this.o3d_.visible;
	this.opts_ = opts || {};

	this.scene_ = opts.map ? opts.map.mapScene : fengmap.Map.instance.mapScene;

	this._gid = 1;

	this.tryCreate_();
};

fengmap['FMLocationMarker'].prototype = Object.create(fengmap.FMNode.prototype);

fengmap['FMLocationMarker'].prototype.constructor = fengmap['FMLocationMarker'];

Object.assign(fengmap['FMLocationMarker'].prototype, {
	tryCreate_: function(fmLayer) {
		if (this.o3d_ instanceof fm.Object3D) {
			// fmLayer.o3d_.remove(this.o3d_);

			// var fmGroup = fmLayer.parent;
			// var scene = fmGroup.scene_;
			// this.scene_ = scene;
			var uo = fengmap.util.Option;

			var map = this.opts_.map || fengmap.Map.instance;

			this.x_ = uo.getValue(this.opts_, 'x', 0);

			this.y_ = uo.getValue(this.opts_, 'y', 0);

			this.height_ = uo.getValue(this.opts_, 'height', 0);

			this.url_ = uo.getValue(this.opts_, 'url',
				'../static/img/user-icons/user_group.png'
			);

			this.name_ = uo.getValue(this.opts_, 'name', null);

			this.id_ = uo.getValue(this.opts_, 'id', fengmap.util.id++);

			this.size_ = uo.getValue(this.opts_, 'size', 128);

			var self = this;
			//fid, vertex, name, type
			var fv = this.o3d_.forceVisible_;
			this.o3d_ = new fengmap.MapPoi3(0, {
				fid: this.id_,
				vertex: [0, 0],
				name: this.name_,
				size_: this.size_
			}, this.url_, function(tex) {
				self.mapLoaded = true;
				self.o3d_.material.visible = true;
				self.o3d_.material.depthWrite = false;

				// direction
				if (self.opts_.direction) {
					self.direction = self.opts_.direction;
				}

				// 被动渲染
				if (self.scene_.map_.passiveMode) {
					self.scene_.map_.forceUpdate(true);
				}

				// visible groupID changed
				self._visibleGroupIDsChanged = self.visibleGroupIDsChanged.bind(self);
				map.on('visibleGroupIDsChanged', self._visibleGroupIDsChanged);

				if (self.opts_.callback) {
					self.opts_.callback(self);
				}
			});

			self.o3d_.initY_ = 0;

			// height
			if (self.opts_.height) {
				self.o3d_.initY_ = self.opts_.height;
			}

			if (self.opts_.groupID) {
				var hei = map.getGroupHeight(self.opts_.groupID);
				self.o3d_.initY_ += hei;
			}

			this.o3d_.x = this.x_;
			this.o3d_.y = this.y_;

			// this.o3d_.updateScreenSize(map.mapView);

			this.o3d_.material.visible = false;
			this.o3d_.notAddImageHeight = true;

			this.o3d_.forceVisible_ = true;
			this.o3d_.fm_ = this;

			map.mapPicker.addUserPOI(this.o3d_);

			this._update_ = this._update.bind(this);
			map.on('update', this._update_);
		}
	},

	// alwaysShow: fengmap.FMImageMarker.prototype.alwaysShow, 

	visibleGroupIDsChanged: fengmap.Line.prototype.visibleGroupIDsChanged,

}, fengmap.MapLabel.parentFunctions, fengmap.FMImageMarker.MarkerFunctions);



Object.defineProperties(fengmap['FMLocationMarker'].prototype, {
	_init_: {
		/*value: function() {
			var c = {
				x: this.x_,
				y: this.y_,
				z: this.height
			};

			this.o3d_.position.copy(this.opts_.map.toSceneCoord(c));
		}*/
	},
	/**
	 * 定位标注的方向
	 * @property direction
	 * @type 度数
	 */
	"direction": {
		get: function() {
			return fengmap.MapUtil.getNearestAngle(0, this.o3d_.rotation.z / Math.PI * 180.0 - 180.0);
		},
		set: function(value) {
			this.o3d_.rotation.set(-Math.PI / 2, 0, value / 180.0 * Math.PI + Math.PI, 'XYZ');
		}
	},

	// 'visible': {
	// 	get: function() {
	// 		return this.o3d_.forceVisible_;
	// 	},
	// 	set: function(v) {
	// 		this.o3d_.forceVisible_ = v;
	// 		this.o3d_.visible = v;
	// 	}
	// },


	height: {
		set: function(val) {
			this.o3d_.initY_ = val;
		},
		get: function() {
			return this.o3d_.position.y;
		}
	},

	_update: {
		value: function(dt) {
			if (this.o3d_.parent) {
				this.o3d_.updateScreenSize(this.scene_.map_.mapView);
			}
		}
	},

	gid: {
		get: function() {
			return this._gid;
		},
		set: function(val) {
			this._gid = val;
		}
	},

	groupID: {
		get: function() {
			return this._gid;
		},
		set: function(gid) {
			this._gid = gid;

			this.visibleGroupIDsChanged(this.scene_.map_.visibleGroupIDs);
		}
	},

	position: {
		get: function() {
			return this.o3d_.position;
		}
	},

	dispose: {
		value: function() {
			if (this.o3d_.parent) {
				var map = this.opts_.map || fengmap.Map.instance;
				map.off('update', this._update_);
				map.off('visibleGroupIDsChanged', this._visibleGroupIDsChanged);
				this.o3d_.parent.remove(this.o3d_);
			}
		}
	},

	// 目前用于在mapPicker中移除
	_dispose_: function() {
		this.scene_.map_.mapPicker.removeObject(this.o3d_);
	},

	/**
	 * 定位标注的ID
	 * @property ID
	 * @type {number}
	 * @final
	 */
	'ID': {
		get: function() {
			return this.id_;
		}
	},

	/**
	 * 定位标注名称
	 * @property name
	 * @type {string}
	 * @final
	 */
	'name': {
		get: function() {
			return this.name_;
		}
	},

	/**
	 * 将locationMarker水平旋转至
	 * @method rotateTo
	 * @param {Json} params {to: 45, duration: 1, callback: function() {}}
	 */
	rotateTo: {
		value: function(ps) {
			var s = this;
			if (typeof ps == 'number') {
				ps = {
					to: ps
				};
			}

			var _time = fmg(ps, 'time', 'duration', .3);

			var from = s.direction;
			var _angle = fengmap.MapUtil.getNearestAngle(from, ps.to);

			var val;
			clearInterval(s._rotateToID);
			s._rotateToID = fm.Tween.work(_time, function(f) {
				val = from + _angle * f;
				if (val <= 0) {
					val = 360 + val;
				} else if (val >= 360) {
					val = val - 360;
				}

				s.direction = val;
			}, function() {
				if (ps.callback) {
					ps.callback();
				}
			});

			return s._rotateToID;
		}
	},
});
/**
 *	FMStoreModel 模型对象，为地图图层，只读，不可实例化。并继承FMNode 属性
 * 	@class FMStoreModel
 *	@constructor
 * 	@module FMNode
 * 	@extends fengmap.FMNode
 *  @namespace fengmap
 */
fengmap['FMModel'] = function(data, mesh, scene) {
	//console.log(data);
	fengmap.FMNode.call(this, fengmap['FMNodeType']['MODEL'], data, mesh, scene);

	//
	// 用于级别显示
	// 
	this.o3d_.minLevel = data.minLevel;
	this.o3d_.maxLevel = data.maxLevel;

	//
	// 可见性的开关
	//
	this._visible = true;
	this._show = true;


	this.setDrawablesVisible = function (boo){

		if (this.data_.storeImages) {
			for (var i = 0; i < this.data_.storeImages.length; i++) {
				this.data_.storeImages[i].visible = boo;
			}
		}

		if (this.storeImages) {
			for (var i = 0; i < this.storeImages.length; i++) {
				this.storeImages[i].visible = boo;
			}
		}

		this.frameLine.visible = boo;
		this.o3d_.visible = boo;
	}

	this.setBrothersShow = function (boo){

		if (this.brothers) {

			for (var i = 0; i < this.brothers.length; i++) {
				this.brothers[i].show = boo;
			}
		}
	}
}

/// -----------------------------------------
/// 动画id
/// ------------------START------------------

fengmap.FMModel.flashID = null;

/// -------------------END-------------------


fengmap['FMModel'].prototype = Object.create(fengmap.FMNode.prototype);

fengmap['FMModel'].prototype.constructor = fengmap['FMModel'];

//Object.assign(fengmap['FMModel'].prototype, {});

Object.defineProperties(fengmap.FMModel.prototype, {
	/**
	 * 模型ID，当前楼层的唯一ID。
	 * @property ID
	 * @type {number}
	 * @final
	 */
	'ID': {
		get: function() {
			return this.data_['oid'];
		}
	},


	/**
	 * 模型FID,整个建筑内唯一ID。
	 * @property FID
	 * @type {number}
	 * @final
	 */
	'FID': {
		get: function() {
			return this.data_['fid'];
		}
	},

	/**
	 * 模型名称
	 * @property name
	 * @type {string}
	 * @final
	 */
	'name': {
		get: function() {
			return this.data_['name'];
		}
	},

	/**
	 * 模型英文名称
	 * @property eName
	 * @type {string}
	 * @final
	 */
	'eName': {
		get: function() {
			return this.data_['ename'];
		}
	},

	// Override!
	'x': {
		get: function() {
			return this.coord_.x;
		},
		set: function(v) {}
	},
	'y': {
		get: function() {
			return this.coord_.y;
		},
		set: function(v) {}
	},
	'z': {
		get: function() {
			return this.coord_.z;
		},
		set: function(v) {}
	},
	'mapCoord': {
		get: function() {
			if (!this.coord_) {
				// 如果boundingSphere是null的话,先去计算它
				if (!this.o3d_.geometry.boundingSphere) {
					this.o3d_.geometry.computeBoundingSphere();
				}

				var loc = this.o3d_.geometry.boundingSphere.center;
				this.coord_ = new fengmap.FMMapCoord(-this.scene_.sceneX_ - loc.x,
					this.scene_.sceneZ_ + loc.y,
					this.o3d_.parent.localToWorld(new fm.Vector3()).y
				);
			}
			return this.coord_;
		}
	},

	/**
	 * 模型类型ID
	 * @property typeID
	 * @type {string}
	 * @final
	 */
	'typeID': {
		get: function() {
			return this.data_['type'];
		}
	},

	setColor: {
		value: function(color, alpha) {
			var s = this;

			alpha = alpha == undefined ? 1 : alpha;
			var strColor = fengmap.Line.prototype._colorToStr(color);

			s.o3d_.defaultMaterial_.color.set(strColor);

			if (!s.frameLine.defaultColor) {
				s.frameLine.defaultColor = s.frameLine.material.color.clone();
			}

			s.frameLine.material.color.set(s.o3d_.defaultMaterial_.color.clone().multiplyScalar(.8));
		}
	},

	setColorToDefault: {
		value: function() {
			this.o3d_.defaultMaterial_.color.copy(this.o3d_.defaultColor);
			this.frameLine.material.color.set(this.frameLine.defaultColor);
		}
	},

	visible: {
		get: function() {
			return this._visible;
		},
		set: function(boo) {

			this._visible = boo;

			var vis = this._show && this._visible;
			this.setDrawablesVisible(vis);
		}
	},

	show: {
		get: function() {
			return this._show;
		},
		set: function(boo) {
			this._show = boo;

			var vis = this._show && this._visible;
			this.setDrawablesVisible(vis);
			this.setBrothersShow(vis);
		}
	}
});

/**
 * subModel class
 */

fengmap.FMStoreModel = function(params) {
	var s = this;

	s.FID = params.FID;
	s.ID = params.ID;
	s.groupID = params.groupID;
	s.name = params.name;
	s.typeID = params.typeID;
	s.mapCoord = params.mapCoord;
	s.eName = params.data_.ename;
	s.minLevel = params.data_.minLevel;
	s.maxLevel = params.data_.maxLevel;
	s.data_ = params.data_;
	// s.selectedColor = params.selectedColor;

	s.nodeType = fengmap.FMNodeType.MODEL;

	s.o3d_ = null;
	s.material = null;
	s.materialIndex = null;
	s.frameLine = params.frameLine; //轮廓线

	this.faceRange = null;
	this.faceMaterialCache = [];

	//
	// 可见性的开关
	//
	this._visible = true;
	this._show = true;
}

fengmap.FMStoreModel.prototype = {
	constructor: fengmap.FMStoreModel,

	/**
	 * 修改模型的颜色及透明度,与是否选中该模型无关
	 * @method setColor
	 * @param {string} color 模型颜色设置。支持16进制颜色值。如：'#FF00FF', 或 0xFF00FF
	 * @param {int} alpha 透明度，0-1之间取值, 默认为 1
	 * @demo map/修改模型颜色.js
	 * @since v2.0.0
	 */
	setColor: function(color, alpha) {
		var s = this;
		alpha = alpha == undefined ? 1 : alpha;

		var strColor = fengmap.Line.prototype._colorToStr(color);

		if (!s.material) {
			s.material = new fengmap.FMMaterial({
				color: strColor,
				alpha: alpha
			});
		}

		// use setModelMaterial append to mateirals array and return materialIndex
		s.materialIndex = fengmap.MapUtil.setModelMaterial(null, s, s.material, s.materialIndex);

		s.material.setColor(strColor);
		s.material.setAlpha(alpha);

		//修改边线颜色 --TODO 
		// if (!s.frameLine.defaultColor) {
		// 	s.frameLine.defaultColor = s.frameLine.material.color.clone();
		// }

		// s.frameLine.material.color.set(s.material.color.clone().multiplyScalar(.8));
	},

	/**
	 * 将模型的颜色及透明度恢复回主题中的设置
	 * @method setColorToDefault
	 * @demo map/还原模型颜色.js
	 * @since v2.0.0
	 */
	setColorToDefault: function() {
		// 如果在 storeApply 里自定义了一颜色及透明度就
		// 还原回自定义的, 否则还原到主题中设置的颜色与透明度
		if (this.defaultColor) {
			this.setColor(this.defaultColor, this.defaultAlpha);
		} else {
			fengmap.MapUtil.setModelMaterialToDefault(null, this);
		}

		//还原边线颜色 --TODO 
		// if (this.frameLine.defaultColor)
		// this.frameLine.material.color.set(this.frameLine.defaultColor);
	},

	/**
	 * 自定义StoreImage的方法
	 * @method addStoreImage
	 * @param {json} params {
	 *      coord: 		{x:, y:}
	 * 		size: 		[width, height]
	 * 		height,		float
	 * 		image, 		'./image/**.png'
	 * 		angle		0~360                  
	 * }
	 * @return {FMStoreImage} FMStoreImage对象
	 */
	addStoreImage: function(params) {
		var _map = this.o3d_.fm_.scene_.map_;

		if (!params.image) {
			return;
		}

		params = Object.assign({
			height: 5,
			size: [5, 5],
		}, params);

		if (!params.coord) {
			var label = fengmap.MapUtil.getModelLabelObject(_map, this);
			params.coord = label ? label.fm_.mapCoord : {
				x: this.x,
				y: this.y
			};
			params.coord.groupID = this.groupID;
		}

		var group = _map.getFMGroup(this.groupID);
		var layer = group.getOrCreateLayer('storeImage');

		params.size = new fm.Vector2(params.size[0], params.size[1]);

		fengmap.MapUtil.loadTexture(params.image, function(tex) {
			params.image = tex;
			layer.addMarker(si);
		});

		var si = new fengmap.FMStoreImage({
			gid: this.groupID,
			fid: this.FID,
			style: params,
			map: _map
		});

		if (!this.storeImages) {
			this.storeImages = [];
		}

		////////////////
		// connection //
		////////////////
		this.storeImages.push(si);
		si.store = this;

		return si;
	},

	/**
	 * 移除自定义的storeImage的方法
	 * @method removeStoreImage
	 * @param  {FMStoreImage} si FMStoreImage 对象
	 * @return null
	 */
	removeStoreImage: function(si) {
		if (!this.storeImages || this.storeImages.length == 0) {
			return;
		}

		var index = this.storeImages.indexOf(si);
		if (index > -1) {
			this.storeImages.splice(index, 1);
		}

		si.dispose();
	},

	setDrawablesVisible :function (visible){

		if (this.data_.storeImages) {
			for (var i = 0; i < this.data_.storeImages.length; i++) {
				this.data_.storeImages[i].visible = visible;
			}
		}

		if (this.storeImages) {
			for (var i = 0; i < this.storeImages.length; i++) {
				this.storeImages[i].visible = visible;
			}
		}

		this.frameLine.visible = visible;

		var faces = this.o3d_.geometry.faces;

		if (visible == false) {
			if (this.faceMaterialCache.length != 0) {
				return;
			}

			this.setColorToDefault();
			this.faceMaterialCache = [];
			for (var i = this.faceRange[0]; i < this.faceRange[1]; i++) {

				this.faceMaterialCache.push(faces[i].materialIndex);
				faces[i].materialIndex = 3;
			}

			this.o3d_.geometry.groupsNeedUpdate = true;

		} else{
			var index = 0;
			if (this.faceMaterialCache.length == 0) {
				return;
			}

			for (var i = this.faceRange[0]; i < this.faceRange[1]; i++) {
				faces[i].materialIndex = this.faceMaterialCache[index]
				index ++;
			}
			this.faceMaterialCache = [];

			this.o3d_.geometry.groupsNeedUpdate = true;
		}

		// this.o3d_.visible = visible;
	}
};

Object.defineProperties(fengmap.FMStoreModel.prototype, {
	visible: {
		get: function() {
			return this._visible;
		},
		set: function(boo) {
			this._visible = boo;

			var vis = this._show && this._visible;
			this.setDrawablesVisible(vis);
		}
	},

	show: {
		get: function() {
			return this._show;
		},
		set: function(boo) {
			this._show = boo;

			var vis = this._show && this._visible;
			this.setDrawablesVisible(vis);
		}
	}
})
fengmap.FMPolygonLabel = function(data) {
    var geo = new fm.PlaneGeometry(1, 1, 1, 1);
    var tex = fengmap.MapLabel.prototype.makeTextSprite_.call(this, data.name, {
        external: true,
        borderThickness: 1,
        borderColor: fengmap.MapUtil.toRgba('255,255,255')
    });

    fm.Mesh.call(this, geo, new fm.MeshLambertMaterial({
        map: tex,
        transparent: true
    }));

    fengmap.FMElement.call(this, {
        data: data,
        o3d: this,
        type: fengmap.FMElementType.POLYGON_LABEL
    });

    this.renderOrder = 1;
    this.castShadow = false;

    this.scale.set(this.canvas.width / this.canvas.height * data.width, data.width, 1);
    this.rotation.set(-Math.PI / 2, 0, Math.PI - data.angle * fm.Math.DEG2RAD, 'XYZ');
    this.position.set(data.vertex[0] - data.sx, .1, data.vertex[1] - data.sz);
}

fengmap.FMPolygonLabel.prototype = Object.create(fm.Mesh.prototype);
fengmap.FMPolygonLabel.prototype.constructor = fengmap.FMPolygonLabel;

Object.assign(fengmap.FMPolygonLabel.prototype, fengmap.FMElement.prototype);
/**
 * FMPolygon 多边型类
 * 	• 继承 Mesh
 *
 * params: 
 * 	points,  // [{x: ,y:}...]
 * 	color: 0xF2561A,
 * 	alpha: .5,
 * 	lineWidth: .6,
 * 	height: 6.5
 * 	canPicked: false, // 是否可以被点击
 * 	
 */

 /**
*	FMPolygonMarker 自定义图片标注对象，继承FMNode 属性
* 	@class FMPolygonMarker
*	@constructor
* 	@module FMNode
* 	@extends fengmap.FMNode
*   @namespace fengmap
*   @param {object} opts
*          @param {float} opts.alpha  多边形的透明度。0-1之间取值, 默认为 0.5
*          @param {float} opts.lineWidth  多边形边框线宽。
*          @param {int} opts.height  多边形与楼层之间的高度, 默认为 6
*		   @param {array|json} opts.points  1.array格式的为多边形的坐标点集数组。类似[{x: 12961583, y: 4861865, z: 56},{x: 12961644, y: 4861874, z: 56}]数组。2.json格式的为圆形或矩形的设置，具体参数如下：
*		   @param {string} opts.points.type  多边形图层类型。'circle'表示圆形；'rectangle' 表示矩形。
*		   @param {fengmap.FMMapCoord} opts.points.center  圆形或矩形的中心点设置。
*		   @param {number} opts.points.radius  圆形的半径。
*		   @param {number} opts.points.segments  组成圆形的段数，默认40。值越大越接近圆。通常设置为近似圆的最小值，这样可以节省资源。
*		   @param {fengmap.FMMapCoord} opts.points.startPoint  矩形的起始点设置，代表矩形的左上角。如存在center设置时，则优先使用stratPoint的值绘制矩形。
*		   @param {number} opts.points.width  矩形的宽度。
*		   @param {number} opts.points.height  矩形的高度。
*		   @demo layer/添加多边形.js
*		   @demo layer/添加圆形.js
*		   @demo layer/添加矩形.js
*/

fengmap.FMPolygonMarker = function( params ) {
	this._geo = null;

	params = params || {};

	this.alias = 'polygonMarker';

	this.map = params.map || fengmap.Map.instance;

	Object.assign(this, {
		color: 0xf2561a,
		alpha: .5,
		lineWidth: 1,
		height: 6,		/* 些参数,将在add到layer的时候,运行的_init_ */
		points: {
			type: 'rectangle',
			center: this.map.center,
			width: 30,
			height: 30,
		}
	}, params);

	fengmap.FMElement.call(this, {
		type: fengmap.FMElementType.POLYGON_MARKER,
		o3d: new fm.Mesh(),
	});

	this.o3d_.material.transparent = true;
	this.o3d_.material.depthWrite  = false;
	this.o3d_.material.side        = fm.DoubleSide;

	// 使marker可以点击
	if (this.canPicked) {
		this.map.mapPicker.addModel(this.o3d_);
	}

	this.update(this, true);
}

fengmap.FMPolygonMarker.prototype = Object.create(fengmap.FMElement.prototype, {
	height: {
		get: function() {
			return this._height;
		},
		set: function(val) {
			this._height = val;
			if (this.o3d_) {
				this.o3d_.position.y = val;
			}
		}
	}
});

Object.assign(fengmap.FMPolygonMarker.prototype, {
	// added to layer then invoke
	_init_: function() {
		this.o3d_.position.y = this._height;
	},

	_dispose_: function() {
		if (this.canPicked) {
			this.map.mapPicker.removeModels(this.o3d_);
		}

		if (this.line) {
			this.line.dispose();
			this.line = null;
		}
	},

	alwaysShow: function (boo, renderOrder) {
		fengmap.MapLabel.generalFunctions.alwaysShow.call(this.o3d_, boo, renderOrder);
		fengmap.MapLabel.generalFunctions.alwaysShow.call(this.line, boo, renderOrder);
	},

	setColor: function(val) {
		this.update({color: val});
	},

	setLineWidth: function(val) {
		this.update({lineWidth: val});
	},

	setAlpha: function(val) {
		this.update({alpha: val});
	},

	_normalizePoints: function(ps) {
		var s = this;
		return ps.map(function(itm) {
			return new fm.Vector2(
				s.map.center.x - itm.x,
				s.map.center.y - itm.y
			);
		});
	},

	_createLine: function(vs) {
		var s = this;

		if (s.line) {
			s.line.dispose();
			s.line = null;
		}

		var vs = s.o3d_.geometry.vertices.map(function(itm) {return itm.clone();});
		vs.push(vs[0]);

		s.line = new fengmap.Line(s.map, vs, {
			color: s.color,
			lineWidth: s.lineWidth,
			lineType: fengmap.FMLineType.FULL,
			// dashArray: [1, 0]
		}, {
			up: new fm.Vector3(0, 0, 1), 
			notCenter: true
		});

		s.o3d_.add(s.line);
		s.line.position.set(0,0,0);
		s.line.material.visible = true;

		s.line.renderOrder = fengmap.FMRenderOrder.polygonMarker;
	},

	_createPoints: function(ps) {
		switch (ps.type) {
			case 'circle':
				if (ps.center && ps.radius) {
					var ct = ps.center;
					var radius = ps.radius || 30;
					var segments = ps.segments || 40;
					var vs = []

					for (var i = 0; i < segments; i++) {
						vs.push({
							x: ct.x + radius * Math.cos(Math.PI * 2 / segments * i),
							y: ct.y + radius * Math.sin(Math.PI * 2 / segments * i)
						});
					}
					return vs;
				}
			break;
			case 'rectangle':
				if (ps.width && ps.height && (ps.startPoint || ps.center)) {
					var ct = ps.center || this.map.center;
					var st = ps.startPoint; //优先取startPoint
					if (!st) {
						var st = {
							x: ct.x - ps.width / 2,
							y: ct.y - ps.height / 2
						};
					}

					return [
						{x: st.x, y: st.y}, 
						{x: st.x + ps.width, y: st.y},
						{x: st.x + ps.width, y: st.y + ps.height},
						{x: st.x , y: st.y + ps.height}
					];
				}
			break;
			default:
			break;
		}
	},

	update: function( params , isInit) {
		var s = this;
		if (!isInit) {
			Object.assign(s, params);
		}

		// 更新几何体
		if (params.points) {
			var _ps = null;

			if (params.points instanceof Array) {
				_ps = params.points;
				if (_ps.length < 3) {
					return;
				}
			} else if (typeof params.points == 'object') {
				_ps = s._createPoints(params.points);
				if (!_ps) {
					return;
				}
			}

			s.o3d_.geometry.dispose();

			var ps = s._normalizePoints(_ps);

			var newGeo = new fm.ShapeGeometry(new fm.Shape(ps));
			s.o3d_.geometry = newGeo;

			if (!params.lineWidth) {
				s._createLine(ps);
			}
			
			if (isInit) {
				s.o3d_.rotateX(-Math.PI / 2);
				s.o3d_.position.y = s.height;
			}

			s.o3d_.renderOrder = fengmap.FMRenderOrder.polygonMarker;
		}

		// 线宽
		if (params.lineWidth) {
			s._createLine(ps);
		}

		// 更新颜色
		if (params.color) {
			s.o3d_.material.color.set(s.color);
			s.line.color = s.color;
		}

		// 更新alpha
		if (params.alpha != undefined) {
			if (s.o3d_.material.opacity) {
				s.o3d_.material.opacity = s.alpha;
			}
		}
	},

	/**
	 * 是否包含指定的坐标
	 */
	contain: function(p) {
		var _p = Object.assign(p);

		_p = this._normalizePoints([_p])[0];

		var v = new fm.Vector3(_p.x, this.o3d_.getWorldPosition().y + 30, -_p.y);
		var dir = new fm.Vector3(0, -1, 0);

		var rc = new fm.Raycaster(v, dir);
		var res = rc.intersectObject(this.o3d_);

		return res.length > 0;
	}
});






/**
 * store 上面的图片
 * style: size, coord, image, height
 */
fengmap.FMStoreImage = function(params) {
    fengmap.FMElement.call(this, params);

    this._type_ = fengmap.FMElementType.STORE_IMAGE;

    var geo = new fm.PlaneBufferGeometry(1, 1, 1, 1);

    var mat = new fm.MeshLambertMaterial({
        transparent: true,
        depthWrite: false
    });

    mat.visible = false;

    this.map = params.map;
    this.o3d_ = new fm.Mesh(geo, mat);
    this.o3d_.visible = false;
    this.o3d_.fm_ = this;

    if (this.map && this.map.options.lazyCreateMode) {
        this.o3d_.rotation.set(Math.PI, 0, Math.PI + params.map.options.storeImageAngle * fm.Math.DEG2RAD, 'XZY');
    } else {
        this.o3d_.rotation.set(-Math.PI / 2, 0, Math.PI + params.map.options.storeImageAngle * fm.Math.DEG2RAD, 'XZY');
    }

    this.o3d_.minLevel = params.minLevel;
    this.o3d_.maxLevel = params.maxLevel;

    this.minLevel = params.minLevel;
    this.maxLevel = params.maxLevel;

    // this.o3d_.renderOrder = 1;
    this.o3d_.renderOrder = fengmap.FMRenderOrder.storeImage;
    
    this.name = params.style.name;

    this.updateStyle(this.params.style);

    this.isLoaded = false;

    // add update event
    // * remove it from performance
    // this._update_ = this._update.bind(this);
    // this.map.on('update', this._update_);
}

fengmap.FMStoreImage.prototype = Object.create(fengmap.FMElement.prototype);
fengmap.FMStoreImage.prototype.constructor = fengmap.FMStoreImage;

Object.assign(fengmap.FMStoreImage.prototype, {
    _display: function (image) {
        var self = this;
        self.o3d_.material.visible = true;

        self.o3d_.material.map = image;
        self.o3d_.material.map.minFilter = fm.LinearFilter;
        self.o3d_.material.map.anisotropy = 16;
        // self.o3d_.material.side = 2;

        if (!self.map.options.storeImageDistanceEnabled) {
            self.o3d_.visible = true;
        }
    },

    _update: function() {
        if (!self.map.options.storeImageDistanceEnabled) {
            return;
        }

        var s = this;
        if (!s.isLoaded) {return;}

        s.o3d_.visible = false;
        var dis;

        if (s.map.viewMode === '3d') {

            var dir = s.map.controls.constraint.getDirection();

            var sub = s.o3d_.position.clone().sub(s.map.controls.object.position);

            dis = sub.length();
            var _dir = sub.normalize();

            if (dir.clone().dot(_dir) > .75) {
                if (dis <= (s.map.options.storeImageDistance)) {
                    s.o3d_.visible = true;
                }
            }

        } else {
            dis = s.map.controls.constraint.getDistance() / s.map.controls.object.zoom;
            if (dis <= (s.map.options.storeImageDistance)) {
                s.o3d_.visible = true;
            }
        }
    },

    updateStyle: function(style) {
        var self = this;

        if (!style) {
            style = this.params.map.mapTheme.storeImages[this.params.fid];
        }

        // 等到图片加载完成之后. 再显示出来, 避免先出现个黑片儿
        // self._id = setInterval(function() {
        //     if (style.image) {
        //         if (style.image.image) {
        //             clearInterval(self._id);
        //             self.o3d_.material.visible = true;

        //             self.o3d_.material.map = style.image;
        //             self.o3d_.material.map.minFilter = fm.LinearFilter;
        //             self.o3d_.material.map.anisotropy = 16;

        //             self.o3d_.visible = true;
        //         } else {
        //             self.map.mapTheme.loadImage(style.image, function (tex) {
                        
        //             });
        //         }
        //     }
        // }, 0);

        if (typeof style.image === 'string') {
            self.map.mapTheme.loadImage(style, function (tex) {
                self._display(tex);
                self.isLoaded = true;
            });
        } else if (style.image instanceof Image) {
            self._display(style.image);
            self.isLoaded = true;
        }

        this.o3d_.scale.set(style.size.width, style.size.height, 1);

        if (this.map && this.map.options.lazyCreateMode) {
            this.o3d_.position.set(-(style.coord.x + this.map.mapScene.sceneX_), style.coord.y - this.map.mapScene.sceneZ_, -.05);
        } else {
            this.o3d_.position.set(-(style.coord.x + this.map.mapScene.sceneX_), style.height, style.coord.y - this.map.mapScene.sceneZ_);
        }

        // angle
        if (style.angle != undefined) {
            this.setAngle(style.angle);
        }
    },

    _dispose_: function () {
        this.map.off('update', this._update_);
        if (this.store) {
            this.store.removeStoreImage(this);
        }
    },

    setSize: function (width, height) {
        this.o3d_.scale.set(width, height, 1);
    },

    setUrl: function (url) {
        var s = this;
        fengmap.MapUtil.loadTexture(url, function (tex) {
            s.o3d_.material.map = tex;
        });
    },

    setAngle: function (angle) {
        this.o3d_.rotation.z = angle * fm.Math.DEG2RAD;
    },

    setPosition: function (coord) {
        var pos = this.map.toSceneCoord(coord);
        this.o3d_.position.copy(pos);
    }

});

/**
 *	FMTextMarker 自定义文本标注对象，为自定义图层。继承FMNode 属性
 * 	@class FMTextMarker
 *	@constructor
 * 	@module FMNode
 *   @namespace fengmap
 * 	@extends fengmap.FMNode
 *   @param {object} opts
 *          @param {float} opts.x  标注地图位置x值
 *          @param {float} opts.y 标注地图位置y值
 *          @param {string} opts.name  标注值
 *          @param {string} opts.fontsize    文本标注字号
 *          @param {string} opts.fillcolor    文本标注填充色，rgb类型字符串。如"255 0 0"
 *          @param {string} opts.strokecolor    文本标注填充色，rgb类型字符串。如'255,255,0'
 *          @param {int} opts.alpha    文本标注透明度，0-1之间取值
 */
fengmap.FMTextMarker = function(opts) {
    fengmap.FMNode.call(this, fengmap['FMNodeType']['TEXT_MARKER'], {}, new fm.Object3D());
    this.o3d_.forceVisible_ = this.o3d_.visible;
    this.opts_ = opts || {};
    // this.style_ = new fengmap.FMTextMarkerStyle(this, this.opts_.style);

    var style = {};

    this.alias = 'textMarker';

    style.fontsize = opts.fontsize || 12;
    style.fillcolor = opts.fillcolor || '0,0,0';
    style.strokecolor = opts.strokecolor || '255,255,255';
    style.alpha = opts.alpha || 1;

    this.style_ = style;
};

fengmap['FMTextMarker'].prototype = Object.create(fengmap.FMNode.prototype);

fengmap['FMTextMarker'].prototype.constructor = fengmap['FMTextMarker'];

Object.assign(fengmap['FMTextMarker'].prototype, {
    tryCreate_: function(fmLayer) {
        if (this.o3d_ instanceof fm.Object3D) {
            if (!fmLayer.parent) {

                fmLayer.o3d_.add(this.o3d_);

            } else {
                //replace dummy Object3D!
                fmLayer.o3d_.remove(this.o3d_);

                var fmGroup = fmLayer.parent;
                var scene = fmGroup.scene_;
                this.scene_ = scene;
                var uo = fengmap.util.Option;

                this.x_ = uo.getValue(this.opts_, 'x', fmGroup.mapCoord.x);
                this.y_ = uo.getValue(this.opts_, 'y', fmGroup.mapCoord.y);
                this.z_ = uo.getValue(this.opts_, 'z', 6);
                this.name_ = uo.getValue(this.opts_, 'name', '测试文本');
                this.id_ = uo.getValue(this.opts_, 'id', fengmap.util.id++);

                var fv = this.o3d_.forceVisible_;

                this.o3d_ = new fengmap.MapLabel(fmGroup.groupID, {
                    oid: this.id_,
                    vertex: [this.x_, this.y_],
                    name: this.name_
                }, this.style_, this.scene_.map_,fengmap['FMNodeType']['TEXT_MARKER']);

                this.o3d_.forceVisible_ = false;
                this.o3d_.visible = false;
                this.o3d_.fm_ = this;

                var _h = 0;

                if (this.opts_.height != undefined) {
                    _h = this.opts_.height;
                } else if (this.z_ != undefined) {
                    _h = this.z_;
                } else {
                    _h = 6;
                }

                this.o3d_.position.set(-this.x_ - scene.sceneX_, _h, this.y_ - scene.sceneZ_);
                this.o3d_.initY_ = _h;

                // 先更新一下大小, 解决加载之后会有一个大小变化的问题
                // this.o3d_.updateScreenSize(this.scene_.map_.mapView);

                var self = this;

                this.scene_.map_.update_(true);

                setTimeout(function() {
                    // self.o3d_.forceVisible_ = fv;
                    self.visible = fv;
                    fmLayer.o3d_.add(self.o3d_);

                    if (self.opts_.callback) {
                        self.opts_.callback();
                    }

                }, 0);

                scene.map_.mapPicker.addUserLabel(this.o3d_);
            }
        }
    },

    _init_: function() {
        
    },

    // 目前用于在mapPicker中移除
    _dispose_: function () {
        this.scene_.map_.mapPicker.removeObject(this.o3d_);
    },

    setPosition: fengmap.FMLocationMarker.prototype.setPosition,

    // alwaysShow: function() {fengmap.MapLabel.prototype.alwaysShow.call(this.o3d_);}
}, fengmap.MapLabel.parentFunctions, fengmap.FMImageMarker.MarkerFunctions);

Object.defineProperties(fengmap['FMTextMarker'].prototype, {
    'x':{
        // get: function() {
        //     if (this.scene_) {
        //         return -this.o3d_.originPosition.x-this.scene_.sceneX_;
        //     } else {
        //         return 0;
        //     }
        // },
        // set: function(v) {
        //     if (this.scene_) {
        //         this.o3d_.originPosition.setX(-v -this.scene_.sceneX_);
        //     } else {
        //         this.opts_ = this.opts_ || {};
        //         this.opts_.x = v;
        //     }
        // }
        get: function () {
            if (this.scene_) {
                return -this.o3d_.position.x - this.scene_.sceneX_;
            } else {
                return 0;
            }
        },
        set: function (v) {
            if (this.scene_) {
                this.o3d_.position.x = -v - this.scene_.sceneX_;
            } else {
                this.opts_ = this.opts_ || {};
                this.opts_.x = v;
            }
        }
    },
    /**
     * 地图元素中心点对应地图坐标y
     * @property y
     * @type {float}
     */
    'y':{
        // get: function() {
        //     if (this.scene_) {
        //         return this.o3d_.originPosition.z + this.scene_.sceneZ_;
        //     } else {
        //         return 0;
        //     }
        // },
        // set: function(v) {
        //     if (this.scene_) {
        //         this.o3d_.originPosition.setZ(v -this.scene_.sceneZ_);
        //     } else {
        //         this.opts_ = this.opts_ || {};
        //         this.opts_.y = v;
        //     }
        // }
        get: function () {
            if (this.scene_) {
                return this.o3d_.position.z + this.scene_.sceneZ_;
            } else {
                return 0;
            }
        },
        set: function (v) {
            if (this.scene_) {
                this.o3d_.position.z = v - this.scene_.sceneZ_;
            } else {
                this.opts_ = this.opts_ || {};
                this.opts_.y = v;
            }
        }
    },
    /**
     * 文本标注名称
     * @property name
     * @type {string}	 
     */
    "name": {
        get: function() {
            if (this.opts_ && this.opts_.name) {
                return this.opts_.name;
            }
        },
        set: function(v) {
            if (this.scene_) {
                this.o3d_.setname(v);
            }

            this.opts_ = this.opts_ || {};
            this.opts_.name = v;
        }
    },

    text: {
        get: function() {
            return this.name;
        },
        set: function(v) {
            this.name = v;
        }
    },

    /**
     * 文本标注字号
     * @property fontsize
     * @type {string}	 
     */
    "fontsize": {
        get: function() {
            if (this.style_ && this.style_.fontsize) {
                return this.style_.fontsize;
            }
        },
        set: function(v) {
            if (this.scene_) {
                this.o3d_.setfontsize(v);
            }

            this.style_ = this.style_ || {};
            this.style_.fontsize = v;
        }
    },

    /**
     * 文本标注填充色(rgb)如："72，61，139"
     * @property fillcolor
     * @type {string}	 
     */
    "fillcolor": {
        get: function() {
            if (this.style_ && this.style_.fillcolor) {
                return this.style_.fillcolor;
            }
        },
        set: function(v) {
            if (this.scene_) {
                this.o3d_.setfillcolor(v);
            }

            this.style_ = this.style_ || {};
            this.style_.fillcolor = v;
        }
    },

    /**
     * 文本标注边框色(rgb)如："72，61，139"
     * @property strokecolor
     * @type {string}	 
     */
    "strokecolor": {
        get: function() {
            if (this.style_ && this.style_.strokecolor) {
                return this.style_.strokecolor;
            }
        },
        set: function(v) {
            if (this.scene_) {
                this.o3d_.setfontstrokecolor(v);
            }

            this.style_ = this.style_ || {};
            this.style_.strokecolor = v;
        }
    },

    "style": {
        get: function() {
            return this.style_;
        }
    },
    /**
     * 是否可见，可修改
     * @property visible
     * @type {boolean}
     */
    // 'visible': {
    //     get: function() {
    //         return this.o3d_.visible;
    //     },
    //     set: function(v) {
    //         this.o3d_.forceVisible_ = v;
    //         this.o3d_.visible = v;
    //     }
    // },
    /**
     * 文本标注ID
     * @property ID
     * @type {number}
     * @final
     */
    'ID': {
        get: function() {
            return this.id_;
        }
    }    
});

/**
 *	FMGroup 模型层对象，并继承FMNode 属性
 * 	@class FMGroup
 *	@constructor FMGroup
 * 	@module FMNode
 *   @namespace fengmap
 * 	@extends fengmap.FMNode
 *   @demo layer/添加文本标注.js
 *   @demo layer/添加图片标注.js
 *   @demo layer/添加定位标注.js
 */
fengmap['FMGroup'] = function(scene, data) {
	//console.log('CREATE FMGROUP!');
	fengmap.FMNode.call(this, 0, data, new fm.Object3D(), scene);
};

fengmap['FMGroup'].prototype = Object.create(fengmap.FMNode.prototype);

fengmap['FMGroup'].prototype.constructor = fengmap['FMGroup'];

Object.assign(fengmap['FMGroup'].prototype, {
	/**
	 * 添加图层。可添加自定义图层展示在地图上。
	 * @method addLayer
	 * @param {object} layer 类型，可添加FMImageMarkerLayer，FMTextMarkerLayer，FMLocationMarkerLayer三种类型的图层
	 */
	'addLayer': function(layer) {
		// if (layer instanceof fengmap.FMImageMarkerLayer) {} else if (layer instanceof fengmap.FMTextMarkerLayer) {} else if (layer instanceof fengmap.FMLocationMarkerLayer) {} else if (layer instanceof fengmap.FMLayer) {} else {
		// 	console.warn("Only FMImageMarkerLayer || FMTextMarkerLayer || FMLocationMarkerLayer acceptable!");
		// 	return;
		// }
		this.o3d_.add(layer.o3d_);

		var c = layer.o3d_.children;
		//console.log('ADD Layer', c);
		for (var i = 0; i < c.length; i++) {
			if (c[i].fm_ && c[i].fm_.tryCreate_) {
				c[i].fm_.tryCreate_(layer);
			}
		}

		//test!
		//this.o3d_.add(new fm.AxisHelper(50));
	},

	/**
	 * 返回与指定 layer别名 的第一个层, 如果不存在,那么就直接创建
	 * @method getOrCreateLayer
	 * @param  {string} layerAlias layer的别名: "imageMarker", "textMarker","polygonMarker","storeImage"
	 * @return {layer}            FMImageMarkerLayer or FMTextMarkerLayer 或者 FMPolygonMarkerLayer
	 */
	getOrCreateLayer: function(layerAlias, data) {
		data = data || {};
		var layer = this.getFirstLayer(layerAlias);
		if (!layer) {
			switch (layerAlias) {
				case 'imageMarker':
					layer = new fengmap.FMImageMarkerLayer(null, this.scene_.map_);
					break;
				case 'textMarker':
					layer = new fengmap.FMTextMarkerLayer();
					break;
				case 'locationMarker':
					layer = new fengmap.FMLocationMarkerLayer();
					break;
				case 'polygonMarker':
					layer = new fengmap.FMPolygonMarkerLayer();
					break;
				case 'storeImage':
					layer = new fengmap.FMLayer({}, fengmap.FMLayerType.STORE_IMAGE);
					break;
				case 'externalModel':
					layer = new fengmap.FMLayer({}, fengmap.FMLayerType.EXTERANL_MODEL);
					break;
				case 'extent':
					layer = new fengmap.FMExtentLayer(data);
					break;
				case 'model':
					layer = new fengmap.FMModelLayer(data);
					break;
				case 'poi':
					layer = new fengmap.FMFacilityLayer(data, this.scene_.map_);
					break;
				case 'label':
					layer = new fengmap.FMLabelLayer(data, this.scene_.map_);
					break;
			}

			if (layer) {
				this.addLayer(layer);
			}

			this.scene_.map_.emit('createLayerComplete', {
								'groupID':this.groupID,
								'layer':layer,
								'alias':layerAlias});
		}
		return layer;
	},

	/**
	 * 返回与指定 layer别名 的第一个层
	 * @method getFirstLayer
	 * @param  {string} layerAlias layer的别名: "imageMarker", "textMarker"
	 * @return {layer}            FMImageMarkerLayer or FMTextMarkerLayer ...
	 */
	getFirstLayer: function(layerAlias) {
		var res = this.scene_.map_.getLayerByAlias(this.groupID, layerAlias);
		if (res) {
			if (res.length) {
				return res[0];
			} else {
				return res;
			}
		}
		return null;
	},

	/**
	 * 返回与指定 layer别名 层或所有层, 如要只有一个层与之相符则会将此层返回,
	 * 如果有两个层与之相符则会以数组的形式返回所有
	 * 
	 * @method getLayer
	 * @param  {string} layerAlias layer的别名: "imageMarker", "textMarker"
	 * @return {layer or Array}            FMImageMarkerLayer or FMTextMarkerLayer ... or [layer, layer...]
	 */
	getLayer: function(layerAlias) {
		return this.scene_.map_.getLayerByAlias(this.groupID, layerAlias);
	},

	/**
	 * 移除图层
	 * @method removeLayer
	 * @param {object} layer 类型，可添加FMImageMarkerLayer，FMTextMarkerLayer，FMLocationMarkerLayer三种类型的图层	 
	 */
	'removeLayer': function(layer) {
		layer.o3d_.visible = false;

		// dispose layer's children (markers)
		var cnt = 0;
		while (layer.o3d_.children.length > cnt) {
			var cdn = layer.o3d_.children[cnt];
			if (cdn.fm && cdn.fm.dispose) {
				cdn.fm.dispose();
			} else {
				cnt++;
			}
		}

		if (layer._dispose_) {
			layer._dispose_();
		}
		this.o3d_.remove(layer.o3d_);
	},

	/**
	 * 应用热力图
	 * @method applyHeatMap
	 * @param {fengmap.FMHeatMap} heatmap 类型，对生成的热力图应用到该楼层上
	 */
	'applyHeatMap': function(heatmap) {
		if (heatmap && this.data_.gid){
			heatmap.renderToMap(this.data_.gid);
			this.heatmap_ = heatmap;
		}
	},

	/**
	 * 移除应用热力图
	 * @method removeHeatMap
	 * @param {fengmap.FMHeatMap} heatmap 类型，移除该楼层上的热力图
	 */
	'removeHeatMap': function(heatmap) {
		if (heatmap && this.data_.gid){
			heatmap.disposeHeatMap(this.data_.gid);
			this.heatmap_ = null;
		}
	},

	/**
	 * 应用散点图
	 * @method applyScatterPlot
	 * @param {fengmap.FMScatterPlot} scatterplot 类型，对生成的散点图应用到该楼层上
	 */
	'applyScatterPlot': function(scatterplot) {
		if (scatterplot && this.data_.gid)
			scatterplot.renderToMap(this.data_.gid);
	},

	/**
	 * 移除应用散点图
	 * @method removeScatterPlot
	 * @param {fengmap.FMScatterPlot} scatterplot 类型，移除该楼层上的散点图
	 */
	'removeScatterPlot': function(scatterplot) {
		if (scatterplot && this.data_.gid)
			scatterplot.disposeScatterPlot(this.data_.gid);
	},

	// -------------------------------------------------------------------------

	/**
	 * 遍历图层方法
	 * @method traverse
	 * @param callback 遍历回调方法
	 * @return 回掉方法返回参数，包含：遍历深度deep、遍历的对象fm. 
	 */
	'traverse': function(callback) {
		this.traverse_(callback, this.o3d_, 0);
	},

	traverse_: function(callback, o3d, deep) {
		if (o3d.fm_) {
			callback(o3d.fm_, deep);
		}
		for (var i = 0; i < o3d.children.length; i++) {
			this.traverse_(callback, o3d.children[i], deep + 1);
		}
	},

	showStairs: function(boo) {
		boo = boo == undefined ? true : boo;
		if (this.stairsLayer) {
			this.stairsLayer.visible = boo;
		}
	},

	stairsConnect: function(boo) {
		fengmap.MapUtil.stairsConnect(this.scene_.map_, this.groupID, boo);
	},

	/**
	 * 为 extent 模型，赋贴图
	 * @method setExtentImage
	 * @param {Image | string} imageOrPath Image对象或图片的路径
	 */
	setExtentImage: function (imageOrPath) {
		var extent = this.scene_.map_.getObjectsByAlias(this.groupID, 'extent')[0];

		if (imageOrPath instanceof fm.Texture) {
			extent.material.map = imageOrPath;
			extent.material.needsUpdate = true;
		} else if (typeof imageOrPath === 'string') {
			fengmap.MapUtil.loadTexture(imageOrPath, function (img) {
				extent.material.map = img;
				extent.material.needsUpdate = true;
			});
		}
	},

	/**
	 * 清除 extent 上的贴图
	 * @method clearExtentImage
	 */
	clearExtentImage: function () {
		var extent = this.scene_.map_.getObjectsByAlias(this.groupID, 'extent')[0];
		
		extent.material.map.dispose();
		extent.material.map = null;
		extent.material.needsUpdate = true;
	}
	
});

Object.defineProperties(fengmap['FMGroup'].prototype, {

	'groupID': {
		get: function() {
			return this.data_.gid;
		}
	},

	/**
	 * 楼层别名
	 * @property groupAlias
	 * @type {string}
	 * @final
	 */
	'groupAlias': {
		get: function() {
			return this.data_.alias;
		}
	},

	/**
	 * 楼层描述
	 * @property groupDesc
	 * @type {string}
	 * @final
	 */
	'groupDesc': {
		get: function() {
			return this.data_.desc;
		}
	},

	/**
	 * 楼层高度
	 * @property groupDesc
	 * @type {string}
	 * @final
	 */
	'groupHeight': {
		get: function() {
			return this.data_.height;
		}
	},

	/**
	 * 楼层名称
	 * @property groupName
	 * @type {string}
	 * @final
	 */
	'groupName': {
		get: function() {
			return this.data_.gname;
		}
	},
	'mapCoord': {
		get: function() {
			return new fengmap.FMMapCoord(-this.scene_.sceneX_, this.scene_.sceneZ_, this.o3d_.meta_.height);
		}
	},
	// -------------------------------------------------------------------------

	'layers': {
		get: function() {
			var layers = [];
			for (var i = 0; i < this.o3d_.children.length; i++) {
				var c = this.o3d_.children[i];
				var fm = c.fm_;
				if (fm) {
					layers.push(fm);
				}
			}
			return layers;
		}
	}

});
/**
 * 
 */

fengmap['FMExtentLayer'] = function(data) {
	fengmap.FMNode.call(this,0, data, new fm.Object3D());
	this.requireCollide_ = true;
};

fengmap['FMExtentLayer'].prototype = Object.create(fengmap.FMNode.prototype);

fengmap['FMExtentLayer'].constructor = fengmap['FMExtentLayer'];

//Object.assign(fengmap['FMExtentLayer'].prototype, {
//});


/**
 * 
 */

fengmap['FMExternalModelLayer'] = function(data) {
    fengmap.FMNode.call(this,0, data, new fm.Object3D());

    this._type_ = fengmap.FMLayerType.EXTERANL_MODEL;
    this._elements = [];
};

fengmap['FMExternalModelLayer'].prototype = Object.create(fengmap.FMNode.prototype);

fengmap['FMExternalModelLayer'].constructor = fengmap['FMExternalModelLayer'];

Object.assign(fengmap['FMExternalModelLayer'].prototype, {

     addElement: function(element) {
        this._elements.push(element);
    },

    removeElement: function(element) {

        var index = this._elements.indexOf( element );
        if ( index !== - 1 ) {
            this._elements.splice( index, 1 );
        }
    },

    removeAllElement: function() {
        this._elements = [];
    }
});


/**
*	FMFacilityLayer 公共设施层对象，并继承FMNode 属性
* 	@class FMFacilityLayer
*	@constructor
* 	@module FMNode
* 	@extends fengmap.FMNode
*   @namespace fengmap
*/
fengmap['FMFacilityLayer'] = function(data, map) {
	fengmap.FMNode.call(this,0, data, new fm.Object3D());
	this.requireCollide_ = true;

	this.map = data.map || map;

	this.fadeSpeed = this.map.options.poiLabelFadeSpeed || 5;
	this.noFade = !this.map.options.poiLabelFadeMode;

	// 注册 Layer 的 update事件
	if (this.map) {
		this._updateFun = this.update.bind(this);
		this.map.on('update', this._updateFun);

		// if (!map.options.lazyCreateMode) {
		// 	this._mapScaleLevelChangedFun = this.display.bind(this);
		// 	this.map.on('mapScaleLevelChanged', this._mapScaleLevelChangedFun);
		// }
	}
};

fengmap['FMFacilityLayer'].prototype = Object.create(fengmap.FMNode.prototype, {
	requireCollide: {
		get: function () {
			return this.requireCollide_;
		},
		set: function (val) {
			this.requireCollide_ = val;
		}
	}
});

fengmap['FMFacilityLayer'].constructor = fengmap['FMFacilityLayer'];

////////////////////////
// POI 与 Label  Layer 的一些常用方法 //
////////////////////////
fengmap.FMFacilityLayer.PoiAndlableFunctions = {
	update: function (delta) {
		var s = this;
		if (!s.map.options.poiLabelFadeMode || !s.requireCollide_ || !s.visible || s.noFade) {return;}

		var cs = s.o3d_.children;

		cs.forEach(function (obj) {
			// not visible
			if (s.map.visibleGroupIDs.indexOf(s.groupID) < 0) {return;}
			
			if (!obj.fm_.visible || !obj.material) {return;}

			var maxValue = 1;
			// focus alpha mode
			if (s.map.options.focusAlphaMode) {
				if (s.groupID != s.map.focusGroupID) {
					maxValue = s.map.options.focusAlpha;
				}
			}

			// 固定的Alpha值, 不发生变化
			if (obj.fm_ && obj.fm_.visible && obj.fm_.constAlpha != undefined) {
				obj.material.opacity = obj.fm_.constAlpha;
				return;
			}

			if (obj.fadeVisible != undefined) {

				if (!obj.visible) {obj.visible = true;}

				if ((obj.fadeVisible && obj.material.opacity == maxValue) || 
					(!obj.fadeVisible && obj.material.opacity == 0)) {
					return;
				}

				var v = obj.material.opacity;
				var added = s.fadeSpeed * delta;

				v += obj.fadeVisible ? added : -added;
				v = fm.Math.clamp(v, 0, maxValue);

				obj.material.opacity = v;
			} else {
				obj.material.opacity = maxValue;
			}
		});

	},
	// display: function (data) {	// {mapScale:, lastMapScale:}
	// 	var ms = data ? data.mapScale : this.map.mapScaleLevel;
	// 	if (this.maxLevel && this.minLevel) {
	// 		if (ms > this.minLevel && ms <= this.maxLevel) {
	// 			this.visible = true;
	// 		} else {
	// 			this.visible = false;
	// 		}
	// 	}
	// },
	_dispose_: function () {
		if (this.map) {
			this.map.off('update', this._updateFun);
			this.map.off('mapScaleLevelChanged', this._mapScaleLevelChangedFun);
		}
	},
	clone: function () {
		var ll = null;
		if (this instanceof fengmap.FMLabelLayer) {
			ll = new fengmap.FMLabelLayer(this.data_, this.map);
			ll.poiLayer = this.poiLayer;
		} else {
			ll = new fengmap.FMFacilityLayer(this.data_, this.map);
		}
		
		ll.o3d_.boxCollision_ = new fengmap.MapBoxCollision();

		if (this.o3d_.parent) {
			this.o3d_.parent.add(ll.o3d_);
		}
		return ll;
	}
};

Object.assign(fengmap['FMFacilityLayer'].prototype, fengmap.FMFacilityLayer.PoiAndlableFunctions, {
	
});

/**
 *	FMImageMarkerLayer 图片标注层对象，可添加任意个图片标注,并继承FMNode 属性
 * 	@class FMImageMarkerLayer
 *	@constructor
 * 	@module FMNode
 *  @namespace fengmap
 * 	@extends fengmap.FMNode
 */

fengmap['FMImageMarkerLayer'] = function(data, map) {
	fengmap.FMNode.call(this, 0, data, new fm.Object3D());
	this.o3d_.boxCollision_ = new fengmap.MapBoxCollision();
	this.requireCollide_ = false;

	if (data) {
		this.map = data.map
	} else {
		this.map = map;
	}

	// 注册 Layer 的 update事件
	if (this.map) {
		this.fadeSpeed = this.map.options.poiLabelFadeSpeed || 5;
		this.noFade = !this.map.options.poiLabelFadeMode;

		if (this.update) {
			this._updateFun = this.update.bind(this);
			this.map.on('update', this._updateFun);
		}

		// if (!map.options.lazyCreateMode) {
		// 	this._mapScaleLevelChangedFun = this.display.bind(this);
		// 	this.map.on('mapScaleLevelChanged', this._mapScaleLevelChangedFun);
		// }
	}
};

fengmap['FMImageMarkerLayer'].prototype = Object.create(fengmap.FMNode.prototype);

fengmap['FMImageMarkerLayer'].constructor = fengmap['FMImageMarkerLayer'];

Object.assign(fengmap['FMImageMarkerLayer'].prototype, {
	/**
	 * 添加图片标注
	 * @method addMarker
	 * @param {fengmap.FMImageMarker} marker 此图层可为FMImageMarker对象	 
	 */
	'addMarker': function(marker) {
		if (marker instanceof fengmap['FMImageMarker']) {
			marker.tryCreate_(this);

			if (marker._init_) {
				marker._init_();
			}
		} else {
			console.warn('Please use fengmap.FMImageMarker!');
		}
	},

	/**
	 * 移除单个图片标注
	 * @method removeMarker
	 * @param {fengmap.FMImageMarker} marker 此图层可为已添加的某个FMImageMarker对象	 
	 */
	'removeMarker': function(marker) {
		if (marker instanceof fengmap['FMImageMarker']) {
			marker.dispose();
		} else {
			console.warn('Please use fengmap.FMImageMarker!');
		}
	},

	/**
	 * 移除该层的所有图片标注
	 * @method removeAll
	 */
	'removeAll': function() {
		fengmap.FMTextMarkerLayer.prototype.removeAll.call(this);
	}
}, fengmap.FMFacilityLayer.PoiAndlableFunctions);

/**
 * 该层的所有图片标注集合数组
 * @property markers
 * @type {array}
 * @final
 */
Object.defineProperty(fengmap['FMImageMarkerLayer'].prototype, "markers", {
	get: function() {
		var ms = [];
		for (var i = 0; i < this.o3d_.children.length; i++) {
			ms.push(this.o3d_.children[i].fm_);
		}
		return ms;
	}
});
/**
*	FMLabelLayer 文字标注层对象，并继承FMNode 属性
* 	@class FMLabelLayer
*	@constructor
* 	@module FMNode
* 	@extends fengmap.FMNode
*   @namespace fengmap
*/
fengmap['FMLabelLayer'] = function(data, map) {
	fengmap.FMNode.call(this,0, data, new fm.Object3D());
	this.requireCollide_ = true;

	// this.o3d_.collider_

	this.map = data.map || map;

	this.fadeSpeed = this.map.options.poiLabelFadeSpeed || 5;
	this.noFade = !this.map.options.poiLabelFadeMode;

	// 注册 Layer 的 update事件
	if (this.map) {
		this._updateFun = this.update.bind(this);
		this.map.on('update', this._updateFun);

		// if (!map.options.lazyCreateMode) {
		// 	this._mapScaleLevelChangedFun = this.display.bind(this);
		// 	this.map.on('mapScaleLevelChanged', this._mapScaleLevelChangedFun);
		// }

	}
};

fengmap['FMLabelLayer'].prototype = Object.create(fengmap.FMNode.prototype, {
	requireCollide: {
		get: function () {
			return this.requireCollide_;
		},
		set: function (val) {
			this.requireCollide_ = val;
		}
	}
});

fengmap['FMLabelLayer'].constructor = fengmap['FMLabelLayer'];

Object.assign(fengmap['FMLabelLayer'].prototype, fengmap.FMFacilityLayer.PoiAndlableFunctions);

/**
 * 通用的Layer
 *
 *  此类支持 marker 的两个接口:
 *     _init_:      用于element添加到layer时的初始化工作
 *     _dispose_:   用于移除element时需要注销掉的一些事件及资源
 *     
 */
fengmap.FMLayer = function(data, type) {
    fengmap.FMNode.call(this, 0, data, new fm.Object3D());

    this._type_ = type || fengmap.FMLayerType.NONE;
};

fengmap.FMLayer.prototype = Object.create(fengmap.FMNode.prototype);
fengmap.FMLayer.prototype.constructor = fengmap.FMLayer;

Object.assign(fengmap.FMLayer.prototype, {
    addMarker: function(element) {
        this.o3d_.add(element.o3d_);

        // 在将element加入layer的时候运行的初始化方法
        if (element._init_) {
            element._init_();
        }
    },
    remove: function(element) {
        element.dispose();
    },
    removeMarker: function(element) {
        element.dispose();
    },
    removeAll: function() {
        var cnt = 0;
        while (this.o3d_.children.length > cnt) {
            var cdn = this.o3d_.children[cnt];
            if (cdn.fm_ && cdn.fm_.dispose) {
                cdn.fm_.dispose();
            } else {
                cnt++;
            }
        }
    }
});

/////////////////////////////////
// layer 的演生类 
/////////////////////////////////

/**
 * polygon marker layer
 */
/**
 *  FMPolygonMarkerLayer 多边形标注层对象，矩形，圆，多边形图层。一个多边形图层上可添加任意个多边形标注,继承FMNode 属性
 *  @class FMPolygonMarkerLayer
 *  @constructor
 *  @module FMNode
 *  @namespace fengmap
 *  @extends fengmap.FMNode
 */

/**
 * 添加多边形标注
 * @method addMarker
 * @param {fengmap.FMPolygonMarker} marker 此图层可为FMPolygonMarker对象    
 */

/**
 * 移除单个多边形标注
 * @method removeMarker
 * @param {fengmap.FMPolygonMarker} marker 此图层可为已添加的某个FMPolygonMarker对象  
 */

/**
 * 移除该层的所有多边形标注
 * @method removeAll
 */

fengmap.FMPolygonMarkerLayer = function(data) {
    fengmap.FMLayer.call(this, data, fengmap.FMLayerType.POLYGON_MARKER);
}

fengmap.FMPolygonMarkerLayer.prototype = Object.create(fengmap.FMLayer.prototype);
/**
 * 
 */
fengmap['FMLineLayer'] = function(data) {
	fengmap.FMNode.call(this,0, data, new fm.Object3D());
	this.requireCollide_ = true;
};

fengmap['FMLineLayer'].prototype = Object.create(fengmap.FMNode.prototype);

fengmap['FMLineLayer'].constructor = fengmap['FMLineLayer'];

Object.assign(fengmap['FMLineLayer'].prototype, {
	'addMarker': function(marker) {
		if (marker instanceof fengmap['FMLineMarker']) {
			marker.tryCreate_(this);
		} else {
			console.warn('Please use fengmap.FMLineMarker!');
		}
	},
	'removeMarker': function(marker) {
		if (marker instanceof fengmap['FMLineMarker']) {
			this.o3d_.remove(marker.o3d_);
		} else {
			console.warn('Please use fengmap.FMLineMarker!');
		}
	},
	'removeAll': function() {
		for (var i=0; i<this.o3d_.children.length; i++) {
			this.o3d_.remove(this.o3d_.children[i]);
		}
	}
});

Object.defineProperty(fengmap['FMLineLayer'].prototype, "markers", {
	get: function() {
		var ms = [];
		for (var i=0; i<this.o3d_.children.length; i++) {
			ms.push(this.o3d_.children[i].fm_);
		}
		return ms;
	}
});

/**
 *	FMLocationMarkerLayer 定位标注层对象，并继承FMNode 属性
 *	不需要了 2017-08-29
 */
fengmap['FMLocationMarkerLayer'] = function(data) {
	fengmap.FMNode.call(this, 0, data, new fm.Object3D());
	this.o3d_.boxCollision_ = new fengmap.MapBoxCollision();
	this.requireCollide_ = false;
};

fengmap['FMLocationMarkerLayer'].prototype = Object.create(fengmap.FMNode.prototype);

fengmap['FMLocationMarkerLayer'].constructor = fengmap['FMLocationMarkerLayer'];

Object.assign(fengmap['FMLocationMarkerLayer'].prototype, {
	/**
	 * 添加定位标注
	 * @method addMarker
	 * @param {fengmap.FMLocationMarker} marker 此图层可为FMLocationMarker对象
	 */
	'addMarker': function(marker) {
		if (marker instanceof fengmap['FMLocationMarker']) {
			var self = this;

			self.o3d_.add(marker.o3d_);

			if (marker._init_) {
				marker._init_();
			}

			// marker.tryCreate_(this);
			/*
			(function() {
				var id = setInterval(function() {
					if (marker.mapLoaded) {
						clearInterval(id);

						var scene = marker.scene_ || fengmap.MapUtil.getMapScene(self);
						marker.scene_ = scene;

						self.o3d_.add(marker.o3d_);

						// scene.map_.forceUpdate();
						marker.height = marker.height_;

						marker.o3d_.material.visible = true;
					}
				}, 0);
			})();
			//*/
		} else {
			console.warn('Please use fengmap.FMLocationMarker!');
		}
	},

	/**
	 * 移除单个定位标注
	 * @method removeMarker
	 * @param {fengmap.FMLocationMarker} marker 此图层可为已添加的某个FMLocationMarker对象	 
	 */
	'removeMarker': function(marker) {
		if (marker instanceof fengmap['FMLocationMarker']) {
			marker.dispose();
		} else {
			console.warn('Please use fengmap.FMLocationMarker!');
		}
	},

	/**
	 * 移除该层的所有定位标注
	 * @method removeAll
	 */
	'removeAll': function() {
		fengmap.FMTextMarkerLayer.prototype.removeAll.call(this);
	}
});

/**
 * 该层的所有定位标注集合数组
 * @property markers
 * @type {array}
 * @final
 */
Object.defineProperty(fengmap['FMLocationMarkerLayer'].prototype, "markers", {
	get: function() {
		var ms = [];
		for (var i = 0; i < this.o3d_.children.length; i++) {
			ms.push(this.o3d_.children[i].fm_);
		}
		return ms;
	}
});

fengmap['FMModelLayer'] = function(data) {
	fengmap.FMNode.call(this,0, data, new fm.Object3D());
	this.requireCollide_ = true;
};

fengmap['FMModelLayer'].prototype = Object.create(fengmap.FMNode.prototype, {
    
    'visible': {
        set: function(value) {
            this._visible = value;
            this.o3d_.visible = this._visible && this._show;
            if(undefined != this.frameLineLayer){this.frameLineLayer.visible = this._visible && this._show;}
        },      
        get: function() {
            // return this.o3d_.visible;
            return this._visible;
        }
    }
});

fengmap['FMModelLayer'].constructor = fengmap['FMModelLayer'];

/**
 * 
 */
fengmap['FMTextLayer'] = function(data) {
	fengmap.FMNode.call(this,0, data, new fm.Object3D());
	this.requireCollide_ = true;
};

fengmap['FMTextLayer'].prototype = Object.create(fengmap.FMNode.prototype);

fengmap['FMTextLayer'].constructor = fengmap['FMTextLayer'];

//Object.assign(fengmap['FMTextLayer'].prototype, {
//});

/**
*	FMTextMarkerLayer 文本标注层对象，可添加任意个文本标注,并继承FMNode 属性
* 	@class FMTextMarkerLayer
*	@constructor
* 	@extends fengmap.FMNode
* 	@module FMNode
*   @namespace fengmap
*/

fengmap['FMTextMarkerLayer'] = function(data, map) {
	fengmap.FMNode.call(this,0, data, new fm.Object3D());
	this.o3d_.boxCollision_ = new fengmap.MapBoxCollision();
	this.requireCollide_ = false;

	if (data) {
		this.map = data.map 
	} else {
		this.map = map;
	}

	// 注册 Layer 的 update事件
	if (this.map) {
		this.fadeSpeed = this.map.options.poiLabelFadeSpeed || 5;
		this.noFade = !this.map.options.poiLabelFadeMode;
		
		if (this.update) {
			this._updateFun = this.update.bind(this);
			this.map.on('update', this._updateFun);
		}

		// if (!map.options.lazyCreateMode) {
		// 	this._mapScaleLevelChangedFun = this.display.bind(this);
		// 	this.map.on('mapScaleLevelChanged', this._mapScaleLevelChangedFun);
		// }
	}
};

fengmap['FMTextMarkerLayer'].prototype = Object.create(fengmap.FMNode.prototype, {
	requireCollide: {
		get: function () {
			return this.requireCollide_;
		},
		set: function (val) {
			this.requireCollide_ = val;
		}
	}
});

fengmap['FMTextMarkerLayer'].constructor = fengmap['FMTextMarkerLayer'];

Object.assign(fengmap['FMTextMarkerLayer'].prototype, {
	/**
	 * 添加文本标注
	 * @method addMarker
	 * @param {fengmap.FMTextMarker} marker 此图层可为FMTextMarker对象	 
	 */
	'addMarker': function(marker) {
		if (marker instanceof fengmap['FMTextMarker']) {
			marker.tryCreate_(this);
			
			if (marker._init_) {
				marker._init_();
			}
		} else {
			console.warn('Please use fengmap.FMTextMarker!');
		}
	},
	/**
	 * 移除单个文本标注
	 * @method removeMarker
	 * @param {fengmap.FMTextMarker} marker 此图层可为已添加的某个FMTextMarker对象	 
	 */
	'removeMarker': function(marker) {
		if (marker instanceof fengmap['FMTextMarker']) {
			marker.dispose();
		} else {
			console.warn('Please use fengmap.FMTextMarker!');
		}
	},
	
	/**
	 * 移除该层的所有图片标注
	 * @method removeAll
	 */
	'removeAll': function() {
		/*if (this.o3d_.children.length > 0 && this.o3d_.children[0].fm_) {
			var picker = this.o3d_.children[0].fm_.scene_.map_.mapPicker;
			for (var i=0; i<this.o3d_.children.length; i++) {
				this.o3d_.remove(this.o3d_.children[i]);
				i-=1;
			}
			picker.removeObject(this.o3d_.children);
		}*/

		for (var i = 0; i < this.o3d_.children.length; i++) {
			var obj = this.o3d_.children[i];
			if (obj.fm_ && obj.fm_.dispose) {
				obj.fm_.dispose();
				i --;
			}
		}
	}
});

/**
* 该层的所有文本标注集合数组
* @property markers
* @type {array}
* @final
*/
Object.defineProperty(fengmap['FMTextMarkerLayer'].prototype, "markers", {
	get: function() {
		var ms = [];
		for (var i=0; i<this.o3d_.children.length; i++) {
			ms.push(this.o3d_.children[i].fm_);
		}
		return ms;
	}
});

/**
 *	FMSearchAnalyser 是可根据类型、ID、楼层ID、名称、关键字模糊查找模型、公共设施、文本标签、自定义图层或所有图层的分析类。
 * 	@class FMSearchAnalyser
 *	@constructor FMSearchAnalyser
 * 	@module FMSearchAnalyser
 * 	@namespace fengmap
 *   @param {object} map map对象;
 */

fengmap.FMSearchAnalyser = function(map) {
	this.map_ = map;
	fm.Evento.convert(this);

};

fengmap.FMSearchAnalyser.prototype = {

	emit_: function(request, result) {
		this.emit("queryResult", {
			'target': this,
			'request': request,
			'result': result
		});
	},
	sort_: function(distanceNodes, result) {
		if (distanceNodes.length == 0)
			return;

		distanceNodes.sort(by("distance"));
		result.clear();

		for (var distanceNode in distanceNodes) {
			result.push(distanceNode.node);
		}
	},

	/**
	 * 根据请求对象查询分析方法
	 * @method query
	 * @param  {fengmap.FMSearchRequest} req fengmap.FMSearchRequest对象，可设置查询类型与关键字参数，详见FMSearchRequest对象接口说明。
	 * @param  {function} callback 分析完成后的回调方法，返回请求对象和查询结果。
	 * @since v1.0.0
	 */
	"query": function(req, callback) {

		var groupIDs;
		if (req.groupID_) {
			groupIDs = [req.groupID_];
		} else {
			groupIDs = this.map_.groupIDs;
		}

		var query = {
			nodeType: req.nodeType_,
			name: req.name_,
			keyword: req.keyword_,
			ID: req.ID_,
			FID: req.FID_,
			typeID: req.typeID_,
			eName:req.ename_,
		    keywordLanguageTypes:req.lanType_
		};

		fengmap.MapUtil.search(this.map_, groupIDs, query, function(result) {
			if (callback !== undefined) {
				callback(req, result);
			} else {
				this.emit_(req, result);
			}
		});

		return this;
	},
};
/**
*	FMSearchRequest 是可设置查询类型，查询关键字的请求类
* 	@class FMSearchRequest
*	@constructor FMSearchRequest
* 	@module FMSearchAnalyser
* 	@namespace fengmap
*   @param {object} nodeType fengmap.nodeType枚举类型参数
*   @param {int} index 异步返回的标记，可不传
*/
fengmap.FMSearchRequest = function(nodeType, index) {
	this.nodeType_ = nodeType;
	this.index_ = index;
	this.lanType_ = ['chn'];
};

fengmap.FMSearchRequest.prototype = {
//	"and":function(field, value) {
//	}
	
	/**
	 * 设置查询的楼层ID值，即查模型在该楼层ID下的nodeType型的地图元素
	 * @method groupID
	 * @chainable
	 */
	"groupID": function(groupID) {
		this.groupID_ = groupID;
		return this;
	},

	/**
	 * 设置查询的元素ID值，即查地图元素的ID等于该ID的所有地图元素
	 * @method ID
	 * @chainable
	 */
	"ID": function(ID) {
		this.ID_ = ID;
		return this;
	},

	/**
	 * 设置查询的元素ID值，即查地图元素的FID等于该FID的所有地图元素
	 * @method FID
	 * @chainable
	 */
	"FID": function(FID) {
		this.FID_ = FID;
		return this;
	},

	/**
	 * 设置查询的元素关键字，即查地图元素所有字段与关键字匹配的元素
	 * @method keyword
	 * @chainable
	 */
	"keyword": function(keyword) {
		this.keyword_ = keyword;
		return this;
	},

	/**
	 * 设置查询的元素名称，即查地图元素名称模糊匹配该值的元素。名称字母区分大小写
	 * @method name
	 * @chainable
	 */
	"name": function(name) {
		this.name_ = name;
		return this;
	},

	/**
	 * 设置查询的元素英文名称名称，即查地图元素名称模糊匹配该值的元素。名称字母区分大小写
	 * @method eName
	 * @chainable
	 */
	"eName":function(ename) {
		this.ename_ = ename;
		return this;
	},

	/**
	 * 设置模糊搜索的语言类型，只针对keyword类型的搜索。默认只模糊匹配name,不区分大小写，可以通过设置模糊匹配eName，设置类型为数组类型。如：req.keywordLanguageTypes([fengmap.FMLanguageType.EN,fengmap.FMLanguageType.CHN])
	 * @method keywordLanguageTypes
	 * @chainable
	 */
	"keywordLanguageTypes":function(lanTypes) {
		if(lanTypes instanceof Array)
			this.lanType_ = lanTypes;
		
		return this;
	},
	
    /**
     * 设置查询的范围，即查地图元素周边查询的地理范围。
     * @method circle
     * @chainable
     */
    "circle": function(mapCoord,radius) {
        this.mapCoord_ = mapCoord;
        this.radius_ = radius;
        return this;
    },

	/**
	 * 设置查询的公共设施或模型的类型ID，即查所有公共设施类型ID模糊匹配该值的元素。此时nodetype 可设置为 fengmap.FMNodeType.FACILITY或fengmap.FMNodeType.MODEL
	 * @method typeID
	 * @chainable
	 */
	"typeID": function(typeID) {
		this.typeID_ = typeID;
		return this;
	},
	
	get index() {
		return this.index_;
	}
};



//FMSearchFacilityByTypeRequest	groupID, typeid

//FMSearchModelByIdRequest	groupID, fid

//FMSearchModelByKeywordRequest groupID, keyword

//FMSearchModelByNameRequest groupID, name

//FMSearchModelByTypeRequest groupID, type

//FMSearchModelByCircleRequest groupID, mapCoord,radius






/**
 * 
 */

//返回iOS,android API 似为hashtable 结构，js建议采用轻量化的数组返回即可，用户使用会更加可能且方便

/*
fengmap.FMSearchResult = function() {
	
};

fengmap.FMSearchResult.prototype = {
	
};
*/


/**
 * 
 */

fengmap.util = fengmap.util || {};
fengmap.util.Option = {};
fengmap.util.Option.getValue = function(obj, field, defaultValue) {
	return (obj && obj.hasOwnProperty(field))?obj[field]:defaultValue;
};

fengmap.util.id = 10001; //for system id generator!

fengmap.util.FullScreen = {
	get _hasWebkitFullScreen() {
//		console.log(document['webkitCancelFullScreen'], 'webkitCancelFullScreen' in document);
		return 'webkitCancelFullScreen' in document ? true : false;
	},
	get _hasMozFullScreen() {
		return 'mozCancelFullScreen' in document ? true : false;	
	},
	get available() {
		return this._hasWebkitFullScreen || this._hasMozFullScreen;
	},
	get activated() {
		if( this._hasWebkitFullScreen ){
			return document.webkitIsFullScreen;
		} else if( this._hasMozFullScreen ){
			return document.mozFullScreen;
		} else{
//			console.assert(false);
			return false;
		}
	},
	request: function(element) {
		element	= element || document.body;
		if( this._hasWebkitFullScreen ){
//			console.log('webkitRequestFullScreen');
			element.webkitRequestFullScreen();
		} else if( this._hasMozFullScreen ){
//			console.log('mozRequestFullScreen');
			element.mozRequestFullScreen();
		} else {
//			console.log('fullScreen not avaliable!');
//			console.assert(false);
		}
	},
	cancel: function(){
		if( this._hasWebkitFullScreen ){
			document.webkitCancelFullScreen();
		} else if( this._hasMozFullScreen ){
			document.mozCancelFullScreen();
		} else{
//			console.assert(false);
		}
	}
};
(function() {
    fengmap.FMScatterPlot = {
        create: function(map, config) {
            return new ScatterPlot(map, config);
        }
    };

    function ScatterPlot(map, config) {
        this.map_ = map;

        //添加麻点图的图片地址和麻点大小
        this.url_ = config.url ? config.url : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAB6ZJREFUeNqcV22MXUUZfmfmnHPv3bsft3S3XVi2CpaWYhHi0goRoWj8CIqkWkEwMQQxQf/YmGD0j8S/EmI0BiLCDxMg/FACKFQ+IklNW0FJhTQgcbtulV1ou193773na87M+L4z59x79qO0cDez59w5c+Z53uf9msvgHD99NV65dffYZ78+sfXmL1x+0TV+0L8DvJpvH6axAR2+84/js3975o3J5x87fPzA1Kls9lz2ZWdbMDroDe/fs/2O26689LYtG4cvh6DiAxcABO3h1WiAzABI/K4UXiUsLTdPvDA19czPX/7nQ6+diI99KAKEcc/1F93142smftqobxy3kwLBAg+gXgdoNBAwQRIBQBwDdDoAYYpq4MhwW+RkZBg/9vZbD/7g2dd/ttBWzXMmsGlQDD1y0+6HvvKRrbeAYpAJA169CrBhAAngK6ICUB0BmJsGqPQDaARVEZLB+RRVaHYgC2Ng0oBgDCZbp4995/mDdxycCl87K4Ftm7zNT++97o+XBpt3hUaBqArEQIvRUOi0ABaX0OIQAVFzjmrgGrxxkgVIYBBJ1geRlICkE0EWSQg0h1iEzbsPHdr3+NGFl85IYLjOGy/f8pkXtvGNu0JmoFYLoDJQA2gtACwjsNbO74KtpW4oBoyLA4MP66jM0HlIQEMLifgZPgrS1u0H//ql595uHe66unuDdw9cv/O3l2SNXU30Y5VxqBDQu+8ALMy7TYXogen8Wr4vgoc2a6FaszPgqRQGPQ9ClQFri4H7r5h4YsuAGF1D4O5PjN755caF+xajFNVmUCXw0yddgDHhELqApgesV83Zgf/QAEBQWDgFAt01iMTamCEX6r7x+67e8SuWI1uTGgE/7ze7rviDn3r9CqUfqWHAhYuYUhhcIl/J2EqvmVUDSuDFldaSW5IIPK8KUapxZLCtNvDxN9onj0w25XG7+13bN995vqqNhlkGG0jCpI0jdqCKrbSWLF1hbUkBO0qqqJwsxWm4DJi4IDGOVGTgexd/7CfoKcZ9j9VuGj7/22Gc2Q1qFNVJ6LyjmSs0loQpWVcGNGvlp6Hyd3VBArMBh49rQ1ThysrQdZ/c4E/wL4727RljtcviTEHNsk9dJOtisxIJvRoY1p8rg5t8jvbBvSu4RmoFfsr5jaMje73Pbxq52cuYSBgSMCg/PjQGtbEvMmcWuYJrJyVFDy87vfQpFAOzCry4IjDZhHGRoCsm+ht7vKuGhq6VEYJ6DPfVjgD+MdqA5xsVV1aSeL2PyS0FWAOuC89o90Vi/xj3q1u9WiK2a5w0WL8zTJuMopb2QFBuQXM3FFazckasJmB6oujed41XwjU5eZPRdyzvkg97QSI8zYx9L0TfV9F/jOcAOM85K1mcq8DeR4Gy9cQDgWxokAd1zgknaJCNHqMvlgDDRRw7KxJAFWzpQUvdE8Klv1ydM/VQU6pX2hnlFDeuQpML0M3kBnrOqLLHXJmqEswuQmkUPWB5JBMxIkQeyM1jjHXxWcndvTpkehmbW5vlbrDJpFzPIBElBr6XBHK22uZjlABSOd8QiAUnMGNs7ymIFCqs14ugVAQJWOUkbAwYRy6TpAbuSQQCtcyPtVtH7GY4KaWGlLqWckpk2l0lDeUiV5aelYdatUbqlevsnmh9nGlLhBSYSaJp/tL83IHYZHaSXk6RhM67qrKbQD5Md0gkiXVrxaC58prye5rWaDqrkJHGxQTWhKNh81XvwOnw2W8NtmcugPoYx+LcSRg2DtYNPAEuJroDnHvO7IKVMaBy6el5lGhbhlOyDgvbXxYWnxbYoDrjfXDxNta3O8XoRAGwFXNs/aybTTpPQV3y8ZpWUNznqZYZFwNuzliV5tsJtFOJ9xqmTfvfD5xc+pFtx/+N5H8+N9T/XfSEkBiqEhf0+V6vtmBB0qVeo9choUyRck56kt0GH6Ufkp/vJLCAZw1rPc78rjl775ud7LAlsKzMXKMmhy9htatT9E2CDqN87Q/8FYBGu2zQtpAwB9gd5FvWKzz5evLbIp6WZ1shgkvQKPGkaB379anW90kYUfjw9Ugenhjw9valYphUIKnIqnoQWH/bPAbWrba65Ofuve5J7moDg7lODNOLLTQqw0BVEPE0+8Xi3L6TiZ7qnohsFmpI/pXGRz7VH3wTEqgiV1hOJER4jKr5Pvh4ULHRq9ePga70OTCl4v+abTjRbEGMlicUBFzBE+n8/kPN7PcFrihH8lJm3p3h8d93VvyvsQQCckc7yWA+im3g+HgMF3TgzHOg2xiN8zNdKX7mwggm55fgPfyxQj6XlIMI/me+eO+T8/K+chdft6rv6Oefvr1af3QkDT6qeF5+cWUFCQxVqzBUqUAVg9TLa7FCFmRhWyawFCfQwVO1ztPRFjhfy+dM654Xm+qXRZM660+zAY+NfWPQu39nVr2VK5Q/J0GRwKka4BeRd01bbGyMmK4y1OTo7DITxEef6sj9k4k++MF/nOIGOzx+47UV8cMtxr8hkIwb1w3cgb7cjHTXMWCw0J8W2ZuvKPXgK4l6GL0Qf+hfxwWRCwS76jKPf3WcsRs2MrZVZGyT0O50j0d5YzyzjL8+p99j+tW3pP7TcWVeRODobFv/X4ABANpdXOn8IcWdAAAAAElFTkSuQmCC';
        this.size_ = config.size ? config.size : 24;

        //保存散点    
        this.plotsData_ = [];

        //为每一个楼层保存散点图图层
        this.groupLayers_ = {};
    }

    ScatterPlot.prototype = {
        renderToMap: function(groupID) {
        	var groupLayer = this.map_.getFMGroup(groupID);
        	if(this.plotsData_.length > 0 && !groupLayer) return;
            
            //在每一个楼层新建一个FMImageMarkerLayer层。               
            if (!this.groupLayers_[groupID]) {
                this.groupLayers_[groupID] = new fengmap.FMImageMarkerLayer();
                groupLayer.addLayer(this.groupLayers_[groupID]);
            } else
                this.groupLayers_[groupID].removeAll();

            for(var i = 0,ilen = this.plotsData_.length; i < ilen; i++) {
                var im = this.plotsData_[i];
            	this.groupLayers_[groupID].addMarker(im);
                //控制图标在公共设施和文字的上面显示
                setTimeout(function(){
                    im.o3d_.material.depthTest = false;
                    im.o3d_.renderOrder = 10;
                }, 100);
            }
        },

        //从地图上移除热力图
        disposeScatterPlot: function(groupID) {
        	if(this.groupLayers_[groupID]) {
        		var groupLayer = this.map_.getFMGroup(groupID);
        		groupLayer.removeLayer(this.groupLayers_[groupID]);
        		this.groupLayers_[groupID] = null;
        	}
        }
    }

    ScatterPlot.prototype.addPoints = function(data) {

        //为每一个imageMarkerLayer层添加多个imageMarker
        for (var i = 0, ilen = data.length; i < ilen; i++) {
        	var pnt = data[i];
            this.addPoint(pnt.x,pnt.y);
        }
    }

    ScatterPlot.prototype.addPoint = function(x, y) {
        var im = new fengmap.FMImageMarker({
        	id:'fm-scatterplot',
            x: x,
            y: y,
            url: this.url_,
            size: this.size_
        });

        this.plotsData_.push(im);
    }
}());
